[
    {
        "lemma_name": "safe_pure",
        "proof": [
            {
                "tactic_sig": "Lemma safe_pure : forall n v h ( Q : postcond ) J , Q v h -> safe n ( PURE v ) h Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_pure : forall n v h ( Q : postcond ) J , Q v h -> safe n ( PURE v ) h Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n  (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n  (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c2_goal : safe n (PURE v) h Q J",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_H : Q v h"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe n (PURE v) h Q J",
                    "c2_n : nat",
                    "c2_H : Q v h",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c3_goal : safe 0 (PURE v) h Q J",
                    "c4_goal : safe (S n) (PURE v) h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe 0 (PURE v) h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (S n) (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c5_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Q v h",
                    "c2_H : Q v h",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_pure_inv",
        "proof": [
            {
                "tactic_sig": "Lemma safe_pure_inv : forall n v h Q J , safe ( S n ) ( PURE v ) h Q J -> Q v h .",
                "tactic_sig_no_out_arg": "Lemma safe_pure_inv : forall n v h Q J , safe ( S n ) ( PURE v ) h Q J -> Q v h .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n  (J : invariant) (_ : safe (S n) (PURE v) h Q J), \nQ v h"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n  (J : invariant) (_ : safe (S n) (PURE v) h Q J), \nQ v h"
                ],
                "tactic_res": [
                    "c2_goal : Q v h",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_H : safe (S n) (PURE v) h Q J"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : Q v h",
                    "c2_H : safe (S n) (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c3_goal : Q v h",
                    "c3_H2 : Q v h",
                    "c4_goal : Q v h",
                    "c4_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (PURE v) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (PURE v) h0))",
                    "c4_ACC : forall (l : addr) (_ : immacc l (PURE v)), not (eq (h l) None)",
                    "c4_NOTDONE : False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Q v h",
                    "c3_H2 : Q v h",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c4_goal : Q v h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_red",
        "proof": [
            {
                "tactic_sig": "Lemma safe_red : forall n c h1 Q J hj hf c' h' , red ( c , hunion h1 ( hunion hj hf ) ) ( c' , h' ) -> safe ( S n ) c h1 Q J -> J hj -> hdisj3 h1 hj hf -> exists h1' hj' , hdisj3 h1' hj' hf /\\ h' = hunion h1' ( hunion hj' hf ) /\\ J hj' /\\ safe n c' h1' Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_red : forall n c h1 Q J hj hf c' h' , red ( c , hunion h1 ( hunion hj hf ) ) ( c' , h' ) -> safe ( S n ) c h1 Q J -> J hj -> hdisj3 h1 hj hf -> exists h1' hj' , hdisj3 h1' hj' hf /\\ h' = hunion h1' ( hunion hj' hf ) /\\ J hj' /\\ safe n c' h1' Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (c' : com) (h' : heap)\n  (_ : red (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (c' : com) (h' : heap)\n  (_ : red (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_h1 : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_hj : heap",
                    "c2_hf : heap",
                    "c2_c' : com",
                    "c2_h' : heap",
                    "c2_H : red (pair c (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c2_H0 : safe (S n) c h1 Q J",
                    "c2_H1 : J hj",
                    "c2_H2 : hdisj3 h1 hj hf"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c2_H0 : safe (S n) c h1 Q J"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c3_H4 : Q v h1",
                    "c3_H : red (pair (PURE v) (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c3_v : Z",
                    "c4_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_STEP : forall (hf hj h : heap) (c' : com) (h' : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_IMM : forall (hf hj h : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h))",
                    "c4_ACC : forall (l : addr) (_ : immacc l c), not (eq (h1 l) None)",
                    "c4_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c3_H : red (pair (PURE v) (hunion h1 (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_STEP : forall (hf hj h : heap) (c' : com) (h' : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c2_H2 : hdisj3 h1 hj hf",
                    "c2_H1 : J hj",
                    "c2_H : red (pair c (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c2_h' : heap",
                    "c2_c' : com",
                    "c2_hf : heap",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_redN",
        "proof": [
            {
                "tactic_sig": "Lemma safe_redN : forall n c h1 Q J hj hf c' h' , starN red n ( c , hunion h1 ( hunion hj hf ) ) ( c' , h' ) -> safe ( S n ) c h1 Q J -> J hj -> hdisj3 h1 hj hf -> exists h1' hj' , hdisj3 h1' hj' hf /\\ h' = hunion h1' ( hunion hj' hf ) /\\ J hj' /\\ safe 1 % nat c' h1' Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_redN : forall n c h1 Q J hj hf c' h' , starN red n ( c , hunion h1 ( hunion hj hf ) ) ( c' , h' ) -> safe ( S n ) c h1 Q J -> J hj -> hdisj3 h1 hj hf -> exists h1' hj' , hdisj3 h1' hj' hf /\\ h' = hunion h1' ( hunion hj' hf ) /\\ J hj' /\\ safe 1 % nat c' h1' Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red 0 (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe 1 c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c4_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red (S n) (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S (S n)) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c4_IHn : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red 0 (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe 1 c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c5_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c5_c : com",
                    "c5_h1 : heap",
                    "c5_Q : postcond",
                    "c5_J : invariant",
                    "c5_hj : heap",
                    "c5_hf : heap",
                    "c5_c' : com",
                    "c5_h' : heap",
                    "c5_H : starN red 0 (pair c (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c5_H0 : safe 1 c h1 Q J",
                    "c5_H1 : J hj",
                    "c5_H2 : hdisj3 h1 hj hf"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red (S n) (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S (S n)) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c6_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c6_c : com",
                    "c6_h1 : heap",
                    "c6_Q : postcond",
                    "c6_J : invariant",
                    "c6_hj : heap",
                    "c6_hf : heap",
                    "c6_c' : com",
                    "c6_h' : heap",
                    "c6_H : starN red (S n) (pair c (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c6_H0 : safe (S (S n)) c h1 Q J",
                    "c6_H1 : J hj",
                    "c6_H2 : hdisj3 h1 hj hf"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c5_H : starN red 0 (pair c (hunion h1 (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c7_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h1 (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c7_H0 : safe 1 c' h1 Q J"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h1 (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c5_h1 : heap",
                    "c5_hj : heap"
                ],
                "tactic_res": [
                    "c8_goal : and (hdisj3 h1 hj hf)\n  (and (eq (hunion h1 (hunion hj hf)) (hunion h1 (hunion hj hf)))\n     (and (J hj) (safe 1 c' h1 Q J)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (hdisj3 h1 hj hf)\n  (and (eq (hunion h1 (hunion hj hf)) (hunion h1 (hunion hj hf)))\n     (and (J hj) (safe 1 c' h1 Q J)))",
                    "c5_H2 : hdisj3 h1 hj hf",
                    "c5_H1 : J hj",
                    "c7_H0 : safe 1 c' h1 Q J",
                    "c5_c' : com",
                    "c5_hj : heap",
                    "c5_hf : heap",
                    "c5_J : invariant",
                    "c5_Q : postcond",
                    "c5_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_H : starN red (S n) (pair c (hunion h1 (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c6_H5 : starN red n b (pair c' h')",
                    "c6_H4 : red (pair c (hunion h1 (hunion hj hf))) b",
                    "c6_b : prod com heap"
                ]
            },
            {
                "tactic_sig": "rename _i into c'' .",
                "tactic_sig_no_out_arg": "rename _i into c'' .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))",
                    "c6_c' : com"
                ],
                "tactic_res": [
                    "c9_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))",
                    "c9_H5 : starN red n b (pair c'' h')",
                    "c9_c'' : com"
                ]
            },
            {
                "tactic_sig": "rename _i into h'' .",
                "tactic_sig_no_out_arg": "rename _i into h'' .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))",
                    "c6_h' : heap"
                ],
                "tactic_res": [
                    "c10_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))",
                    "c10_H5 : starN red n b (pair c'' h'')",
                    "c10_h'' : heap"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ c' h' ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ c' h' ] .",
                "tactic_args": [
                    "c6_b : prod com heap",
                    "c10_H5 : starN red n b (pair c'' h'')",
                    "c6_H4 : red (pair c (hunion h1 (hunion hj hf))) b",
                    "c6_H2 : hdisj3 h1 hj hf",
                    "c6_H1 : J hj",
                    "c6_H0 : safe (S (S n)) c h1 Q J",
                    "c10_h'' : heap",
                    "c9_c'' : com",
                    "c6_hf : heap",
                    "c6_J : invariant",
                    "c6_Q : postcond",
                    "c4_IHn : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c10_H5 : starN red n (pair c' h') (pair c'' h'')",
                    "c10_H4 : red (pair c (hunion h1 (hunion hj hf))) (pair c' h')",
                    "c10_h' : heap",
                    "c10_c' : com"
                ]
            },
            {
                "tactic_sig": "edestruct safe_red as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct safe_red as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c10_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c11_goal : red (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c12_goal : safe (S ?n) c h1 ?Q ?J",
                    "c13_goal : J hj",
                    "c14_goal : hdisj3 h1 hj hf",
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))",
                    "c15_D : safe (S n) c' h1' Q J",
                    "c15_C : J hj'",
                    "c15_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c15_A : hdisj3 h1' hj' hf",
                    "c15_hj' : heap",
                    "c15_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "c11_goal : red (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c10_H4 : red (pair c (hunion h1 (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "c12_goal : safe (S ?n) c h1 ?Q ?J",
                    "c6_H0 : safe (S (S n)) c h1 Q J",
                    "c6_h1 : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c13_goal : J hj",
                    "c6_H1 : J hj",
                    "c6_hj : heap",
                    "c6_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c14_goal : hdisj3 h1 hj hf",
                    "c6_H2 : hdisj3 h1 hj hf",
                    "c6_hj : heap",
                    "c6_hf : heap",
                    "c6_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c10_h' : heap",
                    "c15_B : eq ?h' (hunion h1' (hunion hj' ?hf))"
                ],
                "tactic_res": [
                    "c15_D : safe (S n) c' h1' Q J",
                    "c15_C : J hj'",
                    "c15_A : hdisj3 h1' hj' hf",
                    "c15_H4 : red (pair c (hunion h1 (hunion hj hf)))\n  (pair c' (hunion h1' (hunion hj' hf)))",
                    "c15_H5 : starN red n (pair c' (hunion h1' (hunion hj' hf))) (pair c'' h'')"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c'' h1' Q J)))))",
                    "c4_IHn : forall (c : com) (h1 : heap) (Q : postcond) (J : invariant)\n  (hj hf : heap) (c' : com) (h' : heap)\n  (_ : starN red n (pair c (hunion h1 (hunion hj hf))) (pair c' h'))\n  (_ : safe (S n) c h1 Q J) (_ : J hj) (_ : hdisj3 h1 hj hf),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe 1 c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c16_goal : starN red n (pair ?c (hunion ?h1 (hunion ?hj hf))) (pair c'' h'')",
                    "c17_goal : safe (S n) c' h1' Q J",
                    "c18_goal : J hj'",
                    "c19_goal : hdisj3 h1' hj' hf"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : starN red n (pair ?c (hunion ?h1 (hunion ?hj hf))) (pair c'' h'')",
                    "c15_H5 : starN red n (pair c' (hunion h1' (hunion hj' hf))) (pair c'' h'')",
                    "c10_h'' : heap",
                    "c9_c'' : com",
                    "c6_hf : heap",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : safe (S n) c' h1' Q J",
                    "c15_D : safe (S n) c' h1' Q J",
                    "c15_h1' : heap",
                    "c10_c' : com",
                    "c6_J : invariant",
                    "c6_Q : postcond",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : J hj'",
                    "c15_C : J hj'",
                    "c15_hj' : heap",
                    "c6_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : hdisj3 h1' hj' hf",
                    "c15_A : hdisj3 h1' hj' hf",
                    "c15_h1' : heap",
                    "c15_hj' : heap",
                    "c6_hf : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_not_erroneous",
        "proof": [
            {
                "tactic_sig": "Lemma safe_not_erroneous : forall n c h1 Q J hj hf , safe ( S n ) c h1 Q J -> hdisj3 h1 hj hf -> J hj -> ~ erroneous ( c , hunion h1 ( hunion hj hf ) ) .",
                "tactic_sig_no_out_arg": "Lemma safe_not_erroneous : forall n c h1 Q J hj hf , safe ( S n ) c h1 Q J -> hdisj3 h1 hj hf -> J hj -> ~ erroneous ( c , hunion h1 ( hunion hj hf ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (_ : safe (S n) c h1 Q J)\n  (_ : hdisj3 h1 hj hf) (_ : J hj),\nnot (erroneous (pair c (hunion h1 (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (hj hf : heap) (_ : safe (S n) c h1 Q J)\n  (_ : hdisj3 h1 hj hf) (_ : J hj),\nnot (erroneous (pair c (hunion h1 (hunion hj hf))))"
                ],
                "tactic_res": [
                    "c2_goal : not (erroneous (pair c (hunion h1 (hunion hj hf))))",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_h1 : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_hj : heap",
                    "c2_hf : heap",
                    "c2_H : safe (S n) c h1 Q J",
                    "c2_H0 : hdisj3 h1 hj hf",
                    "c2_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : not (erroneous (pair c (hunion h1 (hunion hj hf))))",
                    "c2_H : safe (S n) c h1 Q J"
                ],
                "tactic_res": [
                    "c3_goal : not (erroneous (pair (PURE v) (hunion h1 (hunion hj hf))))",
                    "c3_H3 : Q v h1",
                    "c3_v : Z",
                    "c4_goal : not (erroneous (pair c (hunion h1 (hunion hj hf))))",
                    "c4_STEP : forall (hf hj h : heap) (c' : com) (h' : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_IMM : forall (hf hj h : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h))",
                    "c4_ACC : forall (l : addr) (_ : immacc l c), not (eq (h1 l) None)",
                    "c4_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros ST .",
                "tactic_args": [
                    "c3_goal : not (erroneous (pair (PURE v) (hunion h1 (hunion hj hf))))"
                ],
                "tactic_res": [
                    "c5_goal : False",
                    "c5_ST : erroneous (pair (PURE v) (hunion h1 (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : False",
                    "c5_ST : erroneous (pair (PURE v) (hunion h1 (hunion hj hf)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : not (erroneous (pair c (hunion h1 (hunion hj hf))))",
                    "c4_IMM : forall (hf hj h : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h))",
                    "c2_H1 : J hj",
                    "c2_H0 : hdisj3 h1 hj hf",
                    "c2_hj : heap",
                    "c2_hf : heap",
                    "c2_h1 : heap",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_immacc",
        "proof": [
            {
                "tactic_sig": "Lemma safe_immacc : forall n c h1 Q J l , safe ( S n ) c h1 Q J -> immacc l c -> h1 l <> None .",
                "tactic_sig_no_out_arg": "Lemma safe_immacc : forall n c h1 Q J l , safe ( S n ) c h1 Q J -> immacc l c -> h1 l <> None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J) \n  (_ : immacc l c), not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n  (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J) \n  (_ : immacc l c), not (eq (h1 l) None)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq (h1 l) None)",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_h1 : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_l : addr",
                    "c2_H : safe (S n) c h1 Q J",
                    "c2_H0 : immacc l c"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : not (eq (h1 l) None)",
                    "c2_H : safe (S n) c h1 Q J"
                ],
                "tactic_res": [
                    "c3_goal : not (eq (h1 l) None)",
                    "c3_H2 : Q v h1",
                    "c3_H0 : immacc l (PURE v)",
                    "c3_v : Z",
                    "c4_goal : not (eq (h1 l) None)",
                    "c4_STEP : forall (hf hj h : heap) (c' : com) (h' : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c4_IMM : forall (hf hj h : heap) (_ : hdisj3 h1 hj hf)\n  (_ : eq h (hunion h1 (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h))",
                    "c4_ACC : forall (l : addr) (_ : immacc l c), not (eq (h1 l) None)",
                    "c4_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c3_goal : not (eq (h1 l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c4_goal : not (eq (h1 l) None)",
                    "c4_ACC : forall (l : addr) (_ : immacc l c), not (eq (h1 l) None)"
                ],
                "tactic_res": [
                    "c5_goal : immacc l c"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : immacc l c",
                    "c2_H0 : immacc l c",
                    "c2_l : addr",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_mono",
        "proof": [
            {
                "tactic_sig": "Lemma safe_mono : forall n c h Q J , safe n c h Q J -> forall n' , ( n' <= n ) % nat -> safe n' c h Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_mono : forall n c h Q J , safe n c h Q J -> forall n' , ( n' <= n ) % nat -> safe n' c h Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (c : com) (h : heap) (Q : postcond) \n  (J : invariant) (_ : safe n c h Q J) (n' : nat) \n  (_ : le n' n), safe n' c h Q J"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (c : com) (h : heap) (Q : postcond) \n  (J : invariant) (_ : safe n c h Q J) (n' : nat) \n  (_ : le n' n), safe n' c h Q J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe 0 c h Q J) (n' : nat) (_ : le n' 0), safe n' c h Q J",
                    "c4_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe (S n) c h Q J) (n' : nat) (_ : le n' (S n)),\nsafe n' c h Q J",
                    "c4_IHn : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe 0 c h Q J) (n' : nat) (_ : le n' 0), safe n' c h Q J"
                ],
                "tactic_res": [
                    "c5_goal : safe n' c h Q J",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_Q : postcond",
                    "c5_J : invariant",
                    "c5_H : safe 0 c h Q J",
                    "c5_n' : nat",
                    "c5_H0 : le n' 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe (S n) c h Q J) (n' : nat) (_ : le n' (S n)),\nsafe n' c h Q J"
                ],
                "tactic_res": [
                    "c6_goal : safe n' c h Q J",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_Q : postcond",
                    "c6_J : invariant",
                    "c6_H : safe (S n) c h Q J",
                    "c6_n' : nat",
                    "c6_H0 : le n' (S n)"
                ]
            },
            {
                "tactic_sig": "replace _i with O by lia .",
                "tactic_sig_no_out_arg": "replace _i with O by lia .",
                "tactic_args": [
                    "c5_goal : safe n' c h Q J",
                    "c5_n' : nat"
                ],
                "tactic_res": [
                    "c7_goal : safe 0 c h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe 0 c h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ | _i ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | _i ] .",
                "tactic_args": [
                    "c6_goal : safe n' c h Q J",
                    "c6_n' : nat",
                    "c6_n' : nat",
                    "c6_H0 : le n' (S n)",
                    "c6_H : safe (S n) c h Q J",
                    "c6_J : invariant",
                    "c6_Q : postcond",
                    "c6_h : heap",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J"
                ],
                "tactic_res": [
                    "c8_goal : safe 0 c h Q J",
                    "c8_H0 : le 0 (S n)",
                    "c9_goal : safe (S n') c h Q J",
                    "c9_H0 : le (S n') (S n)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe 0 c h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe (S n') c h Q J",
                    "c6_H : safe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c10_goal : safe (S n') (PURE v) h Q J",
                    "c10_H2 : Q v h",
                    "c10_v : Z",
                    "c11_goal : safe (S n') c h Q J",
                    "c11_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c11_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c11_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c11_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : safe (S n') (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c12_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Q v h",
                    "c10_H2 : Q v h",
                    "c10_v : Z",
                    "c6_Q : postcond",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe (S n') c h Q J"
                ],
                "tactic_res": [
                    "c13_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c14_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c15_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c16_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c11_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c11_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c11_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c6_J : invariant",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c17_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))",
                    "c17_hf : heap",
                    "c17_hj : heap",
                    "c17_h0 : heap",
                    "c17_c' : com",
                    "c17_h' : heap",
                    "c17_H : hdisj3 h hj hf",
                    "c17_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c17_H2 : J hj",
                    "c17_H3 : red (pair c h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "edestruct _i as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c17_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))",
                    "c11_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c18_goal : hdisj3 h ?hj ?hf",
                    "c19_goal : eq ?h (hunion h (hunion hj hf))",
                    "c20_goal : J hj",
                    "c21_goal : red (pair c h0) (pair ?c' ?h')",
                    "c22_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))",
                    "c22_D : safe n ?c' h1' Q J",
                    "c22_C : J hj'",
                    "c22_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c22_A : hdisj3 h1' hj' ?hf",
                    "c22_hj' : heap",
                    "c22_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : hdisj3 h ?hj ?hf",
                    "c17_H : hdisj3 h hj hf",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : eq ?h (hunion h (hunion hj hf))",
                    "c17_hf : heap",
                    "c17_hj : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : J hj",
                    "c17_H2 : J hj",
                    "c17_hj : heap",
                    "c6_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : red (pair c h0) (pair ?c' ?h')",
                    "c17_H3 : red (pair c h0) (pair c' h')",
                    "c17_h0 : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c22_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n' c' h1' Q J)))))",
                    "c22_h1' : heap",
                    "c22_hj' : heap"
                ],
                "tactic_res": [
                    "c23_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n' c' h1' Q J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c23_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n' c' h1' Q J)))",
                    "c22_D : safe n ?c' h1' Q J",
                    "c22_C : J hj'",
                    "c22_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c22_A : hdisj3 h1' hj' ?hf",
                    "c22_h1' : heap",
                    "c22_hj' : heap",
                    "c17_H3 : red (pair c h0) (pair c' h')",
                    "c17_H2 : J hj",
                    "c17_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c17_H : hdisj3 h hj hf",
                    "c17_h' : heap",
                    "c17_c' : com",
                    "c17_hf : heap",
                    "c11_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c11_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c11_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c11_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c9_H0 : le (S n') (S n)",
                    "c6_n' : nat",
                    "c6_J : invariant",
                    "c6_Q : postcond",
                    "c4_IHn : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J"
                ],
                "tactic_res": [
                    "c24_goal : safe n' c' h1' Q J",
                    "c24_D : safe n c' h1' Q J",
                    "c24_B : eq h' (hunion h1' (hunion hj' hf))",
                    "c24_A : hdisj3 h1' hj' hf",
                    "c24_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : erroneous (pair c h0)), False",
                    "c24_ACC : forall (l : addr) (_ : immacc l c) (_ : eq (h l) None), False"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : safe n' c' h1' Q J",
                    "c4_IHn : forall (c : com) (h : heap) (Q : postcond) (J : invariant)\n  (_ : safe n c h Q J) (n' : nat) (_ : le n' n), safe n' c h Q J"
                ],
                "tactic_res": [
                    "c25_goal : safe n c' h1' Q J",
                    "c26_goal : le n' n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : safe n c' h1' Q J",
                    "c24_D : safe n c' h1' Q J",
                    "c22_h1' : heap",
                    "c17_c' : com",
                    "c6_J : invariant",
                    "c6_Q : postcond",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : le n' n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_frame",
        "proof": [
            {
                "tactic_sig": "Lemma safe_frame : forall ( R : assertion ) ( Q : postcond ) J n c h h' , safe n c h Q J -> hdisjoint h h' -> R h' -> safe n c ( hunion h h' ) ( fun v => Q v ** R ) J .",
                "tactic_sig_no_out_arg": "Lemma safe_frame : forall ( R : assertion ) ( Q : postcond ) J n c h h' , safe n c h Q J -> hdisjoint h h' -> R h' -> safe n c ( hunion h h' ) ( fun v => Q v ** R ) J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (Q : postcond) (J : invariant) \n  (n : nat) (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros R Q J n .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (Q : postcond) (J : invariant) \n  (n : nat) (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c2_R : assertion",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h h' : heap) (_ : safe 0 c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe 0 c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c4_goal : forall (c : com) (h h' : heap) (_ : safe (S n) c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h h' : heap) (_ : safe 0 c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe 0 c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_h' : heap",
                    "c5_H : safe 0 c h Q J",
                    "c5_H0 : hdisjoint h h'",
                    "c5_H1 : R h'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h h' : heap) (_ : safe (S n) c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c6_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_H : safe (S n) c h Q J",
                    "c6_H0 : hdisjoint h h'",
                    "c6_H1 : R h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c6_H : safe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c7_goal : safe (S n) (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c7_H3 : Q v h",
                    "c7_v : Z",
                    "c8_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (S n) (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c9_goal : sepconj (Q v) R (hunion h h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c9_goal : sepconj (Q v) R (hunion h h')",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": [
                    "c10_goal : and (Q v h)\n  (and (R h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : and (Q v h)\n  (and (R h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))",
                    "c7_H3 : Q v h",
                    "c7_v : Z",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c2_Q : postcond",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (hunion h h' l) None)",
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair c h0))",
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h'0 : heap)\n  (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj) (_ : red (pair c h0) (pair c' h'0)),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c15_goal : not (eq (hunion h h' l) None)",
                    "c15_l : addr",
                    "c15_H : immacc l c"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c15_H : immacc l c"
                ],
                "tactic_res": [
                    "c15_H : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c15_goal : not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c16_goal : not (eq (if h l then h l else h' l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c16_goal : not (eq (if h l then h l else h' l) None)",
                    "c6_h : heap",
                    "c15_l : addr",
                    "c15_H : not (eq (h l) None)",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c17_goal : not (eq (Some z) None)",
                    "c17_H : not (eq (Some z) None)",
                    "c17_z : Z",
                    "c18_goal : not (eq (h' l) None)",
                    "c18_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c17_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c18_goal : not (eq (h' l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair c h0))"
                ],
                "tactic_res": [
                    "c19_goal : not (erroneous (pair c h0))",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c19_h0 : heap",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c19_H3 : J hj"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c19_goal : not (erroneous (pair c h0))",
                    "c19_h0 : heap",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c20_goal : not (erroneous (pair c (hunion (hunion h h') (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i _i _i ) _i ) .",
                "tactic_args": [
                    "c20_goal : not (erroneous (pair c (hunion (hunion h h') (hunion hj hf))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c6_h' : heap",
                    "c19_hf : heap",
                    "c19_hj : heap"
                ],
                "tactic_res": [
                    "c21_goal : hdisj3 h hj (hunion h' hf)",
                    "c22_goal : eq (hunion (hunion h h') (hunion hj hf))\n  (hunion h (hunion hj (hunion h' hf)))",
                    "c23_goal : J hj"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c21_goal : hdisj3 h hj (hunion h' hf)",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : eq (hunion (hunion h h') (hunion hj hf))\n  (hunion h (hunion hj (hunion h' hf)))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c24_goal : eq (hunion h (hunion h' (hunion hj hf)))\n  (hunion h (hunion hj (hunion h' hf)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c24_goal : eq (hunion h (hunion h' (hunion hj hf)))\n  (hunion h (hunion hj (hunion h' hf)))"
                ],
                "tactic_res": [
                    "c25_goal : eq (hunion h' (hunion hj hf)) (hunion hj (hunion h' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i by HDISJ .",
                "tactic_args": [
                    "c25_goal : eq (hunion h' (hunion hj hf)) (hunion hj (hunion h' hf))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c19_H3 : J hj",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c26_goal : eq (hunion (hunion hj hf) h') (hunion hj (hunion h' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : eq (hunion (hunion hj hf) h') (hunion hj (hunion h' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c27_goal : eq (hunion hj (hunion hf h')) (hunion hj (hunion h' hf))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c27_goal : eq (hunion hj (hunion hf h')) (hunion hj (hunion h' hf))"
                ],
                "tactic_res": [
                    "c28_goal : eq (hunion hf h') (hunion h' hf)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : eq (hunion hf h') (hunion h' hf)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c29_goal : hdisjoint h' hf"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c29_goal : hdisjoint h' hf",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hf : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : J hj",
                    "c19_H3 : J hj",
                    "c19_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h'0 : heap)\n  (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj) (_ : red (pair c h0) (pair c' h'0)),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))"
                ],
                "tactic_res": [
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))",
                    "c30_hf : heap",
                    "c30_hj : heap",
                    "c30_h0 : heap",
                    "c30_c' : com",
                    "c30_h'0 : heap",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c30_H3 : J hj",
                    "c30_H4 : red (pair c h0) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_h0 : heap",
                    "c30_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "edestruct ( _i ( hunion _i _i ) _i ) as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct ( _i ( hunion _i _i ) _i ) as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c6_h' : heap",
                    "c30_hf : heap",
                    "c30_hj : heap"
                ],
                "tactic_res": [
                    "c31_goal : hdisj3 h hj (hunion h' hf)",
                    "c32_goal : eq ?h (hunion h (hunion hj (hunion h' hf)))",
                    "c33_goal : J hj",
                    "c34_goal : red (pair c (hunion h (hunion hj (hunion h' hf)))) (pair ?c' ?h')",
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))",
                    "c35_D : safe n ?c' h1' Q J",
                    "c35_C : J hj'",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' (hunion h' hf)))",
                    "c35_A : hdisj3 h1' hj' (hunion h' hf)",
                    "c35_hj' : heap",
                    "c35_h1' : heap"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c31_goal : hdisj3 h hj (hunion h' hf)",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_hf : heap",
                    "c30_hj : heap",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c32_goal : eq ?h (hunion h (hunion hj (hunion h' hf)))",
                    "c30_hf : heap",
                    "c30_hj : heap",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : J hj",
                    "c30_H3 : J hj",
                    "c30_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) by HDISJ .",
                "tactic_args": [
                    "c34_goal : red (pair c (hunion h (hunion hj (hunion h' hf)))) (pair ?c' ?h')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c6_h' : heap",
                    "c30_hf : heap",
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c30_H3 : J hj",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c36_goal : red (pair c (hunion h (hunion (hunion h' hf) hj))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : red (pair c (hunion h (hunion (hunion h' hf) hj))) (pair ?c' ?h')",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c37_goal : red (pair c (hunion h (hunion h' (hunion hf hj)))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c37_goal : red (pair c (hunion h (hunion h' (hunion hf hj)))) (pair ?c' ?h')",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c38_goal : red (pair c (hunion (hunion h h') (hunion hf hj))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c38_goal : red (pair c (hunion (hunion h h') (hunion hf hj))) (pair ?c' ?h')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c30_hj : heap",
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c30_H3 : J hj",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c39_goal : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c39_goal : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair ?c' ?h')",
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c30_hf : heap",
                    "c30_hj : heap",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) R) J)))))",
                    "c35_h1' : heap",
                    "c6_h' : heap",
                    "c35_hj' : heap"
                ],
                "tactic_res": [
                    "c40_goal : and (hdisj3 (hunion h1' h') hj' hf)\n  (and (eq h'0 (hunion (hunion h1' h') (hunion hj' hf)))\n     (and (J hj')\n        (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c40_goal : and (hdisj3 (hunion h1' h') hj' hf)\n  (and (eq h'0 (hunion (hunion h1' h') (hunion hj' hf)))\n     (and (J hj')\n        (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J)))"
                ],
                "tactic_res": [
                    "c41_goal : hdisj3 (hunion h1' h') hj' hf",
                    "c42_goal : and (eq h'0 (hunion (hunion h1' h') (hunion hj' hf)))\n  (and (J hj')\n     (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c41_goal : hdisj3 (hunion h1' h') hj' hf",
                    "c35_A : hdisj3 h1' hj' (hunion h' hf)",
                    "c35_h1' : heap",
                    "c35_hj' : heap",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_hf : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c42_goal : and (eq h'0 (hunion (hunion h1' h') (hunion hj' hf)))\n  (and (J hj')\n     (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J))"
                ],
                "tactic_res": [
                    "c43_goal : eq h'0 (hunion (hunion h1' h') (hunion hj' hf))",
                    "c44_goal : and (J hj')\n  (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c43_goal : eq h'0 (hunion (hunion h1' h') (hunion hj' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c45_goal : eq h'0 (hunion h1' (hunion h' (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) by HDISJ .",
                "tactic_args": [
                    "c45_goal : eq h'0 (hunion h1' (hunion h' (hunion hj' hf)))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c35_hj' : heap",
                    "c30_hf : heap",
                    "c35_D : safe n ?c' h1' Q J",
                    "c35_C : J hj'",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' (hunion h' hf)))",
                    "c35_A : hdisj3 h1' hj' (hunion h' hf)",
                    "c35_h1' : heap",
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c30_H3 : J hj",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_h'0 : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c46_goal : eq h'0 (hunion h1' (hunion (hunion hj' hf) h'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c46_goal : eq h'0 (hunion h1' (hunion (hunion hj' hf) h'))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c47_goal : eq h'0 (hunion h1' (hunion hj' (hunion hf h')))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c47_goal : eq h'0 (hunion h1' (hunion hj' (hunion hf h')))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c6_h' : heap",
                    "c35_D : safe n ?c' h1' Q J",
                    "c35_C : J hj'",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' (hunion h' hf)))",
                    "c35_A : hdisj3 h1' hj' (hunion h' hf)",
                    "c35_h1' : heap",
                    "c35_hj' : heap",
                    "c30_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c30_H3 : J hj",
                    "c30_H : hdisj3 (hunion h h') hj hf",
                    "c30_h'0 : heap",
                    "c30_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : R h'",
                    "c6_H0 : hdisjoint h h'",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c48_goal : eq h'0 (hunion h1' (hunion hj' (hunion h' hf)))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c48_goal : eq h'0 (hunion h1' (hunion hj' (hunion h' hf)))",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' (hunion h' hf)))",
                    "c35_h1' : heap",
                    "c35_hj' : heap",
                    "c30_h'0 : heap",
                    "c30_hf : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c44_goal : and (J hj')\n  (safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J)"
                ],
                "tactic_res": [
                    "c49_goal : J hj'",
                    "c50_goal : safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c49_goal : J hj'",
                    "c35_C : J hj'",
                    "c35_hj' : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c50_goal : safe n c' (hunion h1' h') (fun v : Z => sepconj (Q v) R) J",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q J)\n  (_ : hdisjoint h h') (_ : R h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c51_goal : safe n c' h1' Q J",
                    "c52_goal : hdisjoint h1' h'",
                    "c53_goal : R h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : safe n c' h1' Q J",
                    "c35_D : safe n ?c' h1' Q J",
                    "c35_h1' : heap",
                    "c30_c' : com",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : R h'",
                    "c6_H1 : R h'",
                    "c6_h' : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c52_goal : hdisjoint h1' h'",
                    "c35_A : hdisj3 h1' hj' (hunion h' hf)",
                    "c35_h1' : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_frame",
        "proof": [
            {
                "tactic_sig": "Lemma triple_frame : forall J P c Q R , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_frame : forall J P c Q R , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (R : assertion) (_ : triple J P c Q),\ntriple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (R : assertion) (_ : triple J P c Q),\ntriple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c2_goal : triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "c2_J : invariant",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_R : assertion",
                    "c2_H : triple J P c Q"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : sepconj P R h),\nsafe n c h (fun v : Z => sepconj (Q v) R) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : sepconj P R h),\nsafe n c h (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c4_goal : safe n c h (fun v : Z => sepconj (Q v) R) J",
                    "c4_n : nat",
                    "c4_h : heap",
                    "c4_H0 : sepconj P R h"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( h1 & h2 & P1 & R2 & D & U ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( h1 & h2 & P1 & R2 & D & U ) .",
                "tactic_args": [
                    "c4_H0 : sepconj P R h",
                    "c4_h : heap",
                    "c4_n : nat",
                    "c2_H : triple J P c Q",
                    "c2_R : assertion",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c4_U : eq h (hunion h1 h2)",
                    "c4_D : hdisjoint h1 h2",
                    "c4_R2 : R h2",
                    "c4_P1 : P h1",
                    "c4_h2 : heap",
                    "c4_h1 : heap"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_goal : safe n c h (fun v : Z => sepconj (Q v) R) J",
                    "c4_h : heap",
                    "c4_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c5_goal : safe n c (hunion h1 h2) (fun v : Z => sepconj (Q v) R) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe n c (hunion h1 h2) (fun v : Z => sepconj (Q v) R) J",
                    "_global_safe_frame : forall (R : assertion) (Q : postcond) (J : invariant) \n         (n : nat) (c : com) (h h' : heap) (_ : safe n c h Q J)\n         (_ : hdisjoint h h') (_ : R h'),\n       safe n c (hunion h h') (fun v : Z => sepconj (Q v) R) J"
                ],
                "tactic_res": [
                    "c6_goal : safe n c h1 Q J",
                    "c7_goal : hdisjoint h1 h2",
                    "c8_goal : R h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : safe n c h1 Q J",
                    "c4_P1 : P h1",
                    "c4_h1 : heap",
                    "c4_n : nat",
                    "c2_H : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : hdisjoint h1 h2",
                    "c4_D : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : R h2",
                    "c4_R2 : R h2",
                    "c4_h2 : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_frame_invariant",
        "proof": [
            {
                "tactic_sig": "Lemma safe_frame_invariant : forall Q ( J J' : invariant ) n c h , safe n c h Q J -> safe n c h Q ( J ** J' ) .",
                "tactic_sig_no_out_arg": "Lemma safe_frame_invariant : forall Q ( J J' : invariant ) n c h , safe n c h Q J -> safe n c h Q ( J ** J' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : postcond) (J J' : invariant) (n : nat) \n  (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q J J' n .",
                "tactic_args": [
                    "c1_goal : forall (Q : postcond) (J J' : invariant) (n : nat) \n  (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_J' : invariant",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J),\nsafe 0 c h Q (sepconj J J')",
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J),\nsafe (S n) c h Q (sepconj J J')",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J),\nsafe 0 c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 c h Q (sepconj J J')",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_H : safe 0 c h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J),\nsafe (S n) c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c6_goal : safe (S n) c h Q (sepconj J J')",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_H : safe (S n) c h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 c h Q (sepconj J J')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe (S n) c h Q (sepconj J J')",
                    "c6_H : safe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c7_goal : safe (S n) (PURE v) h Q (sepconj J J')",
                    "c7_H1 : Q v h",
                    "c7_v : Z",
                    "c8_goal : safe (S n) c h Q (sepconj J J')",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (S n) (PURE v) h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c9_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Q v h",
                    "c7_H1 : Q v h",
                    "c7_v : Z",
                    "c6_h : heap",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c10_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c11_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c12_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c13_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))"
                ],
                "tactic_res": [
                    "c14_goal : not (erroneous (pair c h0))",
                    "c14_hf : heap",
                    "c14_hj : heap",
                    "c14_h0 : heap",
                    "c14_H : hdisj3 h hj hf",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c14_H1 : sepconj J J' hj"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( hj1 & hj2 & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( hj1 & hj2 & A & B & C & D ) .",
                "tactic_args": [
                    "c14_H1 : sepconj J J' hj",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c14_H : hdisj3 h hj hf",
                    "c14_h0 : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c14_D : eq hj (hunion hj1 hj2)",
                    "c14_C : hdisjoint hj1 hj2",
                    "c14_B : J' hj2",
                    "c14_A : J hj1",
                    "c14_hj2 : heap",
                    "c14_hj1 : heap"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c14_goal : not (erroneous (pair c h0))",
                    "c14_hj : heap",
                    "c14_h0 : heap",
                    "c14_D : eq hj (hunion hj1 hj2)",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c15_goal : not (erroneous (pair c (hunion h (hunion (hunion hj1 hj2) hf))))",
                    "c15_H : hdisj3 h (hunion hj1 hj2) hf"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i _i _i ) _i ) .",
                "tactic_args": [
                    "c15_goal : not (erroneous (pair c (hunion h (hunion (hunion hj1 hj2) hf))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c14_hj2 : heap",
                    "c14_hf : heap",
                    "c14_hj1 : heap"
                ],
                "tactic_res": [
                    "c16_goal : hdisj3 h hj1 (hunion hj2 hf)",
                    "c17_goal : eq (hunion h (hunion (hunion hj1 hj2) hf))\n  (hunion h (hunion hj1 (hunion hj2 hf)))",
                    "c18_goal : J hj1"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c16_goal : hdisj3 h hj1 (hunion hj2 hf)",
                    "c14_C : hdisjoint hj1 hj2",
                    "c15_H : hdisj3 h (hunion hj1 hj2) hf",
                    "c14_hf : heap",
                    "c14_hj1 : heap",
                    "c14_hj2 : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c17_goal : eq (hunion h (hunion (hunion hj1 hj2) hf))\n  (hunion h (hunion hj1 (hunion hj2 hf)))"
                ],
                "tactic_res": [
                    "c19_goal : eq (hunion (hunion hj1 hj2) hf) (hunion hj1 (hunion hj2 hf))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : eq (hunion (hunion hj1 hj2) hf) (hunion hj1 (hunion hj2 hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c20_goal : eq (hunion hj1 (hunion hj2 hf)) (hunion hj1 (hunion hj2 hf))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : eq (hunion hj1 (hunion hj2 hf)) (hunion hj1 (hunion hj2 hf))",
                    "c14_hf : heap",
                    "c14_hj1 : heap",
                    "c14_hj2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : J hj1",
                    "c14_A : J hj1",
                    "c14_hj1 : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))"
                ],
                "tactic_res": [
                    "c21_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c21_hf : heap",
                    "c21_hj : heap",
                    "c21_h0 : heap",
                    "c21_c' : com",
                    "c21_h' : heap",
                    "c21_H : hdisj3 h hj hf",
                    "c21_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c21_H1 : sepconj J J' hj",
                    "c21_H2 : red (pair c h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( hj1 & hj2 & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( hj1 & hj2 & A & B & C & D ) .",
                "tactic_args": [
                    "c21_H1 : sepconj J J' hj",
                    "c21_H2 : red (pair c h0) (pair c' h')",
                    "c21_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c21_H : hdisj3 h hj hf",
                    "c21_h' : heap",
                    "c21_c' : com",
                    "c21_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_J' : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c21_D : eq hj (hunion hj1 hj2)",
                    "c21_C : hdisjoint hj1 hj2",
                    "c21_B : J' hj2",
                    "c21_A : J hj1",
                    "c21_hj2 : heap",
                    "c21_hj1 : heap"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c21_hj : heap",
                    "c21_h0 : heap",
                    "c21_D : eq hj (hunion hj1 hj2)",
                    "c21_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c21_H2 : red (pair c (hunion h (hunion (hunion hj1 hj2) hf))) (pair c' h')",
                    "c21_H : hdisj3 h (hunion hj1 hj2) hf"
                ]
            },
            {
                "tactic_sig": "edestruct ( _i ( hunion _i _i ) _i ) as ( h1' & hj1' & U & V & X & Y ) .",
                "tactic_sig_no_out_arg": "edestruct ( _i ( hunion _i _i ) _i ) as ( h1' & hj1' & U & V & X & Y ) .",
                "tactic_args": [
                    "c21_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c21_hj2 : heap",
                    "c21_hf : heap",
                    "c21_hj1 : heap"
                ],
                "tactic_res": [
                    "c22_goal : hdisj3 h hj1 (hunion hj2 hf)",
                    "c23_goal : eq ?h (hunion h (hunion hj1 (hunion hj2 hf)))",
                    "c24_goal : J hj1",
                    "c25_goal : red (pair c (hunion h (hunion hj1 (hunion hj2 hf)))) (pair ?c' ?h')",
                    "c26_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c26_Y : safe n ?c' h1' Q J",
                    "c26_X : J hj1'",
                    "c26_V : eq ?h' (hunion h1' (hunion hj1' (hunion hj2 hf)))",
                    "c26_U : hdisj3 h1' hj1' (hunion hj2 hf)",
                    "c26_hj1' : heap",
                    "c26_h1' : heap"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c22_goal : hdisj3 h hj1 (hunion hj2 hf)",
                    "c21_C : hdisjoint hj1 hj2",
                    "c21_H : hdisj3 h (hunion hj1 hj2) hf",
                    "c21_hj1 : heap",
                    "c21_hj2 : heap",
                    "c21_hf : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : eq ?h (hunion h (hunion hj1 (hunion hj2 hf)))",
                    "c21_hj1 : heap",
                    "c21_hj2 : heap",
                    "c21_hf : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : J hj1",
                    "c21_A : J hj1",
                    "c21_hj1 : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c25_goal : red (pair c (hunion h (hunion hj1 (hunion hj2 hf)))) (pair ?c' ?h')",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c21_hj1 : heap",
                    "c21_H2 : red (pair c (hunion h (hunion (hunion hj1 hj2) hf))) (pair c' h')",
                    "c21_C : hdisjoint hj1 hj2",
                    "c21_B : J' hj2",
                    "c21_A : J hj1",
                    "c21_H : hdisj3 h (hunion hj1 hj2) hf",
                    "c21_hj2 : heap",
                    "c21_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_h : heap",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c27_goal : red (pair c (hunion h (hunion (hunion hj1 hj2) hf))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : red (pair c (hunion h (hunion (hunion hj1 hj2) hf))) (pair ?c' ?h')",
                    "c21_H2 : red (pair c (hunion h (hunion (hunion hj1 hj2) hf))) (pair c' h')",
                    "c21_hj1 : heap",
                    "c21_hj2 : heap",
                    "c21_hf : heap",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c26_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c21_h' : heap",
                    "c26_V : eq ?h' (hunion h1' (hunion hj1' (hunion hj2 hf)))"
                ],
                "tactic_res": [
                    "c28_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1'0 hj' hf)\n        (and\n           (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n              (hunion h1'0 (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1'0 Q (sepconj J J'))))))",
                    "c28_Y : safe n c' h1' Q J",
                    "c28_H2 : red (pair c (hunion h (hunion (hunion hj1 hj2) hf)))\n  (pair c' (hunion h1' (hunion hj1' (hunion hj2 hf))))"
                ]
            },
            {
                "tactic_sig": "exists _i , ( hunion _i _i ) .",
                "tactic_sig_no_out_arg": "exists _i , ( hunion _i _i ) .",
                "tactic_args": [
                    "c28_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1'0 hj' hf)\n        (and\n           (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n              (hunion h1'0 (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1'0 Q (sepconj J J'))))))",
                    "c26_h1' : heap",
                    "c26_hj1' : heap",
                    "c21_hj2 : heap"
                ],
                "tactic_res": [
                    "c29_goal : and (hdisj3 h1' (hunion hj1' hj2) hf)\n  (and\n     (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n        (hunion h1' (hunion (hunion hj1' hj2) hf)))\n     (and (sepconj J J' (hunion hj1' hj2))\n        (safe n c' h1' Q (sepconj J J'))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c29_goal : and (hdisj3 h1' (hunion hj1' hj2) hf)\n  (and\n     (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n        (hunion h1' (hunion (hunion hj1' hj2) hf)))\n     (and (sepconj J J' (hunion hj1' hj2))\n        (safe n c' h1' Q (sepconj J J'))))"
                ],
                "tactic_res": [
                    "c30_goal : hdisj3 h1' (hunion hj1' hj2) hf",
                    "c31_goal : and\n  (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n     (hunion h1' (hunion (hunion hj1' hj2) hf)))\n  (and (sepconj J J' (hunion hj1' hj2))\n     (safe n c' h1' Q (sepconj J J')))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c30_goal : hdisj3 h1' (hunion hj1' hj2) hf",
                    "c26_U : hdisj3 h1' hj1' (hunion hj2 hf)",
                    "c26_h1' : heap",
                    "c26_hj1' : heap",
                    "c21_H : hdisj3 h (hunion hj1 hj2) hf",
                    "c21_hj2 : heap",
                    "c21_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c31_goal : and\n  (eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n     (hunion h1' (hunion (hunion hj1' hj2) hf)))\n  (and (sepconj J J' (hunion hj1' hj2))\n     (safe n c' h1' Q (sepconj J J')))"
                ],
                "tactic_res": [
                    "c32_goal : eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n  (hunion h1' (hunion (hunion hj1' hj2) hf))",
                    "c33_goal : and (sepconj J J' (hunion hj1' hj2)) (safe n c' h1' Q (sepconj J J'))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c32_goal : eq (hunion h1' (hunion hj1' (hunion hj2 hf)))\n  (hunion h1' (hunion (hunion hj1' hj2) hf))"
                ],
                "tactic_res": [
                    "c34_goal : eq (hunion hj1' (hunion hj2 hf)) (hunion (hunion hj1' hj2) hf)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c34_goal : eq (hunion hj1' (hunion hj2 hf)) (hunion (hunion hj1' hj2) hf)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c35_goal : eq (hunion hj1' (hunion hj2 hf)) (hunion hj1' (hunion hj2 hf))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq (hunion hj1' (hunion hj2 hf)) (hunion hj1' (hunion hj2 hf))",
                    "c26_hj1' : heap",
                    "c21_hj2 : heap",
                    "c21_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c33_goal : and (sepconj J J' (hunion hj1' hj2)) (safe n c' h1' Q (sepconj J J'))"
                ],
                "tactic_res": [
                    "c36_goal : sepconj J J' (hunion hj1' hj2)",
                    "c37_goal : safe n c' h1' Q (sepconj J J')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c36_goal : sepconj J J' (hunion hj1' hj2)",
                    "c26_hj1' : heap",
                    "c21_hj2 : heap"
                ],
                "tactic_res": [
                    "c38_goal : and (J hj1')\n  (and (J' hj2)\n     (and (hdisjoint hj1' hj2) (eq (hunion hj1' hj2) (hunion hj1' hj2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c38_goal : and (J hj1')\n  (and (J' hj2)\n     (and (hdisjoint hj1' hj2) (eq (hunion hj1' hj2) (hunion hj1' hj2))))",
                    "c28_Y : safe n c' h1' Q J",
                    "c26_X : J hj1'",
                    "c26_U : hdisj3 h1' hj1' (hunion hj2 hf)",
                    "c28_H2 : red (pair c (hunion h (hunion (hunion hj1 hj2) hf)))\n  (pair c' (hunion h1' (hunion hj1' (hunion hj2 hf))))",
                    "c26_hj1' : heap",
                    "c21_C : hdisjoint hj1 hj2",
                    "c21_B : J' hj2",
                    "c21_A : J hj1",
                    "c21_H : hdisj3 h (hunion hj1 hj2) hf",
                    "c21_hj2 : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')",
                    "c2_J : invariant",
                    "c2_J' : invariant"
                ],
                "tactic_res": [
                    "c39_goal : hdisjoint hj1' hj2",
                    "c39_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : erroneous (pair c h0)), False",
                    "c39_ACC : forall (l : addr) (_ : immacc l c) (_ : eq (h l) None), False"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c39_goal : hdisjoint hj1' hj2",
                    "c26_U : hdisj3 h1' hj1' (hunion hj2 hf)",
                    "c26_hj1' : heap",
                    "c21_hj2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : safe n c' h1' Q (sepconj J J')",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J),\nsafe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c40_goal : safe n c' h1' Q J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : safe n c' h1' Q J",
                    "c28_Y : safe n c' h1' Q J",
                    "c26_h1' : heap",
                    "c21_c' : com",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_frame_invariant",
        "proof": [
            {
                "tactic_sig": "Lemma triple_frame_invariant : forall J J' P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J ** J' \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_frame_invariant : forall J J' P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J ** J' \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (J' : assertion) (P : precond) \n  (c : com) (Q : postcond) (_ : triple J P c Q),\ntriple (sepconj J J') P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (J' : assertion) (P : precond) \n  (c : com) (Q : postcond) (_ : triple J P c Q),\ntriple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (sepconj J J') P c Q",
                    "c2_J : invariant",
                    "c2_J' : assertion",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : triple J P c Q"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h), safe n c h Q (sepconj J J')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h), safe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c4_goal : safe n c h Q (sepconj J J')",
                    "c4_n : nat",
                    "c4_h : heap",
                    "c4_H0 : P h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe n c h Q (sepconj J J')",
                    "_global_safe_frame_invariant : forall (Q : postcond) (J J' : invariant) (n : nat) \n         (c : com) (h : heap) (_ : safe n c h Q J),\n       safe n c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c5_goal : safe n c h Q J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe n c h Q J",
                    "c4_H0 : P h",
                    "c4_h : heap",
                    "c4_n : nat",
                    "c2_H : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_atomic",
        "proof": [
            {
                "tactic_sig": "Lemma triple_atomic : forall J P c ( Q : postcond ) , emp \u22a2 \u2983 P ** J \u2984 c \u2983 fun v => Q v ** J \u2984 -> J \u22a2 \u2983 P \u2984 ATOMIC c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_atomic : forall J P c ( Q : postcond ) , emp \u22a2 \u2983 P ** J \u2984 c \u2983 fun v => Q v ** J \u2984 -> J \u22a2 \u2983 P \u2984 ATOMIC c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J P : assertion) (c : com) (Q : postcond)\n  (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\ntriple J P (ATOMIC c) Q"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q .",
                "tactic_args": [
                    "c1_goal : forall (J P : assertion) (c : com) (Q : postcond)\n  (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\ntriple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J),\ntriple J P (ATOMIC c) Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_J : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros TR n h Ph .",
                "tactic_args": [
                    "c2_goal : forall _ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J),\ntriple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe n (ATOMIC c) h Q J",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : safe n (ATOMIC c) h Q J",
                    "c3_n : nat",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : assertion"
                ],
                "tactic_res": [
                    "c4_goal : safe 0 (ATOMIC c) h Q J",
                    "c5_goal : safe (S n) (ATOMIC c) h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe 0 (ATOMIC c) h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe (S n) (ATOMIC c) h Q J"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c7_goal : forall (l : addr) (_ : immacc l (ATOMIC c)), not (eq (h l) None)",
                    "c8_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (ATOMIC c) h0))",
                    "c9_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (ATOMIC c) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (l : addr) (_ : immacc l (ATOMIC c)), not (eq (h l) None)",
                    "c3_h : heap",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (ATOMIC c) h0))"
                ],
                "tactic_res": [
                    "c10_goal : not (erroneous (pair (ATOMIC c) h0))",
                    "c10_hf : heap",
                    "c10_hj : heap",
                    "c10_h0 : heap",
                    "c10_H : hdisj3 h hj hf",
                    "c10_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c10_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c10_goal : not (erroneous (pair (ATOMIC c) h0))"
                ],
                "tactic_res": [
                    "c11_goal : False",
                    "c11_ST : erroneous (pair (ATOMIC c) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_ST : erroneous (pair (ATOMIC c) h0)"
                ],
                "tactic_res": [
                    "c11_H5 : erroneous (pair c' h')",
                    "c11_H4 : star red (pair c (hunion h (hunion hj hf))) (pair c' h')",
                    "c11_h' : heap",
                    "c11_c' : com"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_star_starN : forall (A : Type) (R : forall (_ : A) (_ : A), Prop) \n         (a b : A) (_ : star R a b), ex (fun n : nat => starN R n a b)",
                    "c11_H4 : star red (pair c (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_H4 : ex\n  (fun n : nat =>\n   starN red n (pair c (hunion h (hunion hj hf))) (pair c' h'))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( N & STEPS ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( N & STEPS ) .",
                "tactic_args": [
                    "c11_H4 : ex\n  (fun n : nat =>\n   starN red n (pair c (hunion h (hunion hj hf))) (pair c' h'))",
                    "c11_H5 : erroneous (pair c' h')",
                    "c10_H1 : J hj",
                    "c10_H : hdisj3 h hj hf",
                    "c3_Ph : P h",
                    "c3_n : nat",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)"
                ],
                "tactic_res": [
                    "c11_STEPS : starN red N (pair c (hunion h (hunion hj hf))) (pair c' h')",
                    "c11_N : nat"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c11_STEPS : starN red N (pair c (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_STEPS : starN red N (pair c (hunion (hunion h hj) hf)) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i .",
                "tactic_args": [
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "c10_hf : heap",
                    "c11_STEPS : starN red N (pair c (hunion (hunion h hj) hf)) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair c' h')"
                ]
            },
            {
                "tactic_sig": "edestruct safe_redN as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct safe_redN as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c11_goal : False"
                ],
                "tactic_res": [
                    "c12_goal : starN red ?n (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c13_goal : safe (S N) c (hunion h hj) ?Q ?J",
                    "c14_goal : emp hempty",
                    "c15_goal : hdisj3 (hunion h hj) hempty hf",
                    "c16_goal : False",
                    "c16_D : safe 1 ?c' h1' ?Q ?J",
                    "c16_C : ?J hj'",
                    "c16_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c16_A : hdisj3 h1' hj' ?hf",
                    "c16_hj' : heap",
                    "c16_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : starN red ?n (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c11_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair c' h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : safe (S N) c (hunion h hj) ?Q ?J",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)"
                ],
                "tactic_res": [
                    "c17_goal : sepconj P J (hunion h hj)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c17_goal : sepconj P J (hunion h hj)",
                    "c3_h : heap",
                    "c10_hj : heap"
                ],
                "tactic_res": [
                    "c18_goal : and (P h)\n  (and (J hj) (and (hdisjoint h hj) (eq (hunion h hj) (hunion h hj))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c18_goal : and (P h)\n  (and (J hj) (and (hdisjoint h hj) (eq (hunion h hj) (hunion h hj))))",
                    "c11_H5 : erroneous (pair c' h')",
                    "c11_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair c' h')",
                    "c10_H1 : J hj",
                    "c10_H : hdisj3 h hj hf",
                    "c10_hj : heap",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c2_J : assertion",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c19_goal : hdisjoint h hj"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c19_goal : hdisjoint h hj",
                    "c10_H : hdisj3 h hj hf",
                    "c10_hj : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c14_goal : emp hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c15_goal : hdisj3 (hunion h hj) hempty hf",
                    "c10_H : hdisj3 h hj hf",
                    "c10_hf : heap",
                    "c10_hj : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eelim safe_not_erroneous .",
                "tactic_sig_no_out_arg": "eelim safe_not_erroneous .",
                "tactic_args": [
                    "c16_goal : False"
                ],
                "tactic_res": [
                    "c20_goal : safe (S ?n) ?c ?h1 ?Q ?J",
                    "c21_goal : hdisj3 h1' ?hj ?hf",
                    "c22_goal : emp hj'",
                    "c23_goal : erroneous (pair c' (hunion h1' (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c20_goal : safe (S ?n) ?c ?h1 ?Q ?J",
                    "c16_D : safe 1 ?c' h1' ?Q ?J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c21_goal : hdisj3 h1' ?hj ?hf",
                    "c16_A : hdisj3 h1' hj' ?hf"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : emp hj'",
                    "c16_C : ?J hj'",
                    "c16_hj' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c11_h' : heap",
                    "c16_B : eq ?h' (hunion h1' (hunion hj' ?hf))"
                ],
                "tactic_res": [
                    "c23_D : safe 1 c' h1' (fun v : Z => sepconj (Q v) J) emp",
                    "c23_C : emp hj'",
                    "c23_A : hdisj3 h1' hj' hf",
                    "c23_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair c' (hunion h1' (hunion hj' hf)))",
                    "c23_H5 : erroneous (pair c' (hunion h1' (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : erroneous (pair c' (hunion h1' (hunion hj' hf)))",
                    "c23_H5 : erroneous (pair c' (hunion h1' (hunion hj' hf)))",
                    "c16_h1' : heap",
                    "c16_hj' : heap",
                    "c11_c' : com",
                    "c10_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (ATOMIC c) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c24_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c24_hf : heap",
                    "c24_hj : heap",
                    "c24_h0 : heap",
                    "c24_c' : com",
                    "c24_h' : heap",
                    "c24_H : hdisj3 h hj hf",
                    "c24_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c24_H1 : J hj",
                    "c24_H2 : red (pair (ATOMIC c) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c24_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c24_H2 : red (pair (ATOMIC c) h0) (pair c' h')"
                ],
                "tactic_res": [
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (PURE v) h1' Q J)))))",
                    "c25_H4 : star red (pair c (hunion h (hunion hj hf))) (pair (PURE v) h')",
                    "c25_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_star_starN : forall (A : Type) (R : forall (_ : A) (_ : A), Prop) \n         (a b : A) (_ : star R a b), ex (fun n : nat => starN R n a b)",
                    "c25_H4 : star red (pair c (hunion h (hunion hj hf))) (pair (PURE v) h')"
                ],
                "tactic_res": [
                    "c25_H4 : ex\n  (fun n : nat =>\n   starN red n (pair c (hunion h (hunion hj hf))) (pair (PURE v) h'))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( N & STEPS ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( N & STEPS ) .",
                "tactic_args": [
                    "c25_H4 : ex\n  (fun n : nat =>\n   starN red n (pair c (hunion h (hunion hj hf))) (pair (PURE v) h'))",
                    "c25_v : Z",
                    "c24_H1 : J hj",
                    "c24_H : hdisj3 h hj hf",
                    "c24_hf : heap",
                    "c24_h' : heap",
                    "c3_Ph : P h",
                    "c3_n : nat",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c2_Q : postcond",
                    "c2_J : assertion"
                ],
                "tactic_res": [
                    "c25_STEPS : starN red N (pair c (hunion h (hunion hj hf))) (pair (PURE v) h')",
                    "c25_N : nat"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c25_STEPS : starN red N (pair c (hunion h (hunion hj hf))) (pair (PURE v) h')"
                ],
                "tactic_res": [
                    "c25_STEPS : starN red N (pair c (hunion (hunion h hj) hf)) (pair (PURE v) h')"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i .",
                "tactic_args": [
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "c24_hf : heap",
                    "c25_STEPS : starN red N (pair c (hunion (hunion h hj) hf)) (pair (PURE v) h')"
                ],
                "tactic_res": [
                    "c25_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) h')"
                ]
            },
            {
                "tactic_sig": "edestruct safe_redN as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct safe_redN as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (PURE v) h1' Q J)))))"
                ],
                "tactic_res": [
                    "c26_goal : starN red ?n (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c27_goal : safe (S N) c (hunion h hj) ?Q ?J",
                    "c28_goal : emp hempty",
                    "c29_goal : hdisj3 (hunion h hj) hempty hf",
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (PURE v) h1' Q J)))))",
                    "c30_D : safe 1 ?c' h1' ?Q ?J",
                    "c30_C : ?J hj'",
                    "c30_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c30_A : hdisj3 h1' hj' ?hf",
                    "c30_hj' : heap",
                    "c30_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c26_goal : starN red ?n (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c25_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : safe (S N) c (hunion h hj) ?Q ?J",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)"
                ],
                "tactic_res": [
                    "c31_goal : sepconj P J (hunion h hj)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c31_goal : sepconj P J (hunion h hj)",
                    "c3_h : heap",
                    "c24_hj : heap"
                ],
                "tactic_res": [
                    "c32_goal : and (P h)\n  (and (J hj) (and (hdisjoint h hj) (eq (hunion h hj) (hunion h hj))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c32_goal : and (P h)\n  (and (J hj) (and (hdisjoint h hj) (eq (hunion h hj) (hunion h hj))))",
                    "c25_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) h')",
                    "c24_H1 : J hj",
                    "c24_H : hdisj3 h hj hf",
                    "c24_hj : heap",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c2_J : assertion",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c33_goal : hdisjoint h hj"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c33_goal : hdisjoint h hj",
                    "c24_H : hdisj3 h hj hf",
                    "c24_hj : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c28_goal : emp hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c29_goal : hdisj3 (hunion h hj) hempty hf",
                    "c24_H : hdisj3 h hj hf",
                    "c24_hf : heap",
                    "c24_hj : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (PURE v) h1' Q J)))))",
                    "c24_h' : heap",
                    "c30_B : eq ?h' (hunion h1' (hunion hj' ?hf))"
                ],
                "tactic_res": [
                    "c34_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1'0 hj'0 hf)\n        (and\n           (eq (hunion h1' (hunion hj' hf))\n              (hunion h1'0 (hunion hj'0 hf)))\n           (and (J hj'0) (safe n (PURE v) h1'0 Q J)))))",
                    "c34_D : safe 1 (PURE v) h1' (fun v : Z => sepconj (Q v) J) emp",
                    "c34_C : emp hj'",
                    "c34_A : hdisj3 h1' hj' hf",
                    "c34_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) (hunion h1' (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_safe_pure_inv : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe (S n) (PURE v) h Q J), \n       Q v h",
                    "c34_D : safe 1 (PURE v) h1' (fun v : Z => sepconj (Q v) J) emp"
                ],
                "tactic_res": [
                    "c34_D : sepconj (Q v) J h1'"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( h1'' & hj'' & U & V & X & Y ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( h1'' & hj'' & U & V & X & Y ) .",
                "tactic_args": [
                    "c34_D : sepconj (Q v) J h1'",
                    "c34_C : emp hj'",
                    "c34_A : hdisj3 h1' hj' hf",
                    "c34_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) (hunion h1' (hunion hj' hf)))",
                    "c30_h1' : heap",
                    "c30_hj' : heap",
                    "c25_v : Z",
                    "c24_H1 : J hj",
                    "c24_H : hdisj3 h hj hf",
                    "c24_hf : heap",
                    "c3_Ph : P h",
                    "c3_n : nat",
                    "c3_TR : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)",
                    "c2_Q : postcond",
                    "c2_J : assertion"
                ],
                "tactic_res": [
                    "c34_Y : eq h1' (hunion h1'' hj'')",
                    "c34_X : hdisjoint h1'' hj''",
                    "c34_V : J hj''",
                    "c34_U : Q v h1''",
                    "c34_hj'' : heap",
                    "c34_h1'' : heap"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c34_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1'0 hj'0 hf)\n        (and\n           (eq (hunion h1' (hunion hj' hf))\n              (hunion h1'0 (hunion hj'0 hf)))\n           (and (J hj'0) (safe n (PURE v) h1'0 Q J)))))",
                    "c30_h1' : heap",
                    "c34_Y : eq h1' (hunion h1'' hj'')"
                ],
                "tactic_res": [
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1' hj'0 hf)\n        (and\n           (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n              (hunion h1' (hunion hj'0 hf)))\n           (and (J hj'0) (safe n (PURE v) h1' Q J)))))",
                    "c35_STEPS : starN red N (pair c (hunion (hunion h hj) (hunion hempty hf)))\n  (pair (PURE v) (hunion (hunion h1'' hj'') (hunion hj' hf)))",
                    "c35_A : hdisj3 (hunion h1'' hj'') hj' hf"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1' hj'0 hf)\n        (and\n           (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n              (hunion h1' (hunion hj'0 hf)))\n           (and (J hj'0) (safe n (PURE v) h1' Q J)))))",
                    "c34_h1'' : heap",
                    "c34_hj'' : heap"
                ],
                "tactic_res": [
                    "c36_goal : and (hdisj3 h1'' hj'' hf)\n  (and\n     (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n        (hunion h1'' (hunion hj'' hf)))\n     (and (J hj'') (safe n (PURE v) h1'' Q J)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c36_goal : and (hdisj3 h1'' hj'' hf)\n  (and\n     (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n        (hunion h1'' (hunion hj'' hf)))\n     (and (J hj'') (safe n (PURE v) h1'' Q J)))"
                ],
                "tactic_res": [
                    "c37_goal : hdisj3 h1'' hj'' hf",
                    "c38_goal : and\n  (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n     (hunion h1'' (hunion hj'' hf)))\n  (and (J hj'') (safe n (PURE v) h1'' Q J))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c37_goal : hdisj3 h1'' hj'' hf",
                    "c34_X : hdisjoint h1'' hj''",
                    "c35_A : hdisj3 (hunion h1'' hj'') hj' hf",
                    "c34_h1'' : heap",
                    "c34_hj'' : heap",
                    "c24_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c38_goal : and\n  (eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n     (hunion h1'' (hunion hj'' hf)))\n  (and (J hj'') (safe n (PURE v) h1'' Q J))"
                ],
                "tactic_res": [
                    "c39_goal : eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n  (hunion h1'' (hunion hj'' hf))",
                    "c40_goal : and (J hj'') (safe n (PURE v) h1'' Q J)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c39_goal : eq (hunion (hunion h1'' hj'') (hunion hj' hf))\n  (hunion h1'' (hunion hj'' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c41_goal : eq (hunion h1'' (hunion hj'' (hunion hj' hf)))\n  (hunion h1'' (hunion hj'' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c41_goal : eq (hunion h1'' (hunion hj'' (hunion hj' hf)))\n  (hunion h1'' (hunion hj'' hf))",
                    "c34_C : emp hj'"
                ],
                "tactic_res": [
                    "c42_goal : eq (hunion h1'' (hunion hj'' (hunion hempty hf)))\n  (hunion h1'' (hunion hj'' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c42_goal : eq (hunion h1'' (hunion hj'' (hunion hempty hf)))\n  (hunion h1'' (hunion hj'' hf))",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c43_goal : eq (hunion h1'' (hunion hj'' hf)) (hunion h1'' (hunion hj'' hf))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c43_goal : eq (hunion h1'' (hunion hj'' hf)) (hunion h1'' (hunion hj'' hf))",
                    "c34_h1'' : heap",
                    "c34_hj'' : heap",
                    "c24_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c40_goal : and (J hj'') (safe n (PURE v) h1'' Q J)"
                ],
                "tactic_res": [
                    "c44_goal : J hj''",
                    "c45_goal : safe n (PURE v) h1'' Q J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c44_goal : J hj''",
                    "c34_V : J hj''",
                    "c34_hj'' : heap",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c45_goal : safe n (PURE v) h1'' Q J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c46_goal : Q v h1''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : Q v h1''",
                    "c34_U : Q v h1''",
                    "c34_h1'' : heap",
                    "c25_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_share",
        "proof": [
            {
                "tactic_sig": "Lemma safe_share : forall Q ( J J' : invariant ) n c h h' , safe n c h Q ( J ** J' ) -> hdisjoint h h' -> J' h' -> safe n c ( hunion h h' ) ( fun v => Q v ** J' ) J .",
                "tactic_sig_no_out_arg": "Lemma safe_share : forall Q ( J J' : invariant ) n c h h' , safe n c h Q ( J ** J' ) -> hdisjoint h h' -> J' h' -> safe n c ( hunion h h' ) ( fun v => Q v ** J' ) J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : postcond) (J J' : invariant) (n : nat) \n  (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q J J' n .",
                "tactic_args": [
                    "c1_goal : forall (Q : postcond) (J J' : invariant) (n : nat) \n  (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_J' : invariant",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h h' : heap) (_ : safe 0 c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe 0 c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c4_goal : forall (c : com) (h h' : heap) (_ : safe (S n) c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h h' : heap) (_ : safe 0 c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe 0 c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_h' : heap",
                    "c5_H : safe 0 c h Q (sepconj J J')",
                    "c5_H0 : hdisjoint h h'",
                    "c5_H1 : J' h'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h h' : heap) (_ : safe (S n) c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c6_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_H : safe (S n) c h Q (sepconj J J')",
                    "c6_H0 : hdisjoint h h'",
                    "c6_H1 : J' h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c6_H : safe (S n) c h Q (sepconj J J')"
                ],
                "tactic_res": [
                    "c7_goal : safe (S n) (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c7_H3 : Q v h",
                    "c7_v : Z",
                    "c8_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (S n) (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c9_goal : sepconj (Q v) J' (hunion h h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c9_goal : sepconj (Q v) J' (hunion h h')",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": [
                    "c10_goal : and (Q v h)\n  (and (J' h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : and (Q v h)\n  (and (J' h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))",
                    "c7_H3 : Q v h",
                    "c7_v : Z",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c2_J' : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (hunion h h' l) None)",
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair c h0))",
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h'0 : heap)\n  (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj) (_ : red (pair c h0) (pair c' h'0)),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c15_goal : not (eq (hunion h h' l) None)",
                    "c15_l : addr",
                    "c15_H : immacc l c"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c15_H : immacc l c"
                ],
                "tactic_res": [
                    "c15_H : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c15_goal : not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c16_goal : not (eq (if h l then h l else h' l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c16_goal : not (eq (if h l then h l else h' l) None)",
                    "c6_h : heap",
                    "c15_l : addr",
                    "c15_H : not (eq (h l) None)",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c17_goal : not (eq (Some z) None)",
                    "c17_H : not (eq (Some z) None)",
                    "c17_z : Z",
                    "c18_goal : not (eq (h' l) None)",
                    "c18_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c17_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c18_goal : not (eq (h' l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair c h0))"
                ],
                "tactic_res": [
                    "c19_goal : not (erroneous (pair c h0))",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c19_h0 : heap",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c19_H3 : J hj"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c19_goal : not (erroneous (pair c h0))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c19_hf : heap",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c6_h' : heap",
                    "c19_hj : heap"
                ],
                "tactic_res": [
                    "c20_goal : hdisj3 h (hunion h' hj) hf",
                    "c21_goal : eq h0 (hunion h (hunion (hunion h' hj) hf))",
                    "c22_goal : sepconj J J' (hunion h' hj)"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c20_goal : hdisj3 h (hunion h' hj) hf",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c21_goal : eq h0 (hunion h (hunion (hunion h' hj) hf))",
                    "c19_h0 : heap",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c23_goal : eq (hunion (hunion h h') (hunion hj hf))\n  (hunion h (hunion (hunion h' hj) hf))"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c23_goal : eq (hunion (hunion h h') (hunion hj hf))\n  (hunion h (hunion (hunion h' hj) hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c24_goal : eq (hunion h (hunion h' (hunion hj hf)))\n  (hunion h (hunion h' (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (hunion h (hunion h' (hunion hj hf)))\n  (hunion h (hunion h' (hunion hj hf)))",
                    "c19_hf : heap",
                    "c19_hj : heap",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i by HDISJ .",
                "tactic_args": [
                    "c22_goal : sepconj J J' (hunion h' hj)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c19_H3 : J hj",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_J : invariant",
                    "c2_J' : invariant"
                ],
                "tactic_res": [
                    "c25_goal : sepconj J J' (hunion hj h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c25_goal : sepconj J J' (hunion hj h')",
                    "c19_hj : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": [
                    "c26_goal : and (J hj)\n  (and (J' h')\n     (and (hdisjoint hj h') (eq (hunion hj h') (hunion hj h'))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c26_goal : and (J hj)\n  (and (J' h')\n     (and (hdisjoint hj h') (eq (hunion hj h') (hunion hj h'))))",
                    "c19_H3 : J hj",
                    "c19_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_J : invariant",
                    "c2_J' : invariant"
                ],
                "tactic_res": [
                    "c27_goal : hdisjoint hj h'",
                    "c27_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : erroneous (pair c h0)), False",
                    "c27_ACC : forall (l : addr) (_ : immacc l c) (_ : eq (h l) None), False"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c27_goal : hdisjoint hj h'",
                    "c19_H : hdisj3 (hunion h h') hj hf",
                    "c19_hj : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h'0 : heap)\n  (_ : hdisj3 (hunion h h') hj hf)\n  (_ : eq h0 (hunion (hunion h h') (hunion hj hf))) \n  (_ : J hj) (_ : red (pair c h0) (pair c' h'0)),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))"
                ],
                "tactic_res": [
                    "c28_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))",
                    "c28_hf : heap",
                    "c28_hj : heap",
                    "c28_h0 : heap",
                    "c28_c' : com",
                    "c28_h'0 : heap",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c28_H3 : J hj",
                    "c28_H4 : red (pair c h0) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "edestruct ( _i _i ( hunion _i _i ) ) as ( h1' & hj' & U & V & X & Y ) .",
                "tactic_sig_no_out_arg": "edestruct ( _i _i ( hunion _i _i ) ) as ( h1' & hj' & U & V & X & Y ) .",
                "tactic_args": [
                    "c28_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c28_hf : heap",
                    "c6_h' : heap",
                    "c28_hj : heap"
                ],
                "tactic_res": [
                    "c29_goal : hdisj3 h (hunion h' hj) hf",
                    "c30_goal : eq ?h (hunion h (hunion (hunion h' hj) hf))",
                    "c31_goal : sepconj J J' (hunion h' hj)",
                    "c32_goal : red (pair c (hunion h (hunion h' (hunion hj hf)))) (pair ?c' ?h')",
                    "c33_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))",
                    "c33_Y : safe n c' h1' Q (sepconj J J')",
                    "c33_X : sepconj J J' hj'",
                    "c33_V : eq ?h' (hunion h1' (hunion hj' hf))",
                    "c33_U : hdisj3 h1' hj' hf",
                    "c33_hj' : heap",
                    "c33_h1' : heap"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c29_goal : hdisj3 h (hunion h' hj) hf",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hf : heap",
                    "c28_hj : heap",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_goal : eq ?h (hunion h (hunion (hunion h' hj) hf))",
                    "c28_h0 : heap",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c34_goal : eq ?h@{h0:=hunion (hunion h h') (hunion hj hf)}\n  (hunion h (hunion (hunion h' hj) hf))",
                    "c34_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c34_goal : eq ?h@{h0:=hunion (hunion h h') (hunion hj hf)}\n  (hunion h (hunion (hunion h' hj) hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c35_goal : eq ?h@{h0:=hunion (hunion h h') (hunion hj hf)}\n  (hunion h (hunion h' (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq ?h@{h0:=hunion (hunion h h') (hunion hj hf)}\n  (hunion h (hunion h' (hunion hj hf)))",
                    "c28_hf : heap",
                    "c28_hj : heap",
                    "c6_h : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i by HDISJ .",
                "tactic_args": [
                    "c31_goal : sepconj J J' (hunion h' hj)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c28_H4 : red (pair c h0) (pair c' h'0)",
                    "c28_H3 : J hj",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_J : invariant",
                    "c2_J' : invariant"
                ],
                "tactic_res": [
                    "c36_goal : sepconj J J' (hunion hj h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c36_goal : sepconj J J' (hunion hj h')",
                    "c28_hj : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": [
                    "c37_goal : and (J hj)\n  (and (J' h')\n     (and (hdisjoint hj h') (eq (hunion hj h') (hunion hj h'))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c37_goal : and (J hj)\n  (and (J' h')\n     (and (hdisjoint hj h') (eq (hunion hj h') (hunion hj h'))))",
                    "c28_H4 : red (pair c h0) (pair c' h'0)",
                    "c28_H3 : J hj",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h' : heap",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_J : invariant",
                    "c2_J' : invariant"
                ],
                "tactic_res": [
                    "c38_goal : hdisjoint hj h'",
                    "c38_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : erroneous (pair c h0)), False",
                    "c38_ACC : forall (l : addr) (_ : immacc l c) (_ : eq (h l) None), False"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c38_goal : hdisjoint hj h'",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hj : heap",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- _i by HDISJ .",
                "tactic_args": [
                    "c32_goal : red (pair c (hunion h (hunion h' (hunion hj hf)))) (pair ?c' ?h')",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c28_H4 : red (pair c h0) (pair c' h'0)",
                    "c28_H3 : J hj",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hf : heap",
                    "c28_hj : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_c : com",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c39_goal : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair ?c' ?h')"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c39_goal : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair ?c' ?h')",
                    "c28_h0 : heap",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c40_goal : red (pair c (hunion (hunion h h') (hunion hj hf)))\n  (pair ?c'@{h0:=hunion (hunion h h') (hunion hj hf)}\n     ?h'@{h0:=hunion (hunion h h') (hunion hj hf)})",
                    "c40_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : red (pair c (hunion (hunion h h') (hunion hj hf)))\n  (pair ?c'@{h0:=hunion (hunion h h') (hunion hj hf)}\n     ?h'@{h0:=hunion (hunion h h') (hunion hj hf)})",
                    "c40_H4 : red (pair c (hunion (hunion h h') (hunion hj hf))) (pair c' h'0)",
                    "c28_hf : heap",
                    "c28_hj : heap",
                    "c6_h : heap",
                    "c6_h' : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( hj1' & hj2' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( hj1' & hj2' & A & B & C & D ) .",
                "tactic_args": [
                    "c33_X : sepconj J J' hj'",
                    "c33_Y : safe n c' h1' Q (sepconj J J')",
                    "c33_V : eq ?h' (hunion h1' (hunion hj' hf))",
                    "c33_U : hdisj3 h1' hj' hf",
                    "c28_H4 : red (pair c h0) (pair c' h'0)",
                    "c28_H3 : J hj",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_h'0 : heap",
                    "c28_c' : com",
                    "c28_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_J' : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c33_Y : safe n c' h1' Q (sepconj J J')",
                    "c33_D : eq hj' (hunion hj1' hj2')",
                    "c33_C : hdisjoint hj1' hj2'",
                    "c33_B : J' hj2'",
                    "c33_A : J hj1'",
                    "c33_hj2' : heap",
                    "c33_hj1' : heap"
                ]
            },
            {
                "tactic_sig": "subst _i _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i _i .",
                "tactic_args": [
                    "c33_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h'0 (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => sepconj (Q v) J') J)))))",
                    "c33_hj' : heap",
                    "c28_h'0 : heap",
                    "c28_h0 : heap",
                    "c33_D : eq hj' (hunion hj1' hj2')",
                    "c33_V : eq ?h' (hunion h1' (hunion hj' hf))",
                    "c28_H2 : eq h0 (hunion (hunion h h') (hunion hj hf))"
                ],
                "tactic_res": [
                    "c41_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1'0 hj' hf)\n        (and\n           (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n              (hunion h1'0 (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'0 (fun v : Z => sepconj (Q v) J') J)))))",
                    "c41_U : hdisj3 h1' (hunion hj1' hj2') hf",
                    "c41_H4 : red (pair c (hunion (hunion h h') (hunion hj hf)))\n  (pair c' (hunion h1' (hunion (hunion hj1' hj2') hf)))"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c41_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1'0 hj' hf)\n        (and\n           (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n              (hunion h1'0 (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'0 (fun v : Z => sepconj (Q v) J') J)))))",
                    "c33_h1' : heap",
                    "c33_hj2' : heap",
                    "c33_hj1' : heap"
                ],
                "tactic_res": [
                    "c42_goal : and (hdisj3 (hunion h1' hj2') hj1' hf)\n  (and\n     (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n        (hunion (hunion h1' hj2') (hunion hj1' hf)))\n     (and (J hj1')\n        (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c42_goal : and (hdisj3 (hunion h1' hj2') hj1' hf)\n  (and\n     (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n        (hunion (hunion h1' hj2') (hunion hj1' hf)))\n     (and (J hj1')\n        (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J)))"
                ],
                "tactic_res": [
                    "c43_goal : hdisj3 (hunion h1' hj2') hj1' hf",
                    "c44_goal : and\n  (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n     (hunion (hunion h1' hj2') (hunion hj1' hf)))\n  (and (J hj1')\n     (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c43_goal : hdisj3 (hunion h1' hj2') hj1' hf",
                    "c33_C : hdisjoint hj1' hj2'",
                    "c41_U : hdisj3 h1' (hunion hj1' hj2') hf",
                    "c33_h1' : heap",
                    "c33_hj1' : heap",
                    "c33_hj2' : heap",
                    "c28_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c44_goal : and\n  (eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n     (hunion (hunion h1' hj2') (hunion hj1' hf)))\n  (and (J hj1')\n     (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J))"
                ],
                "tactic_res": [
                    "c45_goal : eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n  (hunion (hunion h1' hj2') (hunion hj1' hf))",
                    "c46_goal : and (J hj1')\n  (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c45_goal : eq (hunion h1' (hunion (hunion hj1' hj2') hf))\n  (hunion (hunion h1' hj2') (hunion hj1' hf))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c33_hj2' : heap",
                    "c33_Y : safe n c' h1' Q (sepconj J J')",
                    "c33_C : hdisjoint hj1' hj2'",
                    "c33_B : J' hj2'",
                    "c33_A : J hj1'",
                    "c41_U : hdisj3 h1' (hunion hj1' hj2') hf",
                    "c41_H4 : red (pair c (hunion (hunion h h') (hunion hj hf)))\n  (pair c' (hunion h1' (hunion (hunion hj1' hj2') hf)))",
                    "c33_h1' : heap",
                    "c33_hj1' : heap",
                    "c28_H3 : J hj",
                    "c28_H : hdisj3 (hunion h h') hj hf",
                    "c28_hf : heap",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (sepconj J J' hj') (safe n c' h1' Q (sepconj J J'))))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : sepconj J J' hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_H1 : J' h'",
                    "c6_H0 : hdisjoint h h'",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c47_goal : eq (hunion h1' (hunion (hunion hj2' hj1') hf))\n  (hunion (hunion h1' hj2') (hunion hj1' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c47_goal : eq (hunion h1' (hunion (hunion hj2' hj1') hf))\n  (hunion (hunion h1' hj2') (hunion hj1' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c48_goal : eq (hunion h1' (hunion hj2' (hunion hj1' hf)))\n  (hunion h1' (hunion hj2' (hunion hj1' hf)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : eq (hunion h1' (hunion hj2' (hunion hj1' hf)))\n  (hunion h1' (hunion hj2' (hunion hj1' hf)))",
                    "c33_h1' : heap",
                    "c33_hj1' : heap",
                    "c33_hj2' : heap",
                    "c28_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c46_goal : and (J hj1')\n  (safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J)"
                ],
                "tactic_res": [
                    "c49_goal : J hj1'",
                    "c50_goal : safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c49_goal : J hj1'",
                    "c33_A : J hj1'",
                    "c33_hj1' : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c50_goal : safe n c' (hunion h1' hj2') (fun v : Z => sepconj (Q v) J') J",
                    "c4_IHn : forall (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n  (_ : hdisjoint h h') (_ : J' h'),\nsafe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c51_goal : safe n c' h1' Q (sepconj J J')",
                    "c52_goal : hdisjoint h1' hj2'",
                    "c53_goal : J' hj2'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : safe n c' h1' Q (sepconj J J')",
                    "c33_Y : safe n c' h1' Q (sepconj J J')",
                    "c33_h1' : heap",
                    "c28_c' : com",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_J' : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : J' hj2'",
                    "c33_B : J' hj2'",
                    "c33_hj2' : heap",
                    "c2_J' : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c52_goal : hdisjoint h1' hj2'",
                    "c41_U : hdisj3 h1' (hunion hj1' hj2') hf",
                    "c33_h1' : heap",
                    "c33_hj2' : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_share",
        "proof": [
            {
                "tactic_sig": "Lemma triple_share : forall J J' P c Q , J ** J' \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P ** J' \u2984 c \u2983 fun v => Q v ** J' \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_share : forall J J' P c Q , J ** J' \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P ** J' \u2984 c \u2983 fun v => Q v ** J' \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J J' : assertion) (P : precond) (c : com) \n  (Q : postcond) (_ : triple (sepconj J J') P c Q),\ntriple J (sepconj P J') c (fun v : Z => sepconj (Q v) J')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (J J' : assertion) (P : precond) (c : com) \n  (Q : postcond) (_ : triple (sepconj J J') P c Q),\ntriple J (sepconj P J') c (fun v : Z => sepconj (Q v) J')"
                ],
                "tactic_res": [
                    "c2_goal : triple J (sepconj P J') c (fun v : Z => sepconj (Q v) J')",
                    "c2_J : assertion",
                    "c2_J' : assertion",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : triple (sepconj J J') P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros n h ( h1 & h2 & Ph1 & J'h2 & D & U ) .",
                "tactic_args": [
                    "c2_goal : triple J (sepconj P J') c (fun v : Z => sepconj (Q v) J')"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h (fun v : Z => sepconj (Q v) J') J",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_h1 : heap",
                    "c3_h2 : heap",
                    "c3_Ph1 : P h1",
                    "c3_J'h2 : J' h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : safe n c h (fun v : Z => sepconj (Q v) J') J",
                    "c3_h : heap",
                    "c3_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c4_goal : safe n c (hunion h1 h2) (fun v : Z => sepconj (Q v) J') J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe n c (hunion h1 h2) (fun v : Z => sepconj (Q v) J') J",
                    "_global_safe_share : forall (Q : postcond) (J J' : invariant) (n : nat) \n         (c : com) (h h' : heap) (_ : safe n c h Q (sepconj J J'))\n         (_ : hdisjoint h h') (_ : J' h'),\n       safe n c (hunion h h') (fun v : Z => sepconj (Q v) J') J"
                ],
                "tactic_res": [
                    "c5_goal : safe n c h1 Q (sepconj J J')",
                    "c6_goal : hdisjoint h1 h2",
                    "c7_goal : J' h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe n c h1 Q (sepconj J J')",
                    "c3_Ph1 : P h1",
                    "c3_h1 : heap",
                    "c3_n : nat",
                    "c2_H : triple (sepconj J J') P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : assertion",
                    "c2_J' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : hdisjoint h1 h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : J' h2",
                    "c3_J'h2 : J' h2",
                    "c3_h2 : heap",
                    "c2_J' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pure",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pure : forall J P Q v , aimp P ( Q v ) -> J \u22a2 \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pure : forall J P Q v , aimp P ( Q v ) -> J \u22a2 \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n  (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J P Q v IMP n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n  (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c2_goal : safe n (PURE v) h Q J",
                    "c2_J : invariant",
                    "c2_P : assertion",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_v : Z",
                    "c2_IMP : aimp P (Q v)",
                    "c2_n : nat",
                    "c2_h : heap",
                    "c2_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe n (PURE v) h Q J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c3_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Q v h",
                    "c2_Ph : P h",
                    "c2_h : heap",
                    "c2_IMP : aimp P (Q v)",
                    "c2_v : Z",
                    "c2_Q : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_let",
        "proof": [
            {
                "tactic_sig": "Lemma safe_let : forall ( Q R : postcond ) ( J : invariant ) f n c h , safe n c h Q J -> ( forall v n' h' , Q v h' -> ( n' < n ) % nat -> safe n' ( f v ) h' R J ) -> safe n ( LET c f ) h R J .",
                "tactic_sig_no_out_arg": "Lemma safe_let : forall ( Q R : postcond ) ( J : invariant ) f n c h , safe n c h Q J -> ( forall v n' h' , Q v h' -> ( n' < n ) % nat -> safe n' ( f v ) h' R J ) -> safe n ( LET c f ) h R J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q R : postcond) (J : invariant) (f : forall _ : Z, com)\n  (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q R J f n .",
                "tactic_args": [
                    "c1_goal : forall (Q R : postcond) (J : invariant) (f : forall _ : Z, com)\n  (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J",
                    "c2_Q : postcond",
                    "c2_R : postcond",
                    "c2_J : invariant",
                    "c2_f : forall _ : Z, com",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' 0),\n       safe n' (f v) h' R J), safe 0 (LET c f) h R J",
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h')\n         (_ : lt n' (S n)), safe n' (f v) h' R J),\nsafe (S n) (LET c f) h R J",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until h .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' 0),\n       safe n' (f v) h' R J), safe 0 (LET c f) h R J"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : safe 0 c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' 0),\n       safe n' (f v) h' R J), safe 0 (LET c f) h R J",
                    "c5_h : heap",
                    "c5_c : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros S1 S2 .",
                "tactic_args": [
                    "c5_goal : forall (_ : safe 0 c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' 0),\n       safe n' (f v) h' R J), safe 0 (LET c f) h R J"
                ],
                "tactic_res": [
                    "c6_goal : safe 0 (LET c f) h R J",
                    "c6_S1 : safe 0 c h Q J",
                    "c6_S2 : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' 0),\nsafe n' (f v) h' R J"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until h .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h')\n         (_ : lt n' (S n)), safe n' (f v) h' R J),\nsafe (S n) (LET c f) h R J"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : safe (S n) c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h')\n         (_ : lt n' (S n)), safe n' (f v) h' R J),\nsafe (S n) (LET c f) h R J",
                    "c7_h : heap",
                    "c7_c : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros S1 S2 .",
                "tactic_args": [
                    "c7_goal : forall (_ : safe (S n) c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h')\n         (_ : lt n' (S n)), safe n' (f v) h' R J),\nsafe (S n) (LET c f) h R J"
                ],
                "tactic_res": [
                    "c8_goal : safe (S n) (LET c f) h R J",
                    "c8_S1 : safe (S n) c h Q J",
                    "c8_S2 : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' (S n)),\nsafe n' (f v) h' R J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : safe 0 (LET c f) h R J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) (LET c f) h R J"
                ],
                "tactic_res": [
                    "c9_goal : True",
                    "c10_goal : forall (l : addr) (_ : immacc l (LET c f)), not (eq (h l) None)",
                    "c11_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (LET c f) h0))",
                    "c12_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (LET c f) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' R J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (l : addr) (_ : immacc l (LET c f)), not (eq (h l) None)"
                ],
                "tactic_res": [
                    "c13_goal : not (eq (h l) None)",
                    "c13_l : addr",
                    "c13_H : immacc l (LET c f)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (LET c f) h0))"
                ],
                "tactic_res": [
                    "c14_goal : not (erroneous (pair (LET c f) h0))",
                    "c14_hf : heap",
                    "c14_hj : heap",
                    "c14_h0 : heap",
                    "c14_H : hdisj3 h hj hf",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c14_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (LET c f) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' R J)))))"
                ],
                "tactic_res": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' R J)))))",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c15_h0 : heap",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_H : hdisj3 h hj hf",
                    "c15_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c15_H1 : J hj",
                    "c15_H2 : red (pair (LET c f) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c13_goal : not (eq (h l) None)",
                    "_global_safe_immacc : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n         (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J)\n         (_ : immacc l c), not (eq (h1 l) None)"
                ],
                "tactic_res": [
                    "c16_goal : safe (S ?n) ?c h ?Q ?J",
                    "c17_goal : immacc l c"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : safe (S ?n) ?c h ?Q ?J",
                    "c8_S1 : safe (S n) c h Q J",
                    "c7_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : immacc l c",
                    "c13_H : immacc l (LET c f)",
                    "c13_l : addr",
                    "c7_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c14_goal : not (erroneous (pair (LET c f) h0))"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : erroneous (pair (LET c f) h0), False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c18_goal : forall _ : erroneous (pair (LET c f) h0), False"
                ],
                "tactic_res": [
                    "c19_goal : False",
                    "c19_H2 : erroneous (pair (LET c f) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_H2 : erroneous (pair (LET c f) h0)"
                ],
                "tactic_res": [
                    "c19_H4 : erroneous (pair c (hunion h (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "eelim safe_not_erroneous .",
                "tactic_sig_no_out_arg": "eelim safe_not_erroneous .",
                "tactic_args": [
                    "c19_goal : False"
                ],
                "tactic_res": [
                    "c20_goal : safe (S ?n) ?c ?h1 ?Q ?J",
                    "c21_goal : hdisj3 h ?hj ?hf",
                    "c22_goal : J hj",
                    "c23_goal : erroneous (pair c (hunion h (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : safe (S ?n) ?c ?h1 ?Q ?J",
                    "c8_S1 : safe (S n) c h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : hdisj3 h ?hj ?hf",
                    "c14_H : hdisj3 h hj hf",
                    "c7_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : J hj",
                    "c14_H1 : J hj",
                    "c14_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : erroneous (pair c (hunion h (hunion hj hf)))",
                    "c19_H4 : erroneous (pair c (hunion h (hunion hj hf)))",
                    "c14_hf : heap",
                    "c14_hj : heap",
                    "c7_h : heap",
                    "c7_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c15_h0 : heap",
                    "c15_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c15_H2 : red (pair (LET c f) (hunion h (hunion hj hf))) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' R J)))))",
                    "c15_H2 : red (pair (LET c f) (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c24_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (f x) h1' R J)))))",
                    "c24_S1 : safe (S n) (PURE x) h Q J",
                    "c24_x : Z",
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (LET c'0 f) h1' R J)))))",
                    "c25_H3 : red (pair c (hunion h (hunion hj hf))) (pair c'0 h')",
                    "c25_c'0 : com"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c24_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (f x) h1' R J)))))",
                    "c7_h : heap",
                    "c15_hj : heap"
                ],
                "tactic_res": [
                    "c26_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj) (safe n (f x) h R J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c26_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj) (safe n (f x) h R J)))",
                    "c15_H1 : J hj",
                    "c15_H : hdisj3 h hj hf",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c8_S2 : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' (S n)),\nsafe n' (f v) h' R J",
                    "c24_S1 : safe (S n) (PURE x) h Q J",
                    "c24_x : Z",
                    "c7_h : heap",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J",
                    "c2_n : nat",
                    "c2_f : forall _ : Z, com",
                    "c2_J : invariant",
                    "c2_R : postcond"
                ],
                "tactic_res": [
                    "c27_goal : safe n (f x) h R J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : safe n (f x) h R J",
                    "c8_S2 : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' (S n)),\nsafe n' (f v) h' R J"
                ],
                "tactic_res": [
                    "c28_goal : Q x h",
                    "c29_goal : lt n (S n)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c28_goal : Q x h",
                    "_global_safe_pure_inv : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe (S n) (PURE v) h Q J), \n       Q v h"
                ],
                "tactic_res": [
                    "c30_goal : safe (S ?n) (PURE x) h Q ?J"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c30_goal : safe (S ?n) (PURE x) h Q ?J",
                    "c24_S1 : safe (S n) (PURE x) h Q J",
                    "c24_x : Z",
                    "c7_h : heap",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c29_goal : lt n (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct safe_red as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct safe_red as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (LET c'0 f) h1' R J)))))"
                ],
                "tactic_res": [
                    "c31_goal : red (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c32_goal : safe (S ?n) c h ?Q ?J",
                    "c33_goal : J hj",
                    "c34_goal : hdisj3 h hj hf",
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (LET c'0 f) h1' R J)))))",
                    "c35_D : safe ?n ?c' h1' ?Q ?J",
                    "c35_C : ?J hj'",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c35_A : hdisj3 h1' hj' ?hf",
                    "c35_hj' : heap",
                    "c35_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : red (pair ?c (hunion ?h1 (hunion ?hj ?hf))) (pair ?c' ?h')",
                    "c25_H3 : red (pair c (hunion h (hunion hj hf))) (pair c'0 h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c32_goal : safe (S ?n) c h ?Q ?J",
                    "c8_S1 : safe (S n) c h Q J",
                    "c7_h : heap",
                    "c7_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : J hj",
                    "c15_H1 : J hj",
                    "c15_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c34_goal : hdisj3 h hj hf",
                    "c15_H : hdisj3 h hj hf",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c7_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c35_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (LET c'0 f) h1' R J)))))",
                    "c35_h1' : heap",
                    "c35_hj' : heap"
                ],
                "tactic_res": [
                    "c36_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n (LET c'0 f) h1' R J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c36_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n (LET c'0 f) h1' R J)))",
                    "c35_D : safe ?n ?c' h1' ?Q ?J",
                    "c35_C : ?J hj'",
                    "c35_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c35_A : hdisj3 h1' hj' ?hf",
                    "c35_h1' : heap",
                    "c35_hj' : heap",
                    "c25_c'0 : com",
                    "c15_hf : heap",
                    "c15_h' : heap",
                    "c8_S2 : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' (S n)),\nsafe n' (f v) h' R J",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\n       safe n' (f v) h' R J), safe n (LET c f) h R J",
                    "c2_n : nat",
                    "c2_f : forall _ : Z, com",
                    "c2_J : invariant",
                    "c2_R : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_let",
        "proof": [
            {
                "tactic_sig": "Lemma triple_let : forall c f ( J : invariant ) ( P : precond ) ( Q R : postcond ) , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , J \u22a2 \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> J \u22a2 \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_let : forall c f ( J : invariant ) ( P : precond ) ( Q R : postcond ) , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , J \u22a2 \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> J \u22a2 \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n  (P : precond) (Q R : postcond) (_ : triple J P c Q)\n  (_ : forall v : Z, triple J (Q v) (f v) R), triple J P (LET c f) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n  (P : precond) (Q R : postcond) (_ : triple J P c Q)\n  (_ : forall v : Z, triple J (Q v) (f v) R), triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c2_goal : triple J P (LET c f) R",
                    "c2_c : com",
                    "c2_f : forall _ : Z, com",
                    "c2_J : invariant",
                    "c2_P : precond",
                    "c2_Q : postcond",
                    "c2_R : postcond",
                    "c2_H : triple J P c Q",
                    "c2_H0 : forall v : Z, triple J (Q v) (f v) R"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h), safe n (LET c f) h R J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h), safe n (LET c f) h R J"
                ],
                "tactic_res": [
                    "c4_goal : safe n (LET c f) h R J",
                    "c4_n : nat",
                    "c4_h : heap",
                    "c4_H1 : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : safe n (LET c f) h R J",
                    "_global_safe_let : forall (Q R : postcond) (J : invariant) (f : forall _ : Z, com)\n         (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n         (_ : forall (v : Z) (n' : nat) (h' : heap) \n                (_ : Q v h') (_ : lt n' n), safe n' (f v) h' R J),\n       safe n (LET c f) h R J",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c5_goal : safe n c h Q J",
                    "c6_goal : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\nsafe n' (f v) h' R J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe n c h Q J",
                    "c2_H : triple J P c Q"
                ],
                "tactic_res": [
                    "c7_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : P h",
                    "c4_H1 : P h",
                    "c4_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\nsafe n' (f v) h' R J"
                ],
                "tactic_res": [
                    "c8_goal : safe n' (f v) h' R J",
                    "c8_v : Z",
                    "c8_n' : nat",
                    "c8_h' : heap",
                    "c8_H2 : Q v h'",
                    "c8_H3 : lt n' n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : safe n' (f v) h' R J",
                    "c2_H0 : forall v : Z, triple J (Q v) (f v) R"
                ],
                "tactic_res": [
                    "c9_goal : Q v h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Q v h'",
                    "c8_H2 : Q v h'",
                    "c8_h' : heap",
                    "c8_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_seq",
        "proof": [
            {
                "tactic_sig": "Corollary triple_seq : forall c1 c2 ( J : invariant ) ( P Q : precond ) ( R : postcond ) , J \u22a2 \u2983 P \u2984 c1 \u2983 fun _ => Q \u2984 -> J \u22a2 \u2983 Q \u2984 c2 \u2983 R \u2984 -> J \u22a2 \u2983 P \u2984 SEQ c1 c2 \u2983 R \u2984 .",
                "tactic_sig_no_out_arg": "Corollary triple_seq : forall c1 c2 ( J : invariant ) ( P Q : precond ) ( R : postcond ) , J \u22a2 \u2983 P \u2984 c1 \u2983 fun _ => Q \u2984 -> J \u22a2 \u2983 Q \u2984 c2 \u2983 R \u2984 -> J \u22a2 \u2983 P \u2984 SEQ c1 c2 \u2983 R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n  (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n  (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n  (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n  (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c2_goal : triple J P (SEQ c1 c2) R",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_J : invariant",
                    "c2_P : precond",
                    "c2_Q : precond",
                    "c2_R : postcond",
                    "c2_H : triple J P c1 (fun _ : Z => Q)",
                    "c2_H0 : triple J Q c2 R"
                ]
            },
            {
                "tactic_sig": "apply _i with ( fun _i => _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( fun _i => _i ) .",
                "tactic_args": [
                    "c2_goal : triple J P (SEQ c1 c2) R",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R",
                    "_global__ : ?T\nwhere\n?T : [c1 : com\n      c2 : com\n      J : invariant\n      P : precond\n      Q : precond\n      R : postcond\n      H : triple J P c1 (fun _ : Z => Q)\n      H0 : triple J Q c2 R |- Type]\n?y : [c1 : com\n      c2 : com\n      J : invariant\n      P : precond\n      Q : precond\n      R : postcond\n      H : triple J P c1 (fun _ : Z => Q)\n      H0 : triple J Q c2 R |- ?T]",
                    "c2_Q : precond"
                ],
                "tactic_res": [
                    "c3_goal : triple J P c1 (fun _ : Z => Q)",
                    "c4_goal : forall _ : Z, triple J Q c2 R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : triple J P c1 (fun _ : Z => Q)",
                    "c2_H : triple J P c1 (fun _ : Z => Q)",
                    "c2_P : precond",
                    "c2_Q : precond",
                    "c2_J : invariant",
                    "c2_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall _ : Z, triple J Q c2 R",
                    "c2_H0 : triple J Q c2 R",
                    "c2_R : postcond",
                    "c2_Q : precond",
                    "c2_J : invariant",
                    "c2_c2 : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma safe_ifthenelse : forall n b c1 c2 h Q J , ( b <> 0 -> safe n c1 h Q J ) -> ( b = 0 -> safe n c2 h Q J ) -> safe ( S n ) ( IFTHENELSE b c1 c2 ) h Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_ifthenelse : forall n b c1 c2 h Q J , ( b <> 0 -> safe n c1 h Q J ) -> ( b = 0 -> safe n c2 h Q J ) -> safe ( S n ) ( IFTHENELSE b c1 c2 ) h Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (b : Z) (c1 c2 : com) (h : heap) \n  (Q : postcond) (J : invariant)\n  (_ : forall _ : not (eq b 0), safe n c1 h Q J)\n  (_ : forall _ : eq b 0, safe n c2 h Q J),\nsafe (S n) (IFTHENELSE b c1 c2) h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (b : Z) (c1 c2 : com) (h : heap) \n  (Q : postcond) (J : invariant)\n  (_ : forall _ : not (eq b 0), safe n c1 h Q J)\n  (_ : forall _ : eq b 0, safe n c2 h Q J),\nsafe (S n) (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": [
                    "c2_goal : safe (S n) (IFTHENELSE b c1 c2) h Q J",
                    "c2_n : nat",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_J : invariant",
                    "c2_H : forall _ : not (eq b 0), safe n c1 h Q J",
                    "c2_H0 : forall _ : eq b 0, safe n c2 h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : safe (S n) (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": [
                    "c3_goal : True",
                    "c4_goal : forall (l : addr) (_ : immacc l (IFTHENELSE b c1 c2)),\nnot (eq (h l) None)",
                    "c5_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (IFTHENELSE b c1 c2) h0))",
                    "c6_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (IFTHENELSE b c1 c2) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l : addr) (_ : immacc l (IFTHENELSE b c1 c2)),\nnot (eq (h l) None)",
                    "c2_h : heap",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (IFTHENELSE b c1 c2) h0))"
                ],
                "tactic_res": [
                    "c7_goal : not (erroneous (pair (IFTHENELSE b c1 c2) h0))",
                    "c7_hf : heap",
                    "c7_hj : heap",
                    "c7_h0 : heap",
                    "c7_H1 : hdisj3 h hj hf",
                    "c7_H2 : eq h0 (hunion h (hunion hj hf))",
                    "c7_H3 : J hj"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (IFTHENELSE b c1 c2) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_hf : heap",
                    "c8_hj : heap",
                    "c8_h0 : heap",
                    "c8_c' : com",
                    "c8_h' : heap",
                    "c8_H1 : hdisj3 h hj hf",
                    "c8_H2 : eq h0 (hunion h (hunion hj hf))",
                    "c8_H3 : J hj",
                    "c8_H4 : red (pair (IFTHENELSE b c1 c2) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c7_goal : not (erroneous (pair (IFTHENELSE b c1 c2) h0))"
                ],
                "tactic_res": [
                    "c9_goal : False",
                    "c9_ST : erroneous (pair (IFTHENELSE b c1 c2) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : False",
                    "c9_ST : erroneous (pair (IFTHENELSE b c1 c2) h0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_H4 : red (pair (IFTHENELSE b c1 c2) h0) (pair c' h')"
                ],
                "tactic_res": [
                    "c10_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (if Z.eqb b 0 then c2 else c1) h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c10_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n (if Z.eqb b 0 then c2 else c1) h1' Q J)))))",
                    "c2_h : heap",
                    "c8_hj : heap"
                ],
                "tactic_res": [
                    "c11_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj) (safe n (if Z.eqb b 0 then c2 else c1) h Q J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c11_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj) (safe n (if Z.eqb b 0 then c2 else c1) h Q J)))",
                    "c8_H3 : J hj",
                    "c8_H1 : hdisj3 h hj hf",
                    "c8_hf : heap",
                    "c8_hj : heap",
                    "c2_H0 : forall _ : eq b 0, safe n c2 h Q J",
                    "c2_H : forall _ : not (eq b 0), safe n c1 h Q J",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_b : Z",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c12_goal : safe n (if Z.eqb b 0 then c2 else c1) h Q J",
                    "c12_H : forall _ : forall _ : eq b 0, False, safe n c1 h Q J"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eqb_spec _i 0 ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eqb_spec _i 0 ) .",
                "tactic_args": [
                    "c12_goal : safe n (if Z.eqb b 0 then c2 else c1) h Q J",
                    "c2_b : Z",
                    "c8_H3 : J hj",
                    "c8_H1 : hdisj3 h hj hf",
                    "c2_H0 : forall _ : eq b 0, safe n c2 h Q J",
                    "c12_H : forall _ : forall _ : eq b 0, False, safe n c1 h Q J",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c13_goal : safe n c2 h Q J",
                    "c13_e : eq b 0",
                    "c14_goal : safe n c1 h Q J",
                    "c14_n0 : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : safe n c2 h Q J",
                    "c13_e : eq b 0",
                    "c2_H0 : forall _ : eq b 0, safe n c2 h Q J",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_c2 : com",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : safe n c1 h Q J",
                    "c14_n0 : not (eq b 0)",
                    "c12_H : forall _ : forall _ : eq b 0, False, safe n c1 h Q J",
                    "c2_J : invariant",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_c1 : com",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthenelse : forall J b c1 c2 P Q , J \u22a2 \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> J \u22a2 \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> J \u22a2 \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthenelse : forall J b c1 c2 P Q , J \u22a2 \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> J \u22a2 \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> J \u22a2 \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (b : Z) (c1 c2 : com) (P : assertion)\n  (Q : postcond) (_ : triple J (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple J (pureconj (eq b 0) P) c2 Q),\ntriple J P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (b : Z) (c1 c2 : com) (P : assertion)\n  (Q : postcond) (_ : triple J (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple J (pureconj (eq b 0) P) c2 Q),\ntriple J P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple J P (IFTHENELSE b c1 c2) Q",
                    "c2_J : invariant",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : assertion",
                    "c2_Q : postcond",
                    "c2_H : triple J (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_H0 : triple J (pureconj (eq b 0) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple J P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h),\nsafe n (IFTHENELSE b c1 c2) h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h),\nsafe n (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": [
                    "c4_goal : safe n (IFTHENELSE b c1 c2) h Q J",
                    "c4_n : nat",
                    "c4_h : heap",
                    "c4_H1 : P h"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : safe n (IFTHENELSE b c1 c2) h Q J",
                    "c4_n : nat",
                    "c4_H1 : P h",
                    "c4_h : heap",
                    "c2_H0 : triple J (pureconj (eq b 0) P) c2 Q",
                    "c2_H : triple J (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_Q : postcond",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_b : Z",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 (IFTHENELSE b c1 c2) h Q J",
                    "c6_goal : safe (S n) (IFTHENELSE b c1 c2) h Q J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe (S n) (IFTHENELSE b c1 c2) h Q J",
                    "_global_safe_ifthenelse : forall (n : nat) (b : Z) (c1 c2 : com) (h : heap) \n         (Q : postcond) (J : invariant)\n         (_ : forall _ : not (eq b 0), safe n c1 h Q J)\n         (_ : forall _ : eq b 0, safe n c2 h Q J),\n       safe (S n) (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : not (eq b 0), safe n c1 h Q J",
                    "c8_goal : forall _ : eq b 0, safe n c2 h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall _ : not (eq b 0), safe n c1 h Q J"
                ],
                "tactic_res": [
                    "c9_goal : safe n c1 h Q J",
                    "c9_H2 : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : safe n c1 h Q J",
                    "c2_H : triple J (pureconj (not (eq b 0)) P) c1 Q"
                ],
                "tactic_res": [
                    "c10_goal : pureconj (not (eq b 0)) P h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c10_goal : pureconj (not (eq b 0)) P h"
                ],
                "tactic_res": [
                    "c11_goal : not (eq b 0)",
                    "c12_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : not (eq b 0)",
                    "c9_H2 : not (eq b 0)",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : P h",
                    "c4_H1 : P h",
                    "c4_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall _ : eq b 0, safe n c2 h Q J"
                ],
                "tactic_res": [
                    "c13_goal : safe n c2 h Q J",
                    "c13_H2 : eq b 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : safe n c2 h Q J",
                    "c2_H0 : triple J (pureconj (eq b 0) P) c2 Q"
                ],
                "tactic_res": [
                    "c14_goal : pureconj (eq b 0) P h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : pureconj (eq b 0) P h"
                ],
                "tactic_res": [
                    "c15_goal : eq b 0",
                    "c16_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq b 0",
                    "c13_H2 : eq b 0",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : P h",
                    "c4_H1 : P h",
                    "c4_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_repeat",
        "proof": [
            {
                "tactic_sig": "Lemma triple_repeat : forall J P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> aimp ( Q 0 ) P -> J \u22a2 \u2983 P \u2984 REPEAT c \u2983 fun v => ( v <> 0 ) //\\\\ Q v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_repeat : forall J P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> aimp ( Q 0 ) P -> J \u22a2 \u2983 P \u2984 REPEAT c \u2983 fun v => ( v <> 0 ) //\\\\ Q v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (_ : triple J P c Q) (_ : aimp (Q 0) P),\ntriple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J P c Q TR IMP .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (_ : triple J P c Q) (_ : aimp (Q 0) P),\ntriple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ],
                "tactic_res": [
                    "c2_goal : triple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))",
                    "c2_J : invariant",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_TR : triple J P c Q",
                    "c2_IMP : aimp (Q 0) P"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ],
                "tactic_res": [
                    "c4_goal : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c4_goal : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c4_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : forall (h : heap) (_ : P h),\nsafe 0 (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c6_goal : forall (h : heap) (_ : P h),\nsafe (S n) (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c6_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h Ph .",
                "tactic_args": [
                    "c5_goal : forall (h : heap) (_ : P h),\nsafe 0 (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ],
                "tactic_res": [
                    "c7_goal : safe 0 (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c7_h : heap",
                    "c7_Ph : P h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h Ph .",
                "tactic_args": [
                    "c6_goal : forall (h : heap) (_ : P h),\nsafe (S n) (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ],
                "tactic_res": [
                    "c8_goal : safe (S n) (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c8_h : heap",
                    "c8_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe 0 (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J"
                ],
                "tactic_res": [
                    "c9_goal : True",
                    "c10_goal : forall (l : addr) (_ : immacc l (REPEAT c)), not (eq (h l) None)",
                    "c11_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (REPEAT c) h0))",
                    "c12_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (REPEAT c) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : forall (l : addr) (_ : immacc l (REPEAT c)), not (eq (h l) None)",
                    "c8_h : heap",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (REPEAT c) h0))"
                ],
                "tactic_res": [
                    "c13_goal : not (erroneous (pair (REPEAT c) h0))",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c13_h0 : heap",
                    "c13_H : hdisj3 h hj hf",
                    "c13_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c13_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c13_goal : not (erroneous (pair (REPEAT c) h0))"
                ],
                "tactic_res": [
                    "c14_goal : False",
                    "c14_ST : erroneous (pair (REPEAT c) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : False",
                    "c14_ST : erroneous (pair (REPEAT c) h0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (REPEAT c) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))"
                ],
                "tactic_res": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c15_h0 : heap",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_H : hdisj3 h hj hf",
                    "c15_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c15_H1 : J hj",
                    "c15_H2 : red (pair (REPEAT c) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))",
                    "c15_H2 : red (pair (REPEAT c) h0) (pair c' h')"
                ],
                "tactic_res": [
                    "c16_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n\n                 (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c)))\n                 h1' (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c16_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n\n                 (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c)))\n                 h1' (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))))",
                    "c8_h : heap",
                    "c15_hj : heap"
                ],
                "tactic_res": [
                    "c17_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj)\n        (safe n (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c)))\n           h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c17_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj)\n        (safe n (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c)))\n           h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J)))",
                    "c15_H1 : J hj",
                    "c15_H : hdisj3 h hj hf",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c8_Ph : P h",
                    "c8_h : heap",
                    "c6_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h (fun v : Z => pureconj (not (eq v 0)) (Q v)) J",
                    "c4_n : nat",
                    "c2_IMP : aimp (Q 0) P",
                    "c2_TR : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c18_goal : safe n (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c))) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c18_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c18_goal : safe n (LET c (fun b : Z => IFTHENELSE b (PURE b) (REPEAT c))) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "_global_safe_let : forall (Q R : postcond) (J : invariant) (f : forall _ : Z, com)\n         (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n         (_ : forall (v : Z) (n' : nat) (h' : heap) \n                (_ : Q v h') (_ : lt n' n), safe n' (f v) h' R J),\n       safe n (LET c f) h R J",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c19_goal : safe n c h Q J",
                    "c20_goal : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\nsafe n' (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v0 : Z => pureconj (forall _ : eq v0 0, False) (Q v0)) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : safe n c h Q J",
                    "c2_TR : triple J P c Q"
                ],
                "tactic_res": [
                    "c21_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : P h",
                    "c8_Ph : P h",
                    "c8_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c20_goal : forall (v : Z) (n' : nat) (h' : heap) (_ : Q v h') (_ : lt n' n),\nsafe n' (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v0 : Z => pureconj (forall _ : eq v0 0, False) (Q v0)) J"
                ],
                "tactic_res": [
                    "c22_goal : safe n' (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c22_v : Z",
                    "c22_n' : nat",
                    "c22_h' : heap",
                    "c22_H0 : Q v h'",
                    "c22_H2 : lt n' n"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c22_goal : safe n' (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c22_n' : nat",
                    "c22_H2 : lt n' n",
                    "c22_H0 : Q v h'",
                    "c22_h' : heap",
                    "c22_v : Z",
                    "c15_H1 : J hj",
                    "c15_H : hdisj3 h hj hf",
                    "c8_Ph : P h",
                    "c18_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c2_IMP : aimp (Q 0) P",
                    "c2_TR : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c23_goal : safe 0 (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c23_H2 : lt 0 n",
                    "c24_goal : safe (S n') (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c24_H2 : lt (S n') n"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c23_goal : safe 0 (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : safe (S n') (IFTHENELSE v (PURE v) (REPEAT c)) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "_global_safe_ifthenelse : forall (n : nat) (b : Z) (c1 c2 : com) (h : heap) \n         (Q : postcond) (J : invariant)\n         (_ : forall _ : not (eq b 0), safe n c1 h Q J)\n         (_ : forall _ : eq b 0, safe n c2 h Q J),\n       safe (S n) (IFTHENELSE b c1 c2) h Q J"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : not (eq v 0),\nsafe n' (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c26_goal : forall _ : eq v 0,\nsafe n' (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c25_goal : forall _ : not (eq v 0),\nsafe n' (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": [
                    "c27_goal : safe n' (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c27_H3 : not (eq v 0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c27_goal : safe n' (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c22_n' : nat",
                    "c27_H3 : not (eq v 0)",
                    "c24_H2 : lt (S n') n",
                    "c22_H0 : Q v h'",
                    "c22_h' : heap",
                    "c22_v : Z",
                    "c15_H1 : J hj",
                    "c15_H : hdisj3 h hj hf",
                    "c8_Ph : P h",
                    "c18_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c2_IMP : aimp (Q 0) P",
                    "c2_TR : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c28_goal : safe 0 (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c28_H2 : lt 1 n",
                    "c29_goal : safe (S n') (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c29_H2 : lt (S (S n')) n"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c28_goal : safe 0 (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c29_goal : safe (S n') (PURE v) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": [
                    "c30_goal : pureconj (forall _ : eq v 0, False) (Q v) h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c30_goal : pureconj (forall _ : eq v 0, False) (Q v) h'"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : eq v 0, False",
                    "c32_goal : Q v h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : forall _ : eq v 0, False",
                    "c27_H3 : not (eq v 0)",
                    "c22_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : Q v h'",
                    "c22_H0 : Q v h'",
                    "c22_h' : heap",
                    "c22_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c26_goal : forall _ : eq v 0,\nsafe n' (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": [
                    "c33_goal : safe n' (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c33_H3 : eq v 0"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c33_goal : safe n' (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "_global_safe_mono : forall (n : nat) (c : com) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe n c h Q J) (n' : nat) \n         (_ : le n' n), safe n' c h Q J",
                    "c4_n : nat"
                ],
                "tactic_res": [
                    "c34_goal : safe n (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c35_goal : le n' n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c34_goal : safe n (REPEAT c) h'\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J",
                    "c18_IHn : forall (h : heap) (_ : P h),\nsafe n (REPEAT c) h\n  (fun v : Z => pureconj (forall _ : eq v 0, False) (Q v)) J"
                ],
                "tactic_res": [
                    "c36_goal : P h'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : P h'",
                    "c2_IMP : aimp (Q 0) P"
                ],
                "tactic_res": [
                    "c37_goal : Q 0 h'"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c37_goal : Q 0 h'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c35_goal : le n' n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_par",
        "proof": [
            {
                "tactic_sig": "Lemma safe_par : forall ( J : invariant ) ( Q1 Q2 : assertion ) n c1 h1 c2 h2 , safe n c1 h1 ( fun _ => Q1 ) J -> safe n c2 h2 ( fun _ => Q2 ) J -> hdisjoint h1 h2 -> safe n ( PAR c1 c2 ) ( hunion h1 h2 ) ( fun _ => Q1 ** Q2 ) J .",
                "tactic_sig_no_out_arg": "Lemma safe_par : forall ( J : invariant ) ( Q1 Q2 : assertion ) n c1 h1 c2 h2 , safe n c1 h1 ( fun _ => Q1 ) J -> safe n c2 h2 ( fun _ => Q2 ) J -> hdisjoint h1 h2 -> safe n ( PAR c1 c2 ) ( hunion h1 h2 ) ( fun _ => Q1 ** Q2 ) J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (Q1 Q2 : assertion) (n : nat) \n  (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J Q1 Q2 n .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (Q1 Q2 : assertion) (n : nat) \n  (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_J : invariant",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe 0 c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe 0 c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c4_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe (S n) c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe (S n) c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until h2 .",
                "tactic_args": [
                    "c3_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe 0 c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe 0 c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : safe 0 c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe 0 c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c5_h2 : heap",
                    "c5_c2 : com",
                    "c5_h1 : heap",
                    "c5_c1 : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros S1 S2 DISJ .",
                "tactic_args": [
                    "c5_goal : forall (_ : safe 0 c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe 0 c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c6_goal : safe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c6_S1 : safe 0 c1 h1 (fun _ : Z => Q1) J",
                    "c6_S2 : safe 0 c2 h2 (fun _ : Z => Q2) J",
                    "c6_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : safe 0 (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until h2 .",
                "tactic_args": [
                    "c4_goal : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe (S n) c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe (S n) c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : safe (S n) c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe (S n) c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c7_h1 : heap",
                    "c7_c1 : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros S1 S2 DISJ .",
                "tactic_args": [
                    "c7_goal : forall (_ : safe (S n) c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe (S n) c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c8_goal : safe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c9_goal : True",
                    "c10_goal : forall (l : addr) (_ : immacc l (PAR c1 c2)),\nnot (eq (hunion h1 h2 l) None)",
                    "c11_goal : forall (hf hj h : heap) (_ : hdisj3 (hunion h1 h2) hj hf)\n  (_ : eq h (hunion (hunion h1 h2) (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair (PAR c1 c2) h))",
                    "c12_goal : forall (hf hj h : heap) (c' : com) (h' : heap)\n  (_ : hdisj3 (hunion h1 h2) hj hf)\n  (_ : eq h (hunion (hunion h1 h2) (hunion hj hf))) \n  (_ : J hj) (_ : red (pair (PAR c1 c2) h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => sepconj Q1 Q2) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c10_goal : forall (l : addr) (_ : immacc l (PAR c1 c2)),\nnot (eq (hunion h1 h2 l) None)"
                ],
                "tactic_res": [
                    "c13_goal : forall (l : addr) (_ : or (immacc l c1) (immacc l c2)),\nnot (eq (if h1 l then h1 l else h2 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (l : addr) (_ : or (immacc l c1) (immacc l c2)),\nnot (eq (if h1 l then h1 l else h2 l) None)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c14_l : addr",
                    "c14_H : or (immacc l c1) (immacc l c2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ _i | _i ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ _i | _i ] .",
                "tactic_args": [
                    "c14_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c14_H : or (immacc l c1) (immacc l c2)",
                    "c14_H : or (immacc l c1) (immacc l c2)",
                    "c14_H : or (immacc l c1) (immacc l c2)",
                    "c14_l : addr",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_h1 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c15_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c15_H : immacc l c1",
                    "c16_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c16_H : immacc l c2"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) in _i .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) in _i .",
                "tactic_args": [
                    "c15_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "_global_safe_immacc : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n         (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J)\n         (_ : immacc l c), not (eq (h1 l) None)",
                    "c7_h1 : heap",
                    "c7_h1 : heap",
                    "c15_H : immacc l c1"
                ],
                "tactic_res": [
                    "c17_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c17_H : not (eq (h1 l) None)",
                    "c18_goal : safe (S ?n) c1 h1 ?Q ?J"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : safe (S ?n) c1 h1 ?Q ?J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h1 : heap",
                    "c7_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c17_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c7_h1 : heap",
                    "c14_l : addr",
                    "c17_H : not (eq (h1 l) None)",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c19_goal : not (eq (Some z) None)",
                    "c19_H : not (eq (Some z) None)",
                    "c19_z : Z",
                    "c20_goal : not (eq (h2 l) None)",
                    "c20_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c19_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c20_goal : not (eq (h2 l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) in _i .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) in _i .",
                "tactic_args": [
                    "c16_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "_global_safe_immacc : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n         (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J)\n         (_ : immacc l c), not (eq (h1 l) None)",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c16_H : immacc l c2"
                ],
                "tactic_res": [
                    "c21_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c21_H : not (eq (h2 l) None)",
                    "c22_goal : safe (S ?n) c2 h2 ?Q ?J"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : safe (S ?n) c2 h2 ?Q ?J",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c7_h2 : heap",
                    "c7_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_args": [
                    "c21_goal : not (eq (if h1 l then h1 l else h2 l) None)",
                    "c7_h1 : heap",
                    "c14_l : addr",
                    "c21_H : not (eq (h2 l) None)",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c23_goal : not (eq (Some z') None)",
                    "c23_z' : Z",
                    "c24_goal : not (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c23_goal : not (eq (Some z') None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c24_goal : not (eq (h2 l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (hf hj h : heap) (_ : hdisj3 (hunion h1 h2) hj hf)\n  (_ : eq h (hunion (hunion h1 h2) (hunion hj hf))) \n  (_ : J hj), not (erroneous (pair (PAR c1 c2) h))"
                ],
                "tactic_res": [
                    "c25_goal : not (erroneous (pair (PAR c1 c2) h))",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c25_h : heap",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_H0 : eq h (hunion (hunion h1 h2) (hunion hj hf))",
                    "c25_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros ST .",
                "tactic_args": [
                    "c25_goal : not (erroneous (pair (PAR c1 c2) h))"
                ],
                "tactic_res": [
                    "c26_goal : False",
                    "c26_ST : erroneous (pair (PAR c1 c2) h)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c26_goal : False",
                    "c26_ST : erroneous (pair (PAR c1 c2) h)"
                ],
                "tactic_res": [
                    "c27_goal : False",
                    "c27_H3 : and (immacc l c1) (immacc l c2)",
                    "c27_l : addr",
                    "c28_goal : False",
                    "c28_H3 : erroneous (pair c1 (hunion (hunion h1 h2) (hunion hj hf)))",
                    "c29_goal : False",
                    "c29_H3 : erroneous (pair c2 (hunion (hunion h1 h2) (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ IM1 IM2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ IM1 IM2 ] .",
                "tactic_args": [
                    "c27_H3 : and (immacc l c1) (immacc l c2)",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c27_IM2 : immacc l c2",
                    "c27_IM1 : immacc l c1"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) in _i .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) in _i .",
                "tactic_args": [
                    "c27_goal : False",
                    "_global_safe_immacc : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n         (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J)\n         (_ : immacc l c), not (eq (h1 l) None)",
                    "c7_h1 : heap",
                    "c7_h1 : heap",
                    "c27_IM1 : immacc l c1"
                ],
                "tactic_res": [
                    "c30_goal : False",
                    "c30_IM1 : not (eq (h1 l) None)",
                    "c31_goal : safe (S ?n) c1 h1 ?Q ?J"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : safe (S ?n) c1 h1 ?Q ?J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h1 : heap",
                    "c7_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) in _i .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) in _i .",
                "tactic_args": [
                    "c30_goal : False",
                    "_global_safe_immacc : forall (n : nat) (c : com) (h1 : heap) (Q : postcond) \n         (J : invariant) (l : addr) (_ : safe (S n) c h1 Q J)\n         (_ : immacc l c), not (eq (h1 l) None)",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c27_IM2 : immacc l c2"
                ],
                "tactic_res": [
                    "c32_goal : False",
                    "c32_IM2 : not (eq (h2 l) None)",
                    "c33_goal : safe (S ?n) c2 h2 ?Q ?J"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : safe (S ?n) c2 h2 ?Q ?J",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c7_h2 : heap",
                    "c7_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c32_DISJ : hdisjoint h1 h2",
                    "c27_l : addr"
                ],
                "tactic_res": [
                    "c32_DISJ : or (eq (h1 l) None) (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c32_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim ( safe_not_erroneous _ _ _ _ _ _i ( hunion _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( safe_not_erroneous _ _ _ _ _ _i ( hunion _i _i ) _i ) .",
                "tactic_args": [
                    "c28_goal : False",
                    "c25_hj : heap",
                    "c7_h2 : heap",
                    "c25_hf : heap",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J"
                ],
                "tactic_res": [
                    "c34_goal : hdisj3 h1 hj (hunion h2 hf)",
                    "c35_goal : J hj",
                    "c36_goal : erroneous (pair c1 (hunion h1 (hunion hj (hunion h2 hf))))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c34_goal : hdisj3 h1 hj (hunion h2 hf)",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c7_h2 : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : J hj",
                    "c25_H1 : J hj",
                    "c25_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c36_H3 : erroneous (pair c1 (hunion (hunion h1 h2) (hunion hj hf)))"
                ],
                "tactic_res": [
                    "c36_H3 : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c36_goal : erroneous (pair c1 (hunion h1 (hunion hj (hunion h2 hf))))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c25_hj : heap",
                    "c36_H3 : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_h1 : heap",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c37_goal : erroneous (pair c1 (hunion h1 (hunion (hunion h2 hf) hj)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c37_goal : erroneous (pair c1 (hunion h1 (hunion (hunion h2 hf) hj)))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c38_goal : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hf hj))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c38_goal : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hf hj))))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c25_hj : heap",
                    "c36_H3 : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_h1 : heap",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c39_goal : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c39_goal : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))",
                    "c36_H3 : erroneous (pair c1 (hunion h1 (hunion h2 (hunion hj hf))))",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c7_h2 : heap",
                    "c7_h1 : heap",
                    "c7_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim ( safe_not_erroneous _ _ _ _ _ _i ( hunion _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( safe_not_erroneous _ _ _ _ _ _i ( hunion _i _i ) _i ) .",
                "tactic_args": [
                    "c29_goal : False",
                    "c25_hj : heap",
                    "c7_h1 : heap",
                    "c25_hf : heap",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J"
                ],
                "tactic_res": [
                    "c40_goal : hdisj3 h2 hj (hunion h1 hf)",
                    "c41_goal : J hj",
                    "c42_goal : erroneous (pair c2 (hunion h2 (hunion hj (hunion h1 hf))))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c40_goal : hdisj3 h2 hj (hunion h1 hf)",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c7_h2 : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : J hj",
                    "c25_H1 : J hj",
                    "c25_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_args": [
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c42_H3 : erroneous (pair c2 (hunion (hunion h1 h2) (hunion hj hf)))",
                    "c29_H3 : erroneous (pair c2 (hunion (hunion h1 h2) (hunion hj hf)))",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c42_H3 : erroneous (pair c2 (hunion (hunion h2 h1) (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c42_H3 : erroneous (pair c2 (hunion (hunion h2 h1) (hunion hj hf)))"
                ],
                "tactic_res": [
                    "c42_H3 : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c42_goal : erroneous (pair c2 (hunion h2 (hunion hj (hunion h1 hf))))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c25_hj : heap",
                    "c42_H3 : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c7_h1 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c43_goal : erroneous (pair c2 (hunion h2 (hunion (hunion h1 hf) hj)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c43_goal : erroneous (pair c2 (hunion h2 (hunion (hunion h1 hf) hj)))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c44_goal : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hf hj))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c44_goal : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hf hj))))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c25_hj : heap",
                    "c42_H3 : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))",
                    "c25_H1 : J hj",
                    "c25_H : hdisj3 (hunion h1 h2) hj hf",
                    "c25_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c7_h1 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c45_goal : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c45_goal : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))",
                    "c42_H3 : erroneous (pair c2 (hunion h2 (hunion h1 (hunion hj hf))))",
                    "c25_hf : heap",
                    "c25_hj : heap",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (hf hj h : heap) (c' : com) (h' : heap)\n  (_ : hdisj3 (hunion h1 h2) hj hf)\n  (_ : eq h (hunion (hunion h1 h2) (hunion hj hf))) \n  (_ : J hj) (_ : red (pair (PAR c1 c2) h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => sepconj Q1 Q2) J)))))"
                ],
                "tactic_res": [
                    "c46_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c46_hf : heap",
                    "c46_hj : heap",
                    "c46_h : heap",
                    "c46_c' : com",
                    "c46_h' : heap",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_H0 : eq h (hunion (hunion h1 h2) (hunion hj hf))",
                    "c46_H1 : J hj",
                    "c46_H2 : red (pair (PAR c1 c2) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c46_h : heap",
                    "c46_H0 : eq h (hunion (hunion h1 h2) (hunion hj hf))"
                ],
                "tactic_res": [
                    "c46_H2 : red (pair (PAR c1 c2) (hunion (hunion h1 h2) (hunion hj hf)))\n  (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c46_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c46_H2 : red (pair (PAR c1 c2) (hunion (hunion h1 h2) (hunion hj hf)))\n  (pair c' h')"
                ],
                "tactic_res": [
                    "c47_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion (hunion h1 h2) (hunion hj hf))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n SKIP h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c47_S2 : safe (S n) (PURE v2) h2 (fun _ : Z => Q2) J",
                    "c47_v2 : Z",
                    "c47_S1 : safe (S n) (PURE v1) h1 (fun _ : Z => Q1) J",
                    "c47_v1 : Z",
                    "c48_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1' c2) h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c48_H3 : red (pair c1 (hunion (hunion h1 h2) (hunion hj hf))) (pair c1' h')",
                    "c48_c1' : com",
                    "c49_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c49_H3 : red (pair c2 (hunion (hunion h1 h2) (hunion hj hf))) (pair c2' h')",
                    "c49_c2' : com"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_safe_pure_inv : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe (S n) (PURE v) h Q J), \n       Q v h",
                    "c47_S1 : safe (S n) (PURE v1) h1 (fun _ : Z => Q1) J"
                ],
                "tactic_res": [
                    "c47_S1 : Q1 h1"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_safe_pure_inv : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe (S n) (PURE v) h Q J), \n       Q v h",
                    "c47_S2 : safe (S n) (PURE v2) h2 (fun _ : Z => Q2) J"
                ],
                "tactic_res": [
                    "c47_S2 : Q2 h2"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c47_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion (hunion h1 h2) (hunion hj hf))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n SKIP h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c46_hj : heap"
                ],
                "tactic_res": [
                    "c50_goal : and (hdisj3 (hunion h1 h2) hj hf)\n  (and\n     (eq (hunion (hunion h1 h2) (hunion hj hf))\n        (hunion (hunion h1 h2) (hunion hj hf)))\n     (and (J hj)\n        (safe n SKIP (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c50_goal : and (hdisj3 (hunion h1 h2) hj hf)\n  (and\n     (eq (hunion (hunion h1 h2) (hunion hj hf))\n        (hunion (hunion h1 h2) (hunion hj hf)))\n     (and (J hj)\n        (safe n SKIP (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J)))",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c47_S2 : Q2 h2",
                    "c47_v2 : Z",
                    "c47_S1 : Q1 h1",
                    "c47_v1 : Z",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c51_goal : safe n SKIP (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c51_goal : safe n SKIP (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c52_goal : sepconj Q1 Q2 (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c52_goal : sepconj Q1 Q2 (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": [
                    "c53_goal : and (Q1 h1)\n  (and (Q2 h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c53_goal : and (Q1 h1)\n  (and (Q2 h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c47_S2 : Q2 h2",
                    "c47_S1 : Q1 h1",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c48_H3 : red (pair c1 (hunion (hunion h1 h2) (hunion hj hf))) (pair c1' h')"
                ],
                "tactic_res": [
                    "c48_H3 : red (pair c1 (hunion h1 (hunion h2 (hunion hj hf)))) (pair c1' h')"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_args": [
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h2 : heap",
                    "c48_H3 : red (pair c1 (hunion h1 (hunion h2 (hunion hj hf)))) (pair c1' h')",
                    "c48_c1' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_h' : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_c2 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c48_H3 : red (pair c1 (hunion h1 (hunion (hunion hj hf) h2))) (pair c1' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c48_H3 : red (pair c1 (hunion h1 (hunion (hunion hj hf) h2))) (pair c1' h')"
                ],
                "tactic_res": [
                    "c48_H3 : red (pair c1 (hunion h1 (hunion hj (hunion hf h2)))) (pair c1' h')"
                ]
            },
            {
                "tactic_sig": "destruct ( safe_red _ _ _ _ _ _ _ _ _ _i _i ) as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "destruct ( safe_red _ _ _ _ _ _ _ _ _ _i _i ) as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c48_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1' c2) h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c48_H3 : red (pair c1 (hunion h1 (hunion hj (hunion hf h2)))) (pair c1' h')",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c48_c1' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_h' : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c7_c2 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c54_goal : J hj",
                    "c55_goal : hdisj3 h1 hj (hunion hf h2)",
                    "c56_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1' c2) h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c56_D : safe n c1' h1' (fun _ : Z => Q1) J",
                    "c56_C : J hj'",
                    "c56_B : eq h' (hunion h1' (hunion hj' (hunion hf h2)))",
                    "c56_A : hdisj3 h1' hj' (hunion hf h2)",
                    "c56_hj' : heap",
                    "c56_h1' : heap"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : J hj",
                    "c46_H1 : J hj",
                    "c46_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c55_goal : hdisj3 h1 hj (hunion hf h2)",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c7_h2 : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c56_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1' c2) h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c46_h' : heap",
                    "c56_B : eq h' (hunion h1' (hunion hj' (hunion hf h2)))"
                ],
                "tactic_res": [
                    "c57_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1'0 hj'0 hf)\n        (and\n           (eq (hunion h1' (hunion hj' (hunion hf h2)))\n              (hunion h1'0 (hunion hj'0 hf)))\n           (and (J hj'0)\n              (safe n (PAR c1' c2) h1'0 (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c57_H3 : red (pair c1 (hunion h1 (hunion hj (hunion hf h2))))\n  (pair c1' (hunion h1' (hunion hj' (hunion hf h2))))"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c57_goal : ex\n  (fun h1'0 : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1'0 hj'0 hf)\n        (and\n           (eq (hunion h1' (hunion hj' (hunion hf h2)))\n              (hunion h1'0 (hunion hj'0 hf)))\n           (and (J hj'0)\n              (safe n (PAR c1' c2) h1'0 (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c56_h1' : heap",
                    "c7_h2 : heap",
                    "c56_hj' : heap"
                ],
                "tactic_res": [
                    "c58_goal : and (hdisj3 (hunion h1' h2) hj' hf)\n  (and\n     (eq (hunion h1' (hunion hj' (hunion hf h2)))\n        (hunion (hunion h1' h2) (hunion hj' hf)))\n     (and (J hj')\n        (safe n (PAR c1' c2) (hunion h1' h2)\n           (fun _ : Z => sepconj Q1 Q2) J)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c58_goal : and (hdisj3 (hunion h1' h2) hj' hf)\n  (and\n     (eq (hunion h1' (hunion hj' (hunion hf h2)))\n        (hunion (hunion h1' h2) (hunion hj' hf)))\n     (and (J hj')\n        (safe n (PAR c1' c2) (hunion h1' h2)\n           (fun _ : Z => sepconj Q1 Q2) J)))"
                ],
                "tactic_res": [
                    "c59_goal : hdisj3 (hunion h1' h2) hj' hf",
                    "c60_goal : and\n  (eq (hunion h1' (hunion hj' (hunion hf h2)))\n     (hunion (hunion h1' h2) (hunion hj' hf)))\n  (and (J hj')\n     (safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2)\n        J))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c59_goal : hdisj3 (hunion h1' h2) hj' hf",
                    "c56_A : hdisj3 h1' hj' (hunion hf h2)",
                    "c56_h1' : heap",
                    "c56_hj' : heap",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c60_goal : and\n  (eq (hunion h1' (hunion hj' (hunion hf h2)))\n     (hunion (hunion h1' h2) (hunion hj' hf)))\n  (and (J hj')\n     (safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2)\n        J))"
                ],
                "tactic_res": [
                    "c61_goal : eq (hunion h1' (hunion hj' (hunion hf h2)))\n  (hunion (hunion h1' h2) (hunion hj' hf))",
                    "c62_goal : and (J hj')\n  (safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2) J)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c61_goal : eq (hunion h1' (hunion hj' (hunion hf h2)))\n  (hunion (hunion h1' h2) (hunion hj' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c63_goal : eq (hunion h1' (hunion hj' (hunion hf h2)))\n  (hunion h1' (hunion h2 (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c63_goal : eq (hunion h1' (hunion hj' (hunion hf h2)))\n  (hunion h1' (hunion h2 (hunion hj' hf)))"
                ],
                "tactic_res": [
                    "c64_goal : eq (hunion hj' (hunion hf h2)) (hunion h2 (hunion hj' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c64_goal : eq (hunion hj' (hunion hf h2)) (hunion h2 (hunion hj' hf))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h2 : heap",
                    "c56_D : safe n c1' h1' (fun _ : Z => Q1) J",
                    "c56_C : J hj'",
                    "c56_A : hdisj3 h1' hj' (hunion hf h2)",
                    "c57_H3 : red (pair c1 (hunion h1 (hunion hj (hunion hf h2))))\n  (pair c1' (hunion h1' (hunion hj' (hunion hf h2))))",
                    "c56_hj' : heap",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c65_goal : eq (hunion hj' (hunion hf h2)) (hunion (hunion hj' hf) h2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c65_goal : eq (hunion hj' (hunion hf h2)) (hunion (hunion hj' hf) h2)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c66_goal : eq (hunion hj' (hunion hf h2)) (hunion hj' (hunion hf h2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c66_goal : eq (hunion hj' (hunion hf h2)) (hunion hj' (hunion hf h2))",
                    "c56_hj' : heap",
                    "c46_hf : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c62_goal : and (J hj')\n  (safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2) J)"
                ],
                "tactic_res": [
                    "c67_goal : J hj'",
                    "c68_goal : safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c67_goal : J hj'",
                    "c56_C : J hj'",
                    "c56_hj' : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c68_goal : safe n (PAR c1' c2) (hunion h1' h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c69_goal : safe n c1' h1' (fun _ : Z => Q1) J",
                    "c70_goal : safe n c2 h2 (fun _ : Z => Q2) J",
                    "c71_goal : hdisjoint h1' h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c69_goal : safe n c1' h1' (fun _ : Z => Q1) J",
                    "c56_D : safe n c1' h1' (fun _ : Z => Q1) J",
                    "c56_h1' : heap",
                    "c48_c1' : com",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c70_goal : safe n c2 h2 (fun _ : Z => Q2) J",
                    "_global_safe_mono : forall (n : nat) (c : com) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe n c h Q J) (n' : nat) \n         (_ : le n' n), safe n' c h Q J",
                    "_global_S : forall _ : nat, nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c72_goal : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c73_goal : le n (S n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c72_goal : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c7_h2 : heap",
                    "c7_c2 : com",
                    "c2_n : nat",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c73_goal : le n (S n)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c71_goal : hdisjoint h1' h2",
                    "c56_A : hdisj3 h1' hj' (hunion hf h2)",
                    "c56_h1' : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_args": [
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c49_H3 : red (pair c2 (hunion (hunion h1 h2) (hunion hj hf))) (pair c2' h')",
                    "c49_c2' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_h' : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c49_H3 : red (pair c2 (hunion (hunion h2 h1) (hunion hj hf))) (pair c2' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c49_H3 : red (pair c2 (hunion (hunion h2 h1) (hunion hj hf))) (pair c2' h')"
                ],
                "tactic_res": [
                    "c49_H3 : red (pair c2 (hunion h2 (hunion h1 (hunion hj hf)))) (pair c2' h')"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i by HDISJ .",
                "tactic_args": [
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c49_H3 : red (pair c2 (hunion h2 (hunion h1 (hunion hj hf)))) (pair c2' h')",
                    "c49_c2' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_h' : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c49_H3 : red (pair c2 (hunion h2 (hunion (hunion hj hf) h1))) (pair c2' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c49_H3 : red (pair c2 (hunion h2 (hunion (hunion hj hf) h1))) (pair c2' h')"
                ],
                "tactic_res": [
                    "c49_H3 : red (pair c2 (hunion h2 (hunion hj (hunion hf h1)))) (pair c2' h')"
                ]
            },
            {
                "tactic_sig": "destruct ( safe_red _ _ _ _ _ _ _ _ _ _i _i ) as ( h2' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "destruct ( safe_red _ _ _ _ _ _ _ _ _ _i _i ) as ( h2' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c49_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c49_H3 : red (pair c2 (hunion h2 (hunion hj (hunion hf h1)))) (pair c2' h')",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c49_c2' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_h' : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c74_goal : J hj",
                    "c75_goal : hdisj3 h2 hj (hunion hf h1)",
                    "c76_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c76_D : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c76_C : J hj'",
                    "c76_B : eq h' (hunion h2' (hunion hj' (hunion hf h1)))",
                    "c76_A : hdisj3 h2' hj' (hunion hf h1)",
                    "c76_hj' : heap",
                    "c76_h2' : heap"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : J hj",
                    "c46_H1 : J hj",
                    "c46_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c75_goal : hdisj3 h2 hj (hunion hf h1)",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c46_hj : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c7_h2 : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c76_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c46_h' : heap",
                    "c76_B : eq h' (hunion h2' (hunion hj' (hunion hf h1)))"
                ],
                "tactic_res": [
                    "c77_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1' hj'0 hf)\n        (and\n           (eq (hunion h2' (hunion hj' (hunion hf h1)))\n              (hunion h1' (hunion hj'0 hf)))\n           (and (J hj'0)\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c77_H3 : red (pair c2 (hunion h2 (hunion hj (hunion hf h1))))\n  (pair c2' (hunion h2' (hunion hj' (hunion hf h1))))"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c77_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj'0 : heap =>\n      and (hdisj3 h1' hj'0 hf)\n        (and\n           (eq (hunion h2' (hunion hj' (hunion hf h1)))\n              (hunion h1' (hunion hj'0 hf)))\n           (and (J hj'0)\n              (safe n (PAR c1 c2') h1' (fun _ : Z => sepconj Q1 Q2) J)))))",
                    "c76_h2' : heap",
                    "c7_h1 : heap",
                    "c76_hj' : heap"
                ],
                "tactic_res": [
                    "c78_goal : and (hdisj3 (hunion h2' h1) hj' hf)\n  (and\n     (eq (hunion h2' (hunion hj' (hunion hf h1)))\n        (hunion (hunion h2' h1) (hunion hj' hf)))\n     (and (J hj')\n        (safe n (PAR c1 c2') (hunion h2' h1)\n           (fun _ : Z => sepconj Q1 Q2) J)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c78_goal : and (hdisj3 (hunion h2' h1) hj' hf)\n  (and\n     (eq (hunion h2' (hunion hj' (hunion hf h1)))\n        (hunion (hunion h2' h1) (hunion hj' hf)))\n     (and (J hj')\n        (safe n (PAR c1 c2') (hunion h2' h1)\n           (fun _ : Z => sepconj Q1 Q2) J)))"
                ],
                "tactic_res": [
                    "c79_goal : hdisj3 (hunion h2' h1) hj' hf",
                    "c80_goal : and\n  (eq (hunion h2' (hunion hj' (hunion hf h1)))\n     (hunion (hunion h2' h1) (hunion hj' hf)))\n  (and (J hj')\n     (safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2)\n        J))"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c79_goal : hdisj3 (hunion h2' h1) hj' hf",
                    "c76_A : hdisj3 h2' hj' (hunion hf h1)",
                    "c76_h2' : heap",
                    "c76_hj' : heap",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c80_goal : and\n  (eq (hunion h2' (hunion hj' (hunion hf h1)))\n     (hunion (hunion h2' h1) (hunion hj' hf)))\n  (and (J hj')\n     (safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2)\n        J))"
                ],
                "tactic_res": [
                    "c81_goal : eq (hunion h2' (hunion hj' (hunion hf h1)))\n  (hunion (hunion h2' h1) (hunion hj' hf))",
                    "c82_goal : and (J hj')\n  (safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2) J)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c81_goal : eq (hunion h2' (hunion hj' (hunion hf h1)))\n  (hunion (hunion h2' h1) (hunion hj' hf))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c83_goal : eq (hunion h2' (hunion hj' (hunion hf h1)))\n  (hunion h2' (hunion h1 (hunion hj' hf)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c83_goal : eq (hunion h2' (hunion hj' (hunion hf h1)))\n  (hunion h2' (hunion h1 (hunion hj' hf)))"
                ],
                "tactic_res": [
                    "c84_goal : eq (hunion hj' (hunion hf h1)) (hunion h1 (hunion hj' hf))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c84_goal : eq (hunion hj' (hunion hf h1)) (hunion h1 (hunion hj' hf))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c76_D : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c76_C : J hj'",
                    "c76_A : hdisj3 h2' hj' (hunion hf h1)",
                    "c77_H3 : red (pair c2 (hunion h2 (hunion hj (hunion hf h1))))\n  (pair c2' (hunion h2' (hunion hj' (hunion hf h1))))",
                    "c76_hj' : heap",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c46_hf : heap",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c85_goal : eq (hunion hj' (hunion hf h1)) (hunion (hunion hj' hf) h1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c85_goal : eq (hunion hj' (hunion hf h1)) (hunion (hunion hj' hf) h1)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c86_goal : eq (hunion hj' (hunion hf h1)) (hunion hj' (hunion hf h1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : eq (hunion hj' (hunion hf h1)) (hunion hj' (hunion hf h1))",
                    "c76_hj' : heap",
                    "c46_hf : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c82_goal : and (J hj')\n  (safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2) J)"
                ],
                "tactic_res": [
                    "c87_goal : J hj'",
                    "c88_goal : safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c87_goal : J hj'",
                    "c76_C : J hj'",
                    "c76_hj' : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i by HDISJ .",
                "tactic_args": [
                    "c88_goal : safe n (PAR c1 c2') (hunion h2' h1) (fun _ : Z => sepconj Q1 Q2) J",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c76_D : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c76_C : J hj'",
                    "c76_A : hdisj3 h2' hj' (hunion hf h1)",
                    "c77_H3 : red (pair c2 (hunion h2 (hunion hj (hunion hf h1))))\n  (pair c2' (hunion h2' (hunion hj' (hunion hf h1))))",
                    "c76_h2' : heap",
                    "c49_c2' : com",
                    "c46_H1 : J hj",
                    "c46_H : hdisj3 (hunion h1 h2) hj hf",
                    "c8_DISJ : hdisjoint h1 h2",
                    "c8_S2 : safe (S n) c2 h2 (fun _ : Z => Q2) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h1 : heap",
                    "c7_c1 : com",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c89_goal : safe n (PAR c1 c2') (hunion h1 h2') (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c89_goal : safe n (PAR c1 c2') (hunion h1 h2') (fun _ : Z => sepconj Q1 Q2) J",
                    "c4_IHn : forall (c1 : com) (h1 : heap) (c2 : com) (h2 : heap)\n  (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n  (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\nsafe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c90_goal : safe n c1 h1 (fun _ : Z => Q1) J",
                    "c91_goal : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c92_goal : hdisjoint h1 h2'"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c90_goal : safe n c1 h1 (fun _ : Z => Q1) J",
                    "_global_safe_mono : forall (n : nat) (c : com) (h : heap) (Q : postcond) \n         (J : invariant) (_ : safe n c h Q J) (n' : nat) \n         (_ : le n' n), safe n' c h Q J",
                    "_global_S : forall _ : nat, nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c93_goal : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c94_goal : le n (S n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c93_goal : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c8_S1 : safe (S n) c1 h1 (fun _ : Z => Q1) J",
                    "c7_h1 : heap",
                    "c7_c1 : com",
                    "c2_n : nat",
                    "c2_Q1 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c94_goal : le n (S n)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c91_goal : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c76_D : safe n c2' h2' (fun _ : Z => Q2) J",
                    "c76_h2' : heap",
                    "c49_c2' : com",
                    "c2_n : nat",
                    "c2_Q2 : assertion",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c92_goal : hdisjoint h1 h2'",
                    "c76_A : hdisj3 h2' hj' (hunion hf h1)",
                    "c76_h2' : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_par",
        "proof": [
            {
                "tactic_sig": "Lemma triple_par : forall J P1 c1 Q1 P2 c2 Q2 , J \u22a2 \u2983 P1 \u2984 c1 \u2983 fun _ => Q1 \u2984 -> J \u22a2 \u2983 P2 \u2984 c2 \u2983 fun _ => Q2 \u2984 -> J \u22a2 \u2983 P1 ** P2 \u2984 PAR c1 c2 \u2983 fun _ => Q1 ** Q2 \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_par : forall J P1 c1 Q1 P2 c2 Q2 , J \u22a2 \u2983 P1 \u2984 c1 \u2983 fun _ => Q1 \u2984 -> J \u22a2 \u2983 P2 \u2984 c2 \u2983 fun _ => Q2 \u2984 -> J \u22a2 \u2983 P1 ** P2 \u2984 PAR c1 c2 \u2983 fun _ => Q1 ** Q2 \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P1 : precond) (c1 : com) (Q1 : assertion)\n  (P2 : precond) (c2 : com) (Q2 : assertion)\n  (_ : triple J P1 c1 (fun _ : Z => Q1))\n  (_ : triple J P2 c2 (fun _ : Z => Q2)),\ntriple J (sepconj P1 P2) (PAR c1 c2) (fun _ : Z => sepconj Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q2 .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P1 : precond) (c1 : com) (Q1 : assertion)\n  (P2 : precond) (c2 : com) (Q2 : assertion)\n  (_ : triple J P1 c1 (fun _ : Z => Q1))\n  (_ : triple J P2 c2 (fun _ : Z => Q2)),\ntriple J (sepconj P1 P2) (PAR c1 c2) (fun _ : Z => sepconj Q1 Q2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : triple J P1 c1 (fun _ : Z => Q1))\n  (_ : triple J P2 c2 (fun _ : Z => Q2)),\ntriple J (sepconj P1 P2) (PAR c1 c2) (fun _ : Z => sepconj Q1 Q2)",
                    "c2_Q2 : assertion",
                    "c2_c2 : com",
                    "c2_P2 : precond",
                    "c2_Q1 : assertion",
                    "c2_c1 : com",
                    "c2_P1 : precond",
                    "c2_J : invariant"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros TR1 TR2 n h Ph .",
                "tactic_args": [
                    "c2_goal : forall (_ : triple J P1 c1 (fun _ : Z => Q1))\n  (_ : triple J P2 c2 (fun _ : Z => Q2)),\ntriple J (sepconj P1 P2) (PAR c1 c2) (fun _ : Z => sepconj Q1 Q2)"
                ],
                "tactic_res": [
                    "c3_goal : safe n (PAR c1 c2) h (fun _ : Z => sepconj Q1 Q2) J",
                    "c3_TR1 : triple J P1 c1 (fun _ : Z => Q1)",
                    "c3_TR2 : triple J P2 c2 (fun _ : Z => Q2)",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : sepconj P1 P2 h"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( h1 & h2 & Ph1 & Ph2 & D & U ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( h1 & h2 & Ph1 & Ph2 & D & U ) .",
                "tactic_args": [
                    "c3_Ph : sepconj P1 P2 h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c3_TR2 : triple J P2 c2 (fun _ : Z => Q2)",
                    "c3_TR1 : triple J P1 c1 (fun _ : Z => Q1)",
                    "c2_Q2 : assertion",
                    "c2_c2 : com",
                    "c2_Q1 : assertion",
                    "c2_c1 : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_U : eq h (hunion h1 h2)",
                    "c3_D : hdisjoint h1 h2",
                    "c3_Ph2 : P2 h2",
                    "c3_Ph1 : P1 h1",
                    "c3_h2 : heap",
                    "c3_h1 : heap"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : safe n (PAR c1 c2) h (fun _ : Z => sepconj Q1 Q2) J",
                    "c3_h : heap",
                    "c3_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c4_goal : safe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J",
                    "_global_safe_par : forall (J : invariant) (Q1 Q2 : assertion) \n         (n : nat) (c1 : com) (h1 : heap) (c2 : com) \n         (h2 : heap) (_ : safe n c1 h1 (fun _ : Z => Q1) J)\n         (_ : safe n c2 h2 (fun _ : Z => Q2) J) (_ : hdisjoint h1 h2),\n       safe n (PAR c1 c2) (hunion h1 h2) (fun _ : Z => sepconj Q1 Q2) J"
                ],
                "tactic_res": [
                    "c5_goal : safe n c1 h1 (fun _ : Z => Q1) J",
                    "c6_goal : safe n c2 h2 (fun _ : Z => Q2) J",
                    "c7_goal : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe n c1 h1 (fun _ : Z => Q1) J",
                    "c3_Ph1 : P1 h1",
                    "c3_h1 : heap",
                    "c3_n : nat",
                    "c3_TR1 : triple J P1 c1 (fun _ : Z => Q1)",
                    "c2_Q1 : assertion",
                    "c2_c1 : com",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : safe n c2 h2 (fun _ : Z => Q2) J",
                    "c3_Ph2 : P2 h2",
                    "c3_h2 : heap",
                    "c3_n : nat",
                    "c3_TR2 : triple J P2 c2 (fun _ : Z => Q2)",
                    "c2_Q2 : assertion",
                    "c2_c2 : com",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : hdisjoint h1 h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_get",
        "proof": [
            {
                "tactic_sig": "Lemma triple_get : forall J l v , J \u22a2 \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_get : forall J l v , J \u22a2 \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (l : addr) (v : Z),\ntriple J (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J l v n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (l : addr) (v : Z),\ntriple J (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c2_goal : safe n (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J",
                    "c2_J : invariant",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_n : nat",
                    "c2_h : heap",
                    "c2_Ph : contains l v h"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_Ph : contains l v h"
                ],
                "tactic_res": [
                    "c2_L : eq (h l) (Some v)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe n (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J",
                    "c2_n : nat",
                    "c2_L : eq (h l) (Some v)",
                    "c2_Ph : contains l v h",
                    "c2_h : heap",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_goal : safe 0 (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J",
                    "c4_goal : safe (S n) (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))\n  J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe 0 (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (S n) (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))\n  J"
                ],
                "tactic_res": [
                    "c5_goal : True",
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (GET l)), not (eq (h l0) None)",
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (GET l) h0))",
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (GET l) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (GET l)), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (h l0) None)",
                    "c10_l0 : addr",
                    "c10_H : eq l0 l"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (h l0) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (GET l) h0))"
                ],
                "tactic_res": [
                    "c11_goal : not (erroneous (pair (GET l) h0))",
                    "c11_hf : heap",
                    "c11_hj : heap",
                    "c11_h0 : heap",
                    "c11_H : hdisj3 h hj hf",
                    "c11_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c11_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c11_goal : not (erroneous (pair (GET l) h0))",
                    "c11_h0 : heap",
                    "c11_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c12_goal : not (erroneous (pair (GET l) (hunion h (hunion hj hf))))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c12_goal : not (erroneous (pair (GET l) (hunion h (hunion hj hf))))"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_ST : erroneous (pair (GET l) (hunion h (hunion hj hf)))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_ST : erroneous (pair (GET l) (hunion h (hunion hj hf)))"
                ],
                "tactic_res": [
                    "c13_H2 : eq (hunion h (hunion hj hf) l) None"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c13_H2 : eq (hunion h (hunion hj hf) l) None"
                ],
                "tactic_res": [
                    "c13_H2 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_L : eq (h l) (Some v)",
                    "c13_H2 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ],
                "tactic_res": [
                    "c13_H2 : eq (Some v) None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c13_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (GET l) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))"
                ],
                "tactic_res": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c14_hf : heap",
                    "c14_hj : heap",
                    "c14_h0 : heap",
                    "c14_c' : com",
                    "c14_h' : heap",
                    "c14_H : hdisj3 h hj hf",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c14_H1 : J hj",
                    "c14_H2 : red (pair (GET l) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c14_h0 : heap",
                    "c14_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c14_H2 : red (pair (GET l) (hunion h (hunion hj hf))) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c14_H2 : red (pair (GET l) (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v0) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c15_H3 : eq (hunion h (hunion hj hf) l) (Some v0)",
                    "c15_v0 : Z"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v0) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c15_v0 : Z",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c16_goal : eq v0 v",
                    "c17_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v0) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c17_H0 : eq v0 v"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c16_H3 : eq (hunion h (hunion hj hf) l) (Some v0)"
                ],
                "tactic_res": [
                    "c16_H3 : eq (if h l then h l else if hj l then hj l else hf l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_L : eq (h l) (Some v)",
                    "c16_H3 : eq (if h l then h l else if hj l then hj l else hf l) (Some v0)"
                ],
                "tactic_res": [
                    "c16_H3 : eq (Some v) (Some v0)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c16_goal : eq v0 v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c17_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v0) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c15_v0 : Z",
                    "c17_H0 : eq v0 v"
                ],
                "tactic_res": [
                    "c18_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c18_H3 : eq (hunion h (hunion hj hf) l) (Some v)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c18_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hunion h (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE v) h1'\n                 (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))))",
                    "c2_h : heap",
                    "c14_hj : heap"
                ],
                "tactic_res": [
                    "c19_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj)\n        (safe n (PURE v) h\n           (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c19_goal : and (hdisj3 h hj hf)\n  (and (eq (hunion h (hunion hj hf)) (hunion h (hunion hj hf)))\n     (and (J hj)\n        (safe n (PURE v) h\n           (fun v' : Z => pureconj (eq v' v) (contains l v)) J)))",
                    "c18_H3 : eq (hunion h (hunion hj hf) l) (Some v)",
                    "c14_H1 : J hj",
                    "c14_H : hdisj3 h hj hf",
                    "c14_hf : heap",
                    "c14_hj : heap",
                    "c2_L : eq (h l) (Some v)",
                    "c2_Ph : contains l v h",
                    "c2_h : heap",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c20_goal : safe n (PURE v) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : safe n (PURE v) h (fun v' : Z => pureconj (eq v' v) (contains l v)) J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c21_goal : pureconj (eq v v) (contains l v) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c21_goal : pureconj (eq v v) (contains l v) h"
                ],
                "tactic_res": [
                    "c22_goal : eq v v",
                    "c23_goal : contains l v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : eq v v",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : contains l v h",
                    "c2_Ph : contains l v h",
                    "c2_h : heap",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_set",
        "proof": [
            {
                "tactic_sig": "Lemma triple_set : forall J l v , J \u22a2 \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_set : forall J l v , J \u22a2 \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (l : addr) (v : Z),\ntriple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J l v n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (l : addr) (v : Z),\ntriple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c2_goal : safe n (SET l v) h (fun _ : Z => contains l v) J",
                    "c2_J : invariant",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_n : nat",
                    "c2_h : heap",
                    "c2_Ph : valid l h"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( v0 & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( v0 & _i ) .",
                "tactic_args": [
                    "c2_Ph : valid l h",
                    "c2_Ph : valid l h",
                    "c2_h : heap",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z",
                    "c2_Ph : contains l v0 h"
                ],
                "tactic_res": [
                    "c2_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe n (SET l v) h (fun _ : Z => contains l v) J",
                    "c2_n : nat",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_h : heap",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_goal : safe 0 (SET l v) h (fun _ : Z => contains l v) J",
                    "c4_goal : safe (S n) (SET l v) h (fun _ : Z => contains l v) J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe 0 (SET l v) h (fun _ : Z => contains l v) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (S n) (SET l v) h (fun _ : Z => contains l v) J"
                ],
                "tactic_res": [
                    "c5_goal : True",
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (SET l v)), not (eq (h l0) None)",
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (SET l v) h0))",
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (SET l v) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => contains l v) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (SET l v)), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (h l0) None)",
                    "c10_l0 : addr",
                    "c10_H : eq l0 l"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (h l0) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (SET l v) h0))"
                ],
                "tactic_res": [
                    "c11_goal : not (erroneous (pair (SET l v) h0))",
                    "c11_hf : heap",
                    "c11_hj : heap",
                    "c11_h0 : heap",
                    "c11_H : hdisj3 h hj hf",
                    "c11_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c11_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c11_goal : not (erroneous (pair (SET l v) h0))"
                ],
                "tactic_res": [
                    "c12_goal : False",
                    "c12_ST : erroneous (pair (SET l v) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_ST : erroneous (pair (SET l v) h0)"
                ],
                "tactic_res": [
                    "c12_H3 : eq (hunion h (hunion hj hf) l) None"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c12_H3 : eq (hunion h (hunion hj hf) l) None"
                ],
                "tactic_res": [
                    "c12_H3 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_L : eq (h l) (Some v0)",
                    "c12_H3 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ],
                "tactic_res": [
                    "c12_H3 : eq (Some v0) None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c12_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (SET l v) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => contains l v) J)))))"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => contains l v) J)))))",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c13_h0 : heap",
                    "c13_c' : com",
                    "c13_h' : heap",
                    "c13_H : hdisj3 h hj hf",
                    "c13_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c13_H1 : J hj",
                    "c13_H2 : red (pair (SET l v) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c13_h0 : heap",
                    "c13_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c13_H2 : red (pair (SET l v) (hunion h (hunion hj hf))) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_Ph : contains l v0 h",
                    "c13_H : hdisj3 h hj hf"
                ],
                "tactic_res": [
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => contains l v) J)))))",
                    "c13_H2 : red (pair (SET l v) (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hupdate l v (hunion h (hunion hj hf)))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n SKIP h1' (fun _ : Z => contains l v) J)))))",
                    "c14_H3 : not (eq (hunion h (hunion hj hf) l) None)"
                ]
            },
            {
                "tactic_sig": "exists ( hupdate _i _i hempty ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i _i hempty ) , _i .",
                "tactic_args": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hupdate l v (hunion h (hunion hj hf)))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n SKIP h1' (fun _ : Z => contains l v) J)))))",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c13_hj : heap"
                ],
                "tactic_res": [
                    "c15_goal : and (hdisj3 (hupdate l v hempty) hj hf)\n  (and\n     (eq (hupdate l v (hunion h (hunion hj hf)))\n        (hunion (hupdate l v hempty) (hunion hj hf)))\n     (and (J hj)\n        (safe n SKIP (hupdate l v hempty) (fun _ : Z => contains l v) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c15_goal : and (hdisj3 (hupdate l v hempty) hj hf)\n  (and\n     (eq (hupdate l v (hunion h (hunion hj hf)))\n        (hunion (hupdate l v hempty) (hunion hj hf)))\n     (and (J hj)\n        (safe n SKIP (hupdate l v hempty) (fun _ : Z => contains l v) J)))",
                    "c14_H3 : not (eq (hunion h (hunion hj hf) l) None)",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_h : heap",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c16_goal : hdisj3 (hupdate l v hempty) hj hf",
                    "c16_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c17_goal : eq (hupdate l v (hunion h (hunion hj hf)))\n  (hunion (hupdate l v hempty) (hunion hj hf))",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c18_goal : safe n SKIP (hupdate l v hempty) (fun _ : Z => contains l v) J",
                    "c18_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c16_goal : hdisj3 (hupdate l v hempty) hj hf",
                    "c16_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_n : nat",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": [
                    "c19_goal : hdisjoint (hupdate l v hempty) hj",
                    "c19_H2 : hdisjoint hj hf",
                    "c19_H0 : hdisjoint (hupdate l v0 hempty) hf",
                    "c19_H : hdisjoint (hupdate l v0 hempty) hj",
                    "c20_goal : hdisjoint (hupdate l v hempty) hf",
                    "c20_H2 : hdisjoint hj hf",
                    "c20_H0 : hdisjoint (hupdate l v0 hempty) hf",
                    "c20_H : hdisjoint (hupdate l v0 hempty) hj"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c19_goal : hdisjoint (hupdate l v hempty) hj"
                ],
                "tactic_res": [
                    "c21_goal : forall l0 : addr,\nor (eq (hupdate l v hempty l0) None) (eq (hj l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c21_goal : forall l0 : addr,\nor (eq (hupdate l v hempty l0) None) (eq (hj l0) None)"
                ],
                "tactic_res": [
                    "c22_goal : or (eq (hupdate l v hempty l0) None) (eq (hj l0) None)",
                    "c22_l0 : addr"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c22_goal : or (eq (hupdate l v hempty l0) None) (eq (hj l0) None)",
                    "c19_H : hdisjoint (hupdate l v0 hempty) hj",
                    "c22_l0 : addr"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : or (eq (hupdate l v0 hempty l0) None) (eq (hj l0) None),\nor (eq (hupdate l v hempty l0) None) (eq (hj l0) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c23_goal : forall _ : or (eq (hupdate l v0 hempty l0) None) (eq (hj l0) None),\nor (eq (hupdate l v hempty l0) None) (eq (hj l0) None)"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  _ : or (eq (if Z.eq_dec l l0 then Some v0 else None) None)\n        (eq (hj l0) None),\nor (eq (if Z.eq_dec l l0 then Some v else None) None) (eq (hj l0) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c24_goal : forall\n  _ : or (eq (if Z.eq_dec l l0 then Some v0 else None) None)\n        (eq (hj l0) None),\nor (eq (if Z.eq_dec l l0 then Some v else None) None) (eq (hj l0) None)",
                    "c2_l : addr",
                    "c22_l0 : addr",
                    "c16_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c19_H2 : hdisjoint hj hf",
                    "c19_H0 : hdisjoint (hupdate l v0 hempty) hf",
                    "c19_H : hdisjoint (hupdate l v0 hempty) hj",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z",
                    "c2_n : nat",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : or (eq (Some v0) None) (eq (hj l0) None),\nor (eq (Some v) None) (eq (hj l0) None)",
                    "c25_e : eq l l0",
                    "c26_goal : forall _ : or (eq None None) (eq (hj l0) None),\nor (eq None None) (eq (hj l0) None)",
                    "c26_n0 : not (eq l l0)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c25_goal : forall _ : or (eq (Some v0) None) (eq (hj l0) None),\nor (eq (Some v) None) (eq (hj l0) None)",
                    "c22_l0 : addr",
                    "c13_hj : heap",
                    "c2_v0 : Z",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c26_goal : forall _ : or (eq None None) (eq (hj l0) None),\nor (eq None None) (eq (hj l0) None)",
                    "c22_l0 : addr",
                    "c13_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c20_goal : hdisjoint (hupdate l v hempty) hf"
                ],
                "tactic_res": [
                    "c27_goal : forall l0 : addr,\nor (eq (hupdate l v hempty l0) None) (eq (hf l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c27_goal : forall l0 : addr,\nor (eq (hupdate l v hempty l0) None) (eq (hf l0) None)"
                ],
                "tactic_res": [
                    "c28_goal : or (eq (hupdate l v hempty l0) None) (eq (hf l0) None)",
                    "c28_l0 : addr"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c28_goal : or (eq (hupdate l v hempty l0) None) (eq (hf l0) None)",
                    "c20_H0 : hdisjoint (hupdate l v0 hempty) hf",
                    "c28_l0 : addr"
                ],
                "tactic_res": [
                    "c29_goal : forall _ : or (eq (hupdate l v0 hempty l0) None) (eq (hf l0) None),\nor (eq (hupdate l v hempty l0) None) (eq (hf l0) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c29_goal : forall _ : or (eq (hupdate l v0 hempty l0) None) (eq (hf l0) None),\nor (eq (hupdate l v hempty l0) None) (eq (hf l0) None)"
                ],
                "tactic_res": [
                    "c30_goal : forall\n  _ : or (eq (if Z.eq_dec l l0 then Some v0 else None) None)\n        (eq (hf l0) None),\nor (eq (if Z.eq_dec l l0 then Some v else None) None) (eq (hf l0) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c30_goal : forall\n  _ : or (eq (if Z.eq_dec l l0 then Some v0 else None) None)\n        (eq (hf l0) None),\nor (eq (if Z.eq_dec l l0 then Some v else None) None) (eq (hf l0) None)",
                    "c2_l : addr",
                    "c28_l0 : addr",
                    "c16_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c20_H2 : hdisjoint hj hf",
                    "c20_H0 : hdisjoint (hupdate l v0 hempty) hf",
                    "c20_H : hdisjoint (hupdate l v0 hempty) hj",
                    "c13_hf : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z",
                    "c2_n : nat",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : or (eq (Some v0) None) (eq (hf l0) None),\nor (eq (Some v) None) (eq (hf l0) None)",
                    "c31_e : eq l l0",
                    "c32_goal : forall _ : or (eq None None) (eq (hf l0) None),\nor (eq None None) (eq (hf l0) None)",
                    "c32_n0 : not (eq l l0)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c31_goal : forall _ : or (eq (Some v0) None) (eq (hf l0) None),\nor (eq (Some v) None) (eq (hf l0) None)",
                    "c28_l0 : addr",
                    "c13_hf : heap",
                    "c2_v0 : Z",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c32_goal : forall _ : or (eq None None) (eq (hf l0) None),\nor (eq None None) (eq (hf l0) None)",
                    "c28_l0 : addr",
                    "c13_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : eq (hupdate l v (hunion h (hunion hj hf)))\n  (hunion (hupdate l v hempty) (hunion hj hf))",
                    "c2_Ph : contains l v0 h"
                ],
                "tactic_res": [
                    "c33_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)))\n  (hunion (hupdate l v hempty) (hunion hj hf))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c33_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)))\n  (hunion (hupdate l v hempty) (hunion hj hf))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c34_goal : forall l0 : addr,\neq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion (hupdate l v hempty) (hunion hj hf) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c34_goal : forall l0 : addr,\neq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion (hupdate l v hempty) (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c35_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion (hupdate l v hempty) (hunion hj hf) l0)",
                    "c35_l0 : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c35_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion (hupdate l v hempty) (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c36_goal : eq\n  (if Z.eq_dec l l0\n   then Some v\n   else\n    if if Z.eq_dec l l0 then Some v0 else None\n    then if Z.eq_dec l l0 then Some v0 else None\n    else if hj l0 then hj l0 else hf l0)\n  (if if Z.eq_dec l l0 then Some v else None\n   then if Z.eq_dec l l0 then Some v else None\n   else if hj l0 then hj l0 else hf l0)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c36_goal : eq\n  (if Z.eq_dec l l0\n   then Some v\n   else\n    if if Z.eq_dec l l0 then Some v0 else None\n    then if Z.eq_dec l l0 then Some v0 else None\n    else if hj l0 then hj l0 else hf l0)\n  (if if Z.eq_dec l l0 then Some v else None\n   then if Z.eq_dec l l0 then Some v else None\n   else if hj l0 then hj l0 else hf l0)",
                    "c2_l : addr",
                    "c35_l0 : addr",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z",
                    "c2_n : nat",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c37_goal : eq (Some v) (Some v)",
                    "c37_e : eq l l0",
                    "c38_goal : eq (if hj l0 then hj l0 else hf l0) (if hj l0 then hj l0 else hf l0)",
                    "c38_n0 : not (eq l l0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : eq (Some v) (Some v)",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : eq (if hj l0 then hj l0 else hf l0) (if hj l0 then hj l0 else hf l0)",
                    "c35_l0 : addr",
                    "c13_hf : heap",
                    "c13_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : safe n SKIP (hupdate l v hempty) (fun _ : Z => contains l v) J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c39_goal : contains l v (hupdate l v hempty)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c39_goal : contains l v (hupdate l v hempty)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_N_init",
        "proof": [
            {
                "tactic_sig": "Remark valid_N_init : forall sz l , ( valid_N l sz ) ( hinit l sz hempty ) .",
                "tactic_sig_no_out_arg": "Remark valid_N_init : forall sz l , ( valid_N l sz ) ( hinit l sz hempty ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro sz .",
                "tactic_args": [
                    "c1_goal : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ],
                "tactic_res": [
                    "c2_goal : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | _i ] .",
                "tactic_args": [
                    "c2_goal : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr, valid_N l 0 (hinit l 0 hempty)",
                    "c4_goal : forall l : addr, valid_N l (S sz) (hinit l (S sz) hempty)",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr, valid_N l 0 (hinit l 0 hempty)"
                ],
                "tactic_res": [
                    "c5_goal : valid_N l 0 (hinit l 0 hempty)",
                    "c5_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : valid_N l 0 (hinit l 0 hempty)"
                ],
                "tactic_res": [
                    "c6_goal : emp hempty"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c4_goal : forall l : addr, valid_N l (S sz) (hinit l (S sz) hempty)"
                ],
                "tactic_res": [
                    "c7_goal : valid_N l (S sz) (hinit l (S sz) hempty)",
                    "c7_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : valid_N l (S sz) (hinit l (S sz) hempty)"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (valid l) (valid_N (Z.add l 1) sz)\n  (hupdate l 0 (hinit (Z.add l 1) sz hempty))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : emp hempty"
                ],
                "tactic_res": [
                    "c9_goal : eq hempty hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq hempty hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i hempty ) .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i hempty ) .",
                "tactic_args": [
                    "c8_goal : sepconj (valid l) (valid_N (Z.add l 1) sz)\n  (hupdate l 0 (hinit (Z.add l 1) sz hempty))",
                    "c7_l : addr",
                    "c7_l : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c10_goal : and (valid l (hupdate l 0 hempty))\n  (and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n     (and\n        (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c10_goal : and (valid l (hupdate l 0 hempty))\n  (and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n     (and\n        (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))))"
                ],
                "tactic_res": [
                    "c11_goal : valid l (hupdate l 0 hempty)",
                    "c12_goal : and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n  (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n     (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n        (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))))"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c11_goal : valid l (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c13_goal : contains l 0 (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : contains l 0 (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c14_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)",
                    "c7_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n  (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n     (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n        (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))))"
                ],
                "tactic_res": [
                    "c15_goal : valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty)",
                    "c16_goal : and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n  (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n     (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty)",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n  (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n     (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))"
                ],
                "tactic_res": [
                    "c17_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)",
                    "c18_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c17_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)"
                ],
                "tactic_res": [
                    "c19_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c19_x : addr"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i at 1 .",
                "tactic_sig_no_out_arg": "unfold _i , _i at 1 .",
                "tactic_args": [
                    "c19_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "_global_hupdate : forall (_ : addr) (_ : Z) (_ : heap), heap",
                    "_global_hempty : heap"
                ],
                "tactic_res": [
                    "c20_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite := Separation.hupdate_obligation_1 l 0 hempty\n      |} x) None) (eq (hinit (Z.add l 1) sz hempty x) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c20_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite := Separation.hupdate_obligation_1 l 0 hempty\n      |} x) None) (eq (hinit (Z.add l 1) sz hempty x) None)"
                ],
                "tactic_res": [
                    "c21_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c21_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c7_l : addr",
                    "c19_x : addr",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c22_goal : or (eq (Some 0) None) (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c22_e : eq l x",
                    "c23_goal : or (eq None None) (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c23_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : or (eq None None) (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c7_l : addr",
                    "c19_x : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c22_goal : or (eq (Some 0) None) (eq (hinit (Z.add l 1) sz hempty x) None)"
                ],
                "tactic_res": [
                    "c24_goal : eq (hinit (Z.add l 1) sz hempty x) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c24_goal : eq (hinit (Z.add l 1) sz hempty x) None",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c25_goal : eq (hempty x) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq (hempty x) None",
                    "c19_x : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c26_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz hempty) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c26_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz hempty) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) l0)"
                ],
                "tactic_res": [
                    "c27_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) x)",
                    "c27_x : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c27_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) x)"
                ],
                "tactic_res": [
                    "c28_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz hempty x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz hempty x)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c28_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz hempty x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz hempty x)",
                    "c7_l : addr",
                    "c27_x : addr",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c29_goal : eq (Some 0) (Some 0)",
                    "c29_e : eq l x",
                    "c30_goal : eq (hinit (Z.add l 1) sz hempty x) (hinit (Z.add l 1) sz hempty x)",
                    "c30_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : eq (hinit (Z.add l 1) sz hempty x) (hinit (Z.add l 1) sz hempty x)",
                    "c7_l : addr",
                    "c27_x : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_alloc",
        "proof": [
            {
                "tactic_sig": "Lemma triple_alloc : forall J sz , J \u22a2 \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_alloc : forall J sz , J \u22a2 \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (sz : nat),\ntriple J emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J sz n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (sz : nat),\ntriple J emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c2_goal : safe n (ALLOC sz) h\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J",
                    "c2_J : invariant",
                    "c2_sz : nat",
                    "c2_n : nat",
                    "c2_h : heap",
                    "c2_Ph : emp h"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c2_Ph : emp h"
                ],
                "tactic_res": [
                    "c2_Ph : eq h hempty"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_goal : safe n (ALLOC sz) h\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J",
                    "c2_h : heap",
                    "c2_Ph : eq h hempty"
                ],
                "tactic_res": [
                    "c3_goal : safe n (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : safe n (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J",
                    "c2_n : nat",
                    "c2_sz : nat",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c4_goal : safe 0 (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J",
                    "c5_goal : safe (S n) (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe 0 (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe (S n) (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c7_goal : forall (l : addr) (_ : immacc l (ALLOC sz)), not (eq (hempty l) None)",
                    "c8_goal : forall (hf hj h : heap) (_ : hdisj3 hempty hj hf)\n  (_ : eq h (hunion hempty (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (ALLOC sz) h))",
                    "c9_goal : forall (hf hj h : heap) (c' : com) (h' : heap)\n  (_ : hdisj3 hempty hj hf) (_ : eq h (hunion hempty (hunion hj hf)))\n  (_ : J hj) (_ : red (pair (ALLOC sz) h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (l : addr) (_ : immacc l (ALLOC sz)), not (eq (hempty l) None)",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (hf hj h : heap) (_ : hdisj3 hempty hj hf)\n  (_ : eq h (hunion hempty (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (ALLOC sz) h))"
                ],
                "tactic_res": [
                    "c10_goal : not (erroneous (pair (ALLOC sz) h))",
                    "c10_hf : heap",
                    "c10_hj : heap",
                    "c10_h : heap",
                    "c10_H : hdisj3 hempty hj hf",
                    "c10_H0 : eq h (hunion hempty (hunion hj hf))",
                    "c10_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c10_goal : not (erroneous (pair (ALLOC sz) h))"
                ],
                "tactic_res": [
                    "c11_goal : False",
                    "c11_ST : erroneous (pair (ALLOC sz) h)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : False",
                    "c11_ST : erroneous (pair (ALLOC sz) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (hf hj h : heap) (c' : com) (h' : heap)\n  (_ : hdisj3 hempty hj hf) (_ : eq h (hunion hempty (hunion hj hf)))\n  (_ : J hj) (_ : red (pair (ALLOC sz) h) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))"
                ],
                "tactic_res": [
                    "c12_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c12_h : heap",
                    "c12_c' : com",
                    "c12_h' : heap",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_H0 : eq h (hunion hempty (hunion hj hf))",
                    "c12_H1 : J hj",
                    "c12_H2 : red (pair (ALLOC sz) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "c12_H0 : eq h (hunion hempty (hunion hj hf))"
                ],
                "tactic_res": [
                    "c12_H0 : eq h (hunion hj hf)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c12_h : heap",
                    "c12_H0 : eq h (hunion hj hf)"
                ],
                "tactic_res": [
                    "c12_H2 : red (pair (ALLOC sz) (hunion hj hf)) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))",
                    "c12_H2 : red (pair (ALLOC sz) (hunion hj hf)) (pair c' h')"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hinit l sz (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE l) h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))",
                    "c13_H7 : not (eq l 0)",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z"
                ]
            },
            {
                "tactic_sig": "exists ( hinit _i _i hempty ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hinit _i _i hempty ) , _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hinit l sz (hunion hj hf)) (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n (PURE l) h1'\n                 (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))\n                 J)))))",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c12_hj : heap"
                ],
                "tactic_res": [
                    "c14_goal : and (hdisj3 (hinit l sz hempty) hj hf)\n  (and\n     (eq (hinit l sz (hunion hj hf))\n        (hunion (hinit l sz hempty) (hunion hj hf)))\n     (and (J hj)\n        (safe n (PURE l) (hinit l sz hempty)\n           (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c14_goal : and (hdisj3 (hinit l sz hempty) hj hf)\n  (and\n     (eq (hinit l sz (hunion hj hf))\n        (hunion (hinit l sz hempty) (hunion hj hf)))\n     (and (J hj)\n        (safe n (PURE l) (hinit l sz hempty)\n           (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)) J)))",
                    "c13_H7 : not (eq l 0)",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z",
                    "c12_H1 : J hj",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat",
                    "c2_n : nat",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c15_goal : hdisj3 (hinit l sz hempty) hj hf",
                    "c15_H7 : forall _ : eq l 0, False",
                    "c16_goal : eq (hinit l sz (hunion hj hf))\n  (hunion (hinit l sz hempty) (hunion hj hf))",
                    "c16_H7 : forall _ : eq l 0, False",
                    "c17_goal : safe n (PURE l) (hinit l sz hempty)\n  (fun l : Z => pureconj (forall _ : eq l 0, False) (valid_N l sz)) J",
                    "c17_H7 : forall _ : eq l 0, False"
                ]
            },
            {
                "tactic_sig": "assert ( D : hdisjoint ( hinit _i _i hempty ) ( hunion _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( D : hdisjoint ( hinit _i _i hempty ) ( hunion _i _i ) ) .",
                "tactic_args": [
                    "c15_goal : hdisj3 (hinit l sz hempty) hj hf",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c12_hj : heap",
                    "c12_hf : heap"
                ],
                "tactic_res": [
                    "c18_goal : hdisjoint (hinit l sz hempty) (hunion hj hf)",
                    "c19_goal : hdisj3 (hinit l sz hempty) hj hf",
                    "c19_D : hdisjoint (hinit l sz hempty) (hunion hj hf)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c18_goal : hdisjoint (hinit l sz hempty) (hunion hj hf)"
                ],
                "tactic_res": [
                    "c20_goal : forall l0 : addr,\nor (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c20_goal : forall l0 : addr,\nor (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)"
                ],
                "tactic_res": [
                    "c21_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)",
                    "c21_l0 : addr"
                ]
            },
            {
                "tactic_sig": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ _i < _i \\/ _i + Z.of_nat _i <= _i ) by lia .",
                "tactic_sig_no_out_arg": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ _i < _i \\/ _i + Z.of_nat _i <= _i ) by lia .",
                "tactic_args": [
                    "c13_l : Z",
                    "c21_l0 : addr",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c21_l0 : addr",
                    "c13_l : Z",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c21_l0 : addr"
                ],
                "tactic_res": [
                    "c21_EITHER : or (and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz))))\n  (or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c21_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)",
                    "c21_EITHER : or (and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz))))\n  (or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0))",
                    "c21_l0 : addr",
                    "c15_H7 : forall _ : eq l 0, False",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z",
                    "c12_H1 : J hj",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c22_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)",
                    "c22_H0 : and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz)))",
                    "c23_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)",
                    "c23_H0 : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c22_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)"
                ],
                "tactic_res": [
                    "c24_goal : eq (hunion hj hf l0) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (hunion hj hf l0) None",
                    "c22_H0 : and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz)))",
                    "c21_l0 : addr",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c12_hf : heap",
                    "c12_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c23_goal : or (eq (hinit l sz hempty l0) None) (eq (hunion hj hf l0) None)"
                ],
                "tactic_res": [
                    "c25_goal : eq (hinit l sz hempty l0) None"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : eq (hinit l sz hempty l0) None",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c26_goal : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)",
                    "c23_H0 : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)",
                    "c21_l0 : addr",
                    "c13_l : Z",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c19_goal : hdisj3 (hinit l sz hempty) hj hf",
                    "c19_D : hdisjoint (hinit l sz hempty) (hunion hj hf)",
                    "c13_l : Z",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eq (hinit l sz (hunion hj hf))\n  (hunion (hinit l sz hempty) (hunion hj hf))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c27_goal : forall l0 : addr,\neq (hinit l sz (hunion hj hf) l0)\n  (hunion (hinit l sz hempty) (hunion hj hf) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c27_goal : forall l0 : addr,\neq (hinit l sz (hunion hj hf) l0)\n  (hunion (hinit l sz hempty) (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c28_goal : eq (hinit l sz (hunion hj hf) l0)\n  (hunion (hinit l sz hempty) (hunion hj hf) l0)",
                    "c28_l0 : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c28_goal : eq (hinit l sz (hunion hj hf) l0)\n  (hunion (hinit l sz hempty) (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c29_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)"
                ]
            },
            {
                "tactic_sig": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ _i < _i \\/ _i + Z.of_nat _i <= _i ) by lia .",
                "tactic_sig_no_out_arg": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ _i < _i \\/ _i + Z.of_nat _i <= _i ) by lia .",
                "tactic_args": [
                    "c13_l : Z",
                    "c28_l0 : addr",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c28_l0 : addr",
                    "c13_l : Z",
                    "c13_l : Z",
                    "c2_sz : nat",
                    "c28_l0 : addr"
                ],
                "tactic_res": [
                    "c29_EITHER : or (and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz))))\n  (or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c29_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)",
                    "c29_EITHER : or (and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz))))\n  (or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0))",
                    "c28_l0 : addr",
                    "c16_H7 : forall _ : eq l 0, False",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z",
                    "c12_H1 : J hj",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c30_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)",
                    "c30_H0 : and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz)))",
                    "c31_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)",
                    "c31_H0 : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i by auto .",
                "tactic_sig_no_out_arg": "rewrite ! _i by auto .",
                "tactic_args": [
                    "c30_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)",
                    "_global_hinit_inside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\n       eq (hinit l sz h l') (Some 0)",
                    "c30_H0 : and (Z.le l l0) (Z.lt l0 (Z.add l (Z.of_nat sz)))",
                    "c28_l0 : addr",
                    "c16_H7 : forall _ : eq l 0, False",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z",
                    "c12_H1 : J hj",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c32_goal : eq (Some 0) (Some 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! _i by auto .",
                "tactic_sig_no_out_arg": "rewrite ! _i by auto .",
                "tactic_args": [
                    "c31_goal : eq (hinit l sz (hunion hj hf) l0)\n  (if hinit l sz hempty l0\n   then hinit l sz hempty l0\n   else if hj l0 then hj l0 else hf l0)",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')",
                    "c31_H0 : or (Z.lt l0 l) (Z.le (Z.add l (Z.of_nat sz)) l0)",
                    "c28_l0 : addr",
                    "c16_H7 : forall _ : eq l 0, False",
                    "c13_H5 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion hj hf i) None",
                    "c13_l : Z",
                    "c12_H1 : J hj",
                    "c12_H : hdisj3 hempty hj hf",
                    "c12_hf : heap",
                    "c12_hj : heap",
                    "c2_sz : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c33_goal : eq (hunion hj hf l0)\n  (if hempty l0 then hempty l0 else if hj l0 then hj l0 else hf l0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : eq (hunion hj hf l0)\n  (if hempty l0 then hempty l0 else if hj l0 then hj l0 else hf l0)",
                    "c28_l0 : addr",
                    "c12_hf : heap",
                    "c12_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : safe n (PURE l) (hinit l sz hempty)\n  (fun l : Z => pureconj (forall _ : eq l 0, False) (valid_N l sz)) J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c34_goal : pureconj (forall _ : eq l 0, False) (valid_N l sz) (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c34_goal : pureconj (forall _ : eq l 0, False) (valid_N l sz) (hinit l sz hempty)"
                ],
                "tactic_res": [
                    "c35_goal : forall _ : eq l 0, False",
                    "c36_goal : valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : forall _ : eq l 0, False",
                    "c17_H7 : forall _ : eq l 0, False",
                    "c13_l : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : valid_N l sz (hinit l sz hempty)",
                    "_global_valid_N_init : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_free",
        "proof": [
            {
                "tactic_sig": "Lemma triple_free : forall J l , J \u22a2 \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_free : forall J l , J \u22a2 \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (l : addr),\ntriple J (valid l) (FREE l) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J l n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (l : addr),\ntriple J (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : safe n (FREE l) h (fun _ : Z => emp) J",
                    "c2_J : invariant",
                    "c2_l : addr",
                    "c2_n : nat",
                    "c2_h : heap",
                    "c2_Ph : valid l h"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( v0 & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( v0 & _i ) .",
                "tactic_args": [
                    "c2_Ph : valid l h",
                    "c2_Ph : valid l h",
                    "c2_h : heap",
                    "c2_n : nat",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) by ( rewrite _i ; apply hupdate_same ) .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z",
                    "c2_Ph : contains l v0 h"
                ],
                "tactic_res": [
                    "c2_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe n (FREE l) h (fun _ : Z => emp) J",
                    "c2_n : nat",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_goal : safe 0 (FREE l) h (fun _ : Z => emp) J",
                    "c4_goal : safe (S n) (FREE l) h (fun _ : Z => emp) J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe 0 (FREE l) h (fun _ : Z => emp) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (S n) (FREE l) h (fun _ : Z => emp) J"
                ],
                "tactic_res": [
                    "c5_goal : True",
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (FREE l)), not (eq (h l0) None)",
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (FREE l) h0))",
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (FREE l) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => emp) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : forall (l0 : addr) (_ : immacc l0 (FREE l)), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (l0 : addr) (_ : eq l0 l), not (eq (h l0) None)"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (h l0) None)",
                    "c10_l0 : addr",
                    "c10_H : eq l0 l"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (h l0) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (FREE l) h0))"
                ],
                "tactic_res": [
                    "c11_goal : not (erroneous (pair (FREE l) h0))",
                    "c11_hf : heap",
                    "c11_hj : heap",
                    "c11_h0 : heap",
                    "c11_H : hdisj3 h hj hf",
                    "c11_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c11_H1 : J hj"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro ST .",
                "tactic_args": [
                    "c11_goal : not (erroneous (pair (FREE l) h0))"
                ],
                "tactic_res": [
                    "c12_goal : False",
                    "c12_ST : erroneous (pair (FREE l) h0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_ST : erroneous (pair (FREE l) h0)"
                ],
                "tactic_res": [
                    "c12_H3 : eq (hunion h (hunion hj hf) l) None"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c12_H3 : eq (hunion h (hunion hj hf) l) None"
                ],
                "tactic_res": [
                    "c12_H3 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_L : eq (h l) (Some v0)",
                    "c12_H3 : eq (if h l then h l else if hj l then hj l else hf l) None"
                ],
                "tactic_res": [
                    "c12_H3 : eq (Some v0) None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c12_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (FREE l) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => emp) J)))))"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => emp) J)))))",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c13_h0 : heap",
                    "c13_c' : com",
                    "c13_h' : heap",
                    "c13_H : hdisj3 h hj hf",
                    "c13_H0 : eq h0 (hunion h (hunion hj hf))",
                    "c13_H1 : J hj",
                    "c13_H2 : red (pair (FREE l) h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c13_h0 : heap",
                    "c13_H0 : eq h0 (hunion h (hunion hj hf))"
                ],
                "tactic_res": [
                    "c13_H2 : red (pair (FREE l) (hunion h (hunion hj hf))) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_Ph : contains l v0 h",
                    "c13_H : hdisj3 h hj hf"
                ],
                "tactic_res": [
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' (fun _ : Z => emp) J)))))",
                    "c13_H2 : red (pair (FREE l) (hunion h (hunion hj hf))) (pair c' h')"
                ],
                "tactic_res": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hfree l (hunion h (hunion hj hf)))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n SKIP h1' (fun _ : Z => emp) J)))))",
                    "c14_H3 : not (eq (hunion h (hunion hj hf) l) None)"
                ]
            },
            {
                "tactic_sig": "exists hempty , _i .",
                "tactic_sig_no_out_arg": "exists hempty , _i .",
                "tactic_args": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and\n           (eq (hfree l (hunion h (hunion hj hf)))\n              (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n SKIP h1' (fun _ : Z => emp) J)))))",
                    "c13_hj : heap"
                ],
                "tactic_res": [
                    "c15_goal : and (hdisj3 hempty hj hf)\n  (and\n     (eq (hfree l (hunion h (hunion hj hf)))\n        (hunion hempty (hunion hj hf)))\n     (and (J hj) (safe n SKIP hempty (fun _ : Z => emp) J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c15_goal : and (hdisj3 hempty hj hf)\n  (and\n     (eq (hfree l (hunion h (hunion hj hf)))\n        (hunion hempty (hunion hj hf)))\n     (and (J hj) (safe n SKIP hempty (fun _ : Z => emp) J)))",
                    "c14_H3 : not (eq (hunion h (hunion hj hf) l) None)",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_h : heap",
                    "c2_n : nat",
                    "c2_l : addr",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c16_goal : hdisj3 hempty hj hf",
                    "c16_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c17_goal : eq (hfree l (hunion h (hunion hj hf))) (hunion hempty (hunion hj hf))",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c18_goal : safe n SKIP hempty (fun _ : Z => emp) J",
                    "c18_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c16_goal : hdisj3 hempty hj hf",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( D : hdisjoint ( hupdate _i _i hempty ) ( hunion _i _i ) ) by HDISJ .",
                "tactic_sig_no_out_arg": "assert ( D : hdisjoint ( hupdate _i _i hempty ) ( hunion _i _i ) ) by HDISJ .",
                "tactic_args": [
                    "c2_l : addr",
                    "c2_v0 : Z",
                    "c13_hj : heap",
                    "c13_hf : heap",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_h : heap",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c17_D : hdisjoint (hupdate l v0 hempty) (hunion hj hf)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : eq (hfree l (hunion h (hunion hj hf))) (hunion hempty (hunion hj hf))",
                    "c2_Ph : contains l v0 h"
                ],
                "tactic_res": [
                    "c19_goal : eq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)))\n  (hunion hempty (hunion hj hf))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : eq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)))\n  (hunion hempty (hunion hj hf))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c20_goal : forall l0 : addr,\neq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion hempty (hunion hj hf) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l0 .",
                "tactic_args": [
                    "c20_goal : forall l0 : addr,\neq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion hempty (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c21_goal : eq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion hempty (hunion hj hf) l0)",
                    "c21_l0 : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c21_goal : eq (hfree l (hunion (hupdate l v0 hempty) (hunion hj hf)) l0)\n  (hunion hempty (hunion hj hf) l0)"
                ],
                "tactic_res": [
                    "c22_goal : eq\n  (if Z.eq_dec l l0\n   then None\n   else\n    if if Z.eq_dec l l0 then Some v0 else None\n    then if Z.eq_dec l l0 then Some v0 else None\n    else if hj l0 then hj l0 else hf l0)\n  (if hj l0 then hj l0 else hf l0)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c22_goal : eq\n  (if Z.eq_dec l l0\n   then None\n   else\n    if if Z.eq_dec l l0 then Some v0 else None\n    then if Z.eq_dec l l0 then Some v0 else None\n    else if hj l0 then hj l0 else hf l0)\n  (if hj l0 then hj l0 else hf l0)",
                    "c2_l : addr",
                    "c21_l0 : addr",
                    "c17_D : hdisjoint (hupdate l v0 hempty) (hunion hj hf)",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_v0 : Z",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c23_goal : eq None (if hj l0 then hj l0 else hf l0)",
                    "c23_e : eq l l0",
                    "c24_goal : eq (if hj l0 then hj l0 else hf l0) (if hj l0 then hj l0 else hf l0)",
                    "c24_n0 : not (eq l l0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (if hj l0 then hj l0 else hf l0) (if hj l0 then hj l0 else hf l0)",
                    "c21_l0 : addr",
                    "c13_hf : heap",
                    "c13_hj : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c23_goal : eq None (if hj l0 then hj l0 else hf l0)",
                    "c21_l0 : addr",
                    "c23_e : eq l l0"
                ],
                "tactic_res": [
                    "c25_goal : eq None (if hj l then hj l else hf l)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c25_goal : eq None (if hj l then hj l else hf l)",
                    "c17_D : hdisjoint (hupdate l v0 hempty) (hunion hj hf)",
                    "c2_l : addr",
                    "c17_H3 : forall _ : eq (hunion h (hunion hj hf) l) None, False",
                    "c13_H1 : J hj",
                    "c13_H : hdisj3 (hupdate l v0 hempty) hj hf",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_L : eq (h l) (Some v0)",
                    "c2_Ph : contains l v0 h",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c26_goal : eq None (if hj l then hj l else hf l)",
                    "c26_H0 : eq (hupdate l v0 hempty l) None",
                    "c27_goal : eq None (if hj l then hj l else hf l)",
                    "c27_H0 : eq (hunion hj hf l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : eq None (if hj l then hj l else hf l)",
                    "c27_H0 : eq (hunion hj hf l) None",
                    "c13_hf : heap",
                    "c13_hj : heap",
                    "c2_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)",
                    "c26_H0 : eq (hupdate l v0 hempty l) None"
                ],
                "tactic_res": [
                    "c26_H0 : eq (Some v0) None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c26_goal : eq None (if hj l then hj l else hf l)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : safe n SKIP hempty (fun _ : Z => emp) J",
                    "_global_safe_pure : forall (n : nat) (v : Z) (h : heap) (Q : postcond) \n         (J : invariant) (_ : Q v h), safe n (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c28_goal : emp hempty"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c28_goal : emp hempty"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence_pre",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence_pre : forall P' J P c Q , J \u22a2 \u2983 P' \u2984 c \u2983 Q \u2984 -> aimp P P' -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence_pre : forall P' J P c Q , J \u22a2 \u2983 P' \u2984 c \u2983 Q \u2984 -> aimp P P' -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P' : precond) (J : invariant) (P : assertion) \n  (c : com) (Q : postcond) (_ : triple J P' c Q) (_ : aimp P P'),\ntriple J P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P' : precond) (J : invariant) (P : assertion) \n  (c : com) (Q : postcond) (_ : triple J P' c Q) (_ : aimp P P'),\ntriple J P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple J P c Q",
                    "c2_P' : precond",
                    "c2_J : invariant",
                    "c2_P : assertion",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : triple J P' c Q",
                    "c2_H0 : aimp P P'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n h Ph .",
                "tactic_args": [
                    "c2_goal : triple J P c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h Q J",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe n c h Q J",
                    "c2_H : triple J P' c Q"
                ],
                "tactic_res": [
                    "c4_goal : P' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P' h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_H0 : aimp P P'",
                    "c2_P' : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma safe_consequence : forall ( Q Q' : postcond ) ( J : invariant ) , ( forall v , aimp ( Q' v ) ( Q v ) ) -> forall n c h , safe n c h Q' J -> safe n c h Q J .",
                "tactic_sig_no_out_arg": "Lemma safe_consequence : forall ( Q Q' : postcond ) ( J : invariant ) , ( forall v , aimp ( Q' v ) ( Q v ) ) -> forall n c h , safe n c h Q' J -> safe n c h Q J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q Q' : postcond) (J : invariant)\n  (_ : forall v : Z, aimp (Q' v) (Q v)) (n : nat) \n  (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q Q' J H n .",
                "tactic_args": [
                    "c1_goal : forall (Q Q' : postcond) (J : invariant)\n  (_ : forall v : Z, aimp (Q' v) (Q v)) (n : nat) \n  (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J",
                    "c2_Q : postcond",
                    "c2_Q' : postcond",
                    "c2_J : invariant",
                    "c2_H : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q' J), safe 0 c h Q J",
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q' J),\nsafe (S n) c h Q J",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q' J), safe 0 c h Q J"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 c h Q J",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_H0 : safe 0 c h Q' J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q' J),\nsafe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c6_goal : safe (S n) c h Q J",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_H0 : safe (S n) c h Q' J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 c h Q J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe (S n) c h Q J",
                    "c6_H0 : safe (S n) c h Q' J"
                ],
                "tactic_res": [
                    "c7_goal : safe (S n) (PURE v) h Q J",
                    "c7_H2 : Q' v h",
                    "c7_v : Z",
                    "c8_goal : safe (S n) c h Q J",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (S n) (PURE v) h Q J"
                ],
                "tactic_res": [
                    "c9_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Q v h",
                    "c2_H : forall v : Z, aimp (Q' v) (Q v)"
                ],
                "tactic_res": [
                    "c10_goal : Q' v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Q' v h",
                    "c7_H2 : Q' v h",
                    "c7_v : Z",
                    "c6_h : heap",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c6_h : heap",
                    "c6_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c15_h0 : heap",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_H0 : hdisj3 h hj hf",
                    "c15_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c15_H2 : J hj",
                    "c15_H3 : red (pair c h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "edestruct _i as ( h1' & hj' & A & B & C & D ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( h1' & hj' & A & B & C & D ) .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))"
                ],
                "tactic_res": [
                    "c16_goal : hdisj3 h ?hj ?hf",
                    "c17_goal : eq ?h (hunion h (hunion hj hf))",
                    "c18_goal : J hj",
                    "c19_goal : red (pair c h0) (pair ?c' ?h')",
                    "c20_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c20_D : safe n ?c' h1' Q' J",
                    "c20_C : J hj'",
                    "c20_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c20_A : hdisj3 h1' hj' ?hf",
                    "c20_hj' : heap",
                    "c20_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : hdisj3 h ?hj ?hf",
                    "c15_H0 : hdisj3 h hj hf",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : eq ?h (hunion h (hunion hj hf))",
                    "c15_hf : heap",
                    "c15_hj : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : J hj",
                    "c15_H2 : J hj",
                    "c15_hj : heap",
                    "c2_J : invariant"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : red (pair c h0) (pair ?c' ?h')",
                    "c15_H3 : red (pair c h0) (pair c' h')",
                    "c15_h0 : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c20_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c20_h1' : heap",
                    "c20_hj' : heap"
                ],
                "tactic_res": [
                    "c21_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n c' h1' Q J)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c21_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n c' h1' Q J)))",
                    "c20_D : safe n ?c' h1' Q' J",
                    "c20_C : J hj'",
                    "c20_B : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c20_A : hdisj3 h1' hj' ?hf",
                    "c20_h1' : heap",
                    "c20_hj' : heap",
                    "c15_h' : heap",
                    "c15_c' : com",
                    "c15_hf : heap",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q' J), safe n c h Q J",
                    "c2_n : nat",
                    "c2_J : invariant",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence_post",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence_post : forall Q' J P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q' \u2984 -> ( forall v , aimp ( Q' v ) ( Q v ) ) -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence_post : forall Q' J P c Q , J \u22a2 \u2983 P \u2984 c \u2983 Q' \u2984 -> ( forall v , aimp ( Q' v ) ( Q v ) ) -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q' : postcond) (J : invariant) (P : precond) \n  (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n  (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q' : postcond) (J : invariant) (P : precond) \n  (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n  (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple J P c Q",
                    "c2_Q' : postcond",
                    "c2_J : invariant",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_H : triple J P c Q'",
                    "c2_H0 : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n h Ph .",
                "tactic_args": [
                    "c2_goal : triple J P c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h Q J",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe n c h Q J",
                    "_global_safe_consequence : forall (Q Q' : postcond) (J : invariant)\n         (_ : forall v : Z, aimp (Q' v) (Q v)) (n : nat) \n         (c : com) (h : heap) (_ : safe n c h Q' J), \n       safe n c h Q J",
                    "c2_Q' : postcond"
                ],
                "tactic_res": [
                    "c4_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c5_goal : safe n c h Q' J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_H0 : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe n c h Q' J",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c2_H : triple J P c Q'",
                    "c2_c : com",
                    "c2_J : invariant",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_exists_pre",
        "proof": [
            {
                "tactic_sig": "Lemma triple_exists_pre : forall { X : Type } J ( P : X -> assertion ) c Q , ( forall v , J \u22a2 \u2983 P v \u2984 c \u2983 Q \u2984 ) -> J \u22a2 \u2983 aexists P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_exists_pre : forall { X : Type } J ( P : X -> assertion ) c Q , ( forall v , J \u22a2 \u2983 P v \u2984 c \u2983 Q \u2984 ) -> J \u22a2 \u2983 aexists P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (J : invariant) (P : forall _ : X, assertion)\n  (c : com) (Q : postcond) (_ : forall v : X, triple J (P v) c Q),\ntriple J (aexists P) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (J : invariant) (P : forall _ : X, assertion)\n  (c : com) (Q : postcond) (_ : forall v : X, triple J (P v) c Q),\ntriple J (aexists P) c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple J (aexists P) c Q",
                    "c2_X : Type",
                    "c2_J : invariant",
                    "c2_P : forall _ : X, assertion",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : forall v : X, triple J (P v) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n h Ph .",
                "tactic_args": [
                    "c2_goal : triple J (aexists P) c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h Q J",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : aexists P h"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( v & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( v & _i ) .",
                "tactic_args": [
                    "c3_Ph : aexists P h",
                    "c3_Ph : aexists P h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c2_H : forall v : X, triple J (P v) c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_Ph : P v h",
                    "c3_v : X"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : safe n c h Q J",
                    "c2_H : forall v : X, triple J (P v) c Q",
                    "c3_v : X"
                ],
                "tactic_res": [
                    "c4_goal : P v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P v h",
                    "c3_Ph : P v h",
                    "c3_v : X",
                    "c3_h : heap",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_simple_conj_pre",
        "proof": [
            {
                "tactic_sig": "Lemma triple_simple_conj_pre : forall J ( P1 : Prop ) P2 c Q , ( P1 -> J \u22a2 \u2983 P2 \u2984 c \u2983 Q \u2984 ) -> J \u22a2 \u2983 P1 //\\\\ P2 \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_simple_conj_pre : forall J ( P1 : Prop ) P2 c Q , ( P1 -> J \u22a2 \u2983 P2 \u2984 c \u2983 Q \u2984 ) -> J \u22a2 \u2983 P1 //\\\\ P2 \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P1 : Prop) (P2 : precond) \n  (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\ntriple J (pureconj P1 P2) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P1 : Prop) (P2 : precond) \n  (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\ntriple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple J (pureconj P1 P2) c Q",
                    "c2_J : invariant",
                    "c2_P1 : Prop",
                    "c2_P2 : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : forall _ : P1, triple J P2 c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n h Ph .",
                "tactic_args": [
                    "c2_goal : triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h Q J",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : pureconj P1 P2 h"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_Ph : pureconj P1 P2 h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c2_H : forall _ : P1, triple J P2 c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : invariant"
                ],
                "tactic_res": [
                    "c3_H1 : P2 h",
                    "c3_H0 : P1"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe n c h Q J",
                    "c2_H : forall _ : P1, triple J P2 c Q"
                ],
                "tactic_res": [
                    "c4_goal : P1",
                    "c5_goal : P2 h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P1",
                    "c3_H0 : P1",
                    "c2_P1 : Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P2 h",
                    "c3_H1 : P2 h",
                    "c3_h : heap",
                    "c2_P2 : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_or",
        "proof": [
            {
                "tactic_sig": "Lemma triple_or : forall J P c Q P' Q' , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P' \u2984 c \u2983 Q' \u2984 -> J \u22a2 \u2983 aor P P' \u2984 c \u2983 fun v => aor ( Q v ) ( Q' v ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_or : forall J P c Q P' Q' , J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P' \u2984 c \u2983 Q' \u2984 -> J \u22a2 \u2983 aor P P' \u2984 c \u2983 fun v => aor ( Q v ) ( Q' v ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (P' : precond) (Q' : postcond) (_ : triple J P c Q)\n  (_ : triple J P' c Q'),\ntriple J (aor P P') c (fun v : Z => aor (Q v) (Q' v))"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q' .",
                "tactic_args": [
                    "c1_goal : forall (J : invariant) (P : precond) (c : com) (Q : postcond)\n  (P' : precond) (Q' : postcond) (_ : triple J P c Q)\n  (_ : triple J P' c Q'),\ntriple J (aor P P') c (fun v : Z => aor (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : triple J P c Q) (_ : triple J P' c Q'),\ntriple J (aor P P') c (fun v : Z => aor (Q v) (Q' v))",
                    "c2_Q' : postcond",
                    "c2_P' : precond",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond",
                    "c2_J : invariant"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros TR1 TR2 n h [ Ph | P'h ] .",
                "tactic_args": [
                    "c2_goal : forall (_ : triple J P c Q) (_ : triple J P' c Q'),\ntriple J (aor P P') c (fun v : Z => aor (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h (fun v : Z => aor (Q v) (Q' v)) J",
                    "c4_TR1 : triple J P c Q",
                    "c4_TR2 : triple J P' c Q'",
                    "c4_n : nat",
                    "c4_h : heap",
                    "c4_P'h : P' h",
                    "c4_goal : safe n c h (fun v : Z => aor (Q v) (Q' v)) J",
                    "c3_TR1 : triple J P c Q",
                    "c3_TR2 : triple J P' c Q'",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe n c h (fun v : Z => aor (Q v) (Q' v)) J",
                    "_global_safe_consequence : forall (Q Q' : postcond) (J : invariant)\n         (_ : forall v : Z, aimp (Q' v) (Q v)) (n : nat) \n         (c : com) (h : heap) (_ : safe n c h Q' J), \n       safe n c h Q J",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c5_goal : forall v : Z, aimp (Q v) (aor (Q v) (Q' v))",
                    "c6_goal : safe n c h Q J"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros v1 h1 .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q v) (aor (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : Q v1 h1, aor (Q v1) (Q' v1) h1",
                    "c7_v1 : Z",
                    "c7_h1 : heap"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : forall _ : Q v1 h1, aor (Q v1) (Q' v1) h1"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Q v1 h1, or (Q v1 h1) (Q' v1 h1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : forall _ : Q v1 h1, or (Q v1 h1) (Q' v1 h1)",
                    "c7_h1 : heap",
                    "c7_v1 : Z",
                    "c2_Q' : postcond",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe n c h Q J",
                    "c3_TR1 : triple J P c Q"
                ],
                "tactic_res": [
                    "c9_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : safe n c h (fun v : Z => aor (Q v) (Q' v)) J",
                    "_global_safe_consequence : forall (Q Q' : postcond) (J : invariant)\n         (_ : forall v : Z, aimp (Q' v) (Q v)) (n : nat) \n         (c : com) (h : heap) (_ : safe n c h Q' J), \n       safe n c h Q J",
                    "c2_Q' : postcond"
                ],
                "tactic_res": [
                    "c10_goal : forall v : Z, aimp (Q' v) (aor (Q v) (Q' v))",
                    "c11_goal : safe n c h Q' J"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros v1 h1 .",
                "tactic_args": [
                    "c10_goal : forall v : Z, aimp (Q' v) (aor (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Q' v1 h1, aor (Q v1) (Q' v1) h1",
                    "c12_v1 : Z",
                    "c12_h1 : heap"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c12_goal : forall _ : Q' v1 h1, aor (Q v1) (Q' v1) h1"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Q' v1 h1, or (Q v1 h1) (Q' v1 h1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall _ : Q' v1 h1, or (Q v1 h1) (Q' v1 h1)",
                    "c12_h1 : heap",
                    "c12_v1 : Z",
                    "c2_Q' : postcond",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : safe n c h Q' J",
                    "c4_TR2 : triple J P' c Q'"
                ],
                "tactic_res": [
                    "c14_goal : P' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : P' h",
                    "c4_P'h : P' h",
                    "c4_h : heap",
                    "c2_P' : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_and",
        "proof": [
            {
                "tactic_sig": "Lemma safe_and : forall J Q Q' , precise J -> forall n c h , safe n c h Q J -> safe n c h Q' J -> safe n c h ( fun v => aand ( Q v ) ( Q' v ) ) J .",
                "tactic_sig_no_out_arg": "Lemma safe_and : forall J Q Q' , precise J -> forall n c h , safe n c h Q J -> safe n c h Q' J -> safe n c h ( fun v => aand ( Q v ) ( Q' v ) ) J .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : assertion) (Q Q' : postcond) (_ : precise J) \n  (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : safe n c h Q' J), safe n c h (fun v : Z => aand (Q v) (Q' v)) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros J Q Q' H n .",
                "tactic_args": [
                    "c1_goal : forall (J : assertion) (Q Q' : postcond) (_ : precise J) \n  (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n  (_ : safe n c h Q' J), safe n c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c2_J : assertion",
                    "c2_Q : postcond",
                    "c2_Q' : postcond",
                    "c2_H : precise J",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J) (_ : safe 0 c h Q' J),\nsafe 0 c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J)\n  (_ : safe (S n) c h Q' J),\nsafe (S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c h S S' .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (h : heap) (_ : safe 0 c h Q J) (_ : safe 0 c h Q' J),\nsafe 0 c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c5_goal : safe 0 c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c5_c : com",
                    "c5_h : heap",
                    "c5_S : safe 0 c h Q J",
                    "c5_S' : safe 0 c h Q' J"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c h S S' .",
                "tactic_args": [
                    "c4_goal : forall (c : com) (h : heap) (_ : safe (S n) c h Q J)\n  (_ : safe (S n) c h Q' J),\nsafe (S n) c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c6_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c6_c : com",
                    "c6_h : heap",
                    "c6_S : safe (S n) c h Q J",
                    "c6_S' : safe (S n) c h Q' J"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe 0 c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c6_S : safe (S n) c h Q J"
                ],
                "tactic_res": [
                    "c7_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c7_H1 : Q v h",
                    "c7_S' : safe (S n) (PURE v) h Q' J",
                    "c7_v : Z",
                    "c8_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c7_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c7_S' : safe (S n) (PURE v) h Q' J"
                ],
                "tactic_res": [
                    "c9_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c9_H3 : Q' v h",
                    "c10_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c10_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (PURE v) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))",
                    "c10_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (PURE v) h0))",
                    "c10_ACC : forall (l : addr) (_ : immacc l (PURE v)), not (eq (h l) None)",
                    "c10_NOTDONE : False"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c6_S' : safe (S n) c h Q' J"
                ],
                "tactic_res": [
                    "c11_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c11_H1 : Q' v h",
                    "c11_NOTDONE : False",
                    "c11_ACC : forall (l : addr) (_ : immacc l (PURE v)), not (eq (h l) None)",
                    "c11_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair (PURE v) h0))",
                    "c11_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair (PURE v) h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c11_v : Z",
                    "c12_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c12_STEP0 : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))",
                    "c12_IMM0 : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c12_ACC0 : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c12_NOTDONE0 : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c9_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c13_goal : aand (Q v) (Q' v) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : aand (Q v) (Q' v) h"
                ],
                "tactic_res": [
                    "c14_goal : Q v h",
                    "c15_goal : Q' v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Q v h",
                    "c7_H1 : Q v h",
                    "c7_v : Z",
                    "c6_h : heap",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Q' v h",
                    "c9_H3 : Q' v h",
                    "c7_v : Z",
                    "c6_h : heap",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c10_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c11_goal : safe (S n) (PURE v) h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : safe (Datatypes.S n) c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c16_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c17_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c18_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c19_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c6_h : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c6_h : heap",
                    "c6_c : com",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c19_goal : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))"
                ],
                "tactic_res": [
                    "c20_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c20_hf : heap",
                    "c20_hj : heap",
                    "c20_h0 : heap",
                    "c20_c' : com",
                    "c20_h' : heap",
                    "c20_H0 : hdisj3 h hj hf",
                    "c20_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c20_H2 : J hj",
                    "c20_H3 : red (pair c h0) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "edestruct _i as ( h1' & hj' & D' & E' & J' & SAFE' ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( h1' & hj' & D' & E' & J' & SAFE' ) .",
                "tactic_args": [
                    "c20_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))"
                ],
                "tactic_res": [
                    "c21_goal : hdisj3 h ?hj ?hf",
                    "c22_goal : eq ?h (hunion h (hunion hj hf))",
                    "c23_goal : J hj",
                    "c24_goal : red (pair c h0) (pair ?c' ?h')",
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c25_SAFE' : safe n ?c' h1' Q J",
                    "c25_J' : J hj'",
                    "c25_E' : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c25_D' : hdisj3 h1' hj' ?hf",
                    "c25_hj' : heap",
                    "c25_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : hdisj3 h ?hj ?hf",
                    "c20_H0 : hdisj3 h hj hf",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : eq ?h (hunion h (hunion hj hf))",
                    "c20_hf : heap",
                    "c20_hj : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : J hj",
                    "c20_H2 : J hj",
                    "c20_hj : heap",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : red (pair c h0) (pair ?c' ?h')",
                    "c20_H3 : red (pair c h0) (pair c' h')",
                    "c20_h0 : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( h1'' & hj'' & D'' & E'' & J'' & SAFE'' ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( h1'' & hj'' & D'' & E'' & J'' & SAFE'' ) .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c12_STEP0 : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))"
                ],
                "tactic_res": [
                    "c26_goal : hdisj3 h ?hj ?hf",
                    "c27_goal : eq ?h (hunion h (hunion hj hf))",
                    "c28_goal : J hj",
                    "c29_goal : red (pair c h0) (pair ?c' ?h')",
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c30_SAFE'' : safe n ?c' h1'' Q' J",
                    "c30_J'' : J hj''",
                    "c30_E'' : eq ?h' (hunion h1'' (hunion hj'' ?hf))",
                    "c30_D'' : hdisj3 h1'' hj'' ?hf",
                    "c30_hj'' : heap",
                    "c30_h1'' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : hdisj3 h ?hj ?hf",
                    "c20_H0 : hdisj3 h hj hf",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : eq ?h (hunion h (hunion hj hf))",
                    "c20_hf : heap",
                    "c20_hj : heap",
                    "c6_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : J hj",
                    "c20_H2 : J hj",
                    "c20_hj : heap",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : red (pair c h0) (pair ?c' ?h')",
                    "c20_H3 : red (pair c h0) (pair c' h')",
                    "c20_h0 : heap",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c30_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c25_hj' : heap",
                    "c30_hj'' : heap"
                ],
                "tactic_res": [
                    "c31_goal : eq hj' hj''",
                    "c32_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c32_H4 : eq hj' hj''"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_args": [
                    "c31_goal : eq hj' hj''",
                    "c2_H : precise J",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c25_h1' : heap",
                    "c20_hf : heap",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c30_h1'' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": [
                    "c33_goal : hdisjoint hj' (hunion h1' hf)",
                    "c34_goal : hdisjoint hj'' (hunion h1'' hf)",
                    "c35_goal : eq (hunion hj' (hunion h1' hf)) (hunion hj'' (hunion h1'' hf))",
                    "c36_goal : J hj'",
                    "c37_goal : J hj''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : J hj'",
                    "c25_J' : J hj'",
                    "c25_hj' : heap",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : J hj''",
                    "c30_J'' : J hj''",
                    "c30_hj'' : heap",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c33_goal : hdisjoint hj' (hunion h1' hf)",
                    "c25_D' : hdisj3 h1' hj' ?hf",
                    "c25_h1' : heap",
                    "c25_hj' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c34_goal : hdisjoint hj'' (hunion h1'' hf)",
                    "c30_D'' : hdisj3 h1'' hj'' ?hf",
                    "c30_h1'' : heap",
                    "c30_hj'' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ! ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c35_goal : eq (hunion hj' (hunion h1' hf)) (hunion hj'' (hunion h1'' hf))",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c20_hf : heap",
                    "c30_SAFE'' : safe n ?c' h1'' Q' J",
                    "c30_J'' : J hj''",
                    "c30_E'' : eq ?h' (hunion h1'' (hunion hj'' ?hf))",
                    "c30_D'' : hdisj3 h1'' hj'' ?hf",
                    "c30_h1'' : heap",
                    "c30_hj'' : heap",
                    "c25_SAFE' : safe n ?c' h1' Q J",
                    "c25_J' : J hj'",
                    "c25_E' : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c25_D' : hdisj3 h1' hj' ?hf",
                    "c25_h1' : heap",
                    "c25_hj' : heap",
                    "c20_H3 : red (pair c h0) (pair c' h')",
                    "c20_H2 : J hj",
                    "c20_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c20_H0 : hdisj3 h hj hf",
                    "c12_STEP0 : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))",
                    "c12_IMM0 : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c12_ACC0 : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c12_NOTDONE0 : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c2_H : precise J"
                ],
                "tactic_res": [
                    "c38_goal : eq (hunion hj' (hunion hf h1')) (hunion hj'' (hunion hf h1''))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i .",
                "tactic_args": [
                    "c38_goal : eq (hunion hj' (hunion hf h1')) (hunion hj'' (hunion hf h1''))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c39_goal : eq (hunion (hunion hj' hf) h1') (hunion (hunion hj'' hf) h1'')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c39_goal : eq (hunion (hunion hj' hf) h1') (hunion (hunion hj'' hf) h1'')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c25_h1' : heap",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c30_h1'' : heap",
                    "c30_SAFE'' : safe n ?c' h1'' Q' J",
                    "c30_J'' : J hj''",
                    "c30_E'' : eq ?h' (hunion h1'' (hunion hj'' ?hf))",
                    "c30_D'' : hdisj3 h1'' hj'' ?hf",
                    "c30_hj'' : heap",
                    "c25_SAFE' : safe n ?c' h1' Q J",
                    "c25_J' : J hj'",
                    "c25_E' : eq ?h' (hunion h1' (hunion hj' ?hf))",
                    "c25_D' : hdisj3 h1' hj' ?hf",
                    "c25_hj' : heap",
                    "c20_H3 : red (pair c h0) (pair c' h')",
                    "c20_H2 : J hj",
                    "c20_H1 : eq h0 (hunion h (hunion hj hf))",
                    "c20_H0 : hdisj3 h hj hf",
                    "c20_hf : heap",
                    "c12_STEP0 : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q' J)))))",
                    "c12_IMM0 : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c12_ACC0 : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c12_NOTDONE0 : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_STEP : forall (hf hj h0 : heap) (c' : com) (h' : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj)\n  (_ : red (pair c h0) (pair c' h')),\nex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj') (safe n c' h1' Q J)))))",
                    "c8_IMM : forall (hf hj h0 : heap) (_ : hdisj3 h hj hf)\n  (_ : eq h0 (hunion h (hunion hj hf))) (_ : J hj),\nnot (erroneous (pair c h0))",
                    "c8_ACC : forall (l : addr) (_ : immacc l c), not (eq (h l) None)",
                    "c8_NOTDONE : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c2_H : precise J"
                ],
                "tactic_res": [
                    "c40_goal : eq (hunion h1' (hunion hj' hf)) (hunion h1'' (hunion hj'' hf))"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c40_goal : eq (hunion h1' (hunion hj' hf)) (hunion h1'' (hunion hj'' hf))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_hj'' : heap",
                    "c32_H4 : eq hj' hj''"
                ],
                "tactic_res": [
                    "c32_SAFE'' : safe n c' h1'' Q' J",
                    "c32_D'' : hdisj3 h1'' hj' hf",
                    "c32_E'' : eq h' (hunion h1'' (hunion hj' hf))",
                    "c32_J'' : J hj'"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c32_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c25_h1' : heap",
                    "c30_h1'' : heap"
                ],
                "tactic_res": [
                    "c41_goal : eq h1' h1''",
                    "c42_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c42_H4 : eq h1' h1''"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c41_goal : eq h1' h1''",
                    "_global_hunion_invert_l : forall (h1 h2 h : heap) (_ : eq (hunion h1 h) (hunion h2 h))\n         (_ : hdisjoint h1 h) (_ : hdisjoint h2 h), \n       eq h1 h2",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c25_hj' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": [
                    "c43_goal : eq (hunion h1' (hunion hj' hf)) (hunion h1'' (hunion hj' hf))",
                    "c44_goal : hdisjoint h1' (hunion hj' hf)",
                    "c45_goal : hdisjoint h1'' (hunion hj' hf)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c43_goal : eq (hunion h1' (hunion hj' hf)) (hunion h1'' (hunion hj' hf))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c44_goal : hdisjoint h1' (hunion hj' hf)",
                    "c25_D' : hdisj3 h1' hj' ?hf",
                    "c25_h1' : heap",
                    "c25_hj' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c45_goal : hdisjoint h1'' (hunion hj' hf)",
                    "c32_D'' : hdisj3 h1'' hj' hf",
                    "c30_h1'' : heap",
                    "c25_hj' : heap",
                    "c20_hf : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_h1'' : heap",
                    "c42_H4 : eq h1' h1''"
                ],
                "tactic_res": [
                    "c42_E'' : eq h' (hunion h1' (hunion hj' hf))",
                    "c42_D'' : hdisj3 h1' hj' hf",
                    "c42_SAFE'' : safe n c' h1' Q' J"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c42_goal : ex\n  (fun h1' : heap =>\n   ex\n     (fun hj' : heap =>\n      and (hdisj3 h1' hj' hf)\n        (and (eq h' (hunion h1' (hunion hj' hf)))\n           (and (J hj')\n              (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))))",
                    "c25_h1' : heap",
                    "c25_hj' : heap"
                ],
                "tactic_res": [
                    "c46_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : and (hdisj3 h1' hj' hf)\n  (and (eq h' (hunion h1' (hunion hj' hf)))\n     (and (J hj') (safe n c' h1' (fun v : Z => aand (Q v) (Q' v)) J)))",
                    "c42_SAFE'' : safe n c' h1' Q' J",
                    "c25_SAFE' : safe n ?c' h1' Q J",
                    "c25_h1' : heap",
                    "c25_hj' : heap",
                    "c20_h' : heap",
                    "c20_c' : com",
                    "c20_hf : heap",
                    "c4_IHn : forall (c : com) (h : heap) (_ : safe n c h Q J) (_ : safe n c h Q' J),\nsafe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c2_n : nat",
                    "c2_Q : postcond",
                    "c2_Q' : postcond",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_and",
        "proof": [
            {
                "tactic_sig": "Lemma triple_and : forall J P c Q P' Q' , precise J -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P' \u2984 c \u2983 Q' \u2984 -> J \u22a2 \u2983 aand P P' \u2984 c \u2983 fun v => aand ( Q v ) ( Q' v ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_and : forall J P c Q P' Q' , precise J -> J \u22a2 \u2983 P \u2984 c \u2983 Q \u2984 -> J \u22a2 \u2983 P' \u2984 c \u2983 Q' \u2984 -> J \u22a2 \u2983 aand P P' \u2984 c \u2983 fun v => aand ( Q v ) ( Q' v ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (J : assertion) (P : precond) (c : com) (Q : postcond)\n  (P' : precond) (Q' : postcond) (_ : precise J) (_ : triple J P c Q)\n  (_ : triple J P' c Q'),\ntriple J (aand P P') c (fun v : Z => aand (Q v) (Q' v))"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q' .",
                "tactic_args": [
                    "c1_goal : forall (J : assertion) (P : precond) (c : com) (Q : postcond)\n  (P' : precond) (Q' : postcond) (_ : precise J) (_ : triple J P c Q)\n  (_ : triple J P' c Q'),\ntriple J (aand P P') c (fun v : Z => aand (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : precise J) (_ : triple J P c Q) (_ : triple J P' c Q'),\ntriple J (aand P P') c (fun v : Z => aand (Q v) (Q' v))",
                    "c2_Q' : postcond",
                    "c2_P' : precond",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond",
                    "c2_J : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros PR TR1 TR2 n h ( Ph & P'h ) .",
                "tactic_args": [
                    "c2_goal : forall (_ : precise J) (_ : triple J P c Q) (_ : triple J P' c Q'),\ntriple J (aand P P') c (fun v : Z => aand (Q v) (Q' v))"
                ],
                "tactic_res": [
                    "c3_goal : safe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "c3_PR : precise J",
                    "c3_TR1 : triple J P c Q",
                    "c3_TR2 : triple J P' c Q'",
                    "c3_n : nat",
                    "c3_h : heap",
                    "c3_Ph : P h",
                    "c3_P'h : P' h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe n c h (fun v : Z => aand (Q v) (Q' v)) J",
                    "_global_safe_and : forall (J : assertion) (Q Q' : postcond) (_ : precise J) \n         (n : nat) (c : com) (h : heap) (_ : safe n c h Q J)\n         (_ : safe n c h Q' J), safe n c h (fun v : Z => aand (Q v) (Q' v)) J"
                ],
                "tactic_res": [
                    "c4_goal : precise J",
                    "c5_goal : safe n c h Q J",
                    "c6_goal : safe n c h Q' J"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : precise J",
                    "c3_PR : precise J",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe n c h Q J",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c3_TR1 : triple J P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : safe n c h Q' J",
                    "c3_P'h : P' h",
                    "c3_h : heap",
                    "c3_n : nat",
                    "c3_TR2 : triple J P' c Q'",
                    "c2_Q' : postcond",
                    "c2_c : com",
                    "c2_J : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_swap",
        "proof": [
            {
                "tactic_sig": "Lemma triple_swap : forall lck R , sem_invariant lck R \u22a2 \u2983 emp \u2984 SWAP lck 0 \u2983 fun v => if Z.eqb v 0 then emp else R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_swap : forall lck R , sem_invariant lck R \u22a2 \u2983 emp \u2984 SWAP lck 0 \u2983 fun v => if Z.eqb v 0 then emp else R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lck : addr) (R : assertion),\ntriple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lck : addr) (R : assertion),\ntriple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)"
                ],
                "tactic_res": [
                    "c2_goal : triple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)",
                    "c2_lck : addr",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)",
                    "_global_triple_atomic : forall (J P : assertion) (c : com) (Q : postcond)\n         (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\n       triple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c3_goal : triple emp (sepconj emp (sem_invariant lck R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : triple emp (sepconj emp (sem_invariant lck R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c4_goal : triple emp (sem_invariant lck R)\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "unfold _i at 1 .",
                "tactic_sig_no_out_arg": "unfold _i at 1 .",
                "tactic_args": [
                    "c4_goal : triple emp (sem_invariant lck R)\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_sem_invariant : forall (_ : addr) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c5_goal : triple emp\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R)))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple emp\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R)))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [lck : addr  R : assertion |- Type]"
                ],
                "tactic_res": [
                    "c6_goal : forall v : Z,\ntriple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v0 : Z =>\n   sepconj (if Z.eqb v0 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v .",
                "tactic_args": [
                    "c6_goal : forall v : Z,\ntriple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v0 : Z =>\n   sepconj (if Z.eqb v0 0 then emp else R) (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c7_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "c7_v : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( Q := fun v' => ( ( v' = _i ) //\\\\ _i _i _i ) ** ( if _i =? 0 then _i else _i ) ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( Q := fun v' => ( ( v' = _i ) //\\\\ _i _i _i ) ** ( if _i =? 0 then _i else _i ) ) .",
                "tactic_args": [
                    "c7_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (LET (GET lck) (fun old_v : Z => SEQ (SET lck 0) (PURE old_v)))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R",
                    "c7_v : Z",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_lck : addr",
                    "c7_v : Z",
                    "c7_v : Z",
                    "_global_emp : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c8_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (GET lck)\n  (fun v' : Z =>\n   sepconj (pureconj (eq v' v) (contains lck v))\n     (if Z.eqb v 0 then emp else R))",
                    "c9_goal : forall v0 : Z,\ntriple emp\n  (sepconj (pureconj (eq v0 v) (contains lck v))\n     (if Z.eqb v 0 then emp else R)) (SEQ (SET lck 0) (PURE v0))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (GET lck)\n  (fun v' : Z =>\n   sepconj (pureconj (eq v' v) (contains lck v))\n     (if Z.eqb v 0 then emp else R))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c10_goal : triple emp (contains lck v) (GET lck)\n  (fun v0 : Z => pureconj (eq v0 v) (contains lck v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple emp (contains lck v) (GET lck)\n  (fun v0 : Z => pureconj (eq v0 v) (contains lck v))",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v' .",
                "tactic_args": [
                    "c9_goal : forall v0 : Z,\ntriple emp\n  (sepconj (pureconj (eq v0 v) (contains lck v))\n     (if Z.eqb v 0 then emp else R)) (SEQ (SET lck 0) (PURE v0))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c11_goal : triple emp\n  (sepconj (pureconj (eq v' v) (contains lck v))\n     (if Z.eqb v 0 then emp else R)) (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "c11_v' : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : triple emp\n  (sepconj (pureconj (eq v' v) (contains lck v))\n     (if Z.eqb v 0 then emp else R)) (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c12_goal : triple emp\n  (pureconj (eq v' v)\n     (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : triple emp\n  (pureconj (eq v' v)\n     (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : eq v' v,\ntriple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "c13_goal : forall _ : eq v' v,\ntriple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c14_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "c14_EQ : eq v' v"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c14_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v'))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "c11_v' : Z",
                    "c14_EQ : eq v' v"
                ],
                "tactic_res": [
                    "c15_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q := _i _i 0 ** ( if _i =? 0 then _i else _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q := _i _i 0 ** ( if _i =? 0 then _i else _i ) ) .",
                "tactic_args": [
                    "c15_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SEQ (SET lck 0) (PURE v))\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_lck : addr",
                    "c7_v : Z",
                    "_global_emp : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c16_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SET lck 0)\n  (fun _ : Z => sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))",
                    "c17_goal : triple emp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (PURE v)\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : triple emp (sepconj (contains lck v) (if Z.eqb v 0 then emp else R))\n  (SET lck 0)\n  (fun _ : Z => sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c18_goal : triple emp (contains lck v) (SET lck 0) (fun _ : Z => contains lck 0)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c18_goal : triple emp (contains lck v) (SET lck 0) (fun _ : Z => contains lck 0)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q",
                    "_global_valid : forall _ : addr, assertion",
                    "c2_lck : addr"
                ],
                "tactic_res": [
                    "c19_goal : triple emp (valid lck) (SET lck 0) (fun _ : Z => contains lck 0)",
                    "c20_goal : aimp (contains lck v) (valid lck)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : triple emp (valid lck) (SET lck 0) (fun _ : Z => contains lck 0)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c20_goal : aimp (contains lck v) (valid lck)"
                ],
                "tactic_res": [
                    "c21_goal : forall (h : heap) (_ : contains lck v h), valid lck h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (h : heap) (_ : contains lck v h), valid lck h"
                ],
                "tactic_res": [
                    "c22_goal : valid lck h",
                    "c22_h : heap",
                    "c22_H : contains lck v h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c22_goal : valid lck h",
                    "c7_v : Z"
                ],
                "tactic_res": [
                    "c23_goal : contains lck v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : contains lck v h",
                    "c22_H : contains lck v h",
                    "c22_h : heap",
                    "c7_v : Z",
                    "c2_lck : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : triple emp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (PURE v)\n  (fun v : Z =>\n   sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c24_goal : aimp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c24_goal : aimp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (sepconj (if Z.eqb v 0 then emp else R) (sem_invariant lck R))",
                    "_global_sem_invariant : forall (_ : addr) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c25_goal : aimp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (sepconj (if Z.eqb v 0 then emp else R)\n     (aexists\n        (fun v : Z =>\n         sepconj (contains lck v) (if Z.eqb v 0 then emp else R))))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c25_goal : aimp (sepconj (contains lck 0) (if Z.eqb v 0 then emp else R))\n  (sepconj (if Z.eqb v 0 then emp else R)\n     (aexists\n        (fun v : Z =>\n         sepconj (contains lck v) (if Z.eqb v 0 then emp else R))))"
                ],
                "tactic_res": [
                    "c26_goal : forall (h : heap)\n  (_ : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h),\nsepconj (if Z.eqb v 0 then emp else R)\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c26_goal : forall (h : heap)\n  (_ : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h),\nsepconj (if Z.eqb v 0 then emp else R)\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) h"
                ],
                "tactic_res": [
                    "c27_goal : sepconj (if Z.eqb v 0 then emp else R)\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) h",
                    "c27_h : heap",
                    "c27_H : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c27_goal : sepconj (if Z.eqb v 0 then emp else R)\n  (aexists\n     (fun v : Z =>\n      sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) h",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c28_goal : aexists\n  (fun x : Z =>\n   sepconj (sepconj (contains lck x) (if Z.eqb x 0 then emp else R))\n     (if Z.eqb v 0 then emp else R)) h"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c28_goal : aexists\n  (fun x : Z =>\n   sepconj (sepconj (contains lck x) (if Z.eqb x 0 then emp else R))\n     (if Z.eqb v 0 then emp else R)) h"
                ],
                "tactic_res": [
                    "c29_goal : sepconj (sepconj (contains lck 0) (if Z.eqb 0 0 then emp else R))\n  (if Z.eqb v 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : sepconj (sepconj (contains lck 0) (if Z.eqb 0 0 then emp else R))\n  (if Z.eqb v 0 then emp else R) h",
                    "_global_Z.eqb_refl : forall x : Z, eq (Z.eqb x x) true"
                ],
                "tactic_res": [
                    "c30_goal : sepconj (sepconj (contains lck 0) emp) (if Z.eqb v 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) , _i .",
                "tactic_args": [
                    "c30_goal : sepconj (sepconj (contains lck 0) emp) (if Z.eqb v 0 then emp else R) h",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "_global_emp : assertion",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c31_goal : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c31_goal : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h",
                    "c27_H : sepconj (contains lck 0) (if Z.eqb v 0 then emp else R) h",
                    "c27_h : heap",
                    "c7_v : Z",
                    "c2_R : assertion",
                    "c2_lck : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_acquire",
        "proof": [
            {
                "tactic_sig": "Lemma triple_acquire : forall lck R , sem_invariant lck R \u22a2 \u2983 emp \u2984 ACQUIRE lck \u2983 fun _ => R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_acquire : forall lck R , sem_invariant lck R \u22a2 \u2983 emp \u2984 ACQUIRE lck \u2983 fun _ => R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lck : addr) (R : assertion),\ntriple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lck : addr) (R : assertion),\ntriple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ],
                "tactic_res": [
                    "c2_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)",
                    "c2_lck : addr",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q' := fun v => ( v <> 0 ) //\\\\ ( if _i v 0 then _i else _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q' := fun v => ( v <> 0 ) //\\\\ ( if _i v 0 then _i else _i ) ) .",
                "tactic_args": [
                    "c2_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)",
                    "_global_triple_consequence_post : forall (Q' : postcond) (J : invariant) (P : precond) \n         (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q",
                    "_global_Z.eqb : forall (_ : Z) (_ : Z), bool",
                    "_global_emp : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple (sem_invariant lck R) emp (ACQUIRE lck)\n  (fun v : Z => pureconj (not (eq v 0)) (if Z.eqb v 0 then emp else R))",
                    "c4_goal : forall v : Z,\naimp (pureconj (not (eq v 0)) (if Z.eqb v 0 then emp else R)) R"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (sem_invariant lck R) emp (ACQUIRE lck)\n  (fun v : Z => pureconj (not (eq v 0)) (if Z.eqb v 0 then emp else R))",
                    "_global_triple_repeat : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (_ : triple J P c Q) (_ : aimp (Q 0) P),\n       triple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ],
                "tactic_res": [
                    "c5_goal : triple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)",
                    "c6_goal : aimp (if Z.eqb 0 0 then emp else R) emp"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (sem_invariant lck R) emp (SWAP lck 0)\n  (fun v : Z => if Z.eqb v 0 then emp else R)",
                    "_global_triple_swap : forall (lck : addr) (R : assertion),\n       triple (sem_invariant lck R) emp (SWAP lck 0)\n         (fun v : Z => if Z.eqb v 0 then emp else R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : aimp (if Z.eqb 0 0 then emp else R) emp",
                    "_global_Z.eqb_refl : forall x : Z, eq (Z.eqb x x) true"
                ],
                "tactic_res": [
                    "c7_goal : aimp emp emp"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : aimp emp emp"
                ],
                "tactic_res": [
                    "c8_goal : forall (h : heap) (_ : emp h), emp h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : forall (h : heap) (_ : emp h), emp h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros v h [ H1 H2 ] .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\naimp (pureconj (not (eq v 0)) (if Z.eqb v 0 then emp else R)) R"
                ],
                "tactic_res": [
                    "c9_goal : R h",
                    "c9_v : Z",
                    "c9_h : heap",
                    "c9_H1 : not (eq v 0)",
                    "c9_H2 : (if Z.eqb v 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c9_H1 : not (eq v 0)"
                ],
                "tactic_res": [
                    "c9_H1 : eq (Z.eqb v 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c9_H1 : eq (Z.eqb v 0) false",
                    "c9_H2 : (if Z.eqb v 0 then emp else R) h"
                ],
                "tactic_res": [
                    "c9_H2 : R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : R h",
                    "c9_H2 : R h",
                    "c9_h : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_release",
        "proof": [
            {
                "tactic_sig": "Lemma triple_release : forall lck R , precise R -> sem_invariant lck R \u22a2 \u2983 R \u2984 RELEASE lck \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_release : forall lck R , precise R -> sem_invariant lck R \u22a2 \u2983 R \u2984 RELEASE lck \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lck : addr) (R : assertion) (_ : precise R),\ntriple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lck : addr) (R : assertion) (_ : precise R),\ntriple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)",
                    "c2_lck : addr",
                    "c2_R : assertion",
                    "c2_H : precise R"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)",
                    "_global_triple_atomic : forall (J P : assertion) (c : com) (Q : postcond)\n         (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\n       triple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c3_goal : triple emp (sepconj R (sem_invariant lck R)) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : triple emp (sepconj R (sem_invariant lck R)) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c4_goal : triple emp (sepconj (sem_invariant lck R) R) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "unfold _i at 1 .",
                "tactic_sig_no_out_arg": "unfold _i at 1 .",
                "tactic_args": [
                    "c4_goal : triple emp (sepconj (sem_invariant lck R) R) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_sem_invariant : forall (_ : addr) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c5_goal : triple emp\n  (sepconj\n     (aexists\n        (fun v : Z =>\n         sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : triple emp\n  (sepconj\n     (aexists\n        (fun v : Z =>\n         sepconj (contains lck v) (if Z.eqb v 0 then emp else R))) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c6_goal : triple emp\n  (aexists\n     (fun x : Z =>\n      sepconj (sepconj (contains lck x) (if Z.eqb x 0 then emp else R))\n        R)) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple emp\n  (aexists\n     (fun x : Z =>\n      sepconj (sepconj (contains lck x) (if Z.eqb x 0 then emp else R))\n        R)) (SET lck 1)\n  (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [lck : addr  R : assertion  H : precise R |- Type]"
                ],
                "tactic_res": [
                    "c7_goal : forall v : Z,\ntriple emp\n  (sepconj (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v .",
                "tactic_args": [
                    "c7_goal : forall v : Z,\ntriple emp\n  (sepconj (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c8_goal : triple emp\n  (sepconj (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "c8_v : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : triple emp\n  (sepconj (sepconj (contains lck v) (if Z.eqb v 0 then emp else R)) R)\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c9_goal : triple emp\n  (sepconj (contains lck v) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q' := fun _i => _i _i 1 ** ( if _i =? 0 then _i else _i ) ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q' := fun _i => _i _i 1 ** ( if _i =? 0 then _i else _i ) ** _i ) .",
                "tactic_args": [
                    "c9_goal : triple emp\n  (sepconj (contains lck v) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (SET lck 1) (fun _ : Z => sepconj emp (sem_invariant lck R))",
                    "_global_triple_consequence_post : forall (Q' : postcond) (J : invariant) (P : precond) \n         (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q",
                    "_global__ : ?T\nwhere\n?T : [lck : addr  R : assertion  H : precise R  v : Z |- Type]\n?y : [lck : addr  R : assertion  H : precise R  v : Z |- ?T]",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_lck : addr",
                    "c8_v : Z",
                    "_global_emp : assertion",
                    "c2_R : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c10_goal : triple emp\n  (sepconj (contains lck v) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (SET lck 1)\n  (fun _ : Z =>\n   sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))",
                    "c11_goal : forall _ : Z,\naimp\n  (sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple emp\n  (sepconj (contains lck v) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (SET lck 1)\n  (fun _ : Z =>\n   sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c12_goal : triple emp (contains lck v) (SET lck 1) (fun _ : Z => contains lck 1)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c12_goal : triple emp (contains lck v) (SET lck 1) (fun _ : Z => contains lck 1)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q",
                    "_global_valid : forall _ : addr, assertion",
                    "c2_lck : addr"
                ],
                "tactic_res": [
                    "c13_goal : triple emp (valid lck) (SET lck 1) (fun _ : Z => contains lck 1)",
                    "c14_goal : aimp (contains lck v) (valid lck)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : triple emp (valid lck) (SET lck 1) (fun _ : Z => contains lck 1)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c14_goal : aimp (contains lck v) (valid lck)"
                ],
                "tactic_res": [
                    "c15_goal : forall (h : heap) (_ : contains lck v h), valid lck h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall (h : heap) (_ : contains lck v h), valid lck h"
                ],
                "tactic_res": [
                    "c16_goal : valid lck h",
                    "c16_h : heap",
                    "c16_H0 : contains lck v h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c16_goal : valid lck h",
                    "c8_v : Z"
                ],
                "tactic_res": [
                    "c17_goal : contains lck v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : contains lck v h",
                    "c16_H0 : contains lck v h",
                    "c16_h : heap",
                    "c8_v : Z",
                    "c2_lck : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c11_goal : forall _ : Z,\naimp\n  (sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (sepconj emp (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c18_goal : aimp\n  (sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (sepconj emp (sem_invariant lck R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h P .",
                "tactic_args": [
                    "c18_goal : aimp\n  (sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R))\n  (sepconj emp (sem_invariant lck R))"
                ],
                "tactic_res": [
                    "c19_goal : sepconj emp (sem_invariant lck R) h",
                    "c19_h : heap",
                    "c19_P : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h"
                ]
            },
            {
                "tactic_sig": "assert ( ( contains _i 1 ** _i ) _i ) .",
                "tactic_sig_no_out_arg": "assert ( ( contains _i 1 ** _i ) _i ) .",
                "tactic_args": [
                    "c19_goal : sepconj emp (sem_invariant lck R) h",
                    "c2_lck : addr",
                    "c2_R : assertion",
                    "c19_h : heap"
                ],
                "tactic_res": [
                    "c20_goal : sepconj (contains lck 1) R h",
                    "c21_goal : sepconj emp (sem_invariant lck R) h",
                    "c21_H0 : sepconj (contains lck 1) R h"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := ( if _i =? 0 then _i else _i ) ** _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := ( if _i =? 0 then _i else _i ) ** _i ) .",
                "tactic_args": [
                    "c20_goal : sepconj (contains lck 1) R h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)",
                    "c19_P : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h",
                    "c8_v : Z",
                    "_global_emp : assertion",
                    "c2_R : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c22_goal : aimp (sepconj (if Z.eqb v 0 then emp else R) R) R",
                    "c23_goal : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h",
                    "c19_P : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h",
                    "c19_h : heap",
                    "c8_v : Z",
                    "c2_R : assertion",
                    "c2_lck : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i =? 0 ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i =? 0 ) .",
                "tactic_args": [
                    "c22_goal : aimp (sepconj (if Z.eqb v 0 then emp else R) R) R",
                    "c8_v : Z",
                    "c19_P : sepconj (contains lck 1) (sepconj (if Z.eqb v 0 then emp else R) R) h",
                    "c2_H : precise R",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c24_goal : aimp (sepconj emp R) R",
                    "c24_P : sepconj (contains lck 1) (sepconj emp R) h",
                    "c25_goal : aimp (sepconj R R) R",
                    "c25_P : sepconj (contains lck 1) (sepconj R R) h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : aimp (sepconj emp R) R",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c26_goal : aimp R R"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c26_goal : aimp R R"
                ],
                "tactic_res": [
                    "c27_goal : forall (h : heap) (_ : R h), R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : forall (h : heap) (_ : R h), R h",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : aimp (sepconj R R) R",
                    "_global_sepconj_self : forall (P : assertion) (_ : precise P), aimp (sepconj P P) P"
                ],
                "tactic_res": [
                    "c28_goal : precise R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : precise R",
                    "c2_H : precise R",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : sepconj emp (sem_invariant lck R) h",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c29_goal : sem_invariant lck R h"
                ]
            },
            {
                "tactic_sig": "exists 1 .",
                "tactic_sig_no_out_arg": "exists 1 .",
                "tactic_args": [
                    "c29_goal : sem_invariant lck R h"
                ],
                "tactic_res": [
                    "c30_goal : sepconj (contains lck 1) (if Z.eqb 1 0 then emp else R) h"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : sepconj (contains lck 1) (if Z.eqb 1 0 then emp else R) h"
                ],
                "tactic_res": [
                    "c31_goal : sepconj (contains lck 1) R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : sepconj (contains lck 1) R h",
                    "c21_H0 : sepconj (contains lck 1) R h",
                    "c19_h : heap",
                    "c2_R : assertion",
                    "c2_lck : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_critregion",
        "proof": [
            {
                "tactic_sig": "Lemma triple_critregion : forall lck R c P Q , precise R -> emp \u22a2 \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 -> sem_invariant lck R \u22a2 \u2983 P \u2984 CRITREGION lck c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_critregion : forall lck R c P Q , precise R -> emp \u22a2 \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 -> sem_invariant lck R \u22a2 \u2983 P \u2984 CRITREGION lck c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lck : addr) (R : assertion) (c : com) (P : assertion)\n  (Q : forall _ : Z, assertion) (_ : precise R)\n  (_ : triple emp (sepconj P R) c (fun v : Z => sepconj (Q v) R)),\ntriple (sem_invariant lck R) P (CRITREGION lck c) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lck : addr) (R : assertion) (c : com) (P : assertion)\n  (Q : forall _ : Z, assertion) (_ : precise R)\n  (_ : triple emp (sepconj P R) c (fun v : Z => sepconj (Q v) R)),\ntriple (sem_invariant lck R) P (CRITREGION lck c) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (sem_invariant lck R) P (CRITREGION lck c) Q",
                    "c2_lck : addr",
                    "c2_R : assertion",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_H : precise R",
                    "c2_H0 : triple emp (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ** _i ) .",
                "tactic_args": [
                    "c2_goal : triple (sem_invariant lck R) P (CRITREGION lck c) Q",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_R : assertion",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple (sem_invariant lck R) P (ACQUIRE lck) (fun _ : Z => sepconj R P)",
                    "c4_goal : triple (sem_invariant lck R) (sepconj R P)\n  (LET c (fun v : Z => SEQ (RELEASE lck) (PURE v))) Q"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) at 1 .",
                "tactic_args": [
                    "c3_goal : triple (sem_invariant lck R) P (ACQUIRE lck) (fun _ : Z => sepconj R P)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c5_goal : triple (sem_invariant lck R) (sepconj emp P) (ACQUIRE lck)\n  (fun _ : Z => sepconj R P)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (sem_invariant lck R) (sepconj emp P) (ACQUIRE lck)\n  (fun _ : Z => sepconj R P)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c6_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)",
                    "_global_triple_acquire : forall (lck : addr) (R : assertion),\n       triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c4_goal : triple (sem_invariant lck R) (sepconj R P)\n  (LET c (fun v : Z => SEQ (RELEASE lck) (PURE v))) Q",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c7_goal : triple (sem_invariant lck R) (sepconj R P) c ?Q",
                    "c8_goal : forall v : Z,\ntriple (sem_invariant lck R) ((fun v0 : Z => sepconj (Q v0) R) v)\n  (SEQ (RELEASE lck) (PURE v)) Q"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : triple (sem_invariant lck R) (sepconj R P) c ?Q",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c9_goal : triple (sem_invariant lck R) (sepconj P R) c ?Q"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 1 .",
                "tactic_args": [
                    "c9_goal : triple (sem_invariant lck R) (sepconj P R) c ?Q",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c10_goal : triple (sepconj emp (sem_invariant lck R)) (sepconj P R) c ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple (sepconj emp (sem_invariant lck R)) (sepconj P R) c ?Q",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c11_goal : triple emp (sepconj P R) c ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : triple emp (sepconj P R) c ?Q",
                    "c2_H0 : triple emp (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall v : Z,\ntriple (sem_invariant lck R) ((fun v0 : Z => sepconj (Q v0) R) v)\n  (SEQ (RELEASE lck) (PURE v)) Q"
                ],
                "tactic_res": [
                    "c12_goal : triple (sem_invariant lck R) ((fun v : Z => sepconj (Q v) R) v)\n  (SEQ (RELEASE lck) (PURE v)) Q",
                    "c12_v : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : triple (sem_invariant lck R) ((fun v : Z => sepconj (Q v) R) v)\n  (SEQ (RELEASE lck) (PURE v)) Q"
                ],
                "tactic_res": [
                    "c13_goal : triple (sem_invariant lck R) (sepconj (Q v) R)\n  (SEQ (RELEASE lck) (PURE v)) Q"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ** _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ** _i _i ) .",
                "tactic_args": [
                    "c13_goal : triple (sem_invariant lck R) (sepconj (Q v) R)\n  (SEQ (RELEASE lck) (PURE v)) Q",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "c2_Q : forall _ : Z, assertion",
                    "_global_emp : assertion",
                    "c2_Q : forall _ : Z, assertion",
                    "c12_v : Z"
                ],
                "tactic_res": [
                    "c14_goal : triple (sem_invariant lck R) (sepconj (Q v) R) (RELEASE lck)\n  (fun _ : Z => sepconj emp (Q v))",
                    "c15_goal : triple (sem_invariant lck R) (sepconj emp (Q v)) (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : triple (sem_invariant lck R) (sepconj (Q v) R) (RELEASE lck)\n  (fun _ : Z => sepconj emp (Q v))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c16_goal : triple (sem_invariant lck R) (sepconj R (Q v)) (RELEASE lck)\n  (fun _ : Z => sepconj emp (Q v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : triple (sem_invariant lck R) (sepconj R (Q v)) (RELEASE lck)\n  (fun _ : Z => sepconj emp (Q v))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c17_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)",
                    "_global_triple_release : forall (lck : addr) (R : assertion) (_ : precise R),\n       triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c18_goal : precise R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : precise R",
                    "c2_H : precise R",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : triple (sem_invariant lck R) (sepconj emp (Q v)) (PURE v) Q",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c19_goal : triple (sem_invariant lck R) (Q v) (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : triple (sem_invariant lck R) (Q v) (PURE v) Q",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c20_goal : aimp (Q v) (Q v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c20_goal : aimp (Q v) (Q v)"
                ],
                "tactic_res": [
                    "c21_goal : forall (h : heap) (_ : Q v h), Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : forall (h : heap) (_ : Q v h), Q v h",
                    "c12_v : Z",
                    "c2_Q : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ccr",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ccr : forall lck R b c B P Q , precise R -> emp \u22a2 \u2983 P ** R \u2984 b \u2983 fun v => if v =? 0 then P ** R else B \u2984 -> emp \u22a2 \u2983 B \u2984 c \u2983 fun _ => Q ** R \u2984 -> sem_invariant lck R \u22a2 \u2983 P \u2984 CCR lck b c \u2983 fun _ => Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ccr : forall lck R b c B P Q , precise R -> emp \u22a2 \u2983 P ** R \u2984 b \u2983 fun v => if v =? 0 then P ** R else B \u2984 -> emp \u22a2 \u2983 B \u2984 c \u2983 fun _ => Q ** R \u2984 -> sem_invariant lck R \u22a2 \u2983 P \u2984 CCR lck b c \u2983 fun _ => Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lck : addr) (R : assertion) (b c : com) (B P Q : assertion)\n  (_ : precise R)\n  (_ : triple emp (sepconj P R) b\n         (fun v : Z => if Z.eqb v 0 then sepconj P R else B))\n  (_ : triple emp B c (fun _ : Z => sepconj Q R)),\ntriple (sem_invariant lck R) P (CCR lck b c) (fun _ : Z => Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lck : addr) (R : assertion) (b c : com) (B P Q : assertion)\n  (_ : precise R)\n  (_ : triple emp (sepconj P R) b\n         (fun v : Z => if Z.eqb v 0 then sepconj P R else B))\n  (_ : triple emp B c (fun _ : Z => sepconj Q R)),\ntriple (sem_invariant lck R) P (CCR lck b c) (fun _ : Z => Q)"
                ],
                "tactic_res": [
                    "c2_goal : triple (sem_invariant lck R) P (CCR lck b c) (fun _ : Z => Q)",
                    "c2_lck : addr",
                    "c2_R : assertion",
                    "c2_b : com",
                    "c2_c : com",
                    "c2_B : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : precise R",
                    "c2_H0 : triple emp (sepconj P R) b\n  (fun v : Z => if Z.eqb v 0 then sepconj P R else B)",
                    "c2_H1 : triple emp B c (fun _ : Z => sepconj Q R)"
                ]
            },
            {
                "tactic_sig": "set ( Qloop := fun v => if v =? 0 then _i else _i ) .",
                "tactic_sig_no_out_arg": "set ( Qloop := fun v => if v =? 0 then _i else _i ) .",
                "tactic_args": [
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c2_Qloop : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( fun v => ( v <> 0 ) //\\\\ _i v ) .",
                "tactic_sig_no_out_arg": "apply _i with ( fun v => ( v <> 0 ) //\\\\ _i v ) .",
                "tactic_args": [
                    "c2_goal : triple (sem_invariant lck R) P (CCR lck b c) (fun _ : Z => Q)",
                    "_global_triple_consequence_post : forall (Q' : postcond) (J : invariant) (P : precond) \n         (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple (sem_invariant lck R) P (CCR lck b c)\n  (fun v : Z => pureconj (not (eq v 0)) (Qloop v))",
                    "c4_goal : forall v : Z, aimp (pureconj (not (eq v 0)) (Qloop v)) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (sem_invariant lck R) P (CCR lck b c)\n  (fun v : Z => pureconj (not (eq v 0)) (Qloop v))",
                    "_global_triple_repeat : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (_ : triple J P c Q) (_ : aimp (Q 0) P),\n       triple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ],
                "tactic_res": [
                    "c5_goal : triple (sem_invariant lck R) P\n  (SEQ (ACQUIRE lck)\n     (LET b\n        (fun v : Z =>\n         IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n           (SEQ (RELEASE lck) (PURE 0))))) Qloop",
                    "c6_goal : aimp (Qloop 0) P"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ** _i ) .",
                "tactic_args": [
                    "c5_goal : triple (sem_invariant lck R) P\n  (SEQ (ACQUIRE lck)\n     (LET b\n        (fun v : Z =>\n         IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n           (SEQ (RELEASE lck) (PURE 0))))) Qloop",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c7_goal : triple (sem_invariant lck R) P (ACQUIRE lck) (fun _ : Z => sepconj R P)",
                    "c8_goal : triple (sem_invariant lck R) (sepconj R P)\n  (LET b\n     (fun v : Z =>\n      IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n        (SEQ (RELEASE lck) (PURE 0)))) Qloop"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) at 1 .",
                "tactic_args": [
                    "c7_goal : triple (sem_invariant lck R) P (ACQUIRE lck) (fun _ : Z => sepconj R P)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c9_goal : triple (sem_invariant lck R) (sepconj emp P) (ACQUIRE lck)\n  (fun _ : Z => sepconj R P)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple (sem_invariant lck R) (sepconj emp P) (ACQUIRE lck)\n  (fun _ : Z => sepconj R P)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c10_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)",
                    "_global_triple_acquire : forall (lck : addr) (R : assertion),\n       triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite _i at 1 .",
                "tactic_args": [
                    "c8_goal : triple (sem_invariant lck R) (sepconj R P)\n  (LET b\n     (fun v : Z =>\n      IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n        (SEQ (RELEASE lck) (PURE 0)))) Qloop",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c11_goal : triple (sem_invariant lck R) (sepconj P R)\n  (LET b\n     (fun v : Z =>\n      IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n        (SEQ (RELEASE lck) (PURE 0)))) Qloop"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c11_goal : triple (sem_invariant lck R) (sepconj P R)\n  (LET b\n     (fun v : Z =>\n      IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n        (SEQ (RELEASE lck) (PURE 0)))) Qloop",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c12_goal : triple (sem_invariant lck R) (sepconj P R) b ?Q",
                    "c13_goal : forall v : Z,\ntriple (sem_invariant lck R) (?Q v)\n  (IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n     (SEQ (RELEASE lck) (PURE 0))) Qloop"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 1 .",
                "tactic_args": [
                    "c12_goal : triple (sem_invariant lck R) (sepconj P R) b ?Q",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c14_goal : triple (sepconj emp (sem_invariant lck R)) (sepconj P R) b ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple (sepconj emp (sem_invariant lck R)) (sepconj P R) b ?Q",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c15_goal : triple emp (sepconj P R) b ?Q"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c15_goal : triple emp (sepconj P R) b ?Q",
                    "c2_H0 : triple emp (sepconj P R) b\n  (fun v : Z => if Z.eqb v 0 then sepconj P R else B)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v .",
                "tactic_args": [
                    "c13_goal : forall v : Z,\ntriple (sem_invariant lck R)\n  ((fun v0 : Z => if Z.eqb v0 0 then sepconj P R else B) v)\n  (IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n     (SEQ (RELEASE lck) (PURE 0))) Qloop"
                ],
                "tactic_res": [
                    "c16_goal : triple (sem_invariant lck R)\n  ((fun v : Z => if Z.eqb v 0 then sepconj P R else B) v)\n  (IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n     (SEQ (RELEASE lck) (PURE 0))) Qloop",
                    "c16_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : triple (sem_invariant lck R)\n  ((fun v : Z => if Z.eqb v 0 then sepconj P R else B) v)\n  (IFTHENELSE v (SEQ c (SEQ (RELEASE lck) (PURE 1)))\n     (SEQ (RELEASE lck) (PURE 0))) Qloop",
                    "_global_triple_ifthenelse : forall (J : invariant) (b : Z) (c1 c2 : com) \n         (P : assertion) (Q : postcond)\n         (_ : triple J (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple J (pureconj (eq b 0) P) c2 Q),\n       triple J P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c17_goal : triple (sem_invariant lck R)\n  (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B))\n  (SEQ c (SEQ (RELEASE lck) (PURE 1))) Qloop",
                    "c18_goal : triple (sem_invariant lck R)\n  (pureconj (eq v 0) (if Z.eqb v 0 then sepconj P R else B))\n  (SEQ (RELEASE lck) (PURE 0)) Qloop"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c17_goal : triple (sem_invariant lck R)\n  (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B))\n  (SEQ c (SEQ (RELEASE lck) (PURE 1))) Qloop",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c19_goal : triple (sem_invariant lck R)\n  (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B)) c\n  (fun _ : Z => ?Q)",
                    "c20_goal : triple (sem_invariant lck R) (sepconj Q R) (SEQ (RELEASE lck) (PURE 1))\n  Qloop"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c19_goal : triple (sem_invariant lck R)\n  (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B)) c\n  (fun _ : Z => ?Q)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c21_goal : triple (sem_invariant lck R) ?P' c (fun _ : Z => ?Q)",
                    "c22_goal : aimp (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B))\n  ?P'"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 1 .",
                "tactic_args": [
                    "c21_goal : triple (sem_invariant lck R) ?P' c (fun _ : Z => ?Q)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c23_goal : triple (sepconj emp (sem_invariant lck R)) ?P' c (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : triple (sepconj emp (sem_invariant lck R)) ?P' c (fun _ : Z => ?Q)",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c24_goal : triple emp ?P' c (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c24_goal : triple emp ?P' c (fun _ : Z => ?Q)",
                    "c2_H1 : triple emp B c (fun _ : Z => sepconj Q R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( X & Y ) .",
                "tactic_args": [
                    "c22_goal : aimp (pureconj (not (eq v 0)) (if Z.eqb v 0 then sepconj P R else B)) B"
                ],
                "tactic_res": [
                    "c25_goal : B h",
                    "c25_h : heap",
                    "c25_X : not (eq v 0)",
                    "c25_Y : (if Z.eqb v 0 then sepconj P R else B) h"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c25_X : not (eq v 0)"
                ],
                "tactic_res": [
                    "c25_X : eq (Z.eqb v 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c25_X : eq (Z.eqb v 0) false",
                    "c25_Y : (if Z.eqb v 0 then sepconj P R else B) h"
                ],
                "tactic_res": [
                    "c25_Y : B h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : B h",
                    "c25_Y : B h",
                    "c25_h : heap",
                    "c2_B : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ** _i ) .",
                "tactic_args": [
                    "c20_goal : triple (sem_invariant lck R) (sepconj Q R) (SEQ (RELEASE lck) (PURE 1))\n  Qloop",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "c2_Q : assertion",
                    "_global_emp : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c26_goal : triple (sem_invariant lck R) (sepconj Q R) (RELEASE lck)\n  (fun _ : Z => sepconj emp Q)",
                    "c27_goal : triple (sem_invariant lck R) (sepconj emp Q) (PURE 1) Qloop"
                ]
            },
            {
                "tactic_sig": "rewrite _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite _i at 1 .",
                "tactic_args": [
                    "c26_goal : triple (sem_invariant lck R) (sepconj Q R) (RELEASE lck)\n  (fun _ : Z => sepconj emp Q)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c28_goal : triple (sem_invariant lck R) (sepconj R Q) (RELEASE lck)\n  (fun _ : Z => sepconj emp Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : triple (sem_invariant lck R) (sepconj R Q) (RELEASE lck)\n  (fun _ : Z => sepconj emp Q)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c29_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)",
                    "_global_triple_release : forall (lck : addr) (R : assertion) (_ : precise R),\n       triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c30_goal : precise R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : precise R",
                    "c2_H : precise R",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : triple (sem_invariant lck R) (sepconj emp Q) (PURE 1) Qloop",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c31_goal : aimp (sepconj emp Q) (Qloop 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : aimp (sepconj emp Q) (Qloop 1)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c32_goal : aimp Q (Qloop 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c32_goal : aimp Q (Qloop 1)",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c33_goal : aimp Q (if Z.eqb 1 0 then P else Q)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c33_goal : aimp Q (if Z.eqb 1 0 then P else Q)"
                ],
                "tactic_res": [
                    "c34_goal : aimp Q Q"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c34_goal : aimp Q Q"
                ],
                "tactic_res": [
                    "c35_goal : forall (h : heap) (_ : Q h), Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : forall (h : heap) (_ : Q h), Q h",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ** _i ) .",
                "tactic_args": [
                    "c18_goal : triple (sem_invariant lck R)\n  (pureconj (eq v 0) (if Z.eqb v 0 then sepconj P R else B))\n  (SEQ (RELEASE lck) (PURE 0)) Qloop",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q",
                    "c2_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c36_goal : triple (sem_invariant lck R) (sepconj P R) (SEQ (RELEASE lck) (PURE 0))\n  Qloop",
                    "c37_goal : aimp (pureconj (eq v 0) (if Z.eqb v 0 then sepconj P R else B))\n  (sepconj P R)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ** _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ** _i ) .",
                "tactic_args": [
                    "c36_goal : triple (sem_invariant lck R) (sepconj P R) (SEQ (RELEASE lck) (PURE 0))\n  Qloop",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "c2_Q : assertion",
                    "_global_emp : assertion",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c38_goal : triple (sem_invariant lck R) (sepconj P R) (RELEASE lck)\n  (fun _ : Z => sepconj emp P)",
                    "c39_goal : triple (sem_invariant lck R) (sepconj emp P) (PURE 0) Qloop"
                ]
            },
            {
                "tactic_sig": "rewrite _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite _i at 1 .",
                "tactic_args": [
                    "c38_goal : triple (sem_invariant lck R) (sepconj P R) (RELEASE lck)\n  (fun _ : Z => sepconj emp P)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c40_goal : triple (sem_invariant lck R) (sepconj R P) (RELEASE lck)\n  (fun _ : Z => sepconj emp P)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : triple (sem_invariant lck R) (sepconj R P) (RELEASE lck)\n  (fun _ : Z => sepconj emp P)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c41_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c41_goal : triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)",
                    "_global_triple_release : forall (lck : addr) (R : assertion) (_ : precise R),\n       triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c42_goal : precise R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : precise R",
                    "c2_H : precise R",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : triple (sem_invariant lck R) (sepconj emp P) (PURE 0) Qloop",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c43_goal : aimp (sepconj emp P) (Qloop 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c43_goal : aimp (sepconj emp P) (Qloop 0)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c44_goal : aimp P (Qloop 0)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c44_goal : aimp P (Qloop 0)",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c45_goal : aimp P (if Z.eqb 0 0 then P else Q)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c45_goal : aimp P (if Z.eqb 0 0 then P else Q)"
                ],
                "tactic_res": [
                    "c46_goal : aimp P P"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c46_goal : aimp P P"
                ],
                "tactic_res": [
                    "c47_goal : forall (h : heap) (_ : P h), P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : forall (h : heap) (_ : P h), P h",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( X & Y ) .",
                "tactic_args": [
                    "c37_goal : aimp (pureconj (eq v 0) (if Z.eqb v 0 then sepconj P R else B))\n  (sepconj P R)"
                ],
                "tactic_res": [
                    "c48_goal : sepconj P R h",
                    "c48_h : heap",
                    "c48_X : eq v 0",
                    "c48_Y : (if Z.eqb v 0 then sepconj P R else B) h"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c16_v : Z",
                    "c48_X : eq v 0"
                ],
                "tactic_res": [
                    "c48_Y : (if Z.eqb 0 0 then sepconj P R else B) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : sepconj P R h",
                    "c48_Y : (if Z.eqb 0 0 then sepconj P R else B) h",
                    "c48_h : heap",
                    "c2_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : aimp (Qloop 0) P",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c49_goal : aimp (if Z.eqb 0 0 then P else Q) P"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros v U .",
                "tactic_args": [
                    "c49_goal : aimp (if Z.eqb 0 0 then P else Q) P"
                ],
                "tactic_res": [
                    "c50_goal : P v",
                    "c50_v : heap",
                    "c50_U : (if Z.eqb 0 0 then P else Q) v"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c50_U : (if Z.eqb 0 0 then P else Q) v"
                ],
                "tactic_res": [
                    "c50_U : P v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c50_goal : P v",
                    "c50_U : P v",
                    "c50_v : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros v h ( U & V ) .",
                "tactic_args": [
                    "c4_goal : forall v : Z, aimp (pureconj (not (eq v 0)) (Qloop v)) Q"
                ],
                "tactic_res": [
                    "c51_goal : Q h",
                    "c51_v : Z",
                    "c51_h : heap",
                    "c51_U : not (eq v 0)",
                    "c51_V : Qloop v h"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c51_V : Qloop v h"
                ],
                "tactic_res": [
                    "c51_V : (if Z.eqb v 0 then P else Q) h"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c51_U : not (eq v 0)"
                ],
                "tactic_res": [
                    "c51_U : eq (Z.eqb v 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c51_U : eq (Z.eqb v 0) false",
                    "c51_V : (if Z.eqb v 0 then P else Q) h"
                ],
                "tactic_res": [
                    "c51_V : Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : Q h",
                    "c51_V : Q h",
                    "c51_h : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "precise_buffer_invariant",
        "proof": [
            {
                "tactic_sig": "Remark precise_buffer_invariant : forall ( R : Z -> assertion ) buff , ( forall v , precise ( R v ) ) -> precise ( aexists ( fun v => contains buff v ** R v ) ) .",
                "tactic_sig_no_out_arg": "Remark precise_buffer_invariant : forall ( R : Z -> assertion ) buff , ( forall v , precise ( R v ) ) -> precise ( aexists ( fun v => contains buff v ** R v ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr)\n  (_ : forall v : Z, precise (R v)),\nprecise (aexists (fun v : Z => sepconj (contains buff v) (R v)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr)\n  (_ : forall v : Z, precise (R v)),\nprecise (aexists (fun v : Z => sepconj (contains buff v) (R v)))"
                ],
                "tactic_res": [
                    "c2_goal : precise (aexists (fun v : Z => sepconj (contains buff v) (R v)))",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr",
                    "c2_H : forall v : Z, precise (R v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : precise (aexists (fun v : Z => sepconj (contains buff v) (R v)))",
                    "_global_aexists_precise : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P),\n       precise (aexists P)"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (fun v : Z => sepconj (contains buff v) (R v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : param_precise (fun v : Z => sepconj (contains buff v) (R v))",
                    "_global_sepconj_param_precise : forall (X : Type) (P Q : forall _ : X, assertion)\n         (_ : param_precise P) (_ : forall x : X, precise (Q x)),\n       param_precise (fun x : X => sepconj (P x) (Q x))"
                ],
                "tactic_res": [
                    "c4_goal : param_precise (contains buff)",
                    "c5_goal : forall x : Z, precise (R x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall x : Z, precise (R x)",
                    "c2_H : forall v : Z, precise (R v)",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : param_precise (contains buff)",
                    "_global_contains_param_precise : forall l : addr, param_precise (fun v : Z => contains l v)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consume",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consume : forall R buff free busy , buffer_invariant R buff free busy \u22a2 \u2983 emp \u2984 CONSUME buff free busy \u2983 fun v => R v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consume : forall R buff free busy , buffer_invariant R buff free busy \u22a2 \u2983 emp \u2984 CONSUME buff free busy \u2983 fun v => R v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff free busy : addr),\ntriple (buffer_invariant R buff free busy) emp (CONSUME buff free busy)\n  (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff free busy : addr),\ntriple (buffer_invariant R buff free busy) emp (CONSUME buff free busy)\n  (fun v : Z => R v)"
                ],
                "tactic_res": [
                    "c2_goal : triple (buffer_invariant R buff free busy) emp (CONSUME buff free busy)\n  (fun v : Z => R v)",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr",
                    "c2_free : addr",
                    "c2_busy : addr"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : triple (buffer_invariant R buff free busy) emp (CONSUME buff free busy)\n  (fun v : Z => R v)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c3_goal : triple (buffer_invariant R buff free busy) emp (ACQUIRE busy)\n  (fun _ : Z => ?Q)",
                    "c4_goal : triple (buffer_invariant R buff free busy) ?Q\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : triple (buffer_invariant R buff free busy) emp (ACQUIRE busy)\n  (fun _ : Z => ?Q)",
                    "_global_buffer_invariant : forall (_ : forall _ : Z, assertion) (_ : addr) (_ : addr) (_ : addr),\n       assertion"
                ],
                "tactic_res": [
                    "c5_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))) emp\n  (ACQUIRE busy) (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))) emp\n  (ACQUIRE busy) (fun _ : Z => ?Q)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c6_goal : triple\n  (sepconj\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n     (sem_invariant free (valid buff))) emp (ACQUIRE busy)\n  (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple\n  (sepconj\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n     (sem_invariant free (valid buff))) emp (ACQUIRE busy)\n  (fun _ : Z => ?Q)",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c7_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v)))) emp\n  (ACQUIRE busy) (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v)))) emp\n  (ACQUIRE busy) (fun _ : Z => ?Q)",
                    "_global_triple_acquire : forall (lck : addr) (R : assertion),\n       triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple (buffer_invariant R buff free busy)\n  (aexists (fun v : Z => sepconj (contains buff v) (R v)))\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v : Z => R v)",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion  buff : addr  free : addr  busy : addr\n     |- Type]"
                ],
                "tactic_res": [
                    "c8_goal : forall v : Z,\ntriple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v))\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v0 : Z => R v0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v .",
                "tactic_args": [
                    "c8_goal : forall v : Z,\ntriple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v))\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v0 : Z => R v0)"
                ],
                "tactic_res": [
                    "c9_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v))\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v : Z => R v)",
                    "c9_v : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c9_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v))\n  (LET (GET buff) (fun data : Z => SEQ (RELEASE free) (PURE data)))\n  (fun v : Z => R v)",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c10_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (GET buff) ?Q",
                    "c11_goal : forall v0 : Z,\ntriple (buffer_invariant R buff free busy) (?Q v0)\n  (SEQ (RELEASE free) (PURE v0)) (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (GET buff) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c12_goal : triple (buffer_invariant R buff free busy) (contains buff v) \n  (GET buff) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : triple (buffer_invariant R buff free busy) (contains buff v) \n  (GET buff) ?Q",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros v' .",
                "tactic_args": [
                    "c11_goal : forall v0 : Z,\ntriple (buffer_invariant R buff free busy)\n  ((fun v1 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' v) (contains buff v)) v1)\n      (R v)) v0) (SEQ (RELEASE free) (PURE v0)) (fun v : Z => R v)"
                ],
                "tactic_res": [
                    "c13_goal : triple (buffer_invariant R buff free busy)\n  ((fun v0 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' v) (contains buff v)) v0)\n      (R v)) v') (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)",
                    "c13_v' : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c13_goal : triple (buffer_invariant R buff free busy)\n  ((fun v0 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' v) (contains buff v)) v0)\n      (R v)) v') (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)"
                ],
                "tactic_res": [
                    "c14_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (pureconj (eq v' v) (contains buff v)) (R v))\n  (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (pureconj (eq v' v) (contains buff v)) (R v))\n  (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c15_goal : triple (buffer_invariant R buff free busy)\n  (pureconj (eq v' v) (sepconj (contains buff v) (R v)))\n  (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : triple (buffer_invariant R buff free busy)\n  (pureconj (eq v' v) (sepconj (contains buff v) (R v)))\n  (SEQ (RELEASE free) (PURE v')) (fun v : Z => R v)",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : eq v' v,\ntriple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v'))\n  (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "c16_goal : forall _ : eq v' v,\ntriple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v'))\n  (fun v : Z => R v)"
                ],
                "tactic_res": [
                    "c17_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v'))\n  (fun v : Z => R v)",
                    "c17_EQ : eq v' v"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c17_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v'))\n  (fun v : Z => R v)",
                    "c13_v' : Z",
                    "c17_EQ : eq v' v"
                ],
                "tactic_res": [
                    "c18_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v))\n  (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ** _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ** _i _i ) .",
                "tactic_args": [
                    "c18_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (SEQ (RELEASE free) (PURE v))\n  (fun v : Z => R v)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "_global_emp : assertion",
                    "c2_R : forall _ : Z, assertion",
                    "c9_v : Z"
                ],
                "tactic_res": [
                    "c19_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))",
                    "c20_goal : triple (buffer_invariant R buff free busy) (sepconj emp (R v)) \n  (PURE v) (fun v : Z => R v)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))",
                    "_global_buffer_invariant : forall (_ : forall _ : Z, assertion) (_ : addr) (_ : addr) (_ : addr),\n       assertion"
                ],
                "tactic_res": [
                    "c21_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c22_goal : triple (sem_invariant free (valid buff))\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : triple (sem_invariant free (valid buff))\n  (sepconj (contains buff v) (R v)) (RELEASE free)\n  (fun _ : Z => sepconj emp (R v))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c23_goal : triple (sem_invariant free (valid buff)) (contains buff v)\n  (RELEASE free) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c23_goal : triple (sem_invariant free (valid buff)) (contains buff v)\n  (RELEASE free) (fun _ : Z => emp)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c24_goal : triple (sem_invariant free (valid buff)) ?P' (RELEASE free)\n  (fun _ : Z => emp)",
                    "c25_goal : aimp (contains buff v) (valid buff)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : triple (sem_invariant free (valid buff)) ?P' (RELEASE free)\n  (fun _ : Z => emp)",
                    "_global_triple_release : forall (lck : addr) (R : assertion) (_ : precise R),\n       triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c26_goal : precise (valid buff)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : precise (valid buff)",
                    "_global_valid_precise : forall l : addr, precise (valid l)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c25_goal : aimp (contains buff v) (valid buff)"
                ],
                "tactic_res": [
                    "c27_goal : forall (h : heap) (_ : contains buff v h), valid buff h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c27_goal : forall (h : heap) (_ : contains buff v h), valid buff h"
                ],
                "tactic_res": [
                    "c28_goal : valid buff h",
                    "c28_h : heap",
                    "c28_H : contains buff v h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c28_goal : valid buff h",
                    "c9_v : Z"
                ],
                "tactic_res": [
                    "c29_goal : contains buff v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : contains buff v h",
                    "c28_H : contains buff v h",
                    "c28_h : heap",
                    "c9_v : Z",
                    "c2_buff : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : triple (buffer_invariant R buff free busy) (sepconj emp (R v)) \n  (PURE v) (fun v : Z => R v)",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c30_goal : aimp (sepconj emp (R v)) (R v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c30_goal : aimp (sepconj emp (R v)) (R v)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c31_goal : aimp (R v) (R v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c31_goal : aimp (R v) (R v)"
                ],
                "tactic_res": [
                    "c32_goal : forall (h : heap) (_ : R v h), R v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : forall (h : heap) (_ : R v h), R v h",
                    "c9_v : Z",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_produce",
        "proof": [
            {
                "tactic_sig": "Lemma triple_produce : forall ( R : Z -> assertion ) buff free busy data , ( forall v , precise ( R v ) ) -> buffer_invariant R buff free busy \u22a2 \u2983 R data \u2984 PRODUCE buff free busy data \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_produce : forall ( R : Z -> assertion ) buff free busy data , ( forall v , precise ( R v ) ) -> buffer_invariant R buff free busy \u22a2 \u2983 R data \u2984 PRODUCE buff free busy data \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff free busy : addr) \n  (data : Z) (_ : forall v : Z, precise (R v)),\ntriple (buffer_invariant R buff free busy) (R data)\n  (PRODUCE buff free busy data) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff free busy : addr) \n  (data : Z) (_ : forall v : Z, precise (R v)),\ntriple (buffer_invariant R buff free busy) (R data)\n  (PRODUCE buff free busy data) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : triple (buffer_invariant R buff free busy) (R data)\n  (PRODUCE buff free busy data) (fun _ : Z => emp)",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr",
                    "c2_free : addr",
                    "c2_busy : addr",
                    "c2_data : Z",
                    "c2_H : forall v : Z, precise (R v)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ** _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ** _i _i ) .",
                "tactic_args": [
                    "c2_goal : triple (buffer_invariant R buff free busy) (R data)\n  (PRODUCE buff free busy data) (fun _ : Z => emp)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "_global_valid : forall _ : addr, assertion",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c3_goal : triple (buffer_invariant R buff free busy) (R data) \n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))",
                    "c4_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (valid buff) (R data)) (SEQ (SET buff data) (RELEASE busy))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : triple (buffer_invariant R buff free busy) (R data) \n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))",
                    "_global_buffer_invariant : forall (_ : forall _ : Z, assertion) (_ : addr) (_ : addr) (_ : addr),\n       assertion"
                ],
                "tactic_res": [
                    "c5_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (R data) (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (R data) (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c6_goal : triple (sem_invariant free (valid buff)) (R data) \n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i ) ) at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i ) ) at 1 .",
                "tactic_args": [
                    "c6_goal : triple (sem_invariant free (valid buff)) (R data) \n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P",
                    "c2_R : forall _ : Z, assertion",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c7_goal : triple (sem_invariant free (valid buff)) (sepconj emp (R data))\n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : triple (sem_invariant free (valid buff)) (sepconj emp (R data))\n  (ACQUIRE free) (fun _ : Z => sepconj (valid buff) (R data))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c8_goal : triple (sem_invariant free (valid buff)) emp (ACQUIRE free)\n  (fun _ : Z => valid buff)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple (sem_invariant free (valid buff)) emp (ACQUIRE free)\n  (fun _ : Z => valid buff)",
                    "_global_triple_acquire : forall (lck : addr) (R : assertion),\n       triple (sem_invariant lck R) emp (ACQUIRE lck) (fun _ : Z => R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ** _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ** _i _i ) .",
                "tactic_args": [
                    "c4_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (valid buff) (R data)) (SEQ (SET buff data) (RELEASE busy))\n  (fun _ : Z => emp)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_buff : addr",
                    "c2_data : Z",
                    "c2_R : forall _ : Z, assertion",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c9_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (valid buff) (R data)) (SET buff data)\n  (fun _ : Z => sepconj (contains buff data) (R data))",
                    "c10_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (valid buff) (R data)) (SET buff data)\n  (fun _ : Z => sepconj (contains buff data) (R data))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c11_goal : triple (buffer_invariant R buff free busy) (valid buff) \n  (SET buff data) (fun _ : Z => contains buff data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : triple (buffer_invariant R buff free busy) (valid buff) \n  (SET buff data) (fun _ : Z => contains buff data)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c10_goal : triple (buffer_invariant R buff free busy)\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)",
                    "_global_buffer_invariant : forall (_ : forall _ : Z, assertion) (_ : addr) (_ : addr) (_ : addr),\n       assertion"
                ],
                "tactic_res": [
                    "c12_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : triple\n  (sepconj (sem_invariant free (valid buff))\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v)))))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c13_goal : triple\n  (sepconj\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n     (sem_invariant free (valid buff)))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : triple\n  (sepconj\n     (sem_invariant busy\n        (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n     (sem_invariant free (valid buff)))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)",
                    "_global_triple_frame_invariant : forall (J : invariant) (J' : assertion) (P : precond) \n         (c : com) (Q : postcond) (_ : triple J P c Q),\n       triple (sepconj J J') P c Q"
                ],
                "tactic_res": [
                    "c14_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c14_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v))))\n  (sepconj (contains buff data) (R data)) (RELEASE busy)\n  (fun _ : Z => emp)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c15_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v)))) \n  ?P' (RELEASE busy) (fun _ : Z => emp)",
                    "c16_goal : aimp (sepconj (contains buff data) (R data)) ?P'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : triple\n  (sem_invariant busy\n     (aexists (fun v : Z => sepconj (contains buff v) (R v)))) \n  ?P' (RELEASE busy) (fun _ : Z => emp)",
                    "_global_triple_release : forall (lck : addr) (R : assertion) (_ : precise R),\n       triple (sem_invariant lck R) R (RELEASE lck) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c17_goal : precise (aexists (fun v : Z => sepconj (contains buff v) (R v)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : precise (aexists (fun v : Z => sepconj (contains buff v) (R v)))",
                    "_global_precise_buffer_invariant : forall (R : forall _ : Z, assertion) (buff : addr)\n         (_ : forall v : Z, precise (R v)),\n       precise (aexists (fun v : Z => sepconj (contains buff v) (R v)))"
                ],
                "tactic_res": [
                    "c18_goal : forall v : Z, precise (R v)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c18_goal : forall v : Z, precise (R v)",
                    "c2_H : forall v : Z, precise (R v)",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c16_goal : aimp (sepconj (contains buff data) (R data))\n  (aexists (fun v : Z => sepconj (contains buff v) (R v)))"
                ],
                "tactic_res": [
                    "c19_goal : forall (h : heap) (_ : sepconj (contains buff data) (R data) h),\naexists (fun v : Z => sepconj (contains buff v) (R v)) h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c19_goal : forall (h : heap) (_ : sepconj (contains buff data) (R data) h),\naexists (fun v : Z => sepconj (contains buff v) (R v)) h"
                ],
                "tactic_res": [
                    "c20_goal : aexists (fun v : Z => sepconj (contains buff v) (R v)) h",
                    "c20_h : heap",
                    "c20_H0 : sepconj (contains buff data) (R data) h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c20_goal : aexists (fun v : Z => sepconj (contains buff v) (R v)) h",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c21_goal : sepconj (contains buff data) (R data) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : sepconj (contains buff data) (R data) h",
                    "c20_H0 : sepconj (contains buff data) (R data) h",
                    "c20_h : heap",
                    "c2_data : Z",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_produce",
        "proof": [
            {
                "tactic_sig": "Lemma triple_produce : forall R buff data , buffer_invariant R buff \u22a2 \u2983 R data \u2984 PRODUCE buff data \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_produce : forall R buff data , buffer_invariant R buff \u22a2 \u2983 R data \u2984 PRODUCE buff data \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr) (data : Z),\ntriple (buffer_invariant R buff) (R data) (PRODUCE buff data)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr) (data : Z),\ntriple (buffer_invariant R buff) (R data) (PRODUCE buff data)\n  (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : triple (buffer_invariant R buff) (R data) (PRODUCE buff data)\n  (fun _ : Z => emp)",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr",
                    "c2_data : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : triple (buffer_invariant R buff) (R data) (PRODUCE buff data)\n  (fun _ : Z => emp)",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : triple (buffer_invariant R buff) (R data) (ALLOC 2) ?Q",
                    "c4_goal : forall v : Z,\ntriple (buffer_invariant R buff) (?Q v)\n  (SEQ (SET v data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add v 1) prev) (SET buff v)))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c3_goal : triple (buffer_invariant R buff) (R data) (ALLOC 2) ?Q",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P",
                    "c2_R : forall _ : Z, assertion",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c5_goal : triple (buffer_invariant R buff) (sepconj emp (R data)) (ALLOC 2) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (buffer_invariant R buff) (sepconj emp (R data)) (ALLOC 2) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c6_goal : triple (buffer_invariant R buff) emp (ALLOC 2) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple (buffer_invariant R buff) emp (ALLOC 2) ?Q",
                    "_global_triple_alloc : forall (J : invariant) (sz : nat),\n       triple J emp (ALLOC sz)\n         (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\ntriple (buffer_invariant R buff)\n  ((fun v0 : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v0)\n      (R data)) v)\n  (SEQ (SET v data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add v 1) prev) (SET buff v)))))\n  (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c7_goal : triple (buffer_invariant R buff)\n  ((fun v : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v)\n      (R data)) a)\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "c7_a : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : triple (buffer_invariant R buff)\n  ((fun v : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v)\n      (R data)) a)\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c8_goal : triple (buffer_invariant R buff)\n  (sepconj\n     (pureconj (not (eq a 0))\n        (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))) \n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : triple (buffer_invariant R buff)\n  (sepconj\n     (pureconj (not (eq a 0))\n        (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))) \n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c9_goal : triple (buffer_invariant R buff)\n  (pureconj (not (eq a 0))\n     (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n        (R data)))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple (buffer_invariant R buff)\n  (pureconj (not (eq a 0))\n     (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n        (R data)))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : not (eq a 0),\ntriple (buffer_invariant R buff)\n  (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros NOT0 .",
                "tactic_args": [
                    "c10_goal : forall _ : not (eq a 0),\ntriple (buffer_invariant R buff)\n  (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c11_goal : triple (buffer_invariant R buff)\n  (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "c11_NOT0 : not (eq a 0)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i , _i .",
                "tactic_args": [
                    "c11_goal : triple (buffer_invariant R buff)\n  (sepconj (sepconj (valid a) (sepconj (valid (Z.add a 1)) emp))\n     (R data))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c12_goal : triple (buffer_invariant R buff)\n  (sepconj (valid a) (sepconj (valid (Z.add a 1)) (R data)))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ** _i ( _i + 1 ) ** _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ** _i ( _i + 1 ) ** _i _i ) .",
                "tactic_args": [
                    "c12_goal : triple (buffer_invariant R buff)\n  (sepconj (valid a) (sepconj (valid (Z.add a 1)) (R data)))\n  (SEQ (SET a data)\n     (ATOMIC\n        (LET (GET buff)\n           (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))))\n  (fun _ : Z => emp)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c7_a : Z",
                    "c2_data : Z",
                    "_global_valid : forall _ : addr, assertion",
                    "c7_a : Z",
                    "c2_R : forall _ : Z, assertion",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c13_goal : triple (buffer_invariant R buff)\n  (sepconj (valid a) (sepconj (valid (Z.add a 1)) (R data)))\n  (SET a data)\n  (fun _ : Z =>\n   sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))",
                    "c14_goal : triple (buffer_invariant R buff)\n  (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))\n  (ATOMIC\n     (LET (GET buff)\n        (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a))))\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : triple (buffer_invariant R buff)\n  (sepconj (valid a) (sepconj (valid (Z.add a 1)) (R data)))\n  (SET a data)\n  (fun _ : Z =>\n   sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c15_goal : triple (buffer_invariant R buff) (valid a) (SET a data)\n  (fun _ : Z => contains a data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : triple (buffer_invariant R buff) (valid a) (SET a data)\n  (fun _ : Z => contains a data)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple (buffer_invariant R buff)\n  (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))\n  (ATOMIC\n     (LET (GET buff)\n        (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a))))\n  (fun _ : Z => emp)",
                    "_global_triple_atomic : forall (J P : assertion) (c : com) (Q : postcond)\n         (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\n       triple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c16_goal : triple emp\n  (sepconj\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))\n     (buffer_invariant R buff))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z => sepconj emp (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : triple emp\n  (sepconj\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data)))\n     (buffer_invariant R buff))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z => sepconj emp (buffer_invariant R buff))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c17_goal : triple emp\n  (sepconj (buffer_invariant R buff)\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z => sepconj emp (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c17_goal : triple emp\n  (sepconj (buffer_invariant R buff)\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z => sepconj emp (buffer_invariant R buff))",
                    "_global_buffer_invariant : forall (_ : forall _ : Z, assertion) (_ : addr), assertion"
                ],
                "tactic_res": [
                    "c18_goal : triple emp\n  (sepconj\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p))))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : triple emp\n  (sepconj\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p))))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c19_goal : triple emp\n  (aexists\n     (fun x : list Z =>\n      sepconj\n        (aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R x p)))\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : triple emp\n  (aexists\n     (fun x : list Z =>\n      sepconj\n        (aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R x p)))\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion\n      buff : addr\n      data : Z\n      a : Z\n      NOT0 : not (eq a 0) |- Type]"
                ],
                "tactic_res": [
                    "c20_goal : forall v : list Z,\ntriple emp\n  (sepconj\n     (aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R v p)))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c20_goal : forall v : list Z,\ntriple emp\n  (sepconj\n     (aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R v p)))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c21_goal : triple emp\n  (sepconj\n     (aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "c21_l : list Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : triple emp\n  (sepconj\n     (aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c22_goal : triple emp\n  (aexists\n     (fun x : Z =>\n      sepconj (sepconj (contains buff x) (list_invariant R l x))\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : triple emp\n  (aexists\n     (fun x : Z =>\n      sepconj (sepconj (contains buff x) (list_invariant R l x))\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion\n      buff : addr\n      data : Z\n      a : Z\n      NOT0 : not (eq a 0)\n      l : list Z |- Type]"
                ],
                "tactic_res": [
                    "c23_goal : forall v : Z,\ntriple emp\n  (sepconj (sepconj (contains buff v) (list_invariant R l v))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c23_goal : forall v : Z,\ntriple emp\n  (sepconj (sepconj (contains buff v) (list_invariant R l v))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c24_goal : triple emp\n  (sepconj (sepconj (contains buff p) (list_invariant R l p))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "c24_p : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : triple emp\n  (sepconj (sepconj (contains buff p) (list_invariant R l p))\n     (sepconj (contains a data) (sepconj (valid (Z.add a 1)) (R data))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c25_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c25_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (LET (GET buff)\n     (fun prev : Z => SEQ (SET (Z.add a 1) prev) (SET buff a)))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c26_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data))))) \n  (GET buff) ?Q",
                    "c27_goal : forall v : Z,\ntriple emp (?Q v) (SEQ (SET (Z.add a 1) v) (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data))))) \n  (GET buff) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c28_goal : triple emp (contains buff p) (GET buff) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : triple emp (contains buff p) (GET buff) ?Q",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p' .",
                "tactic_args": [
                    "c27_goal : forall v : Z,\ntriple emp\n  ((fun v0 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains buff p)) v0)\n      (sepconj (list_invariant R l p)\n         (sepconj (contains a data)\n            (sepconj (valid (Z.add a 1)) (R data))))) v)\n  (SEQ (SET (Z.add a 1) v) (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c29_goal : triple emp\n  ((fun v : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains buff p)) v)\n      (sepconj (list_invariant R l p)\n         (sepconj (contains a data)\n            (sepconj (valid (Z.add a 1)) (R data))))) p')\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "c29_p' : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c29_goal : triple emp\n  ((fun v : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains buff p)) v)\n      (sepconj (list_invariant R l p)\n         (sepconj (contains a data)\n            (sepconj (valid (Z.add a 1)) (R data))))) p')\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c30_goal : triple emp\n  (sepconj (pureconj (eq p' p) (contains buff p))\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c30_goal : triple emp\n  (sepconj (pureconj (eq p' p) (contains buff p))\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c31_goal : triple emp\n  (pureconj (eq p' p)\n     (sepconj (contains buff p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data)\n              (sepconj (valid (Z.add a 1)) (R data))))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : triple emp\n  (pureconj (eq p' p)\n     (sepconj (contains buff p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data)\n              (sepconj (valid (Z.add a 1)) (R data))))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c32_goal : forall _ : eq p' p,\ntriple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "c32_goal : forall _ : eq p' p,\ntriple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c33_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "c33_EQ : eq p' p"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c33_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p') (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "c29_p' : Z",
                    "c33_EQ : eq p' p"
                ],
                "tactic_res": [
                    "c34_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p) (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c34_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SEQ (SET (Z.add a 1) p) (SET buff a))\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c35_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)",
                    "c36_goal : triple emp ?Q (SET buff a)\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i ( _i + 1 ) ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i ( _i + 1 ) ) ) .",
                "tactic_args": [
                    "c35_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (list_invariant R l p)\n        (sepconj (contains a data)\n           (sepconj (valid (Z.add a 1)) (R data)))))\n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)",
                    "_global_sepconj_pick3 : forall R P Q S : assertion,\n       eq (sepconj P (sepconj Q (sepconj R S)))\n         (sepconj R (sepconj P (sepconj Q S)))",
                    "_global_valid : forall _ : addr, assertion",
                    "c7_a : Z"
                ],
                "tactic_res": [
                    "c37_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (valid (Z.add a 1))\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c37_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (valid (Z.add a 1))\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c38_goal : triple emp\n  (sepconj (valid (Z.add a 1))\n     (sepconj (contains buff p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q := fun _i => _i ( _i + 1 ) _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q := fun _i => _i ( _i + 1 ) _i ) .",
                "tactic_args": [
                    "c38_goal : triple emp\n  (sepconj (valid (Z.add a 1))\n     (sepconj (contains buff p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET (Z.add a 1) p) (fun _ : Z => ?Q)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global__ : ?T\nwhere\n?T : [R : forall _ : Z, assertion\n      buff : addr\n      data : Z\n      a : Z\n      NOT0 : not (eq a 0)\n      l : list Z\n      p : Z |- Type]\n?y : [R : forall _ : Z, assertion\n      buff : addr\n      data : Z\n      a : Z\n      NOT0 : not (eq a 0)\n      l : list Z\n      p : Z |- ?T]",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c7_a : Z",
                    "c24_p : Z"
                ],
                "tactic_res": [
                    "c39_goal : triple emp (valid (Z.add a 1)) (SET (Z.add a 1) p)\n  (fun _ : Z => contains (Z.add a 1) p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : triple emp (valid (Z.add a 1)) (SET (Z.add a 1) p)\n  (fun _ : Z => contains (Z.add a 1) p)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : triple emp\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (contains buff p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET buff a)\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c40_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET buff a)\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c40_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET buff a)\n  (fun _ : Z =>\n   sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_triple_consequence_post : forall (Q' : postcond) (J : invariant) (P : precond) \n         (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q"
                ],
                "tactic_res": [
                    "c41_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET buff a) ?Q'",
                    "c42_goal : forall v : Z,\naimp (?Q' v)\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c41_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data))))) \n  (SET buff a) ?Q'",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c43_goal : triple emp (contains buff p) (SET buff a) ?Q"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c43_goal : triple emp (contains buff p) (SET buff a) ?Q",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c44_goal : triple emp ?P' (SET buff a) ?Q",
                    "c45_goal : aimp (contains buff p) (valid buff)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c44_goal : triple emp ?P' (SET buff a) ?Q",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c45_goal : aimp (contains buff p) (valid buff)"
                ],
                "tactic_res": [
                    "c46_goal : valid buff h",
                    "c46_h : heap",
                    "c46_A : contains buff p h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c46_goal : valid buff h",
                    "c24_p : Z"
                ],
                "tactic_res": [
                    "c47_goal : contains buff p h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : contains buff p h",
                    "c46_A : contains buff p h",
                    "c46_h : heap",
                    "c24_p : Z",
                    "c2_buff : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c42_goal : forall v : Z,\naimp\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => contains buff a) v0)\n      (sepconj (contains (Z.add a 1) p)\n         (sepconj (list_invariant R l p)\n            (sepconj (contains a data) (R data))))) v)\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c48_goal : forall _ : Z,\naimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c48_goal : forall _ : Z,\naimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ],
                "tactic_res": [
                    "c49_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (sepconj emp\n     (aexists\n        (fun l : list Z =>\n         aexists\n           (fun p : Z =>\n            sepconj (contains buff p) (list_invariant R l p)))))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c50_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i _i _i ) ) .",
                "tactic_args": [
                    "c50_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (list_invariant R l p)\n           (sepconj (contains a data) (R data)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))",
                    "_global_sepconj_swap3 : forall R P Q : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))",
                    "_global_list_invariant : forall (_ : forall _ : Z, assertion) (_ : list Z) (_ : addr),\n       assertion",
                    "c2_R : forall _ : Z, assertion",
                    "c21_l : list Z",
                    "c24_p : Z"
                ],
                "tactic_res": [
                    "c51_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (contains a data)\n           (sepconj (R data) (list_invariant R l p)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c51_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (contains a data)\n           (sepconj (R data) (list_invariant R l p)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c7_a : Z",
                    "c2_data : Z"
                ],
                "tactic_res": [
                    "c52_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains a data)\n        (sepconj (contains (Z.add a 1) p)\n           (sepconj (R data) (list_invariant R l p)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c52_goal : aimp\n  (sepconj (contains buff a)\n     (sepconj (contains a data)\n        (sepconj (contains (Z.add a 1) p)\n           (sepconj (R data) (list_invariant R l p)))))\n  (aexists\n     (fun l : list Z =>\n      aexists\n        (fun p : Z => sepconj (contains buff p) (list_invariant R l p))))"
                ],
                "tactic_res": [
                    "c53_goal : aexists\n  (fun l : list Z =>\n   aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p))) h",
                    "c53_h : heap",
                    "c53_A : sepconj (contains buff a)\n  (sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (R data) (list_invariant R l p)))) h"
                ]
            },
            {
                "tactic_sig": "exists ( _i :: _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( _i :: _i ) , _i .",
                "tactic_args": [
                    "c53_goal : aexists\n  (fun l : list Z =>\n   aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p))) h",
                    "c2_data : Z",
                    "c21_l : list Z",
                    "c7_a : Z"
                ],
                "tactic_res": [
                    "c54_goal : sepconj (contains buff a) (list_invariant R (cons data l) a) h"
                ]
            },
            {
                "tactic_sig": "revert _i _i .",
                "tactic_sig_no_out_arg": "revert _i _i .",
                "tactic_args": [
                    "c54_goal : sepconj (contains buff a) (list_invariant R (cons data l) a) h",
                    "c53_h : heap",
                    "c53_A : sepconj (contains buff a)\n  (sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (R data) (list_invariant R l p)))) h"
                ],
                "tactic_res": [
                    "c55_goal : forall (h : heap)\n  (_ : sepconj (contains buff a)\n         (sepconj (contains a data)\n            (sepconj (contains (Z.add a 1) p)\n               (sepconj (R data) (list_invariant R l p)))) h),\nsepconj (contains buff a) (list_invariant R (cons data l) a) h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c55_goal : forall (h : heap)\n  (_ : sepconj (contains buff a)\n         (sepconj (contains a data)\n            (sepconj (contains (Z.add a 1) p)\n               (sepconj (R data) (list_invariant R l p)))) h),\nsepconj (contains buff a) (list_invariant R (cons data l) a) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c56_goal : aimp\n  (sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (R data) (list_invariant R l p))))\n  (list_invariant R (cons data l) a)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c56_goal : aimp\n  (sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) p)\n        (sepconj (R data) (list_invariant R l p))))\n  (list_invariant R (cons data l) a)"
                ],
                "tactic_res": [
                    "c57_goal : list_invariant R (cons data l) a h",
                    "c57_h : heap",
                    "c57_A : sepconj (contains a data)\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (R data) (list_invariant R l p))) h"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c57_goal : list_invariant R (cons data l) a h"
                ],
                "tactic_res": [
                    "c58_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun q : Z =>\n      sepconj (contains a data)\n        (sepconj (contains (Z.add a 1) q)\n           (sepconj (R data) (list_invariant R l q))))) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c58_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun q : Z =>\n      sepconj (contains a data)\n        (sepconj (contains (Z.add a 1) q)\n           (sepconj (R data) (list_invariant R l q))))) h"
                ],
                "tactic_res": [
                    "c59_goal : not (eq a 0)",
                    "c60_goal : aexists\n  (fun q : Z =>\n   sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) q)\n        (sepconj (R data) (list_invariant R l q)))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : not (eq a 0)",
                    "c11_NOT0 : not (eq a 0)",
                    "c7_a : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c60_goal : aexists\n  (fun q : Z =>\n   sepconj (contains a data)\n     (sepconj (contains (Z.add a 1) q)\n        (sepconj (R data) (list_invariant R l q)))) h",
                    "c24_p : Z"
                ],
                "tactic_res": [
                    "c61_goal : sepconj (contains a data)\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (R data) (list_invariant R l p))) h"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c61_goal : sepconj (contains a data)\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (R data) (list_invariant R l p))) h",
                    "c57_A : sepconj (contains a data)\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (R data) (list_invariant R l p))) h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pop",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pop : forall R buff , buffer_invariant R buff \u22a2 \u2983 emp \u2984 POP buff \u2983 fun p => aexists ( fun x => contains p x ** valid ( p + 1 ) ** R x ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pop : forall R buff , buffer_invariant R buff \u22a2 \u2983 emp \u2984 POP buff \u2983 fun p => aexists ( fun x => contains p x ** valid ( p + 1 ) ** R x ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr),\ntriple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z =>\n   aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr),\ntriple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z =>\n   aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))"
                ],
                "tactic_res": [
                    "c2_goal : triple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z =>\n   aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr"
                ]
            },
            {
                "tactic_sig": "set ( Qloop := fun p => if p =? 0 then emp else aexists ( fun x => contains p x ** valid ( p + 1 ) ** _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( Qloop := fun p => if p =? 0 then emp else aexists ( fun x => contains p x ** valid ( p + 1 ) ** _i x ) ) .",
                "tactic_args": [
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c2_Qloop : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( fun p => ( p <> 0 ) //\\\\ _i p ) .",
                "tactic_sig_no_out_arg": "apply _i with ( fun p => ( p <> 0 ) //\\\\ _i p ) .",
                "tactic_args": [
                    "c2_goal : triple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z =>\n   aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))",
                    "_global_triple_consequence_post : forall (Q' : postcond) (J : invariant) (P : precond) \n         (c : com) (Q : forall _ : Z, assertion) (_ : triple J P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple J P c Q",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z => pureconj (not (eq p 0)) (Qloop p))",
                    "c4_goal : forall v : Z,\naimp (pureconj (not (eq v 0)) (Qloop v))\n  (aexists\n     (fun x : Z =>\n      sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (buffer_invariant R buff) emp (POP buff)\n  (fun p : Z => pureconj (not (eq p 0)) (Qloop p))",
                    "_global_triple_repeat : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (_ : triple J P c Q) (_ : aimp (Q 0) P),\n       triple J P (REPEAT c) (fun v : Z => pureconj (not (eq v 0)) (Q v))"
                ],
                "tactic_res": [
                    "c5_goal : triple (buffer_invariant R buff) emp\n  (ATOMIC\n     (LET (GET buff)\n        (fun b : Z =>\n         IFTHENELSE b\n           (LET (GET (Z.add b 1))\n              (fun next : Z => SEQ (SET buff next) (PURE b))) \n           (PURE 0)))) Qloop",
                    "c6_goal : aimp (Qloop 0) emp"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (buffer_invariant R buff) emp\n  (ATOMIC\n     (LET (GET buff)\n        (fun b : Z =>\n         IFTHENELSE b\n           (LET (GET (Z.add b 1))\n              (fun next : Z => SEQ (SET buff next) (PURE b))) \n           (PURE 0)))) Qloop",
                    "_global_triple_atomic : forall (J P : assertion) (c : com) (Q : postcond)\n         (_ : triple emp (sepconj P J) c (fun v : Z => sepconj (Q v) J)),\n       triple J P (ATOMIC c) Q"
                ],
                "tactic_res": [
                    "c7_goal : triple emp (sepconj emp (buffer_invariant R buff))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : triple emp (sepconj emp (buffer_invariant R buff))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c8_goal : triple emp (buffer_invariant R buff)\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple emp (buffer_invariant R buff)\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion\n      buff : addr\n      Qloop := fun p : Z =>\n               if Z.eqb p 0\n               then emp\n               else\n                aexists\n                  (fun x : Z =>\n                   sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n       : forall _ : Z, assertion |- Type]"
                ],
                "tactic_res": [
                    "c9_goal : forall v : list Z,\ntriple emp\n  (aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R v p)))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c9_goal : forall v : list Z,\ntriple emp\n  (aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R v p)))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c10_goal : triple emp\n  (aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c10_l : list Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple emp\n  (aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion\n      buff : addr\n      Qloop := fun p : Z =>\n               if Z.eqb p 0\n               then emp\n               else\n                aexists\n                  (fun x : Z =>\n                   sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n       : forall _ : Z, assertion\n      l : list Z |- Type]"
                ],
                "tactic_res": [
                    "c11_goal : forall v : Z,\ntriple emp (sepconj (contains buff v) (list_invariant R l v))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c11_goal : forall v : Z,\ntriple emp (sepconj (contains buff v) (list_invariant R l v))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c12_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c12_p : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c12_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET buff)\n     (fun b : Z =>\n      IFTHENELSE b\n        (LET (GET (Z.add b 1))\n           (fun next : Z => SEQ (SET buff next) (PURE b))) \n        (PURE 0)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c13_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (GET buff) ?Q",
                    "c14_goal : forall v : Z,\ntriple emp (?Q v)\n  (IFTHENELSE v\n     (LET (GET (Z.add v 1))\n        (fun next : Z => SEQ (SET buff next) (PURE v))) \n     (PURE 0))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (GET buff) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c15_goal : triple emp (contains buff p) (GET buff) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : triple emp (contains buff p) (GET buff) ?Q",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c14_goal : forall v : Z,\ntriple emp\n  ((fun v0 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains buff p)) v0)\n      (list_invariant R l p)) v)\n  (IFTHENELSE v\n     (LET (GET (Z.add v 1))\n        (fun next : Z => SEQ (SET buff next) (PURE v))) \n     (PURE 0))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c16_goal : forall v : Z,\ntriple emp\n  (sepconj (pureconj (eq v p) (contains buff p)) (list_invariant R l p))\n  (IFTHENELSE v\n     (LET (GET (Z.add v 1))\n        (fun next : Z => SEQ (SET buff next) (PURE v))) \n     (PURE 0))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p' .",
                "tactic_args": [
                    "c16_goal : forall v : Z,\ntriple emp\n  (sepconj (pureconj (eq v p) (contains buff p)) (list_invariant R l p))\n  (IFTHENELSE v\n     (LET (GET (Z.add v 1))\n        (fun next : Z => SEQ (SET buff next) (PURE v))) \n     (PURE 0))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c17_goal : triple emp\n  (sepconj (pureconj (eq p' p) (contains buff p))\n     (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c17_p' : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : triple emp\n  (sepconj (pureconj (eq p' p) (contains buff p))\n     (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c18_goal : triple emp\n  (pureconj (eq p' p)\n     (sepconj (contains buff p) (list_invariant R l p)))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : triple emp\n  (pureconj (eq p' p)\n     (sepconj (contains buff p) (list_invariant R l p)))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : eq p' p,\ntriple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros E .",
                "tactic_args": [
                    "c19_goal : forall _ : eq p' p,\ntriple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c20_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c20_E : eq p' p"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c20_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p'\n     (LET (GET (Z.add p' 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p'))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c17_p' : Z",
                    "c20_E : eq p' p"
                ],
                "tactic_res": [
                    "c21_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p\n     (LET (GET (Z.add p 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (IFTHENELSE p\n     (LET (GET (Z.add p 1))\n        (fun next : Z => SEQ (SET buff next) (PURE p))) \n     (PURE 0))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_ifthenelse : forall (J : invariant) (b : Z) (c1 c2 : com) \n         (P : assertion) (Q : postcond)\n         (_ : triple J (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple J (pureconj (eq b 0) P) c2 Q),\n       triple J P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c22_goal : triple emp\n  (pureconj (not (eq p 0))\n     (sepconj (contains buff p) (list_invariant R l p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c23_goal : triple emp\n  (pureconj (eq p 0) (sepconj (contains buff p) (list_invariant R l p)))\n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : triple emp\n  (pureconj (not (eq p 0))\n     (sepconj (contains buff p) (list_invariant R l p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : not (eq p 0),\ntriple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros NOTZERO .",
                "tactic_args": [
                    "c24_goal : forall _ : not (eq p 0),\ntriple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c25_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c25_NOTZERO : not (eq p 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c25_goal : triple emp (sepconj (contains buff p) (list_invariant R l p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c26_goal : triple emp (sepconj (list_invariant R l p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ | x _i ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | x _i ] .",
                "tactic_args": [
                    "c26_goal : triple emp (sepconj (list_invariant R l p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c10_l : list Z",
                    "c10_l : list Z",
                    "c25_NOTZERO : not (eq p 0)",
                    "c12_p : Z",
                    "c2_Qloop : forall _ : Z, assertion",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c27_goal : triple emp (sepconj (list_invariant R nil p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c28_goal : triple emp (sepconj (list_invariant R (cons x l) p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c28_x : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c27_goal : triple emp (sepconj (list_invariant R nil p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c29_goal : triple emp (sepconj (pureconj (eq p 0) emp) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : triple emp (sepconj (pureconj (eq p 0) emp) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c30_goal : triple emp (pureconj (eq p 0) (sepconj emp (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : triple emp (pureconj (eq p 0) (sepconj emp (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : eq p 0,\ntriple emp (sepconj emp (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c31_goal : forall _ : eq p 0,\ntriple emp (sepconj emp (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c32_goal : triple emp (sepconj emp (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c32_H : eq p 0"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c32_goal : triple emp (sepconj emp (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c28_goal : triple emp (sepconj (list_invariant R (cons x l) p) (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c33_goal : triple emp\n  (sepconj\n     (pureconj (not (eq p 0))\n        (aexists\n           (fun q : Z =>\n            sepconj (contains p x)\n              (sepconj (contains (Z.add p 1) q)\n                 (sepconj (R x) (list_invariant R l q))))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c33_goal : triple emp\n  (sepconj\n     (pureconj (not (eq p 0))\n        (aexists\n           (fun q : Z =>\n            sepconj (contains p x)\n              (sepconj (contains (Z.add p 1) q)\n                 (sepconj (R x) (list_invariant R l q))))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c34_goal : triple emp\n  (pureconj (not (eq p 0))\n     (sepconj\n        (aexists\n           (fun q : Z =>\n            sepconj (contains p x)\n              (sepconj (contains (Z.add p 1) q)\n                 (sepconj (R x) (list_invariant R l q)))))\n        (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c34_goal : triple emp\n  (pureconj (not (eq p 0))\n     (sepconj\n        (aexists\n           (fun q : Z =>\n            sepconj (contains p x)\n              (sepconj (contains (Z.add p 1) q)\n                 (sepconj (R x) (list_invariant R l q)))))\n        (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c35_goal : forall _ : not (eq p 0),\ntriple emp\n  (sepconj\n     (aexists\n        (fun q : Z =>\n         sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) q)\n              (sepconj (R x) (list_invariant R l q)))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c35_goal : forall _ : not (eq p 0),\ntriple emp\n  (sepconj\n     (aexists\n        (fun q : Z =>\n         sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) q)\n              (sepconj (R x) (list_invariant R l q)))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c36_goal : triple emp\n  (sepconj\n     (aexists\n        (fun q : Z =>\n         sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) q)\n              (sepconj (R x) (list_invariant R l q)))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c36_H : not (eq p 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : triple emp\n  (sepconj\n     (aexists\n        (fun q : Z =>\n         sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) q)\n              (sepconj (R x) (list_invariant R l q)))))\n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c37_goal : triple emp\n  (aexists\n     (fun x0 : Z =>\n      sepconj\n        (sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) x0)\n              (sepconj (R x) (list_invariant R l x0))))\n        (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : triple emp\n  (aexists\n     (fun x0 : Z =>\n      sepconj\n        (sepconj (contains p x)\n           (sepconj (contains (Z.add p 1) x0)\n              (sepconj (R x) (list_invariant R l x0))))\n        (contains buff p)))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion\n      buff : addr\n      Qloop := fun p : Z =>\n               if Z.eqb p 0\n               then emp\n               else\n                aexists\n                  (fun x : Z =>\n                   sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n       : forall _ : Z, assertion\n      x : Z\n      l : list Z\n      p : Z\n      NOTZERO : not (eq p 0)\n      H : not (eq p 0) |- Type]"
                ],
                "tactic_res": [
                    "c38_goal : forall v : Z,\ntriple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) v)\n           (sepconj (R x) (list_invariant R l v)))) \n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t .",
                "tactic_args": [
                    "c38_goal : forall v : Z,\ntriple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) v)\n           (sepconj (R x) (list_invariant R l v)))) \n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c39_goal : triple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))) \n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c39_t : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c39_goal : triple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))) \n     (contains buff p))\n  (LET (GET (Z.add p 1)) (fun next : Z => SEQ (SET buff next) (PURE p)))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c40_goal : triple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))) \n     (contains buff p)) (GET (Z.add p 1)) ?Q",
                    "c41_goal : forall v : Z,\ntriple emp (?Q v) (SEQ (SET buff v) (PURE p))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i , _i .",
                "tactic_args": [
                    "c40_goal : triple emp\n  (sepconj\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))) \n     (contains buff p)) (GET (Z.add p 1)) ?Q",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c42_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (GET (Z.add p 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c42_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (GET (Z.add p 1)) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c43_goal : triple emp (contains (Z.add p 1) t) (GET (Z.add p 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c43_goal : triple emp (contains (Z.add p 1) t) (GET (Z.add p 1)) ?Q",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t' .",
                "tactic_args": [
                    "c41_goal : forall v : Z,\ntriple emp\n  ((fun v0 : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' t) (contains (Z.add p 1) t)) v0)\n      (sepconj (contains p x)\n         (sepconj (R x)\n            (sepconj (list_invariant R l t) (contains buff p))))) v)\n  (SEQ (SET buff v) (PURE p))\n  (fun v0 : Z => sepconj (Qloop v0) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c44_goal : triple emp\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' t) (contains (Z.add p 1) t)) v)\n      (sepconj (contains p x)\n         (sepconj (R x)\n            (sepconj (list_invariant R l t) (contains buff p))))) t')\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c44_t' : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c44_goal : triple emp\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' t) (contains (Z.add p 1) t)) v)\n      (sepconj (contains p x)\n         (sepconj (R x)\n            (sepconj (list_invariant R l t) (contains buff p))))) t')\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c45_goal : triple emp\n  (sepconj (pureconj (eq t' t) (contains (Z.add p 1) t))\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c45_goal : triple emp\n  (sepconj (pureconj (eq t' t) (contains (Z.add p 1) t))\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c46_goal : triple emp\n  (pureconj (eq t' t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x)\n           (sepconj (R x)\n              (sepconj (list_invariant R l t) (contains buff p))))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c46_goal : triple emp\n  (pureconj (eq t' t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x)\n           (sepconj (R x)\n              (sepconj (list_invariant R l t) (contains buff p))))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c47_goal : forall _ : eq t' t,\ntriple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros E .",
                "tactic_args": [
                    "c47_goal : forall _ : eq t' t,\ntriple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c48_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c48_E : eq t' t"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c48_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t') (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c44_t' : Z",
                    "c48_E : eq t' t"
                ],
                "tactic_res": [
                    "c49_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t) (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ! _i , _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i , _i , ! _i .",
                "tactic_args": [
                    "c49_goal : triple emp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (contains p x)\n        (sepconj (R x)\n           (sepconj (list_invariant R l t) (contains buff p)))))\n  (SEQ (SET buff t) (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c50_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (SEQ (SET buff t) (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c50_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (SEQ (SET buff t) (PURE p))\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c51_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (SET buff t) (fun _ : Z => ?Q)",
                    "c52_goal : triple emp ?Q (PURE p)\n  (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q := fun _i => _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q := fun _i => _i _i _i ) .",
                "tactic_args": [
                    "c51_goal : triple emp\n  (sepconj (contains buff p)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (SET buff t) (fun _ : Z => ?Q)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global__ : ?T\nwhere\n?T : [R : forall _ : Z, assertion\n      buff : addr\n      Qloop := fun p : Z =>\n               if Z.eqb p 0\n               then emp\n               else\n                aexists\n                  (fun x : Z =>\n                   sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n       : forall _ : Z, assertion\n      x : Z\n      l : list Z\n      p : Z\n      NOTZERO : not (eq p 0)\n      H : not (eq p 0)\n      t : Z |- Type]\n?y : [R : forall _ : Z, assertion\n      buff : addr\n      Qloop := fun p : Z =>\n               if Z.eqb p 0\n               then emp\n               else\n                aexists\n                  (fun x : Z =>\n                   sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n       : forall _ : Z, assertion\n      x : Z\n      l : list Z\n      p : Z\n      NOTZERO : not (eq p 0)\n      H : not (eq p 0)\n      t : Z |- ?T]",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_buff : addr",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c53_goal : triple emp (contains buff p) (SET buff t)\n  (fun _ : Z => contains buff t)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c53_goal : triple emp (contains buff p) (SET buff t)\n  (fun _ : Z => contains buff t)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c54_goal : triple emp ?P' (SET buff t) (fun _ : Z => contains buff t)",
                    "c55_goal : aimp (contains buff p) (valid buff)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c54_goal : triple emp ?P' (SET buff t) (fun _ : Z => contains buff t)",
                    "_global_triple_set : forall (J : invariant) (l : addr) (v : Z),\n       triple J (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c55_goal : aimp (contains buff p) (valid buff)"
                ],
                "tactic_res": [
                    "c56_goal : valid buff h",
                    "c56_h : heap",
                    "c56_A : contains buff p h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c56_goal : valid buff h",
                    "c12_p : Z"
                ],
                "tactic_res": [
                    "c57_goal : contains buff p h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c57_goal : contains buff p h",
                    "c56_A : contains buff p h",
                    "c56_h : heap",
                    "c12_p : Z",
                    "c2_buff : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c52_goal : triple emp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (PURE p) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c58_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj (Qloop p) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c58_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj (Qloop p) (buffer_invariant R buff))",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c59_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (if Z.eqb p 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c59_NOTZERO : not (eq p 0)"
                ],
                "tactic_res": [
                    "c59_NOTZERO : eq (Z.eqb p 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c59_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (if Z.eqb p 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))",
                    "c59_NOTZERO : eq (Z.eqb p 0) false"
                ],
                "tactic_res": [
                    "c60_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c60_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains p x) (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c12_p : Z",
                    "c28_x : Z"
                ],
                "tactic_res": [
                    "c61_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c61_goal : aimp\n  (sepconj (contains buff t)\n     (sepconj (contains p x)\n        (sepconj (contains (Z.add p 1) t)\n           (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))",
                    "_global_sepconj_pick3 : forall R P Q S : assertion,\n       eq (sepconj P (sepconj Q (sepconj R S)))\n         (sepconj R (sepconj P (sepconj Q S)))",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_buff : addr",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c62_goal : aimp\n  (sepconj (contains p x)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains buff t)\n           (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c62_goal : aimp\n  (sepconj (contains p x)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (contains buff t)\n           (sepconj (R x) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_buff : addr",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c63_goal : aimp\n  (sepconj (contains p x)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (R x)\n           (sepconj (contains buff t) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c63_goal : aimp\n  (sepconj (contains p x)\n     (sepconj (contains (Z.add p 1) t)\n        (sepconj (R x)\n           (sepconj (contains buff t) (list_invariant R l t)))))\n  (sepconj\n     (aexists\n        (fun x : Z =>\n         sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n     (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c64_goal : sepconj\n  (aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n  (buffer_invariant R buff) h",
                    "c64_h : heap",
                    "c64_A : sepconj (contains p x)\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c64_goal : sepconj\n  (aexists\n     (fun x : Z =>\n      sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))\n  (buffer_invariant R buff) h",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c65_goal : aexists\n  (fun x : Z =>\n   sepconj (sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n     (buffer_invariant R buff)) h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c65_goal : aexists\n  (fun x : Z =>\n   sepconj (sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n     (buffer_invariant R buff)) h",
                    "c28_x : Z"
                ],
                "tactic_res": [
                    "c66_goal : sepconj (sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n  (buffer_invariant R buff) h"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c66_goal : sepconj (sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))\n  (buffer_invariant R buff) h",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c67_goal : sepconj (contains p x)\n  (sepconj (valid (Z.add p 1))\n     (sepconj (R x) (buffer_invariant R buff))) h"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( P := _i ( _i + 1 ) _i ** _i _i ** _i _i _i ** _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( P := _i ( _i + 1 ) _i ** _i _i ** _i _i _i ** _i _i _i _i ) .",
                "tactic_args": [
                    "c67_goal : sepconj (contains p x)\n  (sepconj (valid (Z.add p 1))\n     (sepconj (R x) (buffer_invariant R buff))) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c12_p : Z",
                    "c39_t : Z",
                    "c2_R : forall _ : Z, assertion",
                    "c28_x : Z",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c2_buff : addr",
                    "c39_t : Z",
                    "_global_list_invariant : forall (_ : forall _ : Z, assertion) (_ : list Z) (_ : addr),\n       assertion",
                    "c2_R : forall _ : Z, assertion",
                    "c10_l : list Z",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c68_goal : aimp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  (sepconj (valid (Z.add p 1))\n     (sepconj (R x) (buffer_invariant R buff)))",
                    "c69_goal : sepconj (contains p x)\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  h"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c69_goal : sepconj (contains p x)\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  h",
                    "c64_A : sepconj (contains p x)\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  h",
                    "c64_h : heap",
                    "c39_t : Z",
                    "c12_p : Z",
                    "c10_l : list Z",
                    "c28_x : Z",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h' B .",
                "tactic_args": [
                    "c68_goal : aimp\n  (sepconj (contains (Z.add p 1) t)\n     (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))))\n  (sepconj (valid (Z.add p 1))\n     (sepconj (R x) (buffer_invariant R buff)))"
                ],
                "tactic_res": [
                    "c70_goal : sepconj (valid (Z.add p 1)) (sepconj (R x) (buffer_invariant R buff))\n  h'",
                    "c70_h' : heap",
                    "c70_B : sepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))) h'"
                ]
            },
            {
                "tactic_sig": "apply _i with ( P := _i ( _i + 1 ) _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( P := _i ( _i + 1 ) _i ) .",
                "tactic_args": [
                    "c70_goal : sepconj (valid (Z.add p 1)) (sepconj (R x) (buffer_invariant R buff))\n  h'",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion",
                    "c12_p : Z",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c71_goal : aimp (contains (Z.add p 1) t) (valid (Z.add p 1))",
                    "c72_goal : sepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (buffer_invariant R buff)) h'"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h'' C .",
                "tactic_args": [
                    "c71_goal : aimp (contains (Z.add p 1) t) (valid (Z.add p 1))"
                ],
                "tactic_res": [
                    "c73_goal : valid (Z.add p 1) h''",
                    "c73_h'' : heap",
                    "c73_C : contains (Z.add p 1) t h''"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c73_goal : valid (Z.add p 1) h''",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c74_goal : contains (Z.add p 1) t h''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : contains (Z.add p 1) t h''",
                    "c73_C : contains (Z.add p 1) t h''",
                    "c73_h'' : heap",
                    "c39_t : Z",
                    "c12_p : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "revert _i _i .",
                "tactic_sig_no_out_arg": "revert _i _i .",
                "tactic_args": [
                    "c72_goal : sepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (buffer_invariant R buff)) h'",
                    "c70_h' : heap",
                    "c70_B : sepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t))) h'"
                ],
                "tactic_res": [
                    "c75_goal : forall (h' : heap)\n  (_ : sepconj (contains (Z.add p 1) t)\n         (sepconj (R x)\n            (sepconj (contains buff t) (list_invariant R l t))) h'),\nsepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (buffer_invariant R buff)) h'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c75_goal : forall (h' : heap)\n  (_ : sepconj (contains (Z.add p 1) t)\n         (sepconj (R x)\n            (sepconj (contains buff t) (list_invariant R l t))) h'),\nsepconj (contains (Z.add p 1) t)\n  (sepconj (R x) (buffer_invariant R buff)) h'",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c76_goal : aimp (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t)))\n  (sepconj (R x) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c76_goal : aimp (sepconj (R x) (sepconj (contains buff t) (list_invariant R l t)))\n  (sepconj (R x) (buffer_invariant R buff))",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c77_goal : aimp (sepconj (contains buff t) (list_invariant R l t))\n  (buffer_invariant R buff)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h''' D .",
                "tactic_args": [
                    "c77_goal : aimp (sepconj (contains buff t) (list_invariant R l t))\n  (buffer_invariant R buff)"
                ],
                "tactic_res": [
                    "c78_goal : buffer_invariant R buff h'''",
                    "c78_h''' : heap",
                    "c78_D : sepconj (contains buff t) (list_invariant R l t) h'''"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c78_goal : buffer_invariant R buff h'''"
                ],
                "tactic_res": [
                    "c79_goal : aexists\n  (fun l : list Z =>\n   aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n  h'''"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c79_goal : aexists\n  (fun l : list Z =>\n   aexists\n     (fun p : Z => sepconj (contains buff p) (list_invariant R l p)))\n  h'''",
                    "c10_l : list Z"
                ],
                "tactic_res": [
                    "c80_goal : aexists (fun p : Z => sepconj (contains buff p) (list_invariant R l p))\n  h'''"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c80_goal : aexists (fun p : Z => sepconj (contains buff p) (list_invariant R l p))\n  h'''",
                    "c39_t : Z"
                ],
                "tactic_res": [
                    "c81_goal : sepconj (contains buff t) (list_invariant R l t) h'''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c81_goal : sepconj (contains buff t) (list_invariant R l t) h'''",
                    "c78_D : sepconj (contains buff t) (list_invariant R l t) h'''",
                    "c78_h''' : heap",
                    "c39_t : Z",
                    "c10_l : list Z",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : triple emp\n  (pureconj (eq p 0) (sepconj (contains buff p) (list_invariant R l p)))\n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c82_goal : forall _ : eq p 0,\ntriple emp (sepconj (contains buff p) (list_invariant R l p)) \n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros ZERO .",
                "tactic_args": [
                    "c82_goal : forall _ : eq p 0,\ntriple emp (sepconj (contains buff p) (list_invariant R l p)) \n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c83_goal : triple emp (sepconj (contains buff p) (list_invariant R l p)) \n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "c83_ZERO : eq p 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c83_goal : triple emp (sepconj (contains buff p) (list_invariant R l p)) \n  (PURE 0) (fun v : Z => sepconj (Qloop v) (buffer_invariant R buff))",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c84_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj (Qloop 0) (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c84_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj (Qloop 0) (buffer_invariant R buff))",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c85_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj\n     (if Z.eqb 0 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains 0 x) (sepconj (valid (Z.add 0 1)) (R x))))\n     (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c85_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj\n     (if Z.eqb 0 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains 0 x) (sepconj (valid (Z.add 0 1)) (R x))))\n     (buffer_invariant R buff))"
                ],
                "tactic_res": [
                    "c86_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj emp (buffer_invariant R buff))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c86_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (sepconj emp (buffer_invariant R buff))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c87_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (buffer_invariant R buff)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c87_goal : aimp (sepconj (contains buff p) (list_invariant R l p))\n  (buffer_invariant R buff)"
                ],
                "tactic_res": [
                    "c88_goal : buffer_invariant R buff h",
                    "c88_h : heap",
                    "c88_A : sepconj (contains buff p) (list_invariant R l p) h"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c88_goal : buffer_invariant R buff h",
                    "c10_l : list Z",
                    "c12_p : Z"
                ],
                "tactic_res": [
                    "c89_goal : sepconj (contains buff p) (list_invariant R l p) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c89_goal : sepconj (contains buff p) (list_invariant R l p) h",
                    "c88_A : sepconj (contains buff p) (list_invariant R l p) h",
                    "c88_h : heap",
                    "c12_p : Z",
                    "c10_l : list Z",
                    "c2_buff : addr",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : aimp (Qloop 0) emp",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c90_goal : aimp\n  (if Z.eqb 0 0\n   then emp\n   else\n    aexists\n      (fun x : Z =>\n       sepconj (contains 0 x) (sepconj (valid (Z.add 0 1)) (R x)))) emp"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c90_goal : aimp\n  (if Z.eqb 0 0\n   then emp\n   else\n    aexists\n      (fun x : Z =>\n       sepconj (contains 0 x) (sepconj (valid (Z.add 0 1)) (R x)))) emp"
                ],
                "tactic_res": [
                    "c91_goal : aimp emp emp"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c91_goal : aimp emp emp"
                ],
                "tactic_res": [
                    "c92_goal : forall (h : heap) (_ : emp h), emp h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c92_goal : forall (h : heap) (_ : emp h), emp h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\naimp (pureconj (not (eq v 0)) (Qloop v))\n  (aexists\n     (fun x : Z =>\n      sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))))",
                    "c2_Qloop : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c93_goal : forall v : Z,\naimp\n  (pureconj (not (eq v 0))\n     (if Z.eqb v 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x)))))\n  (aexists\n     (fun x : Z =>\n      sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros v h [ A B ] .",
                "tactic_args": [
                    "c93_goal : forall v : Z,\naimp\n  (pureconj (not (eq v 0))\n     (if Z.eqb v 0\n      then emp\n      else\n       aexists\n         (fun x : Z =>\n          sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x)))))\n  (aexists\n     (fun x : Z =>\n      sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))))"
                ],
                "tactic_res": [
                    "c94_goal : aexists\n  (fun x : Z =>\n   sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))) h",
                    "c94_v : Z",
                    "c94_h : heap",
                    "c94_A : not (eq v 0)",
                    "c94_B : (if Z.eqb v 0\n then emp\n else\n  aexists\n    (fun x : Z =>\n     sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x)))) h"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c94_A : not (eq v 0)"
                ],
                "tactic_res": [
                    "c94_A : eq (Z.eqb v 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c94_A : eq (Z.eqb v 0) false",
                    "c94_B : (if Z.eqb v 0\n then emp\n else\n  aexists\n    (fun x : Z =>\n     sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x)))) h"
                ],
                "tactic_res": [
                    "c94_B : aexists\n  (fun x : Z =>\n   sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c94_goal : aexists\n  (fun x : Z =>\n   sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))) h",
                    "c94_B : aexists\n  (fun x : Z =>\n   sepconj (contains v x) (sepconj (valid (Z.add v 1)) (R x))) h",
                    "c94_h : heap",
                    "c94_v : Z",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consume2",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consume2 : forall R buff , buffer_invariant R buff \u22a2 \u2983 emp \u2984 CONSUME buff \u2983 fun data => R data \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consume2 : forall R buff , buffer_invariant R buff \u22a2 \u2983 emp \u2984 CONSUME buff \u2983 fun data => R data \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr),\ntriple (buffer_invariant R buff) emp (CONSUME buff)\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : forall _ : Z, assertion) (buff : addr),\ntriple (buffer_invariant R buff) emp (CONSUME buff)\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c2_goal : triple (buffer_invariant R buff) emp (CONSUME buff)\n  (fun data : Z => R data)",
                    "c2_R : forall _ : Z, assertion",
                    "c2_buff : addr"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : triple (buffer_invariant R buff) emp (CONSUME buff)\n  (fun data : Z => R data)",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : triple (buffer_invariant R buff) emp (POP buff) ?Q",
                    "c4_goal : forall v : Z,\ntriple (buffer_invariant R buff) (?Q v)\n  (LET (GET v)\n     (fun data : Z => SEQ (FREE v) (SEQ (FREE (Z.add v 1)) (PURE data))))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (buffer_invariant R buff) emp (POP buff) ?Q",
                    "_global_triple_pop : forall (R : forall _ : Z, assertion) (buff : addr),\n       triple (buffer_invariant R buff) emp (POP buff)\n         (fun p : Z =>\n          aexists\n            (fun x : Z =>\n             sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros b .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\ntriple (buffer_invariant R buff)\n  ((fun p : Z =>\n    aexists\n      (fun x : Z =>\n       sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))) v)\n  (LET (GET v)\n     (fun data : Z => SEQ (FREE v) (SEQ (FREE (Z.add v 1)) (PURE data))))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c5_goal : triple (buffer_invariant R buff)\n  ((fun p : Z =>\n    aexists\n      (fun x : Z =>\n       sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))) b)\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)",
                    "c5_b : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : triple (buffer_invariant R buff)\n  ((fun p : Z =>\n    aexists\n      (fun x : Z =>\n       sepconj (contains p x) (sepconj (valid (Z.add p 1)) (R x)))) b)\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c6_goal : triple (buffer_invariant R buff)\n  (aexists\n     (fun x : Z =>\n      sepconj (contains b x) (sepconj (valid (Z.add b 1)) (R x))))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple (buffer_invariant R buff)\n  (aexists\n     (fun x : Z =>\n      sepconj (contains b x) (sepconj (valid (Z.add b 1)) (R x))))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)",
                    "_global_triple_exists_pre : forall (J : invariant) (P : forall _ : ?X, assertion) \n         (c : com) (Q : postcond) (_ : forall v : ?X, triple J (P v) c Q),\n       triple J (aexists P) c Q\nwhere\n?X : [R : forall _ : Z, assertion  buff : addr  b : Z |- Type]"
                ],
                "tactic_res": [
                    "c7_goal : forall v : Z,\ntriple (buffer_invariant R buff)\n  (sepconj (contains b v) (sepconj (valid (Z.add b 1)) (R v)))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c7_goal : forall v : Z,\ntriple (buffer_invariant R buff)\n  (sepconj (contains b v) (sepconj (valid (Z.add b 1)) (R v)))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c8_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)",
                    "c8_p : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c8_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (LET (GET b)\n     (fun data : Z => SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE data))))\n  (fun data : Z => R data)",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (J : invariant) \n         (P : precond) (Q R : postcond) (_ : triple J P c Q)\n         (_ : forall v : Z, triple J (Q v) (f v) R), \n       triple J P (LET c f) R"
                ],
                "tactic_res": [
                    "c9_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))) \n  (GET b) ?Q",
                    "c10_goal : forall v : Z,\ntriple (buffer_invariant R buff) (?Q v)\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE v)))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))) \n  (GET b) ?Q",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c11_goal : triple (buffer_invariant R buff) (contains b p) (GET b) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : triple (buffer_invariant R buff) (contains b p) (GET b) ?Q",
                    "_global_triple_get : forall (J : invariant) (l : addr) (v : Z),\n       triple J (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p' .",
                "tactic_args": [
                    "c10_goal : forall v : Z,\ntriple (buffer_invariant R buff)\n  ((fun v0 : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains b p)) v0)\n      (sepconj (valid (Z.add b 1)) (R p))) v)\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE v)))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c12_goal : triple (buffer_invariant R buff)\n  ((fun v : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains b p)) v)\n      (sepconj (valid (Z.add b 1)) (R p))) p')\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)",
                    "c12_p' : Z"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c12_goal : triple (buffer_invariant R buff)\n  ((fun v : Z =>\n    sepconj ((fun v' : Z => pureconj (eq v' p) (contains b p)) v)\n      (sepconj (valid (Z.add b 1)) (R p))) p')\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c13_goal : triple (buffer_invariant R buff)\n  (sepconj (pureconj (eq p' p) (contains b p))\n     (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : triple (buffer_invariant R buff)\n  (sepconj (pureconj (eq p' p) (contains b p))\n     (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c14_goal : triple (buffer_invariant R buff)\n  (pureconj (eq p' p)\n     (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple (buffer_invariant R buff)\n  (pureconj (eq p' p)\n     (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)",
                    "_global_triple_simple_conj_pre : forall (J : invariant) (P1 : Prop) (P2 : precond) \n         (c : com) (Q : postcond) (_ : forall _ : P1, triple J P2 c Q),\n       triple J (pureconj P1 P2) c Q"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq p' p,\ntriple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros E .",
                "tactic_args": [
                    "c15_goal : forall _ : eq p' p,\ntriple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)"
                ],
                "tactic_res": [
                    "c16_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)",
                    "c16_E : eq p' p"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c16_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p')))\n  (fun data : Z => R data)",
                    "c12_p' : Z",
                    "c16_E : eq p' p"
                ],
                "tactic_res": [
                    "c17_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p)))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c17_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE b) (SEQ (FREE (Z.add b 1)) (PURE p)))\n  (fun data : Z => R data)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c18_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))) \n  (FREE b) (fun _ : Z => ?Q)",
                    "c19_goal : triple (buffer_invariant R buff) ?Q (SEQ (FREE (Z.add b 1)) (PURE p))\n  (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q := fun _i => _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q := fun _i => _i ) .",
                "tactic_args": [
                    "c18_goal : triple (buffer_invariant R buff)\n  (sepconj (contains b p) (sepconj (valid (Z.add b 1)) (R p))) \n  (FREE b) (fun _ : Z => ?Q)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global__ : ?T\nwhere\n?T : [R : forall _ : Z, assertion  buff : addr  b : Z  p : Z |- Type]\n?y : [R : forall _ : Z, assertion  buff : addr  b : Z  p : Z |- ?T]",
                    "_global_emp : assertion"
                ],
                "tactic_res": [
                    "c20_goal : triple (buffer_invariant R buff) (contains b p) (FREE b)\n  (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c20_goal : triple (buffer_invariant R buff) (contains b p) (FREE b)\n  (fun _ : Z => emp)",
                    "_global_triple_consequence_pre : forall (P' : precond) (J : invariant) (P : assertion) \n         (c : com) (Q : postcond) (_ : triple J P' c Q) \n         (_ : aimp P P'), triple J P c Q"
                ],
                "tactic_res": [
                    "c21_goal : triple (buffer_invariant R buff) ?P' (FREE b) (fun _ : Z => emp)",
                    "c22_goal : aimp (contains b p) (valid b)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : triple (buffer_invariant R buff) ?P' (FREE b) (fun _ : Z => emp)",
                    "_global_triple_free : forall (J : invariant) (l : addr),\n       triple J (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c22_goal : aimp (contains b p) (valid b)"
                ],
                "tactic_res": [
                    "c23_goal : valid b h",
                    "c23_h : heap",
                    "c23_A : contains b p h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c23_goal : valid b h",
                    "c8_p : Z"
                ],
                "tactic_res": [
                    "c24_goal : contains b p h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : contains b p h",
                    "c23_A : contains b p h",
                    "c23_h : heap",
                    "c5_b : Z",
                    "c8_p : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : triple (buffer_invariant R buff)\n  (sepconj emp (sepconj (valid (Z.add b 1)) (R p)))\n  (SEQ (FREE (Z.add b 1)) (PURE p)) (fun data : Z => R data)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c25_goal : triple (buffer_invariant R buff) (sepconj (valid (Z.add b 1)) (R p))\n  (SEQ (FREE (Z.add b 1)) (PURE p)) (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c25_goal : triple (buffer_invariant R buff) (sepconj (valid (Z.add b 1)) (R p))\n  (SEQ (FREE (Z.add b 1)) (PURE p)) (fun data : Z => R data)",
                    "_global_triple_seq : forall (c1 c2 : com) (J : invariant) (P Q : precond) \n         (R : postcond) (_ : triple J P c1 (fun _ : Z => Q))\n         (_ : triple J Q c2 R), triple J P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c26_goal : triple (buffer_invariant R buff) (sepconj (valid (Z.add b 1)) (R p))\n  (FREE (Z.add b 1)) (fun _ : Z => ?Q)",
                    "c27_goal : triple (buffer_invariant R buff) (sepconj emp (R p)) \n  (PURE p) (fun data : Z => R data)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( Q := fun _i => _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( Q := fun _i => _i ) .",
                "tactic_args": [
                    "c26_goal : triple (buffer_invariant R buff) (sepconj (valid (Z.add b 1)) (R p))\n  (FREE (Z.add b 1)) (fun _ : Z => ?Q)",
                    "_global_triple_frame : forall (J : invariant) (P : precond) (c : com) \n         (Q : postcond) (R : assertion) (_ : triple J P c Q),\n       triple J (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global__ : ?T\nwhere\n?T : [R : forall _ : Z, assertion  buff : addr  b : Z  p : Z |- Type]\n?y : [R : forall _ : Z, assertion  buff : addr  b : Z  p : Z |- ?T]",
                    "_global_emp : assertion"
                ],
                "tactic_res": [
                    "c28_goal : triple (buffer_invariant R buff) (valid (Z.add b 1)) \n  (FREE (Z.add b 1)) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : triple (buffer_invariant R buff) (valid (Z.add b 1)) \n  (FREE (Z.add b 1)) (fun _ : Z => emp)",
                    "_global_triple_free : forall (J : invariant) (l : addr),\n       triple J (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : triple (buffer_invariant R buff) (sepconj emp (R p)) \n  (PURE p) (fun data : Z => R data)",
                    "_global_triple_pure : forall (J : invariant) (P : assertion) (Q : forall _ : Z, assertion)\n         (v : Z) (_ : aimp P (Q v)), triple J P (PURE v) Q"
                ],
                "tactic_res": [
                    "c29_goal : aimp (sepconj emp (R p)) (R p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : aimp (sepconj emp (R p)) (R p)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c30_goal : aimp (R p) (R p)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c30_goal : aimp (R p) (R p)"
                ],
                "tactic_res": [
                    "c31_goal : forall (h : heap) (_ : R p h), R p h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : forall (h : heap) (_ : R p h), R p h",
                    "c8_p : Z",
                    "c2_R : forall _ : Z, assertion"
                ],
                "tactic_res": []
            }
        ]
    }
]