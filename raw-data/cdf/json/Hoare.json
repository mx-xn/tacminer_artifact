[
    {
        "lemma_name": "update_same",
        "proof": [
            {
                "tactic_sig": "Lemma update_same : forall x v s , ( update x v s ) x = v .",
                "tactic_sig_no_out_arg": "Lemma update_same : forall x v s , ( update x v s ) x = v .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (v : Z) (s : store), eq (update x v s x) v"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (v : Z) (s : store), eq (update x v s x) v",
                    "_global_update : forall (_ : ident) (_ : Z) (_ : store), store"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : ident) (v : Z) (s : store),\neq (if string_dec x x then v else s x) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (x : ident) (v : Z) (s : store),\neq (if string_dec x x then v else s x) v"
                ],
                "tactic_res": [
                    "c3_goal : eq (if string_dec x x then v else s x) v",
                    "c3_x : ident",
                    "c3_v : Z",
                    "c3_s : store"
                ]
            },
            {
                "tactic_sig": "destruct ( string_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( string_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if string_dec x x then v else s x) v",
                    "c3_x : ident",
                    "c3_x : ident",
                    "c3_s : store",
                    "c3_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq v v",
                    "c4_e : eq x x",
                    "c5_goal : eq (s x) v",
                    "c5_n : not (eq x x)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : eq v v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c5_goal : eq (s x) v"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "update_other",
        "proof": [
            {
                "tactic_sig": "Lemma update_other : forall x v s y , x <> y -> ( update x v s ) y = s y .",
                "tactic_sig_no_out_arg": "Lemma update_other : forall x v s y , x <> y -> ( update x v s ) y = s y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\neq (update x v s y) (s y)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\neq (update x v s y) (s y)",
                    "_global_update : forall (_ : ident) (_ : Z) (_ : store), store"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\neq (if string_dec x y then v else s y) (s y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\neq (if string_dec x y then v else s y) (s y)"
                ],
                "tactic_res": [
                    "c3_goal : eq (if string_dec x y then v else s y) (s y)",
                    "c3_x : ident",
                    "c3_v : Z",
                    "c3_s : store",
                    "c3_y : ident",
                    "c3_H : not (eq x y)"
                ]
            },
            {
                "tactic_sig": "destruct ( string_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( string_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if string_dec x y then v else s y) (s y)",
                    "c3_x : ident",
                    "c3_y : ident",
                    "c3_H : not (eq x y)",
                    "c3_s : store",
                    "c3_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq v (s y)",
                    "c4_e : eq x y",
                    "c5_goal : eq (s y) (s y)",
                    "c5_n : not (eq x y)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : eq v (s y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c5_goal : eq (s y) (s y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_consequence_pre",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_consequence_pre : forall P P' Q c , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P -> \u2983 P' \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_consequence_pre : forall P P' Q c , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P -> \u2983 P' \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q) (_ : aimp P' P),\nHoare P' c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q) (_ : aimp P' P),\nHoare P' c Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P' c Q",
                    "c2_P : assertion",
                    "c2_P' : assertion",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_H : Hoare P c Q",
                    "c2_H0 : aimp P' P"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ) ( _i := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ) ( _i := _i ) .",
                "tactic_args": [
                    "c2_goal : Hoare P' c Q",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'",
                    "c2_P : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : Hoare P c Q",
                    "c4_goal : aimp P' P",
                    "c5_goal : aimp Q Q"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Hoare P c Q",
                    "c2_H : Hoare P c Q",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : aimp P' P",
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : store) (_ : P' s), P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P' s), P s",
                    "c2_H0 : aimp P' P",
                    "c2_P : assertion",
                    "c2_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : aimp Q Q",
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c7_goal : forall (s : store) (_ : Q s), Q s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (s : store) (_ : Q s), Q s",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_consequence_post",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_consequence_post : forall P Q Q' c , \u2983 P \u2984 c \u2983 Q \u2984 -> Q -->> Q' -> \u2983 P \u2984 c \u2983 Q' \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_consequence_post : forall P Q Q' c , \u2983 P \u2984 c \u2983 Q \u2984 -> Q -->> Q' -> \u2983 P \u2984 c \u2983 Q' \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q Q' : assertion) (c : com) (_ : Hoare P c Q) (_ : aimp Q Q'),\nHoare P c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q Q' : assertion) (c : com) (_ : Hoare P c Q) (_ : aimp Q Q'),\nHoare P c Q'"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P c Q'",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_Q' : assertion",
                    "c2_c : com",
                    "c2_H : Hoare P c Q",
                    "c2_H0 : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ) ( _i := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ) ( _i := _i ) .",
                "tactic_args": [
                    "c2_goal : Hoare P c Q'",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'",
                    "c2_P : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : Hoare P c Q",
                    "c4_goal : aimp P P",
                    "c5_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Hoare P c Q",
                    "c2_H : Hoare P c Q",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : aimp P P",
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : store) (_ : P s), P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P s), P s",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : aimp Q Q'",
                    "_global_aimp : forall (_ : assertion) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c7_goal : forall (s : store) (_ : Q s), Q' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (s : store) (_ : Q s), Q' s",
                    "c2_H0 : aimp Q Q'",
                    "c2_Q : assertion",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Floyd_assign",
        "proof": [
            {
                "tactic_sig": "Lemma Floyd_assign : forall P x a , \u2983 P \u2984 ASSIGN x a \u2983 aexists ( fun x0 => aexists ( fun v => aequal ( VAR x ) v //\\\\ aupdate x ( CONST x0 ) ( P //\\\\ aequal a v ) ) ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Floyd_assign : forall P x a , \u2983 P \u2984 ASSIGN x a \u2983 aexists ( fun x0 => aexists ( fun v => aequal ( VAR x ) v //\\\\ aupdate x ( CONST x0 ) ( P //\\\\ aequal a v ) ) ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\nHoare P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\nHoare P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))",
                    "c2_P : assertion",
                    "c2_x : ident",
                    "c2_a : aexp"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : Hoare P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c3_goal : Hoare ?P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))",
                    "c4_goal : aimp P ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Hoare ?P (ASSIGN x a)\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v))))))",
                    "_global_Hoare_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Hoare (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c4_goal : aimp P\n  (aupdate x a\n     (aexists\n        (fun x0 : Z =>\n         aexists\n           (fun v : Z =>\n            aand (aequal (VAR x) v)\n              (aupdate x (CONST x0) (aand P (aequal a v)))))))"
                ],
                "tactic_res": [
                    "c5_goal : aupdate x a\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v)))))) s",
                    "c5_s : store",
                    "c5_Ps : P s"
                ]
            },
            {
                "tactic_sig": "set ( x0 := _i _i ) .",
                "tactic_sig_no_out_arg": "set ( x0 := _i _i ) .",
                "tactic_args": [
                    "c5_s : store",
                    "c2_x : ident"
                ],
                "tactic_res": [
                    "c5_x0 : Z"
                ]
            },
            {
                "tactic_sig": "set ( v := aeval _i _i ) .",
                "tactic_sig_no_out_arg": "set ( v := aeval _i _i ) .",
                "tactic_args": [
                    "c2_a : aexp",
                    "c5_s : store"
                ],
                "tactic_res": [
                    "c5_v : Z"
                ]
            },
            {
                "tactic_sig": "set ( s' := update _i _i _i ) .",
                "tactic_sig_no_out_arg": "set ( s' := update _i _i _i ) .",
                "tactic_args": [
                    "c2_x : ident",
                    "c5_v : Z",
                    "c5_s : store"
                ],
                "tactic_res": [
                    "c5_s' : store"
                ]
            },
            {
                "tactic_sig": "set ( s'' := update _i _i _i ) .",
                "tactic_sig_no_out_arg": "set ( s'' := update _i _i _i ) .",
                "tactic_args": [
                    "c2_x : ident",
                    "c5_x0 : Z",
                    "c5_s' : store"
                ],
                "tactic_res": [
                    "c5_s'' : store"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c5_goal : aupdate x a\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v)))))) s",
                    "c5_s'' : store",
                    "c5_s : store"
                ],
                "tactic_res": [
                    "c6_goal : eq s'' s",
                    "c7_goal : aupdate x a\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v)))))) s",
                    "c7_H : eq s'' s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : eq s'' s",
                    "_global_functional_extensionality : forall (f g : forall _ : ?A, ?B)\n         (_ : forall x1 : ?A, eq (f x1) (g x1)), eq f g\nwhere\n?A : [P : assertion\n      x : ident\n      a : aexp\n      s : store\n      Ps : P s\n      x0 := s x : Z\n      v := aeval a s : Z\n      s' := update x v s : store\n      s'' := update x x0 s' : store |- Type]\n?B : [P : assertion\n      x : ident\n      a : aexp\n      s : store\n      Ps : P s\n      x0 := s x : Z\n      v := aeval a s : Z\n      s' := update x v s : store\n      s'' := update x x0 s' : store |- Type]"
                ],
                "tactic_res": [
                    "c8_goal : forall x : ident, eq (s'' x) (s x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall x : ident, eq (s'' x) (s x)"
                ],
                "tactic_res": [
                    "c9_goal : eq (s'' x1) (s x1)",
                    "c9_x1 : ident"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c9_goal : eq (s'' x1) (s x1)",
                    "c5_s'' : store",
                    "c5_s' : store",
                    "_global_update : forall (_ : ident) (_ : Z) (_ : store), store"
                ],
                "tactic_res": [
                    "c10_goal : eq\n  (if string_dec x x1 then x0 else if string_dec x x1 then v else s x1)\n  (s x1)"
                ]
            },
            {
                "tactic_sig": "destruct ( string_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( string_dec _i _i ) .",
                "tactic_args": [
                    "c10_goal : eq\n  (if string_dec x x1 then x0 else if string_dec x x1 then v else s x1)\n  (s x1)",
                    "c2_x : ident",
                    "c9_x1 : ident",
                    "c5_s'' : store",
                    "c5_v : Z",
                    "c5_x0 : Z",
                    "c5_Ps : P s",
                    "c5_s : store"
                ],
                "tactic_res": [
                    "c11_goal : eq x0 (s x1)",
                    "c11_e : eq x x1",
                    "c12_goal : eq (s x1) (s x1)",
                    "c12_n : not (eq x x1)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c11_goal : eq x0 (s x1)",
                    "c9_x1 : ident",
                    "c11_e : eq x x1"
                ],
                "tactic_res": [
                    "c13_goal : eq x0 (s x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq x0 (s x)",
                    "c5_x0 : Z",
                    "c5_s : store",
                    "c2_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq (s x1) (s x1)",
                    "c9_x1 : ident",
                    "c5_s : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : aupdate x a\n  (aexists\n     (fun x0 : Z =>\n      aexists\n        (fun v : Z =>\n         aand (aequal (VAR x) v)\n           (aupdate x (CONST x0) (aand P (aequal a v)))))) s",
                    "_global_aupdate : forall (_ : ident) (_ : aexp) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c14_goal : aexists\n  (fun x0 : Z =>\n   aexists\n     (fun v : Z =>\n      aand (aequal (VAR x) v)\n        (fun s : store =>\n         aand P (aequal a v) (update x (aeval (CONST x0) s) s))))\n  (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c14_goal : aexists\n  (fun x0 : Z =>\n   aexists\n     (fun v : Z =>\n      aand (aequal (VAR x) v)\n        (fun s : store =>\n         aand P (aequal a v) (update x (aeval (CONST x0) s) s))))\n  (update x (aeval a s) s)",
                    "c5_x0 : Z"
                ],
                "tactic_res": [
                    "c15_goal : aexists\n  (fun v : Z =>\n   aand (aequal (VAR x) v)\n     (fun s : store =>\n      aand P (aequal a v) (update x (aeval (CONST x0) s) s)))\n  (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c15_goal : aexists\n  (fun v : Z =>\n   aand (aequal (VAR x) v)\n     (fun s : store =>\n      aand P (aequal a v) (update x (aeval (CONST x0) s) s)))\n  (update x (aeval a s) s)",
                    "c5_v : Z"
                ],
                "tactic_res": [
                    "c16_goal : aand (aequal (VAR x) v)\n  (fun s : store =>\n   aand P (aequal a v) (update x (aeval (CONST x0) s) s))\n  (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : aand (aequal (VAR x) v)\n  (fun s : store =>\n   aand P (aequal a v) (update x (aeval (CONST x0) s) s))\n  (update x (aeval a s) s)"
                ],
                "tactic_res": [
                    "c17_goal : aequal (VAR x) v (update x (aeval a s) s)",
                    "c18_goal : aand P (aequal a v)\n  (update x (aeval (CONST x0) (update x (aeval a s) s))\n     (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c17_goal : aequal (VAR x) v (update x (aeval a s) s)"
                ],
                "tactic_res": [
                    "c19_goal : eq (aeval (VAR x) (update x (aeval a s) s)) v"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c19_goal : eq (aeval (VAR x) (update x (aeval a s) s)) v"
                ],
                "tactic_res": [
                    "c20_goal : eq (update x (aeval a s) s x) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : eq (update x (aeval a s) s x) v",
                    "_global_update_same : forall (x : ident) (v : Z) (s : store), eq (update x v s x) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c18_goal : aand P (aequal a v)\n  (update x (aeval (CONST x0) (update x (aeval a s) s))\n     (update x (aeval a s) s))"
                ],
                "tactic_res": [
                    "c21_goal : aand P (aequal a v) (update x x0 (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "fold _i .",
                "tactic_sig_no_out_arg": "fold _i .",
                "tactic_args": [
                    "c21_goal : aand P (aequal a v) (update x x0 (update x (aeval a s) s))",
                    "c5_v : Z"
                ],
                "tactic_res": [
                    "c22_goal : aand P (aequal a v) (update x x0 (update x v s))"
                ]
            },
            {
                "tactic_sig": "fold _i .",
                "tactic_sig_no_out_arg": "fold _i .",
                "tactic_args": [
                    "c22_goal : aand P (aequal a v) (update x x0 (update x v s))",
                    "c5_s' : store"
                ],
                "tactic_res": [
                    "c23_goal : aand P (aequal a v) (update x x0 s')"
                ]
            },
            {
                "tactic_sig": "fold _i .",
                "tactic_sig_no_out_arg": "fold _i .",
                "tactic_args": [
                    "c23_goal : aand P (aequal a v) (update x x0 s')",
                    "c5_s'' : store"
                ],
                "tactic_res": [
                    "c24_goal : aand P (aequal a v) s''"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : aand P (aequal a v) s''",
                    "c7_H : eq s'' s"
                ],
                "tactic_res": [
                    "c25_goal : aand P (aequal a v) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c25_goal : aand P (aequal a v) s"
                ],
                "tactic_res": [
                    "c26_goal : P s",
                    "c27_goal : aequal a v s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : P s",
                    "c5_Ps : P s",
                    "c5_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c27_goal : aequal a v s"
                ],
                "tactic_res": [
                    "c28_goal : eq (aeval a s) v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : eq (aeval a s) v",
                    "c5_v : Z",
                    "c5_s : store",
                    "c2_a : aexp"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_ifthen",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_ifthen : forall b c P Q , \u2983 atrue b //\\\\ P \u2984 c \u2983 Q \u2984 -> afalse b //\\\\ P -->> Q -> \u2983 P \u2984 IFTHENELSE b c SKIP \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_ifthen : forall b c P Q , \u2983 atrue b //\\\\ P \u2984 c \u2983 Q \u2984 -> afalse b //\\\\ P -->> Q -> \u2983 P \u2984 IFTHENELSE b c SKIP \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (c : com) (P Q : assertion)\n  (_ : Hoare (aand (atrue b) P) c Q) (_ : aimp (aand (afalse b) P) Q),\nHoare P (IFTHENELSE b c SKIP) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (c : com) (P Q : assertion)\n  (_ : Hoare (aand (atrue b) P) c Q) (_ : aimp (aand (afalse b) P) Q),\nHoare P (IFTHENELSE b c SKIP) Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P (IFTHENELSE b c SKIP) Q",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare (aand (atrue b) P) c Q",
                    "c2_H0 : aimp (aand (afalse b) P) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Hoare P (IFTHENELSE b c SKIP) Q",
                    "_global_Hoare_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Hoare (aand (atrue b) P) c1 Q)\n         (_ : Hoare (aand (afalse b) P) c2 Q), Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (aand (atrue b) P) c Q",
                    "c4_goal : Hoare (aand (afalse b) P) SKIP Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Hoare (aand (atrue b) P) c Q",
                    "c2_H : Hoare (aand (atrue b) P) c Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : Hoare (aand (afalse b) P) SKIP Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c5_goal : Hoare Q SKIP Q",
                    "c6_goal : aimp (aand (afalse b) P) Q"
                ]
            },
            {
                "tactic_sig": "auto using Hoare_skip .",
                "tactic_sig_no_out_arg": "auto using Hoare_skip .",
                "tactic_args": [
                    "c5_goal : Hoare Q SKIP Q",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using Hoare_skip .",
                "tactic_sig_no_out_arg": "auto using Hoare_skip .",
                "tactic_args": [
                    "c6_goal : aimp (aand (afalse b) P) Q",
                    "c2_H0 : aimp (aand (afalse b) P) Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_dowhile",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_dowhile : forall P b c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> ( atrue b //\\\\ Q -->> P ) -> \u2983 P \u2984 DOWHILE c b \u2983 afalse b //\\\\ Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_dowhile : forall P b c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> ( atrue b //\\\\ Q -->> P ) -> \u2983 P \u2984 DOWHILE c b \u2983 afalse b //\\\\ Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com) (Q : assertion)\n  (_ : Hoare P c Q) (_ : aimp (aand (atrue b) Q) P),\nHoare P (DOWHILE c b) (aand (afalse b) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com) (Q : assertion)\n  (_ : Hoare P c Q) (_ : aimp (aand (atrue b) Q) P),\nHoare P (DOWHILE c b) (aand (afalse b) Q)"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P (DOWHILE c b) (aand (afalse b) Q)",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_H : Hoare P c Q",
                    "c2_H0 : aimp (aand (atrue b) Q) P"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c2_goal : Hoare P (DOWHILE c b) (aand (afalse b) Q)",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : Hoare P c Q",
                    "c4_goal : Hoare Q (WHILE b c) (aand (afalse b) Q)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Hoare P c Q",
                    "c2_H : Hoare P c Q",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Hoare Q (WHILE b c) (aand (afalse b) Q)",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c5_goal : Hoare (aand (atrue b) Q) c Q"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c5_goal : Hoare (aand (atrue b) Q) c Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c6_goal : Hoare P c Q",
                    "c7_goal : aimp (aand (atrue b) Q) P"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Hoare P c Q",
                    "c2_H : Hoare P c Q",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : aimp (aand (atrue b) Q) P",
                    "c2_H0 : aimp (aand (atrue b) Q) P",
                    "c2_Q : assertion",
                    "c2_b : bexp",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "HOARE_frame",
        "proof": [
            {
                "tactic_sig": "Lemma HOARE_frame : forall R P c Q , \u301a P \u301b c \u301a Q \u301b -> independent R ( assigns c ) -> \u301a P //\\\\ R \u301b c \u301a Q //\\\\ R \u301b .",
                "tactic_sig_no_out_arg": "Lemma HOARE_frame : forall R P c Q , \u301a P \u301b c \u301a Q \u301b -> independent R ( assigns c ) -> \u301a P //\\\\ R \u301b c \u301a Q //\\\\ R \u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R P : assertion) (c : com) (Q : assertion) \n  (_ : HOARE P c Q) (_ : independent R (assigns c)),\nHOARE (aand P R) c (aand Q R)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros R .",
                "tactic_args": [
                    "c1_goal : forall (R P : assertion) (c : com) (Q : assertion) \n  (_ : HOARE P c Q) (_ : independent R (assigns c)),\nHOARE (aand P R) c (aand Q R)"
                ],
                "tactic_res": [
                    "c2_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q)\n  (_ : independent R (assigns c)), HOARE (aand P R) c (aand Q R)",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "assert ( IND_SUB : forall ( vars1 vars2 : ident -> Prop ) , independent _i vars1 -> ( forall x , vars2 x -> vars1 x ) -> independent _i vars2 ) .",
                "tactic_sig_no_out_arg": "assert ( IND_SUB : forall ( vars1 vars2 : ident -> Prop ) , independent _i vars1 -> ( forall x , vars2 x -> vars1 x ) -> independent _i vars2 ) .",
                "tactic_args": [
                    "c2_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q)\n  (_ : independent R (assigns c)), HOARE (aand P R) c (aand Q R)",
                    "c2_R : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c3_goal : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2",
                    "c4_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q)\n  (_ : independent R (assigns c)), HOARE (aand P R) c (aand Q R)",
                    "c4_IND_SUB : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2",
                    "_global_independent : forall (_ : assertion) (_ : forall _ : ident, Prop), Prop"
                ],
                "tactic_res": [
                    "c5_goal : forall (vars1 vars2 : forall _ : ident, Prop)\n  (_ : forall (s1 s2 : store)\n         (_ : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x))\n         (_ : R s1), R s2)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x) \n  (s1 s2 : store)\n  (_ : forall (x : ident) (_ : not (vars2 x)), eq (s1 x) (s2 x))\n  (_ : R s1), R s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (vars1 vars2 : forall _ : ident, Prop)\n  (_ : forall (s1 s2 : store)\n         (_ : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x))\n         (_ : R s1), R s2)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x) \n  (s1 s2 : store)\n  (_ : forall (x : ident) (_ : not (vars2 x)), eq (s1 x) (s2 x))\n  (_ : R s1), R s2"
                ],
                "tactic_res": [
                    "c6_goal : R s2",
                    "c6_vars1 : forall _ : ident, Prop",
                    "c6_vars2 : forall _ : ident, Prop",
                    "c6_H : forall (s1 s2 : store)\n  (_ : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x))\n  (_ : R s1), R s2",
                    "c6_H0 : forall (x : ident) (_ : vars2 x), vars1 x",
                    "c6_s1 : store",
                    "c6_s2 : store",
                    "c6_H1 : forall (x : ident) (_ : not (vars2 x)), eq (s1 x) (s2 x)",
                    "c6_H2 : R s1"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c6_goal : R s2",
                    "c6_H : forall (s1 s2 : store)\n  (_ : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x))\n  (_ : R s1), R s2",
                    "c6_s1 : store"
                ],
                "tactic_res": [
                    "c7_goal : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x)",
                    "c8_goal : R s1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (x : ident) (_ : not (vars1 x)), eq (s1 x) (s2 x)",
                    "c6_H1 : forall (x : ident) (_ : not (vars2 x)), eq (s1 x) (s2 x)",
                    "c6_s1 : store",
                    "c6_s2 : store",
                    "c6_H0 : forall (x : ident) (_ : vars2 x), vars1 x",
                    "c6_vars1 : forall _ : ident, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : R s1",
                    "c6_H2 : R s1",
                    "c6_s1 : store",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c4_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q)\n  (_ : independent R (assigns c)), HOARE (aand P R) c (aand Q R)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : independent R (assigns SKIP),\nHOARE (aand P R) SKIP (aand P R)",
                    "c9_P : assertion",
                    "c10_goal : forall _ : independent R (assigns (ASSIGN x a)),\nHOARE (aand (aupdate x a P) R) (ASSIGN x a) (aand P R)",
                    "c10_a : aexp",
                    "c10_x : ident",
                    "c10_P : assertion",
                    "c11_goal : forall _ : independent R (assigns (SEQ c1 c2)),\nHOARE (aand P R) (SEQ c1 c2) (aand R0 R)",
                    "c11_IHHOARE2 : forall _ : independent R (assigns c2), HOARE (aand Q R) c2 (aand R0 R)",
                    "c11_IHHOARE1 : forall _ : independent R (assigns c1), HOARE (aand P R) c1 (aand Q R)",
                    "c11_H0 : HOARE Q c2 R0",
                    "c11_H : HOARE P c1 Q",
                    "c11_c2 : com",
                    "c11_c1 : com",
                    "c11_R0 : assertion",
                    "c11_Q : assertion",
                    "c11_P : assertion",
                    "c12_goal : forall _ : independent R (assigns (IFTHENELSE b c1 c2)),\nHOARE (aand P R) (IFTHENELSE b c1 c2) (aand Q R)",
                    "c12_IHHOARE2 : forall _ : independent R (assigns c2),\nHOARE (aand (aand (afalse b) P) R) c2 (aand Q R)",
                    "c12_IHHOARE1 : forall _ : independent R (assigns c1),\nHOARE (aand (aand (atrue b) P) R) c1 (aand Q R)",
                    "c12_H0 : HOARE (aand (afalse b) P) c2 Q",
                    "c12_H : HOARE (aand (atrue b) P) c1 Q",
                    "c12_c2 : com",
                    "c12_c1 : com",
                    "c12_b : bexp",
                    "c12_Q : assertion",
                    "c12_P : assertion",
                    "c13_goal : forall _ : independent R (assigns (WHILE b c)),\nHOARE (aand P R) (WHILE b c) (aand (aand (afalse b) P) R)",
                    "c13_H0 : forall (v : Z) (_ : independent R (assigns c)),\nHOARE (aand (aand (atrue b) (aand (aequal a v) P)) R) c\n  (aand (aand (alessthan a v) P) R)",
                    "c13_H : forall v : Z,\nHOARE (aand (atrue b) (aand (aequal a v) P)) c (aand (alessthan a v) P)",
                    "c13_a : aexp",
                    "c13_c : com",
                    "c13_b : bexp",
                    "c13_P : assertion",
                    "c14_goal : forall _ : independent R (assigns (HAVOC x)),\nHOARE (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R) \n  (HAVOC x) (aand Q R)",
                    "c14_Q : assertion",
                    "c14_x : ident",
                    "c15_goal : forall _ : independent R (assigns (ASSERT b)),\nHOARE (aand (aand (atrue b) P) R) (ASSERT b)\n  (aand (aand (atrue b) P) R)",
                    "c15_b : bexp",
                    "c15_P : assertion",
                    "c16_goal : forall _ : independent R (assigns c), HOARE (aand P' R) c (aand Q' R)",
                    "c16_IHHOARE : forall _ : independent R (assigns c), HOARE (aand P R) c (aand Q R)",
                    "c16_H1 : aimp Q Q'",
                    "c16_H0 : aimp P' P",
                    "c16_H : HOARE P c Q",
                    "c16_c : com",
                    "c16_Q' : assertion",
                    "c16_P' : assertion",
                    "c16_Q : assertion",
                    "c16_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c9_goal : forall _ : independent R (assigns SKIP),\nHOARE (aand P R) SKIP (aand P R)"
                ],
                "tactic_res": [
                    "c17_goal : HOARE (aand P R) SKIP (aand P R)",
                    "c17_IND : independent R (assigns SKIP)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c17_IND : independent R (assigns SKIP)"
                ],
                "tactic_res": [
                    "c17_IND : independent R (fun _ : ident => False)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c10_goal : forall _ : independent R (assigns (ASSIGN x a)),\nHOARE (aand (aupdate x a P) R) (ASSIGN x a) (aand P R)"
                ],
                "tactic_res": [
                    "c18_goal : HOARE (aand (aupdate x a P) R) (ASSIGN x a) (aand P R)",
                    "c18_IND : independent R (assigns (ASSIGN x a))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c18_IND : independent R (assigns (ASSIGN x a))"
                ],
                "tactic_res": [
                    "c18_IND : independent R (fun x0 : ident => eq x0 x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c11_goal : forall _ : independent R (assigns (SEQ c1 c2)),\nHOARE (aand P R) (SEQ c1 c2) (aand R0 R)"
                ],
                "tactic_res": [
                    "c19_goal : HOARE (aand P R) (SEQ c1 c2) (aand R0 R)",
                    "c19_IND : independent R (assigns (SEQ c1 c2))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c19_IND : independent R (assigns (SEQ c1 c2))"
                ],
                "tactic_res": [
                    "c19_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c12_goal : forall _ : independent R (assigns (IFTHENELSE b c1 c2)),\nHOARE (aand P R) (IFTHENELSE b c1 c2) (aand Q R)"
                ],
                "tactic_res": [
                    "c20_goal : HOARE (aand P R) (IFTHENELSE b c1 c2) (aand Q R)",
                    "c20_IND : independent R (assigns (IFTHENELSE b c1 c2))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c20_IND : independent R (assigns (IFTHENELSE b c1 c2))"
                ],
                "tactic_res": [
                    "c20_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c13_goal : forall _ : independent R (assigns (WHILE b c)),\nHOARE (aand P R) (WHILE b c) (aand (aand (afalse b) P) R)"
                ],
                "tactic_res": [
                    "c21_goal : HOARE (aand P R) (WHILE b c) (aand (aand (afalse b) P) R)",
                    "c21_IND : independent R (assigns (WHILE b c))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c21_IND : independent R (assigns (WHILE b c))"
                ],
                "tactic_res": [
                    "c21_IND : independent R (fun x : ident => assigns c x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c14_goal : forall _ : independent R (assigns (HAVOC x)),\nHOARE (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R) \n  (HAVOC x) (aand Q R)"
                ],
                "tactic_res": [
                    "c22_goal : HOARE (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R) \n  (HAVOC x) (aand Q R)",
                    "c22_IND : independent R (assigns (HAVOC x))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c22_IND : independent R (assigns (HAVOC x))"
                ],
                "tactic_res": [
                    "c22_IND : independent R (fun x0 : ident => eq x0 x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c15_goal : forall _ : independent R (assigns (ASSERT b)),\nHOARE (aand (aand (atrue b) P) R) (ASSERT b)\n  (aand (aand (atrue b) P) R)"
                ],
                "tactic_res": [
                    "c23_goal : HOARE (aand (aand (atrue b) P) R) (ASSERT b)\n  (aand (aand (atrue b) P) R)",
                    "c23_IND : independent R (assigns (ASSERT b))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c23_IND : independent R (assigns (ASSERT b))"
                ],
                "tactic_res": [
                    "c23_IND : independent R (fun _ : ident => False)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros IND .",
                "tactic_args": [
                    "c16_goal : forall _ : independent R (assigns c), HOARE (aand P' R) c (aand Q' R)"
                ],
                "tactic_res": [
                    "c24_goal : HOARE (aand P' R) c (aand Q' R)",
                    "c24_IND : independent R (assigns c)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c24_IND : independent R (assigns c)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : HOARE (aand P R) SKIP (aand P R)",
                    "_global_HOARE_skip : forall P : assertion, HOARE P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( Q := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( Q := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c18_goal : HOARE (aand (aupdate x a P) R) (ASSIGN x a) (aand P R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "c10_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c25_goal : HOARE ?P (ASSIGN x a) (aand P R)",
                    "c26_goal : aimp (aand (aupdate x a P) R) (aupdate x a (aand P R))",
                    "c27_goal : aimp (aand P R) (aand P R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : HOARE ?P (ASSIGN x a) (aand P R)",
                    "_global_HOARE_assign : forall (P : assertion) (x : ident) (a : aexp),\n       HOARE (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c26_goal : aimp (aand (aupdate x a P) R) (aupdate x a (aand P R))",
                    "_global_aupdate : forall (_ : ident) (_ : aexp) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c28_goal : aimp (aand (fun s : store => P (update x (aeval a s) s)) R)\n  (fun s : store => aand P R (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ A B ] .",
                "tactic_args": [
                    "c28_goal : aimp (aand (fun s : store => P (update x (aeval a s) s)) R)\n  (fun s : store => aand P R (update x (aeval a s) s))"
                ],
                "tactic_res": [
                    "c29_goal : aand P R (update x (aeval a s) s)",
                    "c29_s : store",
                    "c29_A : P (update x (aeval a s) s)",
                    "c29_B : R s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c29_goal : aand P R (update x (aeval a s) s)"
                ],
                "tactic_res": [
                    "c30_goal : P (update x (aeval a s) s)",
                    "c31_goal : R (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : P (update x (aeval a s) s)",
                    "c29_A : P (update x (aeval a s) s)",
                    "c29_s : store",
                    "c10_a : aexp",
                    "c10_x : ident",
                    "c10_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c31_goal : R (update x (aeval a s) s)",
                    "c18_IND : independent R (fun x0 : ident => eq x0 x)",
                    "c29_s : store"
                ],
                "tactic_res": [
                    "c32_goal : forall (x0 : ident) (_ : not (eq x0 x)),\neq (s x0) (update x (aeval a s) s x0)",
                    "c33_goal : R s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : R s",
                    "c29_B : R s",
                    "c29_s : store",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros y DIFF .",
                "tactic_args": [
                    "c32_goal : forall (x0 : ident) (_ : not (eq x0 x)),\neq (s x0) (update x (aeval a s) s x0)"
                ],
                "tactic_res": [
                    "c34_goal : eq (s y) (update x (aeval a s) s y)",
                    "c34_y : ident",
                    "c34_DIFF : not (eq y x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c34_goal : eq (s y) (update x (aeval a s) s y)",
                    "_global_update_other : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\n       eq (update x v s y) (s y)"
                ],
                "tactic_res": [
                    "c35_goal : eq (s y) (s y)",
                    "c36_goal : not (eq x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq (s y) (s y)",
                    "c34_y : ident",
                    "c29_s : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : not (eq x y)",
                    "c34_DIFF : not (eq y x)",
                    "c34_y : ident",
                    "c10_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c27_goal : aimp (aand P R) (aand P R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i //\\\\ _i ) .",
                "tactic_args": [
                    "c19_goal : HOARE (aand P R) (SEQ c1 c2) (aand R0 R)",
                    "_global_HOARE_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : HOARE P c1 Q)\n         (_ : HOARE Q c2 R), HOARE P (SEQ c1 c2) R",
                    "c11_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c37_goal : HOARE (aand P R) c1 (aand Q R)",
                    "c38_goal : HOARE (aand Q R) c2 (aand R0 R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : HOARE (aand P R) c1 (aand Q R)",
                    "c11_IHHOARE1 : forall _ : independent R (assigns c1), HOARE (aand P R) c1 (aand Q R)"
                ],
                "tactic_res": [
                    "c39_goal : independent R (assigns c1)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c39_goal : independent R (assigns c1)",
                    "c4_IND_SUB : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2"
                ],
                "tactic_res": [
                    "c40_goal : independent R ?vars1",
                    "c41_goal : forall (x : ident) (_ : assigns c1 x), ?vars1 x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : independent R ?vars1",
                    "c19_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c41_goal : forall (x : ident) (_ : assigns c1 x),\n(fun x0 : ident => or (assigns c1 x0) (assigns c2 x0)) x"
                ],
                "tactic_res": [
                    "c42_goal : forall (x : ident) (_ : assigns c1 x), or (assigns c1 x) (assigns c2 x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c42_goal : forall (x : ident) (_ : assigns c1 x), or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": [
                    "c43_goal : or (assigns c1 x) (assigns c2 x)",
                    "c43_x : ident",
                    "c43_H1 : assigns c1 x"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c43_goal : or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : HOARE (aand Q R) c2 (aand R0 R)",
                    "c11_IHHOARE2 : forall _ : independent R (assigns c2), HOARE (aand Q R) c2 (aand R0 R)"
                ],
                "tactic_res": [
                    "c44_goal : independent R (assigns c2)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c44_goal : independent R (assigns c2)",
                    "c4_IND_SUB : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2"
                ],
                "tactic_res": [
                    "c45_goal : independent R ?vars1",
                    "c46_goal : forall (x : ident) (_ : assigns c2 x), ?vars1 x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c45_goal : independent R ?vars1",
                    "c19_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c46_goal : forall (x : ident) (_ : assigns c2 x),\n(fun x0 : ident => or (assigns c1 x0) (assigns c2 x0)) x"
                ],
                "tactic_res": [
                    "c47_goal : forall (x : ident) (_ : assigns c2 x), or (assigns c1 x) (assigns c2 x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c47_goal : forall (x : ident) (_ : assigns c2 x), or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": [
                    "c48_goal : or (assigns c1 x) (assigns c2 x)",
                    "c48_x : ident",
                    "c48_H1 : assigns c2 x"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c48_goal : or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : HOARE (aand P R) (IFTHENELSE b c1 c2) (aand Q R)",
                    "_global_HOARE_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : HOARE (aand (atrue b) P) c1 Q)\n         (_ : HOARE (aand (afalse b) P) c2 Q), HOARE P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c49_goal : HOARE (aand (atrue b) (aand P R)) c1 (aand Q R)",
                    "c50_goal : HOARE (aand (afalse b) (aand P R)) c2 (aand Q R)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c49_goal : HOARE (aand (atrue b) (aand P R)) c1 (aand Q R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "c12_Q : assertion",
                    "c12_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c51_goal : HOARE ?P c1 (aand Q R)",
                    "c52_goal : aimp (aand (atrue b) (aand P R)) (aand (aand (atrue b) P) R)",
                    "c53_goal : aimp (aand Q R) (aand Q R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c51_goal : HOARE ?P c1 (aand Q R)",
                    "c12_IHHOARE1 : forall _ : independent R (assigns c1),\nHOARE (aand (aand (atrue b) P) R) c1 (aand Q R)"
                ],
                "tactic_res": [
                    "c54_goal : independent R (assigns c1)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c54_goal : independent R (assigns c1)",
                    "c4_IND_SUB : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2"
                ],
                "tactic_res": [
                    "c55_goal : independent R ?vars1",
                    "c56_goal : forall (x : ident) (_ : assigns c1 x), ?vars1 x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c55_goal : independent R ?vars1",
                    "c20_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c56_goal : forall (x : ident) (_ : assigns c1 x),\n(fun x0 : ident => or (assigns c1 x0) (assigns c2 x0)) x"
                ],
                "tactic_res": [
                    "c57_goal : forall (x : ident) (_ : assigns c1 x), or (assigns c1 x) (assigns c2 x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c57_goal : forall (x : ident) (_ : assigns c1 x), or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": [
                    "c58_goal : or (assigns c1 x) (assigns c2 x)",
                    "c58_x : ident",
                    "c58_H1 : assigns c1 x"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c58_goal : or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c52_goal : aimp (aand (atrue b) (aand P R)) (aand (aand (atrue b) P) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c53_goal : aimp (aand Q R) (aand Q R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c50_goal : HOARE (aand (afalse b) (aand P R)) c2 (aand Q R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "c12_Q : assertion",
                    "c12_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c59_goal : HOARE ?P c2 (aand Q R)",
                    "c60_goal : aimp (aand (afalse b) (aand P R)) (aand (aand (afalse b) P) R)",
                    "c61_goal : aimp (aand Q R) (aand Q R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c59_goal : HOARE ?P c2 (aand Q R)",
                    "c12_IHHOARE2 : forall _ : independent R (assigns c2),\nHOARE (aand (aand (afalse b) P) R) c2 (aand Q R)"
                ],
                "tactic_res": [
                    "c62_goal : independent R (assigns c2)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c62_goal : independent R (assigns c2)",
                    "c4_IND_SUB : forall (vars1 vars2 : forall _ : ident, Prop) (_ : independent R vars1)\n  (_ : forall (x : ident) (_ : vars2 x), vars1 x), \nindependent R vars2"
                ],
                "tactic_res": [
                    "c63_goal : independent R ?vars1",
                    "c64_goal : forall (x : ident) (_ : assigns c2 x), ?vars1 x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c63_goal : independent R ?vars1",
                    "c20_IND : independent R (fun x : ident => or (assigns c1 x) (assigns c2 x))",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c64_goal : forall (x : ident) (_ : assigns c2 x),\n(fun x0 : ident => or (assigns c1 x0) (assigns c2 x0)) x"
                ],
                "tactic_res": [
                    "c65_goal : forall (x : ident) (_ : assigns c2 x), or (assigns c1 x) (assigns c2 x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c65_goal : forall (x : ident) (_ : assigns c2 x), or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": [
                    "c66_goal : or (assigns c1 x) (assigns c2 x)",
                    "c66_x : ident",
                    "c66_H1 : assigns c2 x"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c66_goal : or (assigns c1 x) (assigns c2 x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c60_goal : aimp (aand (afalse b) (aand P R)) (aand (aand (afalse b) P) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c61_goal : aimp (aand Q R) (aand Q R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c21_goal : HOARE (aand P R) (WHILE b c) (aand (aand (afalse b) P) R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "c13_P : assertion",
                    "c13_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c67_goal : HOARE (aand P R) (WHILE b c) ?Q",
                    "c68_goal : aimp (aand P R) (aand P R)",
                    "c69_goal : aimp (aand (afalse b) (aand P R)) (aand (aand (afalse b) P) R)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c67_goal : HOARE (aand P R) (WHILE b c) ?Q",
                    "_global_HOARE_while : forall (P : assertion) (b : bexp) (c : com) \n         (a : aexp)\n         (_ : forall v : Z,\n              HOARE (aand (atrue b) (aand (aequal a v) P)) c\n                (aand (alessthan a v) P)),\n       HOARE P (WHILE b c) (aand (afalse b) P)",
                    "c13_a : aexp"
                ],
                "tactic_res": [
                    "c70_goal : forall v : Z,\nHOARE (aand (atrue b) (aand (aequal a v) (aand P R))) c\n  (aand (alessthan a v) (aand P R))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c70_goal : forall v : Z,\nHOARE (aand (atrue b) (aand (aequal a v) (aand P R))) c\n  (aand (alessthan a v) (aand P R))"
                ],
                "tactic_res": [
                    "c71_goal : HOARE (aand (atrue b) (aand (aequal a v) (aand P R))) c\n  (aand (alessthan a v) (aand P R))",
                    "c71_v : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c71_goal : HOARE (aand (atrue b) (aand (aequal a v) (aand P R))) c\n  (aand (alessthan a v) (aand P R))",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'"
                ],
                "tactic_res": [
                    "c72_goal : HOARE ?P c ?Q",
                    "c73_goal : aimp (aand (atrue b) (aand (aequal a v) (aand P R))) ?P",
                    "c74_goal : aimp (aand (aand (alessthan a v) P) R)\n  (aand (alessthan a v) (aand P R))"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c72_goal : HOARE ?P c ?Q",
                    "c13_H0 : forall (v : Z) (_ : independent R (assigns c)),\nHOARE (aand (aand (atrue b) (aand (aequal a v) P)) R) c\n  (aand (aand (alessthan a v) P) R)",
                    "c71_v : Z"
                ],
                "tactic_res": [
                    "c75_goal : independent R (assigns c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c75_goal : independent R (assigns c)",
                    "c21_IND : independent R (fun x : ident => assigns c x)",
                    "c13_c : com",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c73_goal : aimp (aand (atrue b) (aand (aequal a v) (aand P R)))\n  (aand (aand (atrue b) (aand (aequal a v) P)) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c74_goal : aimp (aand (aand (alessthan a v) P) R)\n  (aand (alessthan a v) (aand P R))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c68_goal : aimp (aand P R) (aand P R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c69_goal : aimp (aand (afalse b) (aand P R)) (aand (aand (afalse b) P) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c22_goal : HOARE (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R) \n  (HAVOC x) (aand Q R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "c14_Q : assertion",
                    "c14_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c76_goal : HOARE ?P (HAVOC x) (aand Q R)",
                    "c77_goal : aimp (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R) ?P",
                    "c78_goal : aimp (aand Q R) (aand Q R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c76_goal : HOARE ?P (HAVOC x) (aand Q R)",
                    "_global_HOARE_havoc : forall (x : ident) (Q : assertion),\n       HOARE (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] _o .",
                "tactic_sig_no_out_arg": "intros s [ A B ] n .",
                "tactic_args": [
                    "c77_goal : aimp (aand (aforall (fun n : Z => aupdate x (CONST n) Q)) R)\n  (aforall (fun n : Z => aupdate x (CONST n) (aand Q R)))"
                ],
                "tactic_res": [
                    "c79_goal : aupdate x (CONST n) (aand Q R) s",
                    "c79_s : store",
                    "c79_A : aforall (fun n : Z => aupdate x (CONST n) Q) s",
                    "c79_B : R s",
                    "c79_n : Z"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c79_goal : aupdate x (CONST n) (aand Q R) s"
                ],
                "tactic_res": [
                    "c80_goal : Q (update x (aeval (CONST n) s) s)",
                    "c81_goal : R (update x (aeval (CONST n) s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c80_goal : Q (update x (aeval (CONST n) s) s)",
                    "c79_A : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c81_goal : R (update x (aeval (CONST n) s) s)",
                    "c22_IND : independent R (fun x0 : ident => eq x0 x)",
                    "c79_s : store"
                ],
                "tactic_res": [
                    "c82_goal : forall (x0 : ident) (_ : not (eq x0 x)),\neq (s x0) (update x (aeval (CONST n) s) s x0)",
                    "c83_goal : R s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c83_goal : R s",
                    "c79_B : R s",
                    "c79_s : store",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros y DIFF .",
                "tactic_args": [
                    "c82_goal : forall (x0 : ident) (_ : not (eq x0 x)),\neq (s x0) (update x (aeval (CONST n) s) s x0)"
                ],
                "tactic_res": [
                    "c84_goal : eq (s y) (update x (aeval (CONST n) s) s y)",
                    "c84_y : ident",
                    "c84_DIFF : not (eq y x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c84_goal : eq (s y) (update x (aeval (CONST n) s) s y)",
                    "_global_update_other : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\n       eq (update x v s y) (s y)"
                ],
                "tactic_res": [
                    "c85_goal : eq (s y) (s y)",
                    "c86_goal : not (eq x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c85_goal : eq (s y) (s y)",
                    "c84_y : ident",
                    "c79_s : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : not (eq x y)",
                    "c84_DIFF : not (eq y x)",
                    "c84_y : ident",
                    "c14_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c78_goal : aimp (aand Q R) (aand Q R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c23_goal : HOARE (aand (aand (atrue b) P) R) (ASSERT b)\n  (aand (aand (atrue b) P) R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'"
                ],
                "tactic_res": [
                    "c87_goal : HOARE ?P (ASSERT b) ?Q",
                    "c88_goal : aimp (aand (aand (atrue b) P) R) (aand (atrue b) (aand P R))",
                    "c89_goal : aimp (aand (atrue b) (aand P R)) (aand (aand (atrue b) P) R)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c87_goal : HOARE ?P (ASSERT b) ?Q",
                    "_global_HOARE_assert : forall (P : assertion) (b : bexp),\n       HOARE (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c15_P : assertion",
                    "c15_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c88_goal : aimp (aand (aand (atrue b) P) R) (aand (atrue b) (aand P R))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c89_goal : aimp (aand (atrue b) (aand P R)) (aand (aand (atrue b) P) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c24_goal : HOARE (aand P' R) c (aand Q' R)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'"
                ],
                "tactic_res": [
                    "c90_goal : HOARE ?P c ?Q",
                    "c91_goal : aimp (aand P' R) (aand P R)",
                    "c92_goal : aimp (aand Q R) (aand Q' R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c90_goal : HOARE ?P c ?Q",
                    "c16_IHHOARE : forall _ : independent R (assigns c), HOARE (aand P R) c (aand Q R)"
                ],
                "tactic_res": [
                    "c93_goal : independent R (assigns c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c93_goal : independent R (assigns c)",
                    "c24_IND : independent R (assigns c)",
                    "c16_c : com",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ A B ] .",
                "tactic_args": [
                    "c91_goal : aimp (aand P' R) (aand P R)"
                ],
                "tactic_res": [
                    "c94_goal : aand P R s",
                    "c94_s : store",
                    "c94_A : P' s",
                    "c94_B : R s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c94_goal : aand P R s"
                ],
                "tactic_res": [
                    "c95_goal : P s",
                    "c96_goal : R s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c95_goal : P s",
                    "c94_A : P' s",
                    "c94_s : store",
                    "c16_H0 : aimp P' P",
                    "c16_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c96_goal : R s",
                    "c94_B : R s",
                    "c94_s : store",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ A B ] .",
                "tactic_args": [
                    "c92_goal : aimp (aand Q R) (aand Q' R)"
                ],
                "tactic_res": [
                    "c97_goal : aand Q' R s",
                    "c97_s : store",
                    "c97_A : Q s",
                    "c97_B : R s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c97_goal : aand Q' R s"
                ],
                "tactic_res": [
                    "c98_goal : Q' s",
                    "c99_goal : R s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c98_goal : Q' s",
                    "c97_A : Q s",
                    "c97_s : store",
                    "c16_H1 : aimp Q Q'",
                    "c16_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c99_goal : R s",
                    "c97_B : R s",
                    "c97_s : store",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "HOARE_for",
        "proof": [
            {
                "tactic_sig": "Lemma HOARE_for : forall l h i c P , \u301a atrue ( LESSEQUAL ( VAR i ) ( VAR h ) ) //\\\\ P \u301b c \u301a aupdate i ( PLUS ( VAR i ) ( CONST 1 ) ) P \u301b -> ~ assigns c i -> ~ assigns c h -> i <> h -> \u301a aupdate i l P \u301b FOR i l h c \u301a afalse ( LESSEQUAL ( VAR i ) ( VAR h ) ) //\\\\ P \u301b .",
                "tactic_sig_no_out_arg": "Lemma HOARE_for : forall l h i c P , \u301a atrue ( LESSEQUAL ( VAR i ) ( VAR h ) ) //\\\\ P \u301b c \u301a aupdate i ( PLUS ( VAR i ) ( CONST 1 ) ) P \u301b -> ~ assigns c i -> ~ assigns c h -> i <> h -> \u301a aupdate i l P \u301b FOR i l h c \u301a afalse ( LESSEQUAL ( VAR i ) ( VAR h ) ) //\\\\ P \u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : aexp) (h i : ident) (c : com) (P : assertion)\n  (_ : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n         (aupdate i (PLUS (VAR i) (CONST 1)) P))\n  (_ : not (assigns c i)) (_ : not (assigns c h)) \n  (_ : not (eq i h)),\nHOARE (aupdate i l P) (FOR i l h c)\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : aexp) (h i : ident) (c : com) (P : assertion)\n  (_ : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n         (aupdate i (PLUS (VAR i) (CONST 1)) P))\n  (_ : not (assigns c i)) (_ : not (assigns c h)) \n  (_ : not (eq i h)),\nHOARE (aupdate i l P) (FOR i l h c)\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)"
                ],
                "tactic_res": [
                    "c2_goal : HOARE (aupdate i l P) (FOR i l h c)\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)",
                    "c2_l : aexp",
                    "c2_h : ident",
                    "c2_i : ident",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_H : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n  (aupdate i (PLUS (VAR i) (CONST 1)) P)",
                    "c2_H0 : not (assigns c i)",
                    "c2_H1 : not (assigns c h)",
                    "c2_H2 : not (eq i h)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c2_goal : HOARE (aupdate i l P) (FOR i l h c)\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)",
                    "_global_HOARE_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : HOARE P c1 Q)\n         (_ : HOARE Q c2 R), HOARE P (SEQ c1 c2) R",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c3_goal : HOARE (aupdate i l P) (ASSIGN i l) P",
                    "c4_goal : HOARE P\n  (WHILE (LESSEQUAL (VAR i) (VAR h))\n     (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1)))))\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : HOARE (aupdate i l P) (ASSIGN i l) P",
                    "_global_HOARE_assign : forall (P : assertion) (x : ident) (a : aexp),\n       HOARE (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( variant := PLUS ( MINUS ( VAR _i ) ( VAR _i ) ) ( CONST 1 ) ) .",
                "tactic_sig_no_out_arg": "set ( variant := PLUS ( MINUS ( VAR _i ) ( VAR _i ) ) ( CONST 1 ) ) .",
                "tactic_args": [
                    "c2_h : ident",
                    "c2_i : ident"
                ],
                "tactic_res": [
                    "c4_variant : aexp"
                ]
            },
            {
                "tactic_sig": "apply _i with ( a := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( a := _i ) .",
                "tactic_args": [
                    "c4_goal : HOARE P\n  (WHILE (LESSEQUAL (VAR i) (VAR h))\n     (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1)))))\n  (aand (afalse (LESSEQUAL (VAR i) (VAR h))) P)",
                    "_global_HOARE_while : forall (P : assertion) (b : bexp) (c : com) \n         (a : aexp)\n         (_ : forall v : Z,\n              HOARE (aand (atrue b) (aand (aequal a v) P)) c\n                (aand (alessthan a v) P)),\n       HOARE P (WHILE b c) (aand (afalse b) P)",
                    "c4_variant : aexp"
                ],
                "tactic_res": [
                    "c5_goal : forall v : Z,\nHOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1))))\n  (aand (alessthan variant v) P)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro v .",
                "tactic_args": [
                    "c5_goal : forall v : Z,\nHOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1))))\n  (aand (alessthan variant v) P)"
                ],
                "tactic_res": [
                    "c6_goal : HOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1))))\n  (aand (alessthan variant v) P)",
                    "c6_v : Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c6_goal : HOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (SEQ c (ASSIGN i (PLUS (VAR i) (CONST 1))))\n  (aand (alessthan variant v) P)",
                    "_global_HOARE_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : HOARE P c1 Q)\n         (_ : HOARE Q c2 R), HOARE P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c7_goal : HOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  c ?Q",
                    "c8_goal : HOARE ?Q (ASSIGN i (PLUS (VAR i) (CONST 1)))\n  (aand (alessthan variant v) P)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : HOARE\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  c ?Q",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'"
                ],
                "tactic_res": [
                    "c9_goal : HOARE ?P c ?Q0",
                    "c10_goal : aimp\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (aand (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))))",
                    "c11_goal : aimp ?Q0 ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i with ( R := _i _i _i //\\\\ _i ( _i ( _i _i ) ( _i _i ) ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( R := _i _i _i //\\\\ _i ( _i ( _i _i ) ( _i _i ) ) ) .",
                "tactic_args": [
                    "c9_goal : HOARE ?P c ?Q0",
                    "_global_HOARE_frame : forall (R P : assertion) (c : com) (Q : assertion) \n         (_ : HOARE P c Q) (_ : independent R (assigns c)),\n       HOARE (aand P R) c (aand Q R)",
                    "_global_aequal : forall (_ : aexp) (_ : Z), assertion",
                    "c4_variant : aexp",
                    "c6_v : Z",
                    "_global_atrue : forall _ : bexp, assertion",
                    "_global_LESSEQUAL : forall (_ : aexp) (_ : aexp), bexp",
                    "_global_VAR : forall _ : ident, aexp",
                    "c2_i : ident",
                    "_global_VAR : forall _ : ident, aexp",
                    "c2_h : ident"
                ],
                "tactic_res": [
                    "c12_goal : HOARE ?P c ?Q0",
                    "c13_goal : independent\n  (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))))\n  (assigns c)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : HOARE ?P c ?Q0",
                    "c2_H : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n  (aupdate i (PLUS (VAR i) (CONST 1)) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 E .",
                "tactic_args": [
                    "c13_goal : independent\n  (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))))\n  (assigns c)"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  _ : aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))) s1,\naand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))) s2",
                    "c14_s1 : store",
                    "c14_s2 : store",
                    "c14_E : forall (x : ident) (_ : not (assigns c x)), eq (s1 x) (s2 x)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))) s1,\naand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))) s2",
                    "_global_aequal : forall (_ : aexp) (_ : Z), assertion",
                    "_global_atrue : forall _ : bexp, assertion",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c15_goal : forall\n  _ : and (eq (aeval variant s1) v)\n        (eq (beval (LESSEQUAL (VAR i) (VAR h)) s1) true),\nand (eq (aeval variant s2) v)\n  (eq (beval (LESSEQUAL (VAR i) (VAR h)) s2) true)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall\n  _ : and (eq (aeval variant s1) v)\n        (eq (beval (LESSEQUAL (VAR i) (VAR h)) s1) true),\nand (eq (aeval variant s2) v)\n  (eq (beval (LESSEQUAL (VAR i) (VAR h)) s2) true)"
                ],
                "tactic_res": [
                    "c16_goal : forall\n  _ : and (eq (Z.add (Z.sub (s1 h) (s1 i)) 1) v)\n        (eq (Z.leb (s1 i) (s1 h)) true),\nand (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n  (eq (Z.leb (s2 i) (s2 h)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , ( _i _i ) by auto .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , ( _i _i ) by auto .",
                "tactic_args": [
                    "c16_goal : forall\n  _ : and (eq (Z.add (Z.sub (s1 h) (s1 i)) 1) v)\n        (eq (Z.leb (s1 i) (s1 h)) true),\nand (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n  (eq (Z.leb (s2 i) (s2 h)) true)",
                    "c14_E : forall (x : ident) (_ : not (assigns c x)), eq (s1 x) (s2 x)",
                    "c2_i : ident",
                    "c14_E : forall (x : ident) (_ : not (assigns c x)), eq (s1 x) (s2 x)",
                    "c2_h : ident",
                    "c14_s1 : store",
                    "c14_s2 : store",
                    "c6_v : Z",
                    "c4_variant : aexp",
                    "c2_H2 : not (eq i h)",
                    "c2_H1 : not (assigns c h)",
                    "c2_H0 : not (assigns c i)",
                    "c2_H : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n  (aupdate i (PLUS (VAR i) (CONST 1)) P)",
                    "c2_l : aexp"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : and (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n        (eq (Z.leb (s2 i) (s2 h)) true),\nand (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n  (eq (Z.leb (s2 i) (s2 h)) true)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : and (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n        (eq (Z.leb (s2 i) (s2 h)) true),\nand (eq (Z.add (Z.sub (s2 h) (s2 i)) 1) v)\n  (eq (Z.leb (s2 i) (s2 h)) true)",
                    "c14_s2 : store",
                    "c6_v : Z",
                    "c2_h : ident",
                    "c2_i : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c10_goal : aimp\n  (aand (atrue (LESSEQUAL (VAR i) (VAR h))) (aand (aequal variant v) P))\n  (aand (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s A .",
                "tactic_args": [
                    "c11_goal : aimp\n  (aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))))) \n  ?Q"
                ],
                "tactic_res": [
                    "c18_goal : ?Q s",
                    "c18_s : store",
                    "c18_A : aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n  (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))) s"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c18_goal : ?Q s",
                    "c18_A : aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n  (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( Q := _i _i _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( Q := _i _i _i //\\\\ _i ) .",
                "tactic_args": [
                    "c8_goal : HOARE\n  (aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))))\n  (ASSIGN i (PLUS (VAR i) (CONST 1))) (aand (alessthan variant v) P)",
                    "_global_HOARE_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : HOARE P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), HOARE P' c Q'",
                    "_global_alessthan : forall (_ : aexp) (_ : Z), assertion",
                    "c4_variant : aexp",
                    "c6_v : Z",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c19_goal : HOARE ?P (ASSIGN i (PLUS (VAR i) (CONST 1)))\n  (aand (alessthan variant v) P)",
                    "c20_goal : aimp\n  (aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h))))) \n  ?P",
                    "c21_goal : aimp (aand (alessthan variant v) P) (aand (alessthan variant v) P)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : HOARE ?P (ASSIGN i (PLUS (VAR i) (CONST 1)))\n  (aand (alessthan variant v) P)",
                    "_global_HOARE_assign : forall (P : assertion) (x : ident) (a : aexp),\n       HOARE (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( A & B & C ) .",
                "tactic_args": [
                    "c20_goal : aimp\n  (aand (aupdate i (PLUS (VAR i) (CONST 1)) P)\n     (aand (aequal variant v) (atrue (LESSEQUAL (VAR i) (VAR h)))))\n  (aupdate i (PLUS (VAR i) (CONST 1)) (aand (alessthan variant v) P))"
                ],
                "tactic_res": [
                    "c22_goal : aupdate i (PLUS (VAR i) (CONST 1)) (aand (alessthan variant v) P) s",
                    "c22_s : store",
                    "c22_A : aupdate i (PLUS (VAR i) (CONST 1)) P s",
                    "c22_B : aequal variant v s",
                    "c22_C : atrue (LESSEQUAL (VAR i) (VAR h)) s"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_aequal : forall (_ : aexp) (_ : Z), assertion",
                    "c22_B : aequal variant v s"
                ],
                "tactic_res": [
                    "c22_B : eq (aeval variant s) v"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c22_B : eq (aeval variant s) v"
                ],
                "tactic_res": [
                    "c22_B : eq (Z.add (Z.sub (s h) (s i)) 1) v"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_atrue : forall _ : bexp, assertion",
                    "c22_C : atrue (LESSEQUAL (VAR i) (VAR h)) s"
                ],
                "tactic_res": [
                    "c22_C : eq (beval (LESSEQUAL (VAR i) (VAR h)) s) true"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c22_C : eq (beval (LESSEQUAL (VAR i) (VAR h)) s) true"
                ],
                "tactic_res": [
                    "c22_C : eq (Z.leb (s i) (s h)) true"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.leb_le : forall n m : Z, iff (eq (Z.leb n m) true) (Z.le n m)",
                    "c22_C : eq (Z.leb (s i) (s h)) true"
                ],
                "tactic_res": [
                    "c22_C : Z.le (s i) (s h)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c22_goal : aupdate i (PLUS (VAR i) (CONST 1)) (aand (alessthan variant v) P) s"
                ],
                "tactic_res": [
                    "c23_goal : alessthan variant v (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)",
                    "c24_goal : P (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c23_goal : alessthan variant v (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)"
                ],
                "tactic_res": [
                    "c25_goal : and\n  (Z.le 0\n     (aeval variant (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)))\n  (Z.lt (aeval variant (update i (aeval (PLUS (VAR i) (CONST 1)) s) s))\n     v)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c25_goal : and\n  (Z.le 0\n     (aeval variant (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)))\n  (Z.lt (aeval variant (update i (aeval (PLUS (VAR i) (CONST 1)) s) s))\n     v)"
                ],
                "tactic_res": [
                    "c26_goal : and\n  (Z.le 0\n     (Z.add\n        (Z.sub (update i (Z.add (s i) 1) s h)\n           (update i (Z.add (s i) 1) s i)) 1))\n  (Z.lt\n     (Z.add\n        (Z.sub (update i (Z.add (s i) 1) s h)\n           (update i (Z.add (s i) 1) s i)) 1) v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : and\n  (Z.le 0\n     (Z.add\n        (Z.sub (update i (Z.add (s i) 1) s h)\n           (update i (Z.add (s i) 1) s i)) 1))\n  (Z.lt\n     (Z.add\n        (Z.sub (update i (Z.add (s i) 1) s h)\n           (update i (Z.add (s i) 1) s i)) 1) v)",
                    "_global_update_same : forall (x : ident) (v : Z) (s : store), eq (update x v s x) v"
                ],
                "tactic_res": [
                    "c27_goal : and\n  (Z.le 0\n     (Z.add (Z.sub (update i (Z.add (s i) 1) s h) (Z.add (s i) 1)) 1))\n  (Z.lt\n     (Z.add (Z.sub (update i (Z.add (s i) 1) s h) (Z.add (s i) 1)) 1) v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c27_goal : and\n  (Z.le 0\n     (Z.add (Z.sub (update i (Z.add (s i) 1) s h) (Z.add (s i) 1)) 1))\n  (Z.lt\n     (Z.add (Z.sub (update i (Z.add (s i) 1) s h) (Z.add (s i) 1)) 1) v)",
                    "_global_update_other : forall (x : ident) (v : Z) (s : store) (y : ident) (_ : not (eq x y)),\n       eq (update x v s y) (s y)",
                    "c22_C : Z.le (s i) (s h)",
                    "c22_B : eq (Z.add (Z.sub (s h) (s i)) 1) v",
                    "c22_A : aupdate i (PLUS (VAR i) (CONST 1)) P s",
                    "c22_s : store",
                    "c6_v : Z",
                    "c4_variant : aexp",
                    "c2_H2 : not (eq i h)",
                    "c2_H1 : not (assigns c h)",
                    "c2_H0 : not (assigns c i)",
                    "c2_H : HOARE (aand (atrue (LESSEQUAL (VAR i) (VAR h))) P) c\n  (aupdate i (PLUS (VAR i) (CONST 1)) P)",
                    "c2_h : ident",
                    "c2_i : ident",
                    "c2_l : aexp"
                ],
                "tactic_res": [
                    "c28_goal : and (Z.le 0 (Z.add (Z.sub (s h) (Z.add (s i) 1)) 1))\n  (Z.lt (Z.add (Z.sub (s h) (Z.add (s i) 1)) 1) v)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c28_goal : and (Z.le 0 (Z.add (Z.sub (s h) (Z.add (s i) 1)) 1))\n  (Z.lt (Z.add (Z.sub (s h) (Z.add (s i) 1)) 1) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c24_goal : P (update i (aeval (PLUS (VAR i) (CONST 1)) s) s)",
                    "c22_A : aupdate i (PLUS (VAR i) (CONST 1)) P s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c21_goal : aimp (aand (alessthan variant v) P) (aand (alessthan variant v) P)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_skip_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_skip_inv : forall P Q , \u2983 P \u2984 SKIP \u2983 Q \u2984 -> ( P -->> Q ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_skip_inv : forall P Q , \u2983 P \u2984 SKIP \u2983 Q \u2984 -> ( P -->> Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q"
                ],
                "tactic_res": [
                    "c2_goal : aimp P Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P SKIP Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : aimp P Q",
                    "c2_H : Hoare P SKIP Q"
                ],
                "tactic_res": [
                    "c3_goal : aimp P P",
                    "c4_goal : aimp P' Q'",
                    "c4_IHHoare : forall _ : eq SKIP SKIP, aimp P Q",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : aimp P P"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : store) (_ : P s), P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : P s), P s",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp P' Q'"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : store) (_ : P' s), Q' s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P' s), Q' s"
                ],
                "tactic_res": [
                    "c7_goal : Q' s",
                    "c7_s : store",
                    "c7_H2 : P' s"
                ]
            },
            {
                "tactic_sig": "apply _i , _i , _i .",
                "tactic_sig_no_out_arg": "apply _i , _i , _i .",
                "tactic_args": [
                    "c7_goal : Q' s",
                    "c4_H1 : aimp Q Q'",
                    "c4_IHHoare : forall _ : eq SKIP SKIP, aimp P Q",
                    "c4_H0 : aimp P' P"
                ],
                "tactic_res": [
                    "c8_goal : eq SKIP SKIP",
                    "c9_goal : P' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P' s",
                    "c7_H2 : P' s",
                    "c7_s : store",
                    "c4_P' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_assign_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_assign_inv : forall x a P Q , \u2983 P \u2984 ASSIGN x a \u2983 Q \u2984 -> ( P -->> aupdate x a Q ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_assign_inv : forall x a P Q , \u2983 P \u2984 ASSIGN x a \u2983 Q \u2984 -> ( P -->> aupdate x a Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (a : aexp) (P Q : assertion)\n  (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x a P Q H .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (a : aexp) (P Q : assertion)\n  (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp P (aupdate x a Q)",
                    "c2_x : ident",
                    "c2_a : aexp",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (ASSIGN x a) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : aimp P (aupdate x a Q)",
                    "c2_H : Hoare P (ASSIGN x a) Q"
                ],
                "tactic_res": [
                    "c3_goal : aimp (aupdate x a P) (aupdate x a P)",
                    "c4_goal : aimp P' (aupdate x a Q')",
                    "c4_IHHoare : forall (x0 : ident) (a0 : aexp) (_ : eq (ASSIGN x a) (ASSIGN x0 a0)),\naimp P (aupdate x0 a0 Q)",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : aimp (aupdate x a P) (aupdate x a P)"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : store) (_ : aupdate x a P s), aupdate x a P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : aupdate x a P s), aupdate x a P s",
                    "c2_a : aexp",
                    "c2_x : ident",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp P' (aupdate x a Q')"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : store) (_ : P' s), aupdate x a Q' s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P' s), aupdate x a Q' s"
                ],
                "tactic_res": [
                    "c7_goal : aupdate x a Q' s",
                    "c7_s : store",
                    "c7_H2 : P' s"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : aupdate x a Q' s"
                ],
                "tactic_res": [
                    "c8_goal : Q' (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i , _i , _i .",
                "tactic_sig_no_out_arg": "apply _i , _i , _i .",
                "tactic_args": [
                    "c8_goal : Q' (update x (aeval a s) s)",
                    "c4_H1 : aimp Q Q'",
                    "c4_IHHoare : forall (x0 : ident) (a0 : aexp) (_ : eq (ASSIGN x a) (ASSIGN x0 a0)),\naimp P (aupdate x0 a0 Q)",
                    "c4_H0 : aimp P' P"
                ],
                "tactic_res": [
                    "c9_goal : eq (ASSIGN x a) (ASSIGN x a)",
                    "c10_goal : P' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (ASSIGN x a) (ASSIGN x a)",
                    "c2_a : aexp",
                    "c2_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : P' s",
                    "c7_H2 : P' s",
                    "c7_s : store",
                    "c4_P' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_seq_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_seq_inv : forall c1 c2 P Q , \u2983 P \u2984 c1 ; ; c2 \u2983 Q \u2984 -> exists R , \u2983 P \u2984 c1 \u2983 R \u2984 /\\ \u2983 R \u2984 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_seq_inv : forall c1 c2 P Q , \u2983 P \u2984 c1 ; ; c2 \u2983 Q \u2984 -> exists R , \u2983 P \u2984 c1 \u2983 R \u2984 /\\ \u2983 R \u2984 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\nex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c1 c2 P Q H .",
                "tactic_args": [
                    "c1_goal : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\nex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))"
                ],
                "tactic_res": [
                    "c2_goal : ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (SEQ c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))",
                    "c2_H : Hoare P (SEQ c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : ex (fun R0 : assertion => and (Hoare P c1 R0) (Hoare R0 c2 R))",
                    "c3_IHHoare2 : forall (c1 c3 : com) (_ : eq c2 (SEQ c1 c3)),\nex (fun R0 : assertion => and (Hoare Q c1 R0) (Hoare R0 c3 R))",
                    "c3_IHHoare1 : forall (c2 c3 : com) (_ : eq c1 (SEQ c2 c3)),\nex (fun R : assertion => and (Hoare P c2 R) (Hoare R c3 Q))",
                    "c3_H0 : Hoare Q c2 R",
                    "c3_H : Hoare P c1 Q",
                    "c3_R : assertion",
                    "c4_goal : ex (fun R : assertion => and (Hoare P' c1 R) (Hoare R c2 Q'))",
                    "c4_IHHoare : forall (c3 c4 : com) (_ : eq (SEQ c1 c2) (SEQ c3 c4)),\nex (fun R : assertion => and (Hoare P c3 R) (Hoare R c4 Q))",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c3_goal : ex (fun R0 : assertion => and (Hoare P c1 R0) (Hoare R0 c2 R))",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c5_goal : and (Hoare P c1 Q) (Hoare Q c2 R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : and (Hoare P c1 Q) (Hoare Q c2 R)",
                    "c3_H0 : Hoare Q c2 R",
                    "c3_H : Hoare P c1 Q",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c3_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( R & C1 & C2 ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( R & C1 & C2 ) .",
                "tactic_args": [
                    "c4_goal : ex (fun R : assertion => and (Hoare P' c1 R) (Hoare R c2 Q'))",
                    "c4_IHHoare : forall (c3 c4 : com) (_ : eq (SEQ c1 c2) (SEQ c3 c4)),\nex (fun R : assertion => and (Hoare P c3 R) (Hoare R c4 Q))"
                ],
                "tactic_res": [
                    "c6_goal : eq (SEQ c1 c2) (SEQ ?c1 ?c2)",
                    "c7_goal : ex (fun R : assertion => and (Hoare P' c1 R) (Hoare R c2 Q'))",
                    "c7_C2 : Hoare R ?c2 Q",
                    "c7_C1 : Hoare P ?c1 R",
                    "c7_R : assertion"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : eq (SEQ c1 c2) (SEQ ?c1 ?c2)",
                    "c2_c1 : com",
                    "c2_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : ex (fun R : assertion => and (Hoare P' c1 R) (Hoare R c2 Q'))",
                    "c7_R : assertion"
                ],
                "tactic_res": [
                    "c8_goal : and (Hoare P' c1 R) (Hoare R c2 Q')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : and (Hoare P' c1 R) (Hoare R c2 Q')"
                ],
                "tactic_res": [
                    "c9_goal : Hoare P' c1 R",
                    "c10_goal : Hoare R c2 Q'"
                ]
            },
            {
                "tactic_sig": "eauto using Hoare_consequence_pre , Hoare_consequence_post .",
                "tactic_sig_no_out_arg": "eauto using Hoare_consequence_pre , Hoare_consequence_post .",
                "tactic_args": [
                    "c9_goal : Hoare P' c1 R",
                    "c7_C1 : Hoare P ?c1 R",
                    "c7_R : assertion",
                    "c4_H0 : aimp P' P",
                    "c2_c1 : com",
                    "c4_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using Hoare_consequence_pre , Hoare_consequence_post .",
                "tactic_sig_no_out_arg": "eauto using Hoare_consequence_pre , Hoare_consequence_post .",
                "tactic_args": [
                    "c10_goal : Hoare R c2 Q'",
                    "c7_C2 : Hoare R ?c2 Q",
                    "c7_R : assertion",
                    "c4_H1 : aimp Q Q'",
                    "c2_c2 : com",
                    "c4_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_ifthenelse_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_ifthenelse_inv : forall b c1 c2 P Q , \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 -> \u2983 atrue b //\\\\ P \u2984 c1 \u2983 Q \u2984 /\\ \u2983 afalse b //\\\\ P \u2984 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_ifthenelse_inv : forall b c1 c2 P Q , \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 -> \u2983 atrue b //\\\\ P \u2984 c1 \u2983 Q \u2984 /\\ \u2983 afalse b //\\\\ P \u2984 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n  (_ : Hoare P (IFTHENELSE b c1 c2) Q),\nand (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros b c1 c2 P Q H .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n  (_ : Hoare P (IFTHENELSE b c1 c2) Q),\nand (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)"
                ],
                "tactic_res": [
                    "c2_goal : and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c2_b : bexp",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c2_H : Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c3_IHHoare2 : forall (b0 : bexp) (c1 c3 : com) (_ : eq c2 (IFTHENELSE b0 c1 c3)),\nand (Hoare (aand (atrue b0) (aand (afalse b) P)) c1 Q)\n  (Hoare (aand (afalse b0) (aand (afalse b) P)) c3 Q)",
                    "c3_IHHoare1 : forall (b0 : bexp) (c2 c3 : com) (_ : eq c1 (IFTHENELSE b0 c2 c3)),\nand (Hoare (aand (atrue b0) (aand (atrue b) P)) c2 Q)\n  (Hoare (aand (afalse b0) (aand (atrue b) P)) c3 Q)",
                    "c3_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c3_H : Hoare (aand (atrue b) P) c1 Q",
                    "c4_goal : and (Hoare (aand (atrue b) P') c1 Q')\n  (Hoare (aand (afalse b) P') c2 Q')",
                    "c4_IHHoare : forall (b0 : bexp) (c3 c4 : com)\n  (_ : eq (IFTHENELSE b c1 c2) (IFTHENELSE b0 c3 c4)),\nand (Hoare (aand (atrue b0) P) c3 Q) (Hoare (aand (afalse b0) P) c4 Q)",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)"
                ],
                "tactic_res": [
                    "c5_goal : Hoare (aand (atrue b) P) c1 Q",
                    "c6_goal : Hoare (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Hoare (aand (atrue b) P) c1 Q",
                    "c3_H : Hoare (aand (atrue b) P) c1 Q",
                    "c2_c1 : com",
                    "c2_b : bexp",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Hoare (aand (afalse b) P) c2 Q",
                    "c3_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c2_c2 : com",
                    "c2_b : bexp",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( C1 & C2 ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( C1 & C2 ) .",
                "tactic_args": [
                    "c4_goal : and (Hoare (aand (atrue b) P') c1 Q')\n  (Hoare (aand (afalse b) P') c2 Q')",
                    "c4_IHHoare : forall (b0 : bexp) (c3 c4 : com)\n  (_ : eq (IFTHENELSE b c1 c2) (IFTHENELSE b0 c3 c4)),\nand (Hoare (aand (atrue b0) P) c3 Q) (Hoare (aand (afalse b0) P) c4 Q)"
                ],
                "tactic_res": [
                    "c7_goal : eq (IFTHENELSE b c1 c2) (IFTHENELSE ?b ?c1 ?c2)",
                    "c8_goal : and (Hoare (aand (atrue b) P') c1 Q')\n  (Hoare (aand (afalse b) P') c2 Q')",
                    "c8_C2 : Hoare (aand (afalse ?b) P) ?c2 Q",
                    "c8_C1 : Hoare (aand (atrue ?b) P) ?c1 Q"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (IFTHENELSE b c1 c2) (IFTHENELSE ?b ?c1 ?c2)",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : and (Hoare (aand (atrue b) P') c1 Q')\n  (Hoare (aand (afalse b) P') c2 Q')"
                ],
                "tactic_res": [
                    "c9_goal : Hoare (aand (atrue b) P') c1 Q'",
                    "c10_goal : Hoare (aand (afalse b) P') c2 Q'"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c9_goal : Hoare (aand (atrue b) P') c1 Q'",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c11_goal : Hoare ?P c1 ?Q",
                    "c12_goal : aimp (aand (atrue b) P') (aand (atrue b) P)",
                    "c13_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : Hoare ?P c1 ?Q",
                    "c8_C1 : Hoare (aand (atrue ?b) P) ?c1 Q",
                    "c2_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : aimp Q Q'",
                    "c4_H1 : aimp Q Q'",
                    "c2_Q : assertion",
                    "c4_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : Hoare (aand (afalse b) P') c2 Q'",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c14_goal : Hoare ?P c2 ?Q",
                    "c15_goal : aimp (aand (afalse b) P') (aand (afalse b) P)",
                    "c16_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : Hoare ?P c2 ?Q",
                    "c8_C2 : Hoare (aand (afalse ?b) P) ?c2 Q",
                    "c2_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : aimp Q Q'",
                    "c4_H1 : aimp Q Q'",
                    "c2_Q : assertion",
                    "c4_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ A B ] .",
                "tactic_args": [
                    "c12_goal : aimp (aand (atrue b) P') (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c17_goal : aand (atrue b) P s",
                    "c17_s : store",
                    "c17_A : atrue b s",
                    "c17_B : P' s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : aand (atrue b) P s"
                ],
                "tactic_res": [
                    "c18_goal : atrue b s",
                    "c19_goal : P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : atrue b s",
                    "c17_A : atrue b s",
                    "c17_s : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : P s",
                    "c17_B : P' s",
                    "c17_s : store",
                    "c4_H0 : aimp P' P",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ A B ] .",
                "tactic_args": [
                    "c15_goal : aimp (aand (afalse b) P') (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c20_goal : aand (afalse b) P s",
                    "c20_s : store",
                    "c20_A : afalse b s",
                    "c20_B : P' s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c20_goal : aand (afalse b) P s"
                ],
                "tactic_res": [
                    "c21_goal : afalse b s",
                    "c22_goal : P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : afalse b s",
                    "c20_A : afalse b s",
                    "c20_s : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : P s",
                    "c20_B : P' s",
                    "c20_s : store",
                    "c4_H0 : aimp P' P",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_while_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_while_inv : forall b c P Q , \u2983 P \u2984 WHILE b c \u2983 Q \u2984 -> exists Inv , \u2983 atrue b //\\\\ Inv \u2984 c \u2983 Inv \u2984 /\\ ( P -->> Inv ) /\\ ( afalse b //\\\\ Inv -->> Q ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_while_inv : forall b c P Q , \u2983 P \u2984 WHILE b c \u2983 Q \u2984 -> exists Inv , \u2983 atrue b //\\\\ Inv \u2984 c \u2983 Inv \u2984 /\\ ( P -->> Inv ) /\\ ( afalse b //\\\\ Inv -->> Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (c : com) (P Q : assertion)\n  (_ : Hoare P (WHILE b c) Q),\nex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros b c P Q H .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (c : com) (P Q : assertion)\n  (_ : Hoare P (WHILE b c) Q),\nex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (WHILE b c) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))",
                    "c2_H : Hoare P (WHILE b c) Q"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) (aand (afalse b) P))))",
                    "c3_IHHoare : forall (b0 : bexp) (c0 : com) (_ : eq c (WHILE b0 c0)),\nex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b0) Inv) c0 Inv)\n     (and (aimp (aand (atrue b) P) Inv) (aimp (aand (afalse b0) Inv) P)))",
                    "c3_H : Hoare (aand (atrue b) P) c P",
                    "c4_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')))",
                    "c4_IHHoare : forall (b0 : bexp) (c0 : com) (_ : eq (WHILE b c) (WHILE b0 c0)),\nex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b0) Inv) c0 Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b0) Inv) Q)))",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b) Inv) (aand (afalse b) P))))",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c5_goal : and (Hoare (aand (atrue b) P) c P)\n  (and (aimp P P) (aimp (aand (afalse b) P) (aand (afalse b) P)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (Hoare (aand (atrue b) P) c P)\n  (and (aimp P P) (aimp (aand (afalse b) P) (aand (afalse b) P)))"
                ],
                "tactic_res": [
                    "c6_goal : Hoare (aand (atrue b) P) c P",
                    "c7_goal : and (aimp P P) (aimp (aand (afalse b) P) (aand (afalse b) P))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Hoare (aand (atrue b) P) c P",
                    "c3_H : Hoare (aand (atrue b) P) c P",
                    "c2_c : com",
                    "c2_b : bexp",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (aimp P P) (aimp (aand (afalse b) P) (aand (afalse b) P))"
                ],
                "tactic_res": [
                    "c8_goal : aimp P P",
                    "c9_goal : aimp (aand (afalse b) P) (aand (afalse b) P)"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c8_goal : aimp P P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c9_goal : aimp (aand (afalse b) P) (aand (afalse b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( Inv & C & X & Y ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( Inv & C & X & Y ) .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')))",
                    "c4_IHHoare : forall (b0 : bexp) (c0 : com) (_ : eq (WHILE b c) (WHILE b0 c0)),\nex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b0) Inv) c0 Inv)\n     (and (aimp P Inv) (aimp (aand (afalse b0) Inv) Q)))"
                ],
                "tactic_res": [
                    "c10_goal : eq (WHILE b c) (WHILE ?b ?c)",
                    "c11_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')))",
                    "c11_Y : aimp (aand (afalse ?b) Inv) Q",
                    "c11_X : aimp P Inv",
                    "c11_C : Hoare (aand (atrue ?b) Inv) ?c Inv",
                    "c11_Inv : assertion"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c10_goal : eq (WHILE b c) (WHILE ?b ?c)",
                    "c2_c : com",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')))",
                    "c11_Inv : assertion"
                ],
                "tactic_res": [
                    "c12_goal : and (Hoare (aand (atrue b) Inv) c Inv)\n  (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q'))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : and (Hoare (aand (atrue b) Inv) c Inv)\n  (and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q'))"
                ],
                "tactic_res": [
                    "c13_goal : Hoare (aand (atrue b) Inv) c Inv",
                    "c14_goal : and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Hoare (aand (atrue b) Inv) c Inv",
                    "c11_C : Hoare (aand (atrue ?b) Inv) ?c Inv",
                    "c11_Inv : assertion",
                    "c2_c : com",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : and (aimp P' Inv) (aimp (aand (afalse b) Inv) Q')"
                ],
                "tactic_res": [
                    "c15_goal : aimp P' Inv",
                    "c16_goal : aimp (aand (afalse b) Inv) Q'"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c15_goal : aimp P' Inv"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c16_goal : aimp (aand (afalse b) Inv) Q'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_havoc_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_havoc_inv : forall x P Q , \u2983 P \u2984 HAVOC x \u2983 Q \u2984 -> ( P -->> aforall ( fun n => aupdate x ( CONST n ) Q ) ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_havoc_inv : forall x P Q , \u2983 P \u2984 HAVOC x \u2983 Q \u2984 -> ( P -->> aforall ( fun n => aupdate x ( CONST n ) Q ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\naimp P (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x P Q H .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\naimp P (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ],
                "tactic_res": [
                    "c2_goal : aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))",
                    "c2_x : ident",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (HAVOC x) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))",
                    "c2_H : Hoare P (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c3_goal : aimp (aforall (fun n : Z => aupdate x (CONST n) Q))\n  (aforall (fun n : Z => aupdate x (CONST n) Q))",
                    "c4_goal : aimp P' (aforall (fun n : Z => aupdate x (CONST n) Q'))",
                    "c4_IHHoare : forall (x0 : ident) (_ : eq (HAVOC x) (HAVOC x0)),\naimp P (aforall (fun n : Z => aupdate x0 (CONST n) Q))",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : aimp (aforall (fun n : Z => aupdate x (CONST n) Q))\n  (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : store) (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s),\naforall (fun n : Z => aupdate x (CONST n) Q) s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s),\naforall (fun n : Z => aupdate x (CONST n) Q) s",
                    "c2_Q : assertion",
                    "c2_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps n .",
                "tactic_args": [
                    "c4_goal : aimp P' (aforall (fun n : Z => aupdate x (CONST n) Q'))"
                ],
                "tactic_res": [
                    "c6_goal : aupdate x (CONST n) Q' s",
                    "c6_s : store",
                    "c6_Ps : P' s",
                    "c6_n : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : aupdate x (CONST n) Q' s",
                    "c4_H1 : aimp Q Q'"
                ],
                "tactic_res": [
                    "c7_goal : Q (update x (aeval (CONST n) s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Q (update x (aeval (CONST n) s) s)",
                    "c4_IHHoare : forall (x0 : ident) (_ : eq (HAVOC x) (HAVOC x0)),\naimp P (aforall (fun n : Z => aupdate x0 (CONST n) Q))"
                ],
                "tactic_res": [
                    "c8_goal : eq (HAVOC x) (HAVOC x)",
                    "c9_goal : P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (HAVOC x) (HAVOC x)",
                    "c2_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P s",
                    "c6_Ps : P' s",
                    "c6_s : store",
                    "c4_H0 : aimp P' P",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_assert_inv",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_assert_inv : forall b P Q , \u2983 P \u2984 ASSERT b \u2983 Q \u2984 -> exists R , ( P -->> atrue b //\\\\ R ) /\\ ( atrue b //\\\\ R -->> Q ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_assert_inv : forall b P Q , \u2983 P \u2984 ASSERT b \u2983 Q \u2984 -> exists R , ( P -->> atrue b //\\\\ R ) /\\ ( atrue b //\\\\ R -->> Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\nex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros b P Q H .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\nex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))",
                    "c2_b : bexp",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : Hoare P (ASSERT b) Q"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))",
                    "c2_H : Hoare P (ASSERT b) Q"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun R : assertion =>\n   and (aimp (aand (atrue b) P) (aand (atrue b) R))\n     (aimp (aand (atrue b) R) (aand (atrue b) P)))",
                    "c4_goal : ex\n  (fun R : assertion =>\n   and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q'))",
                    "c4_IHHoare : forall (b0 : bexp) (_ : eq (ASSERT b) (ASSERT b0)),\nex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b0) R)) (aimp (aand (atrue b0) R) Q))",
                    "c4_H1 : aimp Q Q'",
                    "c4_H0 : aimp P' P",
                    "c4_Q' : assertion",
                    "c4_P' : assertion"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun R : assertion =>\n   and (aimp (aand (atrue b) P) (aand (atrue b) R))\n     (aimp (aand (atrue b) R) (aand (atrue b) P)))",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c5_goal : and (aimp (aand (atrue b) P) (aand (atrue b) P))\n  (aimp (aand (atrue b) P) (aand (atrue b) P))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (aimp (aand (atrue b) P) (aand (atrue b) P))\n  (aimp (aand (atrue b) P) (aand (atrue b) P))"
                ],
                "tactic_res": [
                    "c6_goal : aimp (aand (atrue b) P) (aand (atrue b) P)",
                    "c7_goal : aimp (aand (atrue b) P) (aand (atrue b) P)"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c6_goal : aimp (aand (atrue b) P) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c7_goal : aimp (aand (atrue b) P) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( R & A & B ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( R & A & B ) .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun R : assertion =>\n   and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q'))",
                    "c4_IHHoare : forall (b0 : bexp) (_ : eq (ASSERT b) (ASSERT b0)),\nex\n  (fun R : assertion =>\n   and (aimp P (aand (atrue b0) R)) (aimp (aand (atrue b0) R) Q))"
                ],
                "tactic_res": [
                    "c8_goal : eq (ASSERT b) (ASSERT ?b)",
                    "c9_goal : ex\n  (fun R : assertion =>\n   and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q'))",
                    "c9_B : aimp (aand (atrue ?b) R) Q",
                    "c9_A : aimp P (aand (atrue ?b) R)",
                    "c9_R : assertion"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : eq (ASSERT b) (ASSERT ?b)",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun R : assertion =>\n   and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q'))",
                    "c9_R : assertion"
                ],
                "tactic_res": [
                    "c10_goal : and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c10_goal : and (aimp P' (aand (atrue b) R)) (aimp (aand (atrue b) R) Q')"
                ],
                "tactic_res": [
                    "c11_goal : aimp P' (aand (atrue b) R)",
                    "c12_goal : aimp (aand (atrue b) R) Q'"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c11_goal : aimp P' (aand (atrue b) R)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c12_goal : aimp (aand (atrue b) R) Q'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_conj",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_conj : forall c P1 P2 Q1 Q2 , \u2983 P1 \u2984 c \u2983 Q1 \u2984 -> \u2983 P2 \u2984 c \u2983 Q2 \u2984 -> \u2983 P1 //\\\\ P2 \u2984 c \u2983 Q1 //\\\\ Q2 \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_conj : forall c P1 P2 Q1 Q2 , \u2983 P1 \u2984 c \u2983 Q1 \u2984 -> \u2983 P2 \u2984 c \u2983 Q2 \u2984 -> \u2983 P1 //\\\\ P2 \u2984 c \u2983 Q1 //\\\\ Q2 \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro c .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 SKIP Q1)\n  (_ : Hoare P2 SKIP Q2), Hoare (aand P1 P2) SKIP (aand Q1 Q2)",
                    "c4_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (ASSIGN x a) Q1)\n  (_ : Hoare P2 (ASSIGN x a) Q2),\nHoare (aand P1 P2) (ASSIGN x a) (aand Q1 Q2)",
                    "c4_a : aexp",
                    "c4_x : ident",
                    "c5_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (SEQ c1 c2) Q1)\n  (_ : Hoare P2 (SEQ c1 c2) Q2),\nHoare (aand P1 P2) (SEQ c1 c2) (aand Q1 Q2)",
                    "c5_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c5_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c6_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (IFTHENELSE b c1 c2) Q1)\n  (_ : Hoare P2 (IFTHENELSE b c1 c2) Q2),\nHoare (aand P1 P2) (IFTHENELSE b c1 c2) (aand Q1 Q2)",
                    "c6_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c6_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c6_c2 : com",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c7_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (WHILE b c) Q1)\n  (_ : Hoare P2 (WHILE b c) Q2),\nHoare (aand P1 P2) (WHILE b c) (aand Q1 Q2)",
                    "c7_IHc : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)",
                    "c7_b : bexp",
                    "c8_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (ASSERT b) Q1)\n  (_ : Hoare P2 (ASSERT b) Q2),\nHoare (aand P1 P2) (ASSERT b) (aand Q1 Q2)",
                    "c8_b : bexp",
                    "c9_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (HAVOC x) Q1)\n  (_ : Hoare P2 (HAVOC x) Q2),\nHoare (aand P1 P2) (HAVOC x) (aand Q1 Q2)",
                    "c9_x : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 SKIP Q1)\n  (_ : Hoare P2 SKIP Q2), Hoare (aand P1 P2) SKIP (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c10_goal : Hoare (aand P1 P2) SKIP (aand Q1 Q2)",
                    "c10_P1 : assertion",
                    "c10_P2 : assertion",
                    "c10_Q1 : assertion",
                    "c10_Q2 : assertion",
                    "c10_H : Hoare P1 SKIP Q1",
                    "c10_H0 : Hoare P2 SKIP Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (ASSIGN x a) Q1)\n  (_ : Hoare P2 (ASSIGN x a) Q2),\nHoare (aand P1 P2) (ASSIGN x a) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c11_goal : Hoare (aand P1 P2) (ASSIGN x a) (aand Q1 Q2)",
                    "c11_P1 : assertion",
                    "c11_P2 : assertion",
                    "c11_Q1 : assertion",
                    "c11_Q2 : assertion",
                    "c11_H : Hoare P1 (ASSIGN x a) Q1",
                    "c11_H0 : Hoare P2 (ASSIGN x a) Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (SEQ c1 c2) Q1)\n  (_ : Hoare P2 (SEQ c1 c2) Q2),\nHoare (aand P1 P2) (SEQ c1 c2) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c12_goal : Hoare (aand P1 P2) (SEQ c1 c2) (aand Q1 Q2)",
                    "c12_P1 : assertion",
                    "c12_P2 : assertion",
                    "c12_Q1 : assertion",
                    "c12_Q2 : assertion",
                    "c12_H : Hoare P1 (SEQ c1 c2) Q1",
                    "c12_H0 : Hoare P2 (SEQ c1 c2) Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (IFTHENELSE b c1 c2) Q1)\n  (_ : Hoare P2 (IFTHENELSE b c1 c2) Q2),\nHoare (aand P1 P2) (IFTHENELSE b c1 c2) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c13_goal : Hoare (aand P1 P2) (IFTHENELSE b c1 c2) (aand Q1 Q2)",
                    "c13_P1 : assertion",
                    "c13_P2 : assertion",
                    "c13_Q1 : assertion",
                    "c13_Q2 : assertion",
                    "c13_H : Hoare P1 (IFTHENELSE b c1 c2) Q1",
                    "c13_H0 : Hoare P2 (IFTHENELSE b c1 c2) Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (WHILE b c) Q1)\n  (_ : Hoare P2 (WHILE b c) Q2),\nHoare (aand P1 P2) (WHILE b c) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c14_goal : Hoare (aand P1 P2) (WHILE b c) (aand Q1 Q2)",
                    "c14_P1 : assertion",
                    "c14_P2 : assertion",
                    "c14_Q1 : assertion",
                    "c14_Q2 : assertion",
                    "c14_H : Hoare P1 (WHILE b c) Q1",
                    "c14_H0 : Hoare P2 (WHILE b c) Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (ASSERT b) Q1)\n  (_ : Hoare P2 (ASSERT b) Q2),\nHoare (aand P1 P2) (ASSERT b) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c15_goal : Hoare (aand P1 P2) (ASSERT b) (aand Q1 Q2)",
                    "c15_P1 : assertion",
                    "c15_P2 : assertion",
                    "c15_Q1 : assertion",
                    "c15_Q2 : assertion",
                    "c15_H : Hoare P1 (ASSERT b) Q1",
                    "c15_H0 : Hoare P2 (ASSERT b) Q2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 (HAVOC x) Q1)\n  (_ : Hoare P2 (HAVOC x) Q2),\nHoare (aand P1 P2) (HAVOC x) (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c16_goal : Hoare (aand P1 P2) (HAVOC x) (aand Q1 Q2)",
                    "c16_P1 : assertion",
                    "c16_P2 : assertion",
                    "c16_Q1 : assertion",
                    "c16_Q2 : assertion",
                    "c16_H : Hoare P1 (HAVOC x) Q1",
                    "c16_H0 : Hoare P2 (HAVOC x) Q2"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_skip_inv : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q",
                    "c10_H : Hoare P1 SKIP Q1"
                ],
                "tactic_res": [
                    "c10_H : aimp P1 Q1"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_skip_inv : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q",
                    "c10_H0 : Hoare P2 SKIP Q2"
                ],
                "tactic_res": [
                    "c10_H0 : aimp P2 Q2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : Hoare (aand P1 P2) SKIP (aand Q1 Q2)",
                    "_global_Hoare_consequence_post : forall (P Q Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp Q Q'), Hoare P c Q'"
                ],
                "tactic_res": [
                    "c17_goal : Hoare (aand P1 P2) SKIP ?Q",
                    "c18_goal : aimp (aand P1 P2) (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Hoare (aand P1 P2) SKIP ?Q",
                    "_global_Hoare_skip : forall P : assertion, Hoare P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c18_goal : aimp (aand P1 P2) (aand Q1 Q2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_assign_inv : forall (x : ident) (a : aexp) (P Q : assertion)\n         (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)",
                    "c11_H : Hoare P1 (ASSIGN x a) Q1"
                ],
                "tactic_res": [
                    "c11_H : aimp P1 (aupdate x a Q1)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_assign_inv : forall (x : ident) (a : aexp) (P Q : assertion)\n         (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)",
                    "c11_H0 : Hoare P2 (ASSIGN x a) Q2"
                ],
                "tactic_res": [
                    "c11_H0 : aimp P2 (aupdate x a Q2)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c11_goal : Hoare (aand P1 P2) (ASSIGN x a) (aand Q1 Q2)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c19_goal : Hoare ?P (ASSIGN x a) (aand Q1 Q2)",
                    "c20_goal : aimp (aand P1 P2) (aupdate x a (aand Q1 Q2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Hoare ?P (ASSIGN x a) (aand Q1 Q2)",
                    "_global_Hoare_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Hoare (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "c20_goal : aimp (aand P1 P2) (aupdate x a (aand Q1 Q2))",
                    "_global_aupdate : forall (_ : ident) (_ : aexp) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c21_goal : aimp (aand P1 P2)\n  (fun s : store => aand Q1 Q2 (update x (aeval a s) s))",
                    "c21_H0 : aimp P2 (fun s : store => Q2 (update x (aeval a s) s))",
                    "c21_H : aimp P1 (fun s : store => Q1 (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c21_goal : aimp (aand P1 P2)\n  (fun s : store => aand Q1 Q2 (update x (aeval a s) s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_seq_inv : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\n       ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))",
                    "c12_H : Hoare P1 (SEQ c1 c2) Q1"
                ],
                "tactic_res": [
                    "c12_H : ex (fun R : assertion => and (Hoare P1 c1 R) (Hoare R c2 Q1))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( R1 & C11 & C21 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R1 & C11 & C21 ) .",
                "tactic_args": [
                    "c12_H : ex (fun R : assertion => and (Hoare P1 c1 R) (Hoare R c2 Q1))",
                    "c12_H0 : Hoare P2 (SEQ c1 c2) Q2",
                    "c12_P1 : assertion",
                    "c12_P2 : assertion",
                    "c12_Q1 : assertion",
                    "c12_Q2 : assertion",
                    "c5_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c5_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c5_c1 : com",
                    "c5_c2 : com"
                ],
                "tactic_res": [
                    "c12_C21 : Hoare R1 c2 Q1",
                    "c12_C11 : Hoare P1 c1 R1",
                    "c12_R1 : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_seq_inv : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\n       ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))",
                    "c12_H0 : Hoare P2 (SEQ c1 c2) Q2"
                ],
                "tactic_res": [
                    "c12_H0 : ex (fun R : assertion => and (Hoare P2 c1 R) (Hoare R c2 Q2))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( R2 & C12 & C22 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R2 & C12 & C22 ) .",
                "tactic_args": [
                    "c12_H0 : ex (fun R : assertion => and (Hoare P2 c1 R) (Hoare R c2 Q2))",
                    "c12_C21 : Hoare R1 c2 Q1",
                    "c12_C11 : Hoare P1 c1 R1",
                    "c12_P1 : assertion",
                    "c12_P2 : assertion",
                    "c12_Q1 : assertion",
                    "c12_Q2 : assertion",
                    "c5_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c5_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c5_c1 : com",
                    "c5_c2 : com"
                ],
                "tactic_res": [
                    "c12_C22 : Hoare R2 c2 Q2",
                    "c12_C12 : Hoare P2 c1 R2",
                    "c12_R2 : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i //\\\\ _i ) .",
                "tactic_args": [
                    "c12_goal : Hoare (aand P1 P2) (SEQ c1 c2) (aand Q1 Q2)",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "c12_R1 : assertion",
                    "c12_R2 : assertion"
                ],
                "tactic_res": [
                    "c22_goal : Hoare (aand P1 P2) c1 (aand R1 R2)",
                    "c23_goal : Hoare (aand R1 R2) c2 (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Hoare (aand P1 P2) c1 (aand R1 R2)",
                    "c12_C12 : Hoare P2 c1 R2",
                    "c12_R2 : assertion",
                    "c12_C11 : Hoare P1 c1 R1",
                    "c12_P1 : assertion",
                    "c12_P2 : assertion",
                    "c12_R1 : assertion",
                    "c5_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c5_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Hoare (aand R1 R2) c2 (aand Q1 Q2)",
                    "c12_C22 : Hoare R2 c2 Q2",
                    "c12_R2 : assertion",
                    "c12_C21 : Hoare R1 c2 Q1",
                    "c12_Q1 : assertion",
                    "c12_Q2 : assertion",
                    "c12_R1 : assertion",
                    "c5_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c5_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c13_H : Hoare P1 (IFTHENELSE b c1 c2) Q1"
                ],
                "tactic_res": [
                    "c13_H : and (Hoare (aand (atrue b) P1) c1 Q1)\n  (Hoare (aand (afalse b) P1) c2 Q1)"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( C11 & C21 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( C11 & C21 ) .",
                "tactic_args": [
                    "c13_H : and (Hoare (aand (atrue b) P1) c1 Q1)\n  (Hoare (aand (afalse b) P1) c2 Q1)",
                    "c13_H0 : Hoare P2 (IFTHENELSE b c1 c2) Q2",
                    "c13_P1 : assertion",
                    "c13_P2 : assertion",
                    "c13_Q1 : assertion",
                    "c13_Q2 : assertion",
                    "c6_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c6_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c6_c1 : com",
                    "c6_c2 : com",
                    "c6_b : bexp"
                ],
                "tactic_res": [
                    "c13_C21 : Hoare (aand (afalse b) P1) c2 Q1",
                    "c13_C11 : Hoare (aand (atrue b) P1) c1 Q1"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c13_H0 : Hoare P2 (IFTHENELSE b c1 c2) Q2"
                ],
                "tactic_res": [
                    "c13_H0 : and (Hoare (aand (atrue b) P2) c1 Q2)\n  (Hoare (aand (afalse b) P2) c2 Q2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( C12 & C22 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( C12 & C22 ) .",
                "tactic_args": [
                    "c13_H0 : and (Hoare (aand (atrue b) P2) c1 Q2)\n  (Hoare (aand (afalse b) P2) c2 Q2)",
                    "c13_C21 : Hoare (aand (afalse b) P1) c2 Q1",
                    "c13_C11 : Hoare (aand (atrue b) P1) c1 Q1",
                    "c13_P1 : assertion",
                    "c13_P2 : assertion",
                    "c13_Q1 : assertion",
                    "c13_Q2 : assertion",
                    "c6_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c6_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c6_c1 : com",
                    "c6_c2 : com",
                    "c6_b : bexp"
                ],
                "tactic_res": [
                    "c13_C22 : Hoare (aand (afalse b) P2) c2 Q2",
                    "c13_C12 : Hoare (aand (atrue b) P2) c1 Q2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Hoare (aand P1 P2) (IFTHENELSE b c1 c2) (aand Q1 Q2)",
                    "_global_Hoare_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Hoare (aand (atrue b) P) c1 Q)\n         (_ : Hoare (aand (afalse b) P) c2 Q), Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c24_goal : Hoare (aand (atrue b) (aand P1 P2)) c1 (aand Q1 Q2)",
                    "c25_goal : Hoare (aand (afalse b) (aand P1 P2)) c2 (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c24_goal : Hoare (aand (atrue b) (aand P1 P2)) c1 (aand Q1 Q2)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c26_goal : Hoare ?P c1 (aand Q1 Q2)",
                    "c27_goal : aimp (aand (atrue b) (aand P1 P2)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : Hoare ?P c1 (aand Q1 Q2)",
                    "c13_C12 : Hoare (aand (atrue b) P2) c1 Q2",
                    "c13_C11 : Hoare (aand (atrue b) P1) c1 Q1",
                    "c13_Q1 : assertion",
                    "c13_Q2 : assertion",
                    "c6_IHc1 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c1 Q1)\n  (_ : Hoare P2 c1 Q2), Hoare (aand P1 P2) c1 (aand Q1 Q2)",
                    "c6_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c27_goal : aimp (aand (atrue b) (aand P1 P2))\n  (aand (aand (atrue b) P1) (aand (atrue b) P2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c25_goal : Hoare (aand (afalse b) (aand P1 P2)) c2 (aand Q1 Q2)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c28_goal : Hoare ?P c2 (aand Q1 Q2)",
                    "c29_goal : aimp (aand (afalse b) (aand P1 P2)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : Hoare ?P c2 (aand Q1 Q2)",
                    "c13_C22 : Hoare (aand (afalse b) P2) c2 Q2",
                    "c13_C21 : Hoare (aand (afalse b) P1) c2 Q1",
                    "c13_Q1 : assertion",
                    "c13_Q2 : assertion",
                    "c6_IHc2 : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c2 Q1)\n  (_ : Hoare P2 c2 Q2), Hoare (aand P1 P2) c2 (aand Q1 Q2)",
                    "c6_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c29_goal : aimp (aand (afalse b) (aand P1 P2))\n  (aand (aand (afalse b) P1) (aand (afalse b) P2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_while_inv : forall (b : bexp) (c : com) (P Q : assertion)\n         (_ : Hoare P (WHILE b c) Q),\n       ex\n         (fun Inv : assertion =>\n          and (Hoare (aand (atrue b) Inv) c Inv)\n            (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))",
                    "c14_H : Hoare P1 (WHILE b c) Q1"
                ],
                "tactic_res": [
                    "c14_H : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P1 Inv) (aimp (aand (afalse b) Inv) Q1)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( Inv1 & C1 & A1 & B1 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( Inv1 & C1 & A1 & B1 ) .",
                "tactic_args": [
                    "c14_H : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P1 Inv) (aimp (aand (afalse b) Inv) Q1)))",
                    "c14_H0 : Hoare P2 (WHILE b c) Q2",
                    "c14_P1 : assertion",
                    "c14_P2 : assertion",
                    "c14_Q1 : assertion",
                    "c14_Q2 : assertion",
                    "c7_IHc : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)",
                    "c2_c : com",
                    "c7_b : bexp"
                ],
                "tactic_res": [
                    "c14_B1 : aimp (aand (afalse b) Inv1) Q1",
                    "c14_A1 : aimp P1 Inv1",
                    "c14_C1 : Hoare (aand (atrue b) Inv1) c Inv1",
                    "c14_Inv1 : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_while_inv : forall (b : bexp) (c : com) (P Q : assertion)\n         (_ : Hoare P (WHILE b c) Q),\n       ex\n         (fun Inv : assertion =>\n          and (Hoare (aand (atrue b) Inv) c Inv)\n            (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))",
                    "c14_H0 : Hoare P2 (WHILE b c) Q2"
                ],
                "tactic_res": [
                    "c14_H0 : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P2 Inv) (aimp (aand (afalse b) Inv) Q2)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( Inv2 & C2 & A2 & B2 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( Inv2 & C2 & A2 & B2 ) .",
                "tactic_args": [
                    "c14_H0 : ex\n  (fun Inv : assertion =>\n   and (Hoare (aand (atrue b) Inv) c Inv)\n     (and (aimp P2 Inv) (aimp (aand (afalse b) Inv) Q2)))",
                    "c14_B1 : aimp (aand (afalse b) Inv1) Q1",
                    "c14_A1 : aimp P1 Inv1",
                    "c14_C1 : Hoare (aand (atrue b) Inv1) c Inv1",
                    "c14_P1 : assertion",
                    "c14_P2 : assertion",
                    "c14_Q1 : assertion",
                    "c14_Q2 : assertion",
                    "c7_IHc : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)",
                    "c2_c : com",
                    "c7_b : bexp"
                ],
                "tactic_res": [
                    "c14_B2 : aimp (aand (afalse b) Inv2) Q2",
                    "c14_A2 : aimp P2 Inv2",
                    "c14_C2 : Hoare (aand (atrue b) Inv2) c Inv2",
                    "c14_Inv2 : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( P := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( P := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c14_goal : Hoare (aand P1 P2) (WHILE b c) (aand Q1 Q2)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'",
                    "c14_Inv1 : assertion",
                    "c14_Inv2 : assertion"
                ],
                "tactic_res": [
                    "c30_goal : Hoare (aand Inv1 Inv2) (WHILE b c) ?Q",
                    "c31_goal : aimp (aand P1 P2) (aand Inv1 Inv2)",
                    "c32_goal : aimp (aand (afalse b) (aand Inv1 Inv2)) (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : Hoare (aand Inv1 Inv2) (WHILE b c) ?Q",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c33_goal : Hoare (aand (atrue b) (aand Inv1 Inv2)) c (aand Inv1 Inv2)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c33_goal : Hoare (aand (atrue b) (aand Inv1 Inv2)) c (aand Inv1 Inv2)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c34_goal : Hoare ?P c (aand Inv1 Inv2)",
                    "c35_goal : aimp (aand (atrue b) (aand Inv1 Inv2)) ?P"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c34_goal : Hoare ?P c (aand Inv1 Inv2)",
                    "c7_IHc : forall (P1 P2 Q1 Q2 : assertion) (_ : Hoare P1 c Q1)\n  (_ : Hoare P2 c Q2), Hoare (aand P1 P2) c (aand Q1 Q2)"
                ],
                "tactic_res": [
                    "c36_goal : Hoare ?P1 c Inv1",
                    "c37_goal : Hoare ?P2 c Inv2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c36_goal : Hoare ?P1 c Inv1",
                    "c14_C1 : Hoare (aand (atrue b) Inv1) c Inv1",
                    "c14_Inv1 : assertion",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c37_goal : Hoare ?P2 c Inv2",
                    "c14_C2 : Hoare (aand (atrue b) Inv2) c Inv2",
                    "c14_Inv2 : assertion",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c35_goal : aimp (aand (atrue b) (aand Inv1 Inv2))\n  (aand (aand (atrue b) Inv1) (aand (atrue b) Inv2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c31_goal : aimp (aand P1 P2) (aand Inv1 Inv2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c32_goal : aimp (aand (afalse b) (aand Inv1 Inv2)) (aand Q1 Q2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_assert_inv : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\n       ex\n         (fun R : assertion =>\n          and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))",
                    "c15_H : Hoare P1 (ASSERT b) Q1"
                ],
                "tactic_res": [
                    "c15_H : ex\n  (fun R : assertion =>\n   and (aimp P1 (aand (atrue b) R)) (aimp (aand (atrue b) R) Q1))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( R1 & A1 & B1 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R1 & A1 & B1 ) .",
                "tactic_args": [
                    "c15_H : ex\n  (fun R : assertion =>\n   and (aimp P1 (aand (atrue b) R)) (aimp (aand (atrue b) R) Q1))",
                    "c15_H0 : Hoare P2 (ASSERT b) Q2",
                    "c15_P1 : assertion",
                    "c15_P2 : assertion",
                    "c15_Q1 : assertion",
                    "c15_Q2 : assertion",
                    "c8_b : bexp"
                ],
                "tactic_res": [
                    "c15_B1 : aimp (aand (atrue b) R1) Q1",
                    "c15_A1 : aimp P1 (aand (atrue b) R1)",
                    "c15_R1 : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_assert_inv : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\n       ex\n         (fun R : assertion =>\n          and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))",
                    "c15_H0 : Hoare P2 (ASSERT b) Q2"
                ],
                "tactic_res": [
                    "c15_H0 : ex\n  (fun R : assertion =>\n   and (aimp P2 (aand (atrue b) R)) (aimp (aand (atrue b) R) Q2))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( R2 & A2 & B2 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R2 & A2 & B2 ) .",
                "tactic_args": [
                    "c15_H0 : ex\n  (fun R : assertion =>\n   and (aimp P2 (aand (atrue b) R)) (aimp (aand (atrue b) R) Q2))",
                    "c15_B1 : aimp (aand (atrue b) R1) Q1",
                    "c15_A1 : aimp P1 (aand (atrue b) R1)",
                    "c15_P1 : assertion",
                    "c15_P2 : assertion",
                    "c15_Q1 : assertion",
                    "c15_Q2 : assertion",
                    "c8_b : bexp"
                ],
                "tactic_res": [
                    "c15_B2 : aimp (aand (atrue b) R2) Q2",
                    "c15_A2 : aimp P2 (aand (atrue b) R2)",
                    "c15_R2 : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c15_goal : Hoare (aand P1 P2) (ASSERT b) (aand Q1 Q2)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c38_goal : Hoare ?P (ASSERT b) ?Q",
                    "c39_goal : aimp (aand P1 P2) (aand (atrue b) (aand R1 R2))",
                    "c40_goal : aimp (aand (atrue b) (aand R1 R2)) (aand Q1 Q2)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( P := _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( P := _i //\\\\ _i ) .",
                "tactic_args": [
                    "c38_goal : Hoare ?P (ASSERT b) ?Q",
                    "_global_Hoare_assert : forall (P : assertion) (b : bexp),\n       Hoare (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c15_R1 : assertion",
                    "c15_R2 : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c39_goal : aimp (aand P1 P2) (aand (atrue b) (aand R1 R2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c40_goal : aimp (aand (atrue b) (aand R1 R2)) (aand Q1 Q2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_havoc_inv : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\n       aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))",
                    "c16_H : Hoare P1 (HAVOC x) Q1"
                ],
                "tactic_res": [
                    "c16_H : aimp P1 (aforall (fun n : Z => aupdate x (CONST n) Q1))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_havoc_inv : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\n       aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))",
                    "c16_H0 : Hoare P2 (HAVOC x) Q2"
                ],
                "tactic_res": [
                    "c16_H0 : aimp P2 (aforall (fun n : Z => aupdate x (CONST n) Q2))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c16_goal : Hoare (aand P1 P2) (HAVOC x) (aand Q1 Q2)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c41_goal : Hoare ?P (HAVOC x) (aand Q1 Q2)",
                    "c42_goal : aimp (aand P1 P2) ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c41_goal : Hoare ?P (HAVOC x) (aand Q1 Q2)",
                    "_global_Hoare_havoc : forall (x : ident) (Q : assertion),\n       Hoare (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i in * .",
                "tactic_sig_no_out_arg": "unfold _i , _i in * .",
                "tactic_args": [
                    "c42_goal : aimp (aand P1 P2)\n  (aforall (fun n : Z => aupdate x (CONST n) (aand Q1 Q2)))",
                    "_global_aupdate : forall (_ : ident) (_ : aexp) (_ : assertion), assertion",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [x : ident\n      P1 : assertion\n      P2 : assertion\n      Q1 : assertion\n      Q2 : assertion\n      H : aimp P1\n            (fun s : store =>\n             forall a : Z, Q1 (update x (aeval (CONST a) s) s))\n      H0 : aimp P2\n             (fun s : store =>\n              forall a : Z, Q2 (update x (aeval (CONST a) s) s)) |- Type]"
                ],
                "tactic_res": [
                    "c43_goal : aimp (aand P1 P2)\n  (fun s : store =>\n   forall a : Z, aand Q1 Q2 (update x (aeval (CONST a) s) s))",
                    "c43_H0 : aimp P2\n  (fun s : store => forall a : Z, Q2 (update x (aeval (CONST a) s) s))",
                    "c43_H : aimp P1\n  (fun s : store => forall a : Z, Q1 (update x (aeval (CONST a) s) s))"
                ]
            },
            {
                "tactic_sig": "Tauto .",
                "tactic_sig_no_out_arg": "Tauto .",
                "tactic_args": [
                    "c43_goal : aimp (aand P1 P2)\n  (fun s : store =>\n   forall a : Z, aand Q1 Q2 (update x (aeval (CONST a) s) s))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_exists",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_exists : choice_axiom -> forall ( X : Type ) c ( P Q : X -> assertion ) , ( forall x , \u2983 P x \u2984 c \u2983 Q x \u2984 ) -> \u2983 aexists P \u2984 c \u2983 aexists Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_exists : choice_axiom -> forall ( X : Type ) c ( P Q : X -> assertion ) , ( forall x , \u2983 P x \u2984 c \u2983 Q x \u2984 ) -> \u2983 aexists P \u2984 c \u2983 aexists Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : choice_axiom) (X : Type) (c : com)\n  (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros CHOICE X c .",
                "tactic_args": [
                    "c1_goal : forall (_ : choice_axiom) (X : Type) (c : com)\n  (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)"
                ],
                "tactic_res": [
                    "c2_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)",
                    "c2_CHOICE : choice_axiom",
                    "c2_X : Type",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) SKIP (Q x)),\nHoare (aexists P) SKIP (aexists Q)",
                    "c4_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)),\nHoare (aexists P) (ASSIGN x a) (aexists Q)",
                    "c4_a : aexp",
                    "c4_x : ident",
                    "c5_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)),\nHoare (aexists P) (SEQ c1 c2) (aexists Q)",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aexists P) c2 (aexists Q)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aexists P) c1 (aexists Q)",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c6_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)),\nHoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c6_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aexists P) c2 (aexists Q)",
                    "c6_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aexists P) c1 (aexists Q)",
                    "c6_c2 : com",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c7_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (WHILE b c) (Q x)),\nHoare (aexists P) (WHILE b c) (aexists Q)",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)",
                    "c7_b : bexp",
                    "c8_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (ASSERT b) (Q x)),\nHoare (aexists P) (ASSERT b) (aexists Q)",
                    "c8_b : bexp",
                    "c9_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)),\nHoare (aexists P) (HAVOC x) (aexists Q)",
                    "c9_x : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c3_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) SKIP (Q x)),\nHoare (aexists P) SKIP (aexists Q)"
                ],
                "tactic_res": [
                    "c10_goal : Hoare (aexists P) SKIP (aexists Q)",
                    "c10_P : forall _ : X, assertion",
                    "c10_Q : forall _ : X, assertion",
                    "c10_H : forall x : X, Hoare (P x) SKIP (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c4_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)),\nHoare (aexists P) (ASSIGN x a) (aexists Q)"
                ],
                "tactic_res": [
                    "c11_goal : Hoare (aexists P) (ASSIGN x a) (aexists Q)",
                    "c11_P : forall _ : X, assertion",
                    "c11_Q : forall _ : X, assertion",
                    "c11_H : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c5_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)),\nHoare (aexists P) (SEQ c1 c2) (aexists Q)"
                ],
                "tactic_res": [
                    "c12_goal : Hoare (aexists P) (SEQ c1 c2) (aexists Q)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c6_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)),\nHoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)"
                ],
                "tactic_res": [
                    "c13_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c13_P : forall _ : X, assertion",
                    "c13_Q : forall _ : X, assertion",
                    "c13_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c7_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (WHILE b c) (Q x)),\nHoare (aexists P) (WHILE b c) (aexists Q)"
                ],
                "tactic_res": [
                    "c14_goal : Hoare (aexists P) (WHILE b c) (aexists Q)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c8_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (ASSERT b) (Q x)),\nHoare (aexists P) (ASSERT b) (aexists Q)"
                ],
                "tactic_res": [
                    "c15_goal : Hoare (aexists P) (ASSERT b) (aexists Q)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c9_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)),\nHoare (aexists P) (HAVOC x) (aexists Q)"
                ],
                "tactic_res": [
                    "c16_goal : Hoare (aexists P) (HAVOC x) (aexists Q)",
                    "c16_P : forall _ : X, assertion",
                    "c16_Q : forall _ : X, assertion",
                    "c16_H : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)"
                ]
            },
            {
                "tactic_sig": "assert ( H' : forall x , _i x -->> _i x ) by ( intros ; apply Hoare_skip_inv ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall x , _i x -->> _i x ) by ( intros ; apply Hoare_skip_inv ; auto ) .",
                "tactic_args": [
                    "c10_P : forall _ : X, assertion",
                    "c10_Q : forall _ : X, assertion",
                    "c10_H : forall x : X, Hoare (P x) SKIP (Q x)",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c10_H' : forall x : X, aimp (P x) (Q x)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : Hoare (aexists P) SKIP (aexists Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c17_goal : Hoare ?P SKIP (aexists Q)",
                    "c18_goal : aimp (aexists P) (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Hoare ?P SKIP (aexists Q)",
                    "_global_Hoare_skip : forall P : assertion, Hoare P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( x & Px ) .",
                "tactic_args": [
                    "c18_goal : aimp (aexists P) (aexists Q)"
                ],
                "tactic_res": [
                    "c19_goal : aexists Q s",
                    "c19_s : store",
                    "c19_x : X",
                    "c19_Px : P x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c19_goal : aexists Q s",
                    "c19_x : X"
                ],
                "tactic_res": [
                    "c20_goal : Q x s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : Q x s",
                    "c10_H' : forall x : X, aimp (P x) (Q x)"
                ],
                "tactic_res": [
                    "c21_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : P x s",
                    "c19_Px : P x s",
                    "c19_x : X",
                    "c19_s : store",
                    "c10_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H' : forall y , _i y -->> aupdate _i _i ( _i y ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall y , _i y -->> aupdate _i _i ( _i y ) ) .",
                "tactic_args": [
                    "c11_goal : Hoare (aexists P) (ASSIGN x a) (aexists Q)",
                    "c11_P : forall _ : X, assertion",
                    "c4_x : ident",
                    "c4_a : aexp",
                    "c11_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c22_goal : forall y : X, aimp (P y) (aupdate x a (Q y))",
                    "c23_goal : Hoare (aexists P) (ASSIGN x a) (aexists Q)",
                    "c23_H' : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c22_goal : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ],
                "tactic_res": [
                    "c24_goal : aimp (P y) (aupdate x a (Q y))",
                    "c24_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : aimp (P y) (aupdate x a (Q y))",
                    "_global_Hoare_assign_inv : forall (x : ident) (a : aexp) (P Q : assertion)\n         (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)"
                ],
                "tactic_res": [
                    "c25_goal : Hoare (P y) (ASSIGN x a) (Q y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Hoare (P y) (ASSIGN x a) (Q y)",
                    "c24_y : X",
                    "c11_H : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)",
                    "c11_P : forall _ : X, assertion",
                    "c11_Q : forall _ : X, assertion",
                    "c4_a : aexp",
                    "c4_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c23_goal : Hoare (aexists P) (ASSIGN x a) (aexists Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c26_goal : Hoare ?P (ASSIGN x a) (aexists Q)",
                    "c27_goal : aimp (aexists P) (aupdate x a (aexists Q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Hoare ?P (ASSIGN x a) (aexists Q)",
                    "_global_Hoare_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Hoare (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( y & Py ) .",
                "tactic_args": [
                    "c27_goal : aimp (aexists P) (aupdate x a (aexists Q))"
                ],
                "tactic_res": [
                    "c28_goal : aupdate x a (aexists Q) s",
                    "c28_s : store",
                    "c28_y : X",
                    "c28_Py : P y s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c28_goal : aupdate x a (aexists Q) s",
                    "c28_y : X"
                ],
                "tactic_res": [
                    "c29_goal : Q y (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : Q y (update x (aeval a s) s)",
                    "c23_H' : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ],
                "tactic_res": [
                    "c30_goal : P y s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : P y s",
                    "c28_Py : P y s",
                    "c28_y : X",
                    "c28_s : store",
                    "c11_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( R : assertion ) => Hoare ( _i x ) _i R /\\ Hoare R _i ( _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( R : assertion ) => Hoare ( _i x ) _i R /\\ Hoare R _i ( _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c12_P : forall _ : X, assertion",
                    "c5_c1 : com",
                    "c5_c2 : com",
                    "c12_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c12_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_args": [
                    "c12_goal : Hoare (aexists P) (SEQ c1 c2) (aexists Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c12_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c31_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c32_goal : Hoare (aexists P) (SEQ c1 c2) (aexists Q)",
                    "c32_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c33_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c33_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c34_goal : ex (fun b : assertion => REL x b)",
                    "c34_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c34_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_seq_inv : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\n       ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))"
                ],
                "tactic_res": [
                    "c35_goal : Hoare (P x) (SEQ c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c34_x : X",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c5_c1 : com",
                    "c5_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( R & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R & _i ) .",
                "tactic_args": [
                    "c32_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c32_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aexists P) c2 (aexists Q)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aexists P) c1 (aexists Q)",
                    "c5_c1 : com",
                    "c5_c2 : com",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c32_H' : forall x : X, REL x (R x)",
                    "c32_R : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c32_goal : Hoare (aexists P) (SEQ c1 c2) (aexists Q)",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "_global_aexists : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      c1 : com\n      c2 : com\n      IHc1 : forall (P Q : forall _ : X, assertion)\n               (_ : forall x : X, Hoare (P x) c1 (Q x)),\n             Hoare (aexists P) c1 (aexists Q)\n      IHc2 : forall (P Q : forall _ : X, assertion)\n               (_ : forall x : X, Hoare (P x) c2 (Q x)),\n             Hoare (aexists P) c2 (aexists Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)\n      REL := fun (x : X) (R : assertion) =>\n             and (Hoare (P x) c1 R) (Hoare R c2 (Q x))\n       : forall (_ : X) (_ : assertion), Prop\n      R : forall _ : X, assertion\n      H' : forall x : X, REL x (R x) |- Type]",
                    "c32_R : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c36_goal : Hoare (aexists P) c1 (aexists R)",
                    "c37_goal : Hoare (aexists R) c2 (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : Hoare (aexists P) c1 (aexists R)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aexists P) c1 (aexists Q)"
                ],
                "tactic_res": [
                    "c38_goal : forall x : X, Hoare (P x) c1 (R x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c38_goal : forall x : X, Hoare (P x) c1 (R x)"
                ],
                "tactic_res": [
                    "c39_goal : Hoare (P x) c1 (R x)",
                    "c39_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : Hoare (P x) c1 (R x)",
                    "c32_H' : forall x : X, REL x (R x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : Hoare (aexists R) c2 (aexists Q)",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aexists P) c2 (aexists Q)"
                ],
                "tactic_res": [
                    "c40_goal : forall x : X, Hoare (R x) c2 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c40_goal : forall x : X, Hoare (R x) c2 (Q x)"
                ],
                "tactic_res": [
                    "c41_goal : Hoare (R x) c2 (Q x)",
                    "c41_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c41_goal : Hoare (R x) c2 (Q x)",
                    "c32_H' : forall x : X, REL x (R x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H1 : Hoare ( aexists ( fun x => atrue _i //\\\\ _i x ) ) _i ( aexists _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H1 : Hoare ( aexists ( fun x => atrue _i //\\\\ _i x ) ) _i ( aexists _i ) ) .",
                "tactic_args": [
                    "c13_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c6_b : bexp",
                    "c13_P : forall _ : X, assertion",
                    "c6_c1 : com",
                    "c13_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c42_goal : Hoare (aexists (fun x : X => aand (atrue b) (P x))) c1 (aexists Q)",
                    "c43_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c43_H1 : Hoare (aexists (fun x : X => aand (atrue b) (P x))) c1 (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c42_goal : Hoare (aexists (fun x : X => aand (atrue b) (P x))) c1 (aexists Q)",
                    "c6_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aexists P) c1 (aexists Q)"
                ],
                "tactic_res": [
                    "c44_goal : forall x : X, Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c44_goal : forall x : X, Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ],
                "tactic_res": [
                    "c45_goal : Hoare (aand (atrue b) (P x)) c1 (Q x)",
                    "c45_x : X"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c45_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)",
                    "c45_x : X"
                ],
                "tactic_res": [
                    "c45_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c45_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ],
                "tactic_res": [
                    "c45_H : and (Hoare (aand (atrue b) (P x)) c1 (Q x))\n  (Hoare (aand (afalse b) (P x)) c2 (Q x))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c45_goal : Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H2 : Hoare ( aexists ( fun x => afalse _i //\\\\ _i x ) ) _i ( aexists _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H2 : Hoare ( aexists ( fun x => afalse _i //\\\\ _i x ) ) _i ( aexists _i ) ) .",
                "tactic_args": [
                    "c43_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c6_b : bexp",
                    "c13_P : forall _ : X, assertion",
                    "c6_c2 : com",
                    "c13_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c46_goal : Hoare (aexists (fun x : X => aand (afalse b) (P x))) c2 (aexists Q)",
                    "c47_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "c47_H2 : Hoare (aexists (fun x : X => aand (afalse b) (P x))) c2 (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c46_goal : Hoare (aexists (fun x : X => aand (afalse b) (P x))) c2 (aexists Q)",
                    "c6_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aexists P) c2 (aexists Q)"
                ],
                "tactic_res": [
                    "c48_goal : forall x : X, Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c48_goal : forall x : X, Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ],
                "tactic_res": [
                    "c49_goal : Hoare (aand (afalse b) (P x)) c2 (Q x)",
                    "c49_x : X"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c49_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)",
                    "c49_x : X"
                ],
                "tactic_res": [
                    "c49_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c49_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ],
                "tactic_res": [
                    "c49_H : and (Hoare (aand (atrue b) (P x)) c1 (Q x))\n  (Hoare (aand (afalse b) (P x)) c2 (Q x))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c49_goal : Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c47_goal : Hoare (aexists P) (IFTHENELSE b c1 c2) (aexists Q)",
                    "_global_Hoare_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Hoare (aand (atrue b) P) c1 Q)\n         (_ : Hoare (aand (afalse b) P) c2 Q), Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c50_goal : Hoare (aand (atrue b) (aexists P)) c1 (aexists Q)",
                    "c51_goal : Hoare (aand (afalse b) (aexists P)) c2 (aexists Q)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c50_goal : Hoare (aand (atrue b) (aexists P)) c1 (aexists Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c52_goal : Hoare ?P c1 (aexists Q)",
                    "c53_goal : aimp (aand (atrue b) (aexists P)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c52_goal : Hoare ?P c1 (aexists Q)",
                    "c43_H1 : Hoare (aexists (fun x : X => aand (atrue b) (P x))) c1 (aexists Q)",
                    "c13_Q : forall _ : X, assertion",
                    "c6_c1 : com",
                    "c2_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c51_goal : Hoare (aand (afalse b) (aexists P)) c2 (aexists Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c54_goal : Hoare ?P c2 (aexists Q)",
                    "c55_goal : aimp (aand (afalse b) (aexists P)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c54_goal : Hoare ?P c2 (aexists Q)",
                    "c47_H2 : Hoare (aexists (fun x : X => aand (afalse b) (P x))) c2 (aexists Q)",
                    "c13_Q : forall _ : X, assertion",
                    "c6_c2 : com",
                    "c2_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( A & x & B ) .",
                "tactic_args": [
                    "c53_goal : aimp (aand (atrue b) (aexists P))\n  (aexists (fun x : X => aand (atrue b) (P x)))"
                ],
                "tactic_res": [
                    "c56_goal : aexists (fun x : X => aand (atrue b) (P x)) s",
                    "c56_s : store",
                    "c56_A : atrue b s",
                    "c56_x : X",
                    "c56_B : P x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c56_goal : aexists (fun x : X => aand (atrue b) (P x)) s",
                    "c56_x : X"
                ],
                "tactic_res": [
                    "c57_goal : aand (atrue b) (P x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c57_goal : aand (atrue b) (P x) s"
                ],
                "tactic_res": [
                    "c58_goal : atrue b s",
                    "c59_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c58_goal : atrue b s",
                    "c56_A : atrue b s",
                    "c56_s : store",
                    "c6_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : P x s",
                    "c56_B : P x s",
                    "c56_x : X",
                    "c56_s : store",
                    "c13_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( A & x & B ) .",
                "tactic_args": [
                    "c55_goal : aimp (aand (afalse b) (aexists P))\n  (aexists (fun x : X => aand (afalse b) (P x)))"
                ],
                "tactic_res": [
                    "c60_goal : aexists (fun x : X => aand (afalse b) (P x)) s",
                    "c60_s : store",
                    "c60_A : afalse b s",
                    "c60_x : X",
                    "c60_B : P x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c60_goal : aexists (fun x : X => aand (afalse b) (P x)) s",
                    "c60_x : X"
                ],
                "tactic_res": [
                    "c61_goal : aand (afalse b) (P x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c61_goal : aand (afalse b) (P x) s"
                ],
                "tactic_res": [
                    "c62_goal : afalse b s",
                    "c63_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c62_goal : afalse b s",
                    "c60_A : afalse b s",
                    "c60_s : store",
                    "c6_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c63_goal : P x s",
                    "c60_B : P x s",
                    "c60_x : X",
                    "c60_s : store",
                    "c13_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( Inv : assertion ) => Hoare ( atrue _i //\\\\ Inv ) _i Inv /\\ ( _i x -->> Inv ) /\\ ( afalse _i //\\\\ Inv -->> _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( Inv : assertion ) => Hoare ( atrue _i //\\\\ Inv ) _i Inv /\\ ( _i x -->> Inv ) /\\ ( afalse _i //\\\\ Inv -->> _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c7_b : bexp",
                    "c2_c : com",
                    "c14_P : forall _ : X, assertion",
                    "c7_b : bexp",
                    "c14_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c14_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists Inv : _i -> assertion , forall x : _i , _i x ( Inv x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists Inv : _i -> assertion , forall x : _i , _i x ( Inv x ) ) .",
                "tactic_args": [
                    "c14_goal : Hoare (aexists P) (WHILE b c) (aexists Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c14_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c64_goal : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c65_goal : Hoare (aexists P) (WHILE b c) (aexists Q)",
                    "c65_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c64_goal : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c66_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c66_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c67_goal : ex (fun b : assertion => REL x b)",
                    "c67_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c67_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_while_inv : forall (b : bexp) (c : com) (P Q : assertion)\n         (_ : Hoare P (WHILE b c) Q),\n       ex\n         (fun Inv : assertion =>\n          and (Hoare (aand (atrue b) Inv) c Inv)\n            (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))"
                ],
                "tactic_res": [
                    "c68_goal : Hoare (P x) (WHILE b c) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c68_goal : Hoare (P x) (WHILE b c) (Q x)",
                    "c67_x : X",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c2_c : com",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( Inv & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( Inv & _i ) .",
                "tactic_args": [
                    "c65_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c65_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)",
                    "c2_c : com",
                    "c7_b : bexp",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c65_H' : forall x : X, REL x (Inv x)",
                    "c65_Inv : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i _i ) .",
                "tactic_args": [
                    "c65_goal : Hoare (aexists P) (WHILE b c) (aexists Q)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'",
                    "c14_P : forall _ : X, assertion",
                    "_global_aexists : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      b : bexp\n      c : com\n      IHc : forall (P Q : forall _ : X, assertion)\n              (_ : forall x : X, Hoare (P x) c (Q x)),\n            Hoare (aexists P) c (aexists Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (WHILE b c) (Q x)\n      REL := fun (x : X) (Inv : assertion) =>\n             and (Hoare (aand (atrue b) Inv) c Inv)\n               (and (aimp (P x) Inv) (aimp (aand (afalse b) Inv) (Q x)))\n       : forall (_ : X) (_ : assertion), Prop\n      Inv : forall _ : X, assertion\n      H' : forall x : X, REL x (Inv x) |- Type]",
                    "c65_Inv : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c69_goal : Hoare (aexists Inv) (WHILE b c) ?Q",
                    "c70_goal : aimp (aexists P) (aexists Inv)",
                    "c71_goal : aimp (aand (afalse b) (aexists Inv)) (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c69_goal : Hoare (aexists Inv) (WHILE b c) ?Q",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c72_goal : Hoare (aand (atrue b) (aexists Inv)) c (aexists Inv)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ( fun x => _i _i //\\\\ _i x ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ( fun x => _i _i //\\\\ _i x ) ) .",
                "tactic_args": [
                    "c72_goal : Hoare (aand (atrue b) (aexists Inv)) c (aexists Inv)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q",
                    "c14_P : forall _ : X, assertion",
                    "_global_aexists : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      b : bexp\n      c : com\n      IHc : forall (P Q : forall _ : X, assertion)\n              (_ : forall x : X, Hoare (P x) c (Q x)),\n            Hoare (aexists P) c (aexists Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (WHILE b c) (Q x)\n      REL := fun (x : X) (Inv : assertion) =>\n             and (Hoare (aand (atrue b) Inv) c Inv)\n               (and (aimp (P x) Inv) (aimp (aand (afalse b) Inv) (Q x)))\n       : forall (_ : X) (_ : assertion), Prop\n      Inv : forall _ : X, assertion\n      H' : forall x : X, REL x (Inv x) |- Type]",
                    "_global_atrue : forall _ : bexp, assertion",
                    "c7_b : bexp",
                    "c65_Inv : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c73_goal : Hoare (aexists (fun x : X => aand (atrue b) (Inv x))) c (aexists Inv)",
                    "c74_goal : aimp (aand (atrue b) (aexists Inv))\n  (aexists (fun x : X => aand (atrue b) (Inv x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c73_goal : Hoare (aexists (fun x : X => aand (atrue b) (Inv x))) c (aexists Inv)",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aexists P) c (aexists Q)"
                ],
                "tactic_res": [
                    "c75_goal : forall x : X, Hoare (aand (atrue b) (Inv x)) c (Inv x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c75_goal : forall x : X, Hoare (aand (atrue b) (Inv x)) c (Inv x)"
                ],
                "tactic_res": [
                    "c76_goal : Hoare (aand (atrue b) (Inv x)) c (Inv x)",
                    "c76_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c76_goal : Hoare (aand (atrue b) (Inv x)) c (Inv x)",
                    "c65_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( A & x & B ) .",
                "tactic_args": [
                    "c74_goal : aimp (aand (atrue b) (aexists Inv))\n  (aexists (fun x : X => aand (atrue b) (Inv x)))"
                ],
                "tactic_res": [
                    "c77_goal : aexists (fun x : X => aand (atrue b) (Inv x)) s",
                    "c77_s : store",
                    "c77_A : atrue b s",
                    "c77_x : X",
                    "c77_B : Inv x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c77_goal : aexists (fun x : X => aand (atrue b) (Inv x)) s",
                    "c77_x : X"
                ],
                "tactic_res": [
                    "c78_goal : aand (atrue b) (Inv x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c78_goal : aand (atrue b) (Inv x) s"
                ],
                "tactic_res": [
                    "c79_goal : atrue b s",
                    "c80_goal : Inv x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c79_goal : atrue b s",
                    "c77_A : atrue b s",
                    "c77_s : store",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c80_goal : Inv x s",
                    "c77_B : Inv x s",
                    "c77_x : X",
                    "c77_s : store",
                    "c65_Inv : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( x & A ) .",
                "tactic_args": [
                    "c70_goal : aimp (aexists P) (aexists Inv)"
                ],
                "tactic_res": [
                    "c81_goal : aexists Inv s",
                    "c81_s : store",
                    "c81_x : X",
                    "c81_A : P x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c81_goal : aexists Inv s",
                    "c81_x : X"
                ],
                "tactic_res": [
                    "c82_goal : Inv x s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c82_goal : Inv x s",
                    "c65_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": [
                    "c83_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c83_goal : P x s",
                    "c81_A : P x s",
                    "c81_x : X",
                    "c81_s : store",
                    "c14_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( A & x & B ) .",
                "tactic_args": [
                    "c71_goal : aimp (aand (afalse b) (aexists Inv)) (aexists Q)"
                ],
                "tactic_res": [
                    "c84_goal : aexists Q s",
                    "c84_s : store",
                    "c84_A : afalse b s",
                    "c84_x : X",
                    "c84_B : Inv x s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c84_goal : aexists Q s",
                    "c84_x : X"
                ],
                "tactic_res": [
                    "c85_goal : Q x s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c85_goal : Q x s",
                    "c65_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": [
                    "c86_goal : aand (afalse b) (Inv x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c86_goal : aand (afalse b) (Inv x) s"
                ],
                "tactic_res": [
                    "c87_goal : afalse b s",
                    "c88_goal : Inv x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c87_goal : afalse b s",
                    "c84_A : afalse b s",
                    "c84_s : store",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c88_goal : Inv x s",
                    "c84_B : Inv x s",
                    "c84_x : X",
                    "c84_s : store",
                    "c65_Inv : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( R : assertion ) => ( _i x -->> atrue _i //\\\\ R ) /\\ ( atrue _i //\\\\ R -->> _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( R : assertion ) => ( _i x -->> atrue _i //\\\\ R ) /\\ ( atrue _i //\\\\ R -->> _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c15_P : forall _ : X, assertion",
                    "c8_b : bexp",
                    "c8_b : bexp",
                    "c15_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c15_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_args": [
                    "c15_goal : Hoare (aexists P) (ASSERT b) (aexists Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c15_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c89_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c90_goal : Hoare (aexists P) (ASSERT b) (aexists Q)",
                    "c90_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c89_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c91_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c91_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c92_goal : ex (fun b : assertion => REL x b)",
                    "c92_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c92_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_assert_inv : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\n       ex\n         (fun R : assertion =>\n          and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))"
                ],
                "tactic_res": [
                    "c93_goal : Hoare (P x) (ASSERT b) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c93_goal : Hoare (P x) (ASSERT b) (Q x)",
                    "c92_x : X",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( R & A ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R & A ) .",
                "tactic_args": [
                    "c90_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c8_b : bexp",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c90_A : forall x : X, REL x (R x)",
                    "c90_R : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c90_goal : Hoare (aexists P) (ASSERT b) (aexists Q)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c94_goal : Hoare ?P (ASSERT b) ?Q",
                    "c95_goal : aimp (aexists P) (aand (atrue b) (aexists R))",
                    "c96_goal : aimp (aand (atrue b) (aexists R)) (aexists Q)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i _i ) .",
                "tactic_args": [
                    "c94_goal : Hoare ?P (ASSERT b) ?Q",
                    "_global_Hoare_assert : forall (P : assertion) (b : bexp),\n       Hoare (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c15_P : forall _ : X, assertion",
                    "_global_aexists : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      b : bexp\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (ASSERT b) (Q x)\n      REL := fun (x : X) (R : assertion) =>\n             and (aimp (P x) (aand (atrue b) R))\n               (aimp (aand (atrue b) R) (Q x))\n       : forall (_ : X) (_ : assertion), Prop\n      R : forall _ : X, assertion\n      A : forall x : X, REL x (R x) |- Type]",
                    "c90_R : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( x & Px ) .",
                "tactic_args": [
                    "c95_goal : aimp (aexists P) (aand (atrue b) (aexists R))"
                ],
                "tactic_res": [
                    "c97_goal : aand (atrue b) (aexists R) s",
                    "c97_s : store",
                    "c97_x : X",
                    "c97_Px : P x s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_args": [
                    "c90_A : forall x : X, REL x (R x)",
                    "c97_x : X",
                    "c97_Px : P x s",
                    "c97_s : store",
                    "c90_R : forall _ : X, assertion",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c8_b : bexp",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c97_C : aimp (aand (atrue b) (R x)) (Q x)",
                    "c97_B : aimp (P x) (aand (atrue b) (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c97_B : aimp (P x) (aand (atrue b) (R x))",
                    "c97_Px : P x s"
                ],
                "tactic_res": [
                    "c97_Px : aand (atrue b) (R x) s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c97_Px : aand (atrue b) (R x) s",
                    "c97_C : aimp (aand (atrue b) (R x)) (Q x)",
                    "c97_B : aimp (P x) (aand (atrue b) (R x))",
                    "c97_s : store",
                    "c90_A : forall x : X, REL x (R x)",
                    "c90_R : forall _ : X, assertion",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c8_b : bexp",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c97_H1 : R x s",
                    "c97_H0 : atrue b s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c97_goal : aand (atrue b) (aexists R) s"
                ],
                "tactic_res": [
                    "c98_goal : atrue b s",
                    "c99_goal : aexists R s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c98_goal : atrue b s",
                    "c97_H0 : atrue b s",
                    "c97_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c99_goal : aexists R s",
                    "c97_x : X"
                ],
                "tactic_res": [
                    "c100_goal : R x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c100_goal : R x s",
                    "c97_H1 : R x s",
                    "c97_x : X",
                    "c97_s : store",
                    "c90_R : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( Bs & x & Rx ) .",
                "tactic_args": [
                    "c96_goal : aimp (aand (atrue b) (aexists R)) (aexists Q)"
                ],
                "tactic_res": [
                    "c101_goal : aexists Q s",
                    "c101_s : store",
                    "c101_Bs : atrue b s",
                    "c101_x : X",
                    "c101_Rx : R x s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_args": [
                    "c90_A : forall x : X, REL x (R x)",
                    "c101_x : X",
                    "c101_Rx : R x s",
                    "c101_Bs : atrue b s",
                    "c101_s : store",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_Q : forall _ : X, assertion",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c101_C : aimp (aand (atrue b) (R x)) (Q x)",
                    "c101_B : aimp (P x) (aand (atrue b) (R x))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c101_goal : aexists Q s",
                    "c101_x : X"
                ],
                "tactic_res": [
                    "c102_goal : Q x s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c102_goal : Q x s",
                    "c101_C : aimp (aand (atrue b) (R x)) (Q x)"
                ],
                "tactic_res": [
                    "c103_goal : aand (atrue b) (R x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c103_goal : aand (atrue b) (R x) s"
                ],
                "tactic_res": [
                    "c104_goal : atrue b s",
                    "c105_goal : R x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c104_goal : atrue b s",
                    "c101_Bs : atrue b s",
                    "c101_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c105_goal : R x s",
                    "c101_Rx : R x s",
                    "c101_x : X",
                    "c101_s : store",
                    "c90_R : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H' : forall y , _i y -->> aforall ( fun n => aupdate _i ( CONST n ) ( _i y ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall y , _i y -->> aforall ( fun n => aupdate _i ( CONST n ) ( _i y ) ) ) .",
                "tactic_args": [
                    "c16_goal : Hoare (aexists P) (HAVOC x) (aexists Q)",
                    "c16_P : forall _ : X, assertion",
                    "c9_x : ident",
                    "c16_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c106_goal : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "c107_goal : Hoare (aexists P) (HAVOC x) (aexists Q)",
                    "c107_H' : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c106_goal : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ],
                "tactic_res": [
                    "c108_goal : aimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "c108_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c108_goal : aimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "_global_Hoare_havoc_inv : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\n       aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ],
                "tactic_res": [
                    "c109_goal : Hoare (P y) (HAVOC x) (Q y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c109_goal : Hoare (P y) (HAVOC x) (Q y)",
                    "c108_y : X",
                    "c16_H : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)",
                    "c16_P : forall _ : X, assertion",
                    "c16_Q : forall _ : X, assertion",
                    "c9_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c107_goal : Hoare (aexists P) (HAVOC x) (aexists Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c110_goal : Hoare ?P (HAVOC x) (aexists Q)",
                    "c111_goal : aimp (aexists P) ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c110_goal : Hoare ?P (HAVOC x) (aexists Q)",
                    "_global_Hoare_havoc : forall (x : ident) (Q : assertion),\n       Hoare (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s ( y & Py ) .",
                "tactic_args": [
                    "c111_goal : aimp (aexists P)\n  (aforall (fun n : Z => aupdate x (CONST n) (aexists Q)))"
                ],
                "tactic_res": [
                    "c112_goal : aforall (fun n : Z => aupdate x (CONST n) (aexists Q)) s",
                    "c112_s : store",
                    "c112_y : X",
                    "c112_Py : P y s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c112_goal : aforall (fun n : Z => aupdate x (CONST n) (aexists Q)) s",
                    "c112_y : X"
                ],
                "tactic_res": [
                    "c113_goal : Q y (update x (aeval (CONST a) s) s)",
                    "c113_a : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c113_goal : Q y (update x (aeval (CONST a) s) s)",
                    "c107_H' : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ],
                "tactic_res": [
                    "c114_goal : P y s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c114_goal : P y s",
                    "c112_Py : P y s",
                    "c112_y : X",
                    "c112_s : store",
                    "c16_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_forall",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_forall : choice_axiom -> forall ( X : Type ) ( inhabited : X ) c ( P Q : X -> assertion ) , ( forall x , \u2983 P x \u2984 c \u2983 Q x \u2984 ) -> \u2983 aforall P \u2984 c \u2983 aforall Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_forall : choice_axiom -> forall ( X : Type ) ( inhabited : X ) c ( P Q : X -> assertion ) , ( forall x , \u2983 P x \u2984 c \u2983 Q x \u2984 ) -> \u2983 aforall P \u2984 c \u2983 aforall Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : choice_axiom) (X : Type) (_ : X) (c : com)\n  (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros CHOICE X inhabited c .",
                "tactic_args": [
                    "c1_goal : forall (_ : choice_axiom) (X : Type) (_ : X) (c : com)\n  (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)"
                ],
                "tactic_res": [
                    "c2_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)",
                    "c2_CHOICE : choice_axiom",
                    "c2_X : Type",
                    "c2_inhabited : X",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) SKIP (Q x)),\nHoare (aforall P) SKIP (aforall Q)",
                    "c4_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)),\nHoare (aforall P) (ASSIGN x a) (aforall Q)",
                    "c4_a : aexp",
                    "c4_x : ident",
                    "c5_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)),\nHoare (aforall P) (SEQ c1 c2) (aforall Q)",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aforall P) c2 (aforall Q)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aforall P) c1 (aforall Q)",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c6_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)),\nHoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c6_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aforall P) c2 (aforall Q)",
                    "c6_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aforall P) c1 (aforall Q)",
                    "c6_c2 : com",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c7_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (WHILE b c) (Q x)),\nHoare (aforall P) (WHILE b c) (aforall Q)",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)",
                    "c7_b : bexp",
                    "c8_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (ASSERT b) (Q x)),\nHoare (aforall P) (ASSERT b) (aforall Q)",
                    "c8_b : bexp",
                    "c9_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)),\nHoare (aforall P) (HAVOC x) (aforall Q)",
                    "c9_x : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c3_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) SKIP (Q x)),\nHoare (aforall P) SKIP (aforall Q)"
                ],
                "tactic_res": [
                    "c10_goal : Hoare (aforall P) SKIP (aforall Q)",
                    "c10_P : forall _ : X, assertion",
                    "c10_Q : forall _ : X, assertion",
                    "c10_H : forall x : X, Hoare (P x) SKIP (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c4_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)),\nHoare (aforall P) (ASSIGN x a) (aforall Q)"
                ],
                "tactic_res": [
                    "c11_goal : Hoare (aforall P) (ASSIGN x a) (aforall Q)",
                    "c11_P : forall _ : X, assertion",
                    "c11_Q : forall _ : X, assertion",
                    "c11_H : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c5_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)),\nHoare (aforall P) (SEQ c1 c2) (aforall Q)"
                ],
                "tactic_res": [
                    "c12_goal : Hoare (aforall P) (SEQ c1 c2) (aforall Q)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c6_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)),\nHoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)"
                ],
                "tactic_res": [
                    "c13_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c13_P : forall _ : X, assertion",
                    "c13_Q : forall _ : X, assertion",
                    "c13_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c7_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (WHILE b c) (Q x)),\nHoare (aforall P) (WHILE b c) (aforall Q)"
                ],
                "tactic_res": [
                    "c14_goal : Hoare (aforall P) (WHILE b c) (aforall Q)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c8_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) (ASSERT b) (Q x)),\nHoare (aforall P) (ASSERT b) (aforall Q)"
                ],
                "tactic_res": [
                    "c15_goal : Hoare (aforall P) (ASSERT b) (aforall Q)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q H .",
                "tactic_args": [
                    "c9_goal : forall (P Q : forall _ : X, assertion)\n  (_ : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)),\nHoare (aforall P) (HAVOC x) (aforall Q)"
                ],
                "tactic_res": [
                    "c16_goal : Hoare (aforall P) (HAVOC x) (aforall Q)",
                    "c16_P : forall _ : X, assertion",
                    "c16_Q : forall _ : X, assertion",
                    "c16_H : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)"
                ]
            },
            {
                "tactic_sig": "assert ( H' : forall x , _i x -->> _i x ) by ( intros ; apply Hoare_skip_inv ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall x , _i x -->> _i x ) by ( intros ; apply Hoare_skip_inv ; auto ) .",
                "tactic_args": [
                    "c10_P : forall _ : X, assertion",
                    "c10_Q : forall _ : X, assertion",
                    "c10_H : forall x : X, Hoare (P x) SKIP (Q x)",
                    "c2_inhabited : X",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c10_H' : forall x : X, aimp (P x) (Q x)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : Hoare (aforall P) SKIP (aforall Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c17_goal : Hoare ?P SKIP (aforall Q)",
                    "c18_goal : aimp (aforall P) (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Hoare ?P SKIP (aforall Q)",
                    "_global_Hoare_skip : forall P : assertion, Hoare P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps x .",
                "tactic_args": [
                    "c18_goal : aimp (aforall P) (aforall Q)"
                ],
                "tactic_res": [
                    "c19_goal : Q x s",
                    "c19_s : store",
                    "c19_Ps : aforall P s",
                    "c19_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Q x s",
                    "c10_H' : forall x : X, aimp (P x) (Q x)"
                ],
                "tactic_res": [
                    "c20_goal : P x s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : P x s",
                    "c19_Ps : aforall P s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H' : forall y , _i y -->> aupdate _i _i ( _i y ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall y , _i y -->> aupdate _i _i ( _i y ) ) .",
                "tactic_args": [
                    "c11_goal : Hoare (aforall P) (ASSIGN x a) (aforall Q)",
                    "c11_P : forall _ : X, assertion",
                    "c4_x : ident",
                    "c4_a : aexp",
                    "c11_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c21_goal : forall y : X, aimp (P y) (aupdate x a (Q y))",
                    "c22_goal : Hoare (aforall P) (ASSIGN x a) (aforall Q)",
                    "c22_H' : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ],
                "tactic_res": [
                    "c23_goal : aimp (P y) (aupdate x a (Q y))",
                    "c23_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : aimp (P y) (aupdate x a (Q y))",
                    "_global_Hoare_assign_inv : forall (x : ident) (a : aexp) (P Q : assertion)\n         (_ : Hoare P (ASSIGN x a) Q), aimp P (aupdate x a Q)"
                ],
                "tactic_res": [
                    "c24_goal : Hoare (P y) (ASSIGN x a) (Q y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Hoare (P y) (ASSIGN x a) (Q y)",
                    "c23_y : X",
                    "c11_H : forall x0 : X, Hoare (P x0) (ASSIGN x a) (Q x0)",
                    "c11_P : forall _ : X, assertion",
                    "c11_Q : forall _ : X, assertion",
                    "c4_a : aexp",
                    "c4_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c22_goal : Hoare (aforall P) (ASSIGN x a) (aforall Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c25_goal : Hoare ?P (ASSIGN x a) (aforall Q)",
                    "c26_goal : aimp (aforall P) (aupdate x a (aforall Q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : Hoare ?P (ASSIGN x a) (aforall Q)",
                    "_global_Hoare_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Hoare (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps y .",
                "tactic_args": [
                    "c26_goal : aimp (aforall P) (aupdate x a (aforall Q))"
                ],
                "tactic_res": [
                    "c27_goal : Q y (update x (aeval a s) s)",
                    "c27_s : store",
                    "c27_Ps : aforall P s",
                    "c27_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : Q y (update x (aeval a s) s)",
                    "c22_H' : forall y : X, aimp (P y) (aupdate x a (Q y))"
                ],
                "tactic_res": [
                    "c28_goal : P y s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : P y s",
                    "c27_y : X",
                    "c27_Ps : aforall P s",
                    "c27_s : store",
                    "c11_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( R : assertion ) => Hoare ( _i x ) _i R /\\ Hoare R _i ( _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( R : assertion ) => Hoare ( _i x ) _i R /\\ Hoare R _i ( _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c12_P : forall _ : X, assertion",
                    "c5_c1 : com",
                    "c5_c2 : com",
                    "c12_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c12_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_args": [
                    "c12_goal : Hoare (aforall P) (SEQ c1 c2) (aforall Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c12_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c29_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c30_goal : Hoare (aforall P) (SEQ c1 c2) (aforall Q)",
                    "c30_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c31_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c31_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c32_goal : ex (fun b : assertion => REL x b)",
                    "c32_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_seq_inv : forall (c1 c2 : com) (P Q : assertion) (_ : Hoare P (SEQ c1 c2) Q),\n       ex (fun R : assertion => and (Hoare P c1 R) (Hoare R c2 Q))"
                ],
                "tactic_res": [
                    "c33_goal : Hoare (P x) (SEQ c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c32_x : X",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c5_c1 : com",
                    "c5_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( R & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R & _i ) .",
                "tactic_args": [
                    "c30_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c30_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c12_H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)",
                    "c12_P : forall _ : X, assertion",
                    "c12_Q : forall _ : X, assertion",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aforall P) c2 (aforall Q)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aforall P) c1 (aforall Q)",
                    "c5_c1 : com",
                    "c5_c2 : com",
                    "c2_inhabited : X",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c30_H' : forall x : X, REL x (R x)",
                    "c30_R : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c30_goal : Hoare (aforall P) (SEQ c1 c2) (aforall Q)",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      inhabited : X\n      c1 : com\n      c2 : com\n      IHc1 : forall (P Q : forall _ : X, assertion)\n               (_ : forall x : X, Hoare (P x) c1 (Q x)),\n             Hoare (aforall P) c1 (aforall Q)\n      IHc2 : forall (P Q : forall _ : X, assertion)\n               (_ : forall x : X, Hoare (P x) c2 (Q x)),\n             Hoare (aforall P) c2 (aforall Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (SEQ c1 c2) (Q x)\n      REL := fun (x : X) (R : assertion) =>\n             and (Hoare (P x) c1 R) (Hoare R c2 (Q x))\n       : forall (_ : X) (_ : assertion), Prop\n      R : forall _ : X, assertion\n      H' : forall x : X, REL x (R x) |- Type]",
                    "c30_R : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c34_goal : Hoare (aforall P) c1 (aforall R)",
                    "c35_goal : Hoare (aforall R) c2 (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c34_goal : Hoare (aforall P) c1 (aforall R)",
                    "c5_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aforall P) c1 (aforall Q)"
                ],
                "tactic_res": [
                    "c36_goal : forall x : X, Hoare (P x) c1 (R x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c36_goal : forall x : X, Hoare (P x) c1 (R x)"
                ],
                "tactic_res": [
                    "c37_goal : Hoare (P x) c1 (R x)",
                    "c37_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : Hoare (P x) c1 (R x)",
                    "c30_H' : forall x : X, REL x (R x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c35_goal : Hoare (aforall R) c2 (aforall Q)",
                    "c5_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aforall P) c2 (aforall Q)"
                ],
                "tactic_res": [
                    "c38_goal : forall x : X, Hoare (R x) c2 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c38_goal : forall x : X, Hoare (R x) c2 (Q x)"
                ],
                "tactic_res": [
                    "c39_goal : Hoare (R x) c2 (Q x)",
                    "c39_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : Hoare (R x) c2 (Q x)",
                    "c30_H' : forall x : X, REL x (R x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H1 : Hoare ( aforall ( fun x => atrue _i //\\\\ _i x ) ) _i ( aforall _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H1 : Hoare ( aforall ( fun x => atrue _i //\\\\ _i x ) ) _i ( aforall _i ) ) .",
                "tactic_args": [
                    "c13_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c6_b : bexp",
                    "c13_P : forall _ : X, assertion",
                    "c6_c1 : com",
                    "c13_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c40_goal : Hoare (aforall (fun x : X => aand (atrue b) (P x))) c1 (aforall Q)",
                    "c41_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c41_H1 : Hoare (aforall (fun x : X => aand (atrue b) (P x))) c1 (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : Hoare (aforall (fun x : X => aand (atrue b) (P x))) c1 (aforall Q)",
                    "c6_IHc1 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c1 (Q x)),\nHoare (aforall P) c1 (aforall Q)"
                ],
                "tactic_res": [
                    "c42_goal : forall x : X, Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c42_goal : forall x : X, Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ],
                "tactic_res": [
                    "c43_goal : Hoare (aand (atrue b) (P x)) c1 (Q x)",
                    "c43_x : X"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c43_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)",
                    "c43_x : X"
                ],
                "tactic_res": [
                    "c43_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c43_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ],
                "tactic_res": [
                    "c43_H : and (Hoare (aand (atrue b) (P x)) c1 (Q x))\n  (Hoare (aand (afalse b) (P x)) c2 (Q x))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c43_goal : Hoare (aand (atrue b) (P x)) c1 (Q x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H2 : Hoare ( aforall ( fun x => afalse _i //\\\\ _i x ) ) _i ( aforall _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H2 : Hoare ( aforall ( fun x => afalse _i //\\\\ _i x ) ) _i ( aforall _i ) ) .",
                "tactic_args": [
                    "c41_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c6_b : bexp",
                    "c13_P : forall _ : X, assertion",
                    "c6_c2 : com",
                    "c13_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c44_goal : Hoare (aforall (fun x : X => aand (afalse b) (P x))) c2 (aforall Q)",
                    "c45_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "c45_H2 : Hoare (aforall (fun x : X => aand (afalse b) (P x))) c2 (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c44_goal : Hoare (aforall (fun x : X => aand (afalse b) (P x))) c2 (aforall Q)",
                    "c6_IHc2 : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c2 (Q x)),\nHoare (aforall P) c2 (aforall Q)"
                ],
                "tactic_res": [
                    "c46_goal : forall x : X, Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c46_goal : forall x : X, Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ],
                "tactic_res": [
                    "c47_goal : Hoare (aand (afalse b) (P x)) c2 (Q x)",
                    "c47_x : X"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c47_H : forall x : X, Hoare (P x) (IFTHENELSE b c1 c2) (Q x)",
                    "c47_x : X"
                ],
                "tactic_res": [
                    "c47_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Hoare_ifthenelse_inv : forall (b : bexp) (c1 c2 : com) (P Q : assertion)\n         (_ : Hoare P (IFTHENELSE b c1 c2) Q),\n       and (Hoare (aand (atrue b) P) c1 Q) (Hoare (aand (afalse b) P) c2 Q)",
                    "c47_H : Hoare (P x) (IFTHENELSE b c1 c2) (Q x)"
                ],
                "tactic_res": [
                    "c47_H : and (Hoare (aand (atrue b) (P x)) c1 (Q x))\n  (Hoare (aand (afalse b) (P x)) c2 (Q x))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c47_goal : Hoare (aand (afalse b) (P x)) c2 (Q x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c45_goal : Hoare (aforall P) (IFTHENELSE b c1 c2) (aforall Q)",
                    "_global_Hoare_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Hoare (aand (atrue b) P) c1 Q)\n         (_ : Hoare (aand (afalse b) P) c2 Q), Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c48_goal : Hoare (aand (atrue b) (aforall P)) c1 (aforall Q)",
                    "c49_goal : Hoare (aand (afalse b) (aforall P)) c2 (aforall Q)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c48_goal : Hoare (aand (atrue b) (aforall P)) c1 (aforall Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c50_goal : Hoare ?P c1 (aforall Q)",
                    "c51_goal : aimp (aand (atrue b) (aforall P)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c50_goal : Hoare ?P c1 (aforall Q)",
                    "c41_H1 : Hoare (aforall (fun x : X => aand (atrue b) (P x))) c1 (aforall Q)",
                    "c13_Q : forall _ : X, assertion",
                    "c6_c1 : com",
                    "c2_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c49_goal : Hoare (aand (afalse b) (aforall P)) c2 (aforall Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c52_goal : Hoare ?P c2 (aforall Q)",
                    "c53_goal : aimp (aand (afalse b) (aforall P)) ?P"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c52_goal : Hoare ?P c2 (aforall Q)",
                    "c45_H2 : Hoare (aforall (fun x : X => aand (afalse b) (P x))) c2 (aforall Q)",
                    "c13_Q : forall _ : X, assertion",
                    "c6_c2 : com",
                    "c2_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) _o .",
                "tactic_sig_no_out_arg": "intros s ( A & B ) x .",
                "tactic_args": [
                    "c51_goal : aimp (aand (atrue b) (aforall P))\n  (aforall (fun x : X => aand (atrue b) (P x)))"
                ],
                "tactic_res": [
                    "c54_goal : aand (atrue b) (P x) s",
                    "c54_s : store",
                    "c54_A : atrue b s",
                    "c54_B : aforall P s",
                    "c54_x : X"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c54_goal : aand (atrue b) (P x) s"
                ],
                "tactic_res": [
                    "c55_goal : atrue b s",
                    "c56_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : atrue b s",
                    "c54_A : atrue b s",
                    "c54_s : store",
                    "c6_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : P x s",
                    "c54_x : X",
                    "c54_B : aforall P s",
                    "c54_s : store",
                    "c13_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) _o .",
                "tactic_sig_no_out_arg": "intros s ( A & B ) x .",
                "tactic_args": [
                    "c53_goal : aimp (aand (afalse b) (aforall P))\n  (aforall (fun x : X => aand (afalse b) (P x)))"
                ],
                "tactic_res": [
                    "c57_goal : aand (afalse b) (P x) s",
                    "c57_s : store",
                    "c57_A : afalse b s",
                    "c57_B : aforall P s",
                    "c57_x : X"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c57_goal : aand (afalse b) (P x) s"
                ],
                "tactic_res": [
                    "c58_goal : afalse b s",
                    "c59_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c58_goal : afalse b s",
                    "c57_A : afalse b s",
                    "c57_s : store",
                    "c6_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : P x s",
                    "c57_x : X",
                    "c57_B : aforall P s",
                    "c57_s : store",
                    "c13_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( Inv : assertion ) => Hoare ( atrue _i //\\\\ Inv ) _i Inv /\\ ( _i x -->> Inv ) /\\ ( afalse _i //\\\\ Inv -->> _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( Inv : assertion ) => Hoare ( atrue _i //\\\\ Inv ) _i Inv /\\ ( _i x -->> Inv ) /\\ ( afalse _i //\\\\ Inv -->> _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c7_b : bexp",
                    "c2_c : com",
                    "c14_P : forall _ : X, assertion",
                    "c7_b : bexp",
                    "c14_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c14_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists Inv : _i -> assertion , forall x : _i , _i x ( Inv x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists Inv : _i -> assertion , forall x : _i , _i x ( Inv x ) ) .",
                "tactic_args": [
                    "c14_goal : Hoare (aforall P) (WHILE b c) (aforall Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c14_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c60_goal : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c61_goal : Hoare (aforall P) (WHILE b c) (aforall Q)",
                    "c61_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c60_goal : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c62_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c62_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c63_goal : ex (fun b : assertion => REL x b)",
                    "c63_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c63_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_while_inv : forall (b : bexp) (c : com) (P Q : assertion)\n         (_ : Hoare P (WHILE b c) Q),\n       ex\n         (fun Inv : assertion =>\n          and (Hoare (aand (atrue b) Inv) c Inv)\n            (and (aimp P Inv) (aimp (aand (afalse b) Inv) Q)))"
                ],
                "tactic_res": [
                    "c64_goal : Hoare (P x) (WHILE b c) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c64_goal : Hoare (P x) (WHILE b c) (Q x)",
                    "c63_x : X",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c2_c : com",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( Inv & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( Inv & _i ) .",
                "tactic_args": [
                    "c61_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c61_H' : ex (fun Inv : forall _ : X, assertion => forall x : X, REL x (Inv x))",
                    "c14_H : forall x : X, Hoare (P x) (WHILE b c) (Q x)",
                    "c14_P : forall _ : X, assertion",
                    "c14_Q : forall _ : X, assertion",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)",
                    "c2_c : com",
                    "c7_b : bexp",
                    "c2_inhabited : X",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c61_H' : forall x : X, REL x (Inv x)",
                    "c61_Inv : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i _i ) .",
                "tactic_args": [
                    "c61_goal : Hoare (aforall P) (WHILE b c) (aforall Q)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'",
                    "c14_P : forall _ : X, assertion",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      inhabited : X\n      b : bexp\n      c : com\n      IHc : forall (P Q : forall _ : X, assertion)\n              (_ : forall x : X, Hoare (P x) c (Q x)),\n            Hoare (aforall P) c (aforall Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (WHILE b c) (Q x)\n      REL := fun (x : X) (Inv : assertion) =>\n             and (Hoare (aand (atrue b) Inv) c Inv)\n               (and (aimp (P x) Inv) (aimp (aand (afalse b) Inv) (Q x)))\n       : forall (_ : X) (_ : assertion), Prop\n      Inv : forall _ : X, assertion\n      H' : forall x : X, REL x (Inv x) |- Type]",
                    "c61_Inv : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c65_goal : Hoare (aforall Inv) (WHILE b c) ?Q",
                    "c66_goal : aimp (aforall P) (aforall Inv)",
                    "c67_goal : aimp (aand (afalse b) (aforall Inv)) (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c65_goal : Hoare (aforall Inv) (WHILE b c) ?Q",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c68_goal : Hoare (aand (atrue b) (aforall Inv)) c (aforall Inv)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ( fun x => _i _i //\\\\ _i x ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ( fun x => _i _i //\\\\ _i x ) ) .",
                "tactic_args": [
                    "c68_goal : Hoare (aand (atrue b) (aforall Inv)) c (aforall Inv)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q",
                    "c14_P : forall _ : X, assertion",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      inhabited : X\n      b : bexp\n      c : com\n      IHc : forall (P Q : forall _ : X, assertion)\n              (_ : forall x : X, Hoare (P x) c (Q x)),\n            Hoare (aforall P) c (aforall Q)\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (WHILE b c) (Q x)\n      REL := fun (x : X) (Inv : assertion) =>\n             and (Hoare (aand (atrue b) Inv) c Inv)\n               (and (aimp (P x) Inv) (aimp (aand (afalse b) Inv) (Q x)))\n       : forall (_ : X) (_ : assertion), Prop\n      Inv : forall _ : X, assertion\n      H' : forall x : X, REL x (Inv x) |- Type]",
                    "_global_atrue : forall _ : bexp, assertion",
                    "c7_b : bexp",
                    "c61_Inv : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c69_goal : Hoare (aforall (fun x : X => aand (atrue b) (Inv x))) c (aforall Inv)",
                    "c70_goal : aimp (aand (atrue b) (aforall Inv))\n  (aforall (fun x : X => aand (atrue b) (Inv x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c69_goal : Hoare (aforall (fun x : X => aand (atrue b) (Inv x))) c (aforall Inv)",
                    "c7_IHc : forall (P Q : forall _ : X, assertion)\n  (_ : forall x : X, Hoare (P x) c (Q x)),\nHoare (aforall P) c (aforall Q)"
                ],
                "tactic_res": [
                    "c71_goal : forall x : X, Hoare (aand (atrue b) (Inv x)) c (Inv x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c71_goal : forall x : X, Hoare (aand (atrue b) (Inv x)) c (Inv x)"
                ],
                "tactic_res": [
                    "c72_goal : Hoare (aand (atrue b) (Inv x)) c (Inv x)",
                    "c72_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c72_goal : Hoare (aand (atrue b) (Inv x)) c (Inv x)",
                    "c61_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] _o .",
                "tactic_sig_no_out_arg": "intros s [ A B ] x .",
                "tactic_args": [
                    "c70_goal : aimp (aand (atrue b) (aforall Inv))\n  (aforall (fun x : X => aand (atrue b) (Inv x)))"
                ],
                "tactic_res": [
                    "c73_goal : aand (atrue b) (Inv x) s",
                    "c73_s : store",
                    "c73_A : atrue b s",
                    "c73_B : aforall Inv s",
                    "c73_x : X"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c73_goal : aand (atrue b) (Inv x) s"
                ],
                "tactic_res": [
                    "c74_goal : atrue b s",
                    "c75_goal : Inv x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : atrue b s",
                    "c73_A : atrue b s",
                    "c73_s : store",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c75_goal : Inv x s",
                    "c73_x : X",
                    "c73_B : aforall Inv s",
                    "c73_s : store",
                    "c61_Inv : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s A x .",
                "tactic_args": [
                    "c66_goal : aimp (aforall P) (aforall Inv)"
                ],
                "tactic_res": [
                    "c76_goal : Inv x s",
                    "c76_s : store",
                    "c76_A : aforall P s",
                    "c76_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c76_goal : Inv x s",
                    "c61_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": [
                    "c77_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c77_goal : P x s",
                    "c76_x : X",
                    "c76_A : aforall P s",
                    "c76_s : store",
                    "c14_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] _o .",
                "tactic_sig_no_out_arg": "intros s [ A B ] x .",
                "tactic_args": [
                    "c67_goal : aimp (aand (afalse b) (aforall Inv)) (aforall Q)"
                ],
                "tactic_res": [
                    "c78_goal : Q x s",
                    "c78_s : store",
                    "c78_A : afalse b s",
                    "c78_B : aforall Inv s",
                    "c78_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c78_goal : Q x s",
                    "c61_H' : forall x : X, REL x (Inv x)"
                ],
                "tactic_res": [
                    "c79_goal : aand (afalse b) (Inv x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c79_goal : aand (afalse b) (Inv x) s"
                ],
                "tactic_res": [
                    "c80_goal : afalse b s",
                    "c81_goal : Inv x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c80_goal : afalse b s",
                    "c78_A : afalse b s",
                    "c78_s : store",
                    "c7_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c81_goal : Inv x s",
                    "c78_x : X",
                    "c78_B : aforall Inv s",
                    "c78_s : store",
                    "c61_Inv : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( REL := fun ( x : _i ) ( R : assertion ) => ( _i x -->> atrue _i //\\\\ R ) /\\ ( atrue _i //\\\\ R -->> _i x ) ) .",
                "tactic_sig_no_out_arg": "set ( REL := fun ( x : _i ) ( R : assertion ) => ( _i x -->> atrue _i //\\\\ R ) /\\ ( atrue _i //\\\\ R -->> _i x ) ) .",
                "tactic_args": [
                    "c2_X : Type",
                    "c15_P : forall _ : X, assertion",
                    "c8_b : bexp",
                    "c8_b : bexp",
                    "c15_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c15_REL : forall (_ : X) (_ : assertion), Prop"
                ]
            },
            {
                "tactic_sig": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : exists R : _i -> assertion , forall x : _i , _i x ( R x ) ) .",
                "tactic_args": [
                    "c15_goal : Hoare (aforall P) (ASSERT b) (aforall Q)",
                    "c2_X : Type",
                    "c2_X : Type",
                    "c15_REL : forall (_ : X) (_ : assertion), Prop"
                ],
                "tactic_res": [
                    "c82_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c83_goal : Hoare (aforall P) (ASSERT b) (aforall Q)",
                    "c83_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c82_goal : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c84_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c84_goal : forall a : X, ex (fun b : assertion => REL a b)"
                ],
                "tactic_res": [
                    "c85_goal : ex (fun b : assertion => REL x b)",
                    "c85_x : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c85_goal : ex (fun b : assertion => REL x b)",
                    "_global_Hoare_assert_inv : forall (b : bexp) (P Q : assertion) (_ : Hoare P (ASSERT b) Q),\n       ex\n         (fun R : assertion =>\n          and (aimp P (aand (atrue b) R)) (aimp (aand (atrue b) R) Q))"
                ],
                "tactic_res": [
                    "c86_goal : Hoare (P x) (ASSERT b) (Q x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : Hoare (P x) (ASSERT b) (Q x)",
                    "c85_x : X",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as ( R & A ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( R & A ) .",
                "tactic_args": [
                    "c83_H' : ex (fun R : forall _ : X, assertion => forall x : X, REL x (R x))",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_P : forall _ : X, assertion",
                    "c15_Q : forall _ : X, assertion",
                    "c8_b : bexp",
                    "c2_inhabited : X",
                    "c2_X : Type",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c83_A : forall x : X, REL x (R x)",
                    "c83_R : forall _ : X, assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c83_goal : Hoare (aforall P) (ASSERT b) (aforall Q)",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c87_goal : Hoare ?P (ASSERT b) ?Q",
                    "c88_goal : aimp (aforall P) (aand (atrue b) (aforall R))",
                    "c89_goal : aimp (aand (atrue b) (aforall R)) (aforall Q)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i _i ) .",
                "tactic_args": [
                    "c87_goal : Hoare ?P (ASSERT b) ?Q",
                    "_global_Hoare_assert : forall (P : assertion) (b : bexp),\n       Hoare (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c15_P : forall _ : X, assertion",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [CHOICE : choice_axiom\n      X : Type\n      inhabited : X\n      b : bexp\n      P : forall _ : X, assertion\n      Q : forall _ : X, assertion\n      H : forall x : X, Hoare (P x) (ASSERT b) (Q x)\n      REL := fun (x : X) (R : assertion) =>\n             and (aimp (P x) (aand (atrue b) R))\n               (aimp (aand (atrue b) R) (Q x))\n       : forall (_ : X) (_ : assertion), Prop\n      R : forall _ : X, assertion\n      A : forall x : X, REL x (R x) |- Type]",
                    "c83_R : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Pall .",
                "tactic_args": [
                    "c88_goal : aimp (aforall P) (aand (atrue b) (aforall R))"
                ],
                "tactic_res": [
                    "c90_goal : aand (atrue b) (aforall R) s",
                    "c90_s : store",
                    "c90_Pall : aforall P s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c90_goal : aand (atrue b) (aforall R) s"
                ],
                "tactic_res": [
                    "c91_goal : atrue b s",
                    "c92_goal : aforall R s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_args": [
                    "c83_A : forall x : X, REL x (R x)",
                    "c2_inhabited : X",
                    "c90_Pall : aforall P s",
                    "c90_s : store",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c8_b : bexp",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c91_C : aimp (aand (atrue b) (R inhabited)) (Q inhabited)",
                    "c91_B : aimp (P inhabited) (aand (atrue b) (R inhabited))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c91_goal : atrue b s",
                    "c91_B : aimp (P inhabited) (aand (atrue b) (R inhabited))"
                ],
                "tactic_res": [
                    "c93_goal : P inhabited s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c93_goal : P inhabited s",
                    "c90_Pall : aforall P s",
                    "c90_s : store",
                    "c15_P : forall _ : X, assertion",
                    "c2_inhabited : X"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c92_goal : aforall R s"
                ],
                "tactic_res": [
                    "c94_goal : R x s",
                    "c94_x : X"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_args": [
                    "c83_A : forall x : X, REL x (R x)",
                    "c94_x : X",
                    "c90_Pall : aforall P s",
                    "c90_s : store",
                    "c83_R : forall _ : X, assertion",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c2_inhabited : X",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c94_C : aimp (aand (atrue b) (R x)) (Q x)",
                    "c94_B : aimp (P x) (aand (atrue b) (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c94_goal : R x s",
                    "c94_B : aimp (P x) (aand (atrue b) (R x))"
                ],
                "tactic_res": [
                    "c95_goal : P x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c95_goal : P x s",
                    "c94_x : X",
                    "c90_Pall : aforall P s",
                    "c90_s : store",
                    "c15_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) _o .",
                "tactic_sig_no_out_arg": "intros s ( Bs & Rall ) x .",
                "tactic_args": [
                    "c89_goal : aimp (aand (atrue b) (aforall R)) (aforall Q)"
                ],
                "tactic_res": [
                    "c96_goal : Q x s",
                    "c96_s : store",
                    "c96_Bs : atrue b s",
                    "c96_Rall : aforall R s",
                    "c96_x : X"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as ( B & C ) .",
                "tactic_args": [
                    "c83_A : forall x : X, REL x (R x)",
                    "c96_x : X",
                    "c96_Rall : aforall R s",
                    "c96_Bs : atrue b s",
                    "c96_s : store",
                    "c15_H : forall x : X, Hoare (P x) (ASSERT b) (Q x)",
                    "c15_Q : forall _ : X, assertion",
                    "c2_inhabited : X",
                    "c2_CHOICE : choice_axiom"
                ],
                "tactic_res": [
                    "c96_C : aimp (aand (atrue b) (R x)) (Q x)",
                    "c96_B : aimp (P x) (aand (atrue b) (R x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c96_goal : Q x s",
                    "c96_C : aimp (aand (atrue b) (R x)) (Q x)"
                ],
                "tactic_res": [
                    "c97_goal : aand (atrue b) (R x) s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c97_goal : aand (atrue b) (R x) s"
                ],
                "tactic_res": [
                    "c98_goal : atrue b s",
                    "c99_goal : R x s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c98_goal : atrue b s",
                    "c96_Bs : atrue b s",
                    "c96_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c99_goal : R x s",
                    "c96_x : X",
                    "c96_Rall : aforall R s",
                    "c96_s : store",
                    "c83_R : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H' : forall y , _i y -->> aforall ( fun n => aupdate _i ( CONST n ) ( _i y ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : forall y , _i y -->> aforall ( fun n => aupdate _i ( CONST n ) ( _i y ) ) ) .",
                "tactic_args": [
                    "c16_goal : Hoare (aforall P) (HAVOC x) (aforall Q)",
                    "c16_P : forall _ : X, assertion",
                    "c9_x : ident",
                    "c16_Q : forall _ : X, assertion"
                ],
                "tactic_res": [
                    "c100_goal : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "c101_goal : Hoare (aforall P) (HAVOC x) (aforall Q)",
                    "c101_H' : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c100_goal : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ],
                "tactic_res": [
                    "c102_goal : aimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "c102_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c102_goal : aimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))",
                    "_global_Hoare_havoc_inv : forall (x : ident) (P Q : assertion) (_ : Hoare P (HAVOC x) Q),\n       aimp P (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ],
                "tactic_res": [
                    "c103_goal : Hoare (P y) (HAVOC x) (Q y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c103_goal : Hoare (P y) (HAVOC x) (Q y)",
                    "c102_y : X",
                    "c16_H : forall x0 : X, Hoare (P x0) (HAVOC x) (Q x0)",
                    "c16_P : forall _ : X, assertion",
                    "c16_Q : forall _ : X, assertion",
                    "c9_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c101_goal : Hoare (aforall P) (HAVOC x) (aforall Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c104_goal : Hoare ?P (HAVOC x) (aforall Q)",
                    "c105_goal : aimp (aforall P) ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c104_goal : Hoare ?P (HAVOC x) (aforall Q)",
                    "_global_Hoare_havoc : forall (x : ident) (Q : assertion),\n       Hoare (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s Pall n y .",
                "tactic_args": [
                    "c105_goal : aimp (aforall P)\n  (aforall (fun n : Z => aupdate x (CONST n) (aforall Q)))"
                ],
                "tactic_res": [
                    "c106_goal : Q y (update x (aeval (CONST n) s) s)",
                    "c106_s : store",
                    "c106_Pall : aforall P s",
                    "c106_n : Z",
                    "c106_y : X"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c106_goal : Q y (update x (aeval (CONST n) s) s)",
                    "c101_H' : forall y : X,\naimp (P y) (aforall (fun n : Z => aupdate x (CONST n) (Q y)))"
                ],
                "tactic_res": [
                    "c107_goal : P y s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c107_goal : P y s",
                    "c106_y : X",
                    "c106_Pall : aforall P s",
                    "c106_s : store",
                    "c16_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_safe",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_safe : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> forall s , P s -> ~ ( error c s ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_safe : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> forall s , P s -> ~ ( error c s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q)\n  (s : store) (_ : P s), not (error c s)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q)\n  (s : store) (_ : P s), not (error c s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : store) (_ : P s), not (error SKIP s)",
                    "c2_P : assertion",
                    "c3_goal : forall (s : store) (_ : aupdate x a P s), not (error (ASSIGN x a) s)",
                    "c3_a : aexp",
                    "c3_x : ident",
                    "c3_P : assertion",
                    "c4_goal : forall (s : store) (_ : P s), not (error (SEQ c1 c2) s)",
                    "c4_IHHoare2 : forall (s : store) (_ : Q s), not (error c2 s)",
                    "c4_IHHoare1 : forall (s : store) (_ : P s), not (error c1 s)",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_H : Hoare P c1 Q",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_R : assertion",
                    "c4_Q : assertion",
                    "c4_P : assertion",
                    "c5_goal : forall (s : store) (_ : P s), not (error (IFTHENELSE b c1 c2) s)",
                    "c5_IHHoare2 : forall (s : store) (_ : aand (afalse b) P s), not (error c2 s)",
                    "c5_IHHoare1 : forall (s : store) (_ : aand (atrue b) P s), not (error c1 s)",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_Q : assertion",
                    "c5_P : assertion",
                    "c6_goal : forall (s : store) (_ : P s), not (error (WHILE b c) s)",
                    "c6_IHHoare : forall (s : store) (_ : aand (atrue b) P s), not (error c s)",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion",
                    "c7_goal : forall (s : store) (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s),\nnot (error (HAVOC x) s)",
                    "c7_Q : assertion",
                    "c7_x : ident",
                    "c8_goal : forall (s : store) (_ : aand (atrue b) P s), not (error (ASSERT b) s)",
                    "c8_b : bexp",
                    "c8_P : assertion",
                    "c9_goal : forall (s : store) (_ : P' s), not (error c s)",
                    "c9_IHHoare : forall (s : store) (_ : P s), not (error c s)",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : Hoare P c Q",
                    "c9_c : com",
                    "c9_Q' : assertion",
                    "c9_P' : assertion",
                    "c9_Q : assertion",
                    "c9_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c2_goal : forall (s : store) (_ : P s), not (error SKIP s)"
                ],
                "tactic_res": [
                    "c10_goal : not (error SKIP s)",
                    "c10_s : store",
                    "c10_Ps : P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : not (error SKIP s)"
                ],
                "tactic_res": [
                    "c11_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c3_goal : forall (s : store) (_ : aupdate x a P s), not (error (ASSIGN x a) s)"
                ],
                "tactic_res": [
                    "c12_goal : not (error (ASSIGN x a) s)",
                    "c12_s : store",
                    "c12_Ps : aupdate x a P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : not (error (ASSIGN x a) s)"
                ],
                "tactic_res": [
                    "c13_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c4_goal : forall (s : store) (_ : P s), not (error (SEQ c1 c2) s)"
                ],
                "tactic_res": [
                    "c14_goal : not (error (SEQ c1 c2) s)",
                    "c14_s : store",
                    "c14_Ps : P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : not (error (SEQ c1 c2) s)"
                ],
                "tactic_res": [
                    "c15_goal : not (error c1 s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : not (error c1 s)",
                    "c14_Ps : P s",
                    "c14_s : store",
                    "c4_IHHoare1 : forall (s : store) (_ : P s), not (error c1 s)",
                    "c4_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : P s), not (error (IFTHENELSE b c1 c2) s)"
                ],
                "tactic_res": [
                    "c16_goal : not (error (IFTHENELSE b c1 c2) s)",
                    "c16_s : store",
                    "c16_Ps : P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : not (error (IFTHENELSE b c1 c2) s)"
                ],
                "tactic_res": [
                    "c17_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P s), not (error (WHILE b c) s)"
                ],
                "tactic_res": [
                    "c18_goal : not (error (WHILE b c) s)",
                    "c18_s : store",
                    "c18_Ps : P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c18_goal : not (error (WHILE b c) s)"
                ],
                "tactic_res": [
                    "c19_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c7_goal : forall (s : store) (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s),\nnot (error (HAVOC x) s)"
                ],
                "tactic_res": [
                    "c20_goal : not (error (HAVOC x) s)",
                    "c20_s : store",
                    "c20_Ps : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c20_goal : not (error (HAVOC x) s)"
                ],
                "tactic_res": [
                    "c21_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c8_goal : forall (s : store) (_ : aand (atrue b) P s), not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c22_goal : not (error (ASSERT b) s)",
                    "c22_s : store",
                    "c22_Ps : aand (atrue b) P s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c23_goal : not (eq (beval b s) false)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c9_goal : forall (s : store) (_ : P' s), not (error c s)"
                ],
                "tactic_res": [
                    "c24_goal : not (error c s)",
                    "c24_s : store",
                    "c24_Ps : P' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : not (error c s)",
                    "c24_Ps : P' s",
                    "c24_s : store",
                    "c9_IHHoare : forall (s : store) (_ : P s), not (error c s)",
                    "c9_H0 : aimp P' P",
                    "c9_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c22_Ps : aand (atrue b) P s",
                    "c22_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": [
                    "c23_H0 : P s",
                    "c23_H : atrue b s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c23_H : atrue b s"
                ],
                "tactic_res": [
                    "c23_H : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c23_goal : not (eq (beval b s) false)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_step",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_step : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> forall s c' s' , P s -> red ( c , s ) ( c' , s' ) -> exists P' , \u2983 P' \u2984 c' \u2983 Q \u2984 /\\ P' s' .",
                "tactic_sig_no_out_arg": "Lemma Hoare_step : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> forall s c' s' , P s -> red ( c , s ) ( c' , s' ) -> exists P' , \u2983 P' \u2984 c' \u2983 Q \u2984 /\\ P' s' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q)\n  (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q)\n  (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair SKIP s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c2_P : assertion",
                    "c3_goal : forall (s : store) (c' : com) (s' : store) (_ : aupdate x a P s)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c3_a : aexp",
                    "c3_x : ident",
                    "c3_P : assertion",
                    "c4_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (SEQ c1 c2) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c4_IHHoare2 : forall (s : store) (c' : com) (s' : store) (_ : Q s)\n  (_ : red (pair c2 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c4_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c1 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_H : Hoare P c1 Q",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_R : assertion",
                    "c4_Q : assertion",
                    "c4_P : assertion",
                    "c5_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_IHHoare2 : forall (s : store) (c' : com) (s' : store) (_ : aand (afalse b) P s)\n  (_ : red (pair c2 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair c1 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_Q : assertion",
                    "c5_P : assertion",
                    "c6_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nex\n  (fun P' : assertion => and (Hoare P' c' (aand (afalse b) P)) (P' s'))",
                    "c6_IHHoare : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion",
                    "c7_goal : forall (s : store) (c' : com) (s' : store)\n  (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s)\n  (_ : red (pair (HAVOC x) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c7_Q : assertion",
                    "c7_x : ident",
                    "c8_goal : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' (aand (atrue b) P)) (P' s'))",
                    "c8_b : bexp",
                    "c8_P : assertion",
                    "c9_goal : forall (s : store) (c' : com) (s' : store) (_ : P' s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q') (P' s'))",
                    "c9_IHHoare : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : Hoare P c Q",
                    "c9_c : com",
                    "c9_Q' : assertion",
                    "c9_P' : assertion",
                    "c9_Q : assertion",
                    "c9_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c2_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair SKIP s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' P) (P' s'))"
                ],
                "tactic_res": [
                    "c10_goal : ex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c10_s : store",
                    "c10_c' : com",
                    "c10_s' : store",
                    "c10_Ps : P s",
                    "c10_RED : red (pair SKIP s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c3_goal : forall (s : store) (c' : com) (s' : store) (_ : aupdate x a P s)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' P) (P' s'))"
                ],
                "tactic_res": [
                    "c11_goal : ex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c11_s : store",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_Ps : aupdate x a P s",
                    "c11_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c4_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (SEQ c1 c2) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' R) (P' s'))"
                ],
                "tactic_res": [
                    "c12_goal : ex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c12_s : store",
                    "c12_c' : com",
                    "c12_s' : store",
                    "c12_Ps : P s",
                    "c12_RED : red (pair (SEQ c1 c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ],
                "tactic_res": [
                    "c13_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c13_s : store",
                    "c13_c' : com",
                    "c13_s' : store",
                    "c13_Ps : P s",
                    "c13_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nex\n  (fun P' : assertion => and (Hoare P' c' (aand (afalse b) P)) (P' s'))"
                ],
                "tactic_res": [
                    "c14_goal : ex\n  (fun P' : assertion => and (Hoare P' c' (aand (afalse b) P)) (P' s'))",
                    "c14_s : store",
                    "c14_c' : com",
                    "c14_s' : store",
                    "c14_Ps : P s",
                    "c14_RED : red (pair (WHILE b c) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c7_goal : forall (s : store) (c' : com) (s' : store)\n  (_ : aforall (fun n : Z => aupdate x (CONST n) Q) s)\n  (_ : red (pair (HAVOC x) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ],
                "tactic_res": [
                    "c15_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c15_s : store",
                    "c15_c' : com",
                    "c15_s' : store",
                    "c15_Ps : aforall (fun n : Z => aupdate x (CONST n) Q) s",
                    "c15_RED : red (pair (HAVOC x) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c8_goal : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' (aand (atrue b) P)) (P' s'))"
                ],
                "tactic_res": [
                    "c16_goal : ex (fun P' : assertion => and (Hoare P' c' (aand (atrue b) P)) (P' s'))",
                    "c16_s : store",
                    "c16_c' : com",
                    "c16_s' : store",
                    "c16_Ps : aand (atrue b) P s",
                    "c16_RED : red (pair (ASSERT b) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s c' s' Ps RED .",
                "tactic_args": [
                    "c9_goal : forall (s : store) (c' : com) (s' : store) (_ : P' s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q') (P' s'))"
                ],
                "tactic_res": [
                    "c17_goal : ex (fun P' : assertion => and (Hoare P' c' Q') (P' s'))",
                    "c17_s : store",
                    "c17_c' : com",
                    "c17_s' : store",
                    "c17_Ps : P' s",
                    "c17_RED : red (pair c s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : ex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c10_RED : red (pair SKIP s) (pair c' s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : ex (fun P' : assertion => and (Hoare P' c' P) (P' s'))",
                    "c11_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c18_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' SKIP P) (P' (update x (aeval a s) s)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c18_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' SKIP P) (P' (update x (aeval a s) s)))",
                    "c3_P : assertion"
                ],
                "tactic_res": [
                    "c19_goal : and (Hoare P SKIP P) (P (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c19_goal : and (Hoare P SKIP P) (P (update x (aeval a s) s))"
                ],
                "tactic_res": [
                    "c20_goal : Hoare P SKIP P",
                    "c21_goal : P (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c20_goal : Hoare P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c21_goal : P (update x (aeval a s) s)",
                    "c11_Ps : aupdate x a P s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : ex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c12_RED : red (pair (SEQ c1 c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c22_goal : ex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c22_Ps : P s'",
                    "c22_IHHoare2 : forall (s : store) (c'0 : com) (s' : store) (_ : Q s)\n  (_ : red (pair c' s) (pair c'0 s')),\nex (fun P' : assertion => and (Hoare P' c'0 R) (P' s'))",
                    "c22_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair SKIP s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c22_H0 : Hoare Q c' R",
                    "c22_H : Hoare P SKIP Q",
                    "c23_goal : ex (fun P' : assertion => and (Hoare P' (SEQ c3 c2) R) (P' s'))",
                    "c23_H2 : red (pair c1 s) (pair c3 s')",
                    "c23_c3 : com"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c22_goal : ex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c24_goal : and (Hoare Q c' R) (Q s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c24_goal : and (Hoare Q c' R) (Q s')"
                ],
                "tactic_res": [
                    "c25_goal : Hoare Q c' R",
                    "c26_goal : Q s'"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c25_goal : Hoare Q c' R",
                    "c22_H0 : Hoare Q c' R",
                    "c12_c' : com",
                    "c4_Q : assertion",
                    "c4_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c26_goal : Q s'",
                    "_global_Hoare_skip_inv : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q"
                ],
                "tactic_res": [
                    "c27_goal : Hoare ?P SKIP Q",
                    "c28_goal : P s'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : Hoare ?P SKIP Q",
                    "c22_H : Hoare P SKIP Q",
                    "c4_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : P s'",
                    "c22_Ps : P s'",
                    "c12_s' : store",
                    "c4_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _ _ _ _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _ _ _ _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_args": [
                    "c4_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c1 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c12_Ps : P s",
                    "c23_H2 : red (pair c1 s) (pair c3 s')",
                    "c23_c3 : com",
                    "c12_s' : store",
                    "c4_IHHoare2 : forall (s : store) (c' : com) (s' : store) (_ : Q s)\n  (_ : red (pair c2 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' R) (P' s'))",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_H : Hoare P c1 Q",
                    "c4_c2 : com",
                    "c4_R : assertion"
                ],
                "tactic_res": [
                    "c23_Ps' : P' s'",
                    "c23_HO' : Hoare P' c3 Q",
                    "c23_P' : assertion"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c23_goal : ex (fun P' : assertion => and (Hoare P' (SEQ c3 c2) R) (P' s'))",
                    "c23_P' : assertion"
                ],
                "tactic_res": [
                    "c29_goal : and (Hoare P' (SEQ c3 c2) R) (P' s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c29_goal : and (Hoare P' (SEQ c3 c2) R) (P' s')"
                ],
                "tactic_res": [
                    "c30_goal : Hoare P' (SEQ c3 c2) R",
                    "c31_goal : P' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : P' s'",
                    "c23_Ps' : P' s'",
                    "c23_P' : assertion",
                    "c12_s' : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c30_goal : Hoare P' (SEQ c3 c2) R",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c32_goal : Hoare P' c3 Q",
                    "c33_goal : Hoare Q c2 R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : Hoare P' c3 Q",
                    "c23_HO' : Hoare P' c3 Q",
                    "c23_P' : assertion",
                    "c23_c3 : com",
                    "c4_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : Hoare Q c2 R",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_c2 : com",
                    "c4_Q : assertion",
                    "c4_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c13_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c34_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (if beval b s' then c1 else c2) Q) (P' s'))",
                    "c34_Ps : P s'"
                ]
            },
            {
                "tactic_sig": "exists ( if beval _i _i then atrue _i //\\\\ _i else afalse _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "exists ( if beval _i _i then atrue _i //\\\\ _i else afalse _i //\\\\ _i ) .",
                "tactic_args": [
                    "c34_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (if beval b s' then c1 else c2) Q) (P' s'))",
                    "c5_b : bexp",
                    "c13_s' : store",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_b : bexp",
                    "c5_P : assertion"
                ],
                "tactic_res": [
                    "c35_goal : and\n  (Hoare (if beval b s' then aand (atrue b) P else aand (afalse b) P)\n     (if beval b s' then c1 else c2) Q)\n  ((if beval b s' then aand (atrue b) P else aand (afalse b) P) s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c35_goal : and\n  (Hoare (if beval b s' then aand (atrue b) P else aand (afalse b) P)\n     (if beval b s' then c1 else c2) Q)\n  ((if beval b s' then aand (atrue b) P else aand (afalse b) P) s')"
                ],
                "tactic_res": [
                    "c36_goal : Hoare (if beval b s' then aand (atrue b) P else aand (afalse b) P)\n  (if beval b s' then c1 else c2) Q",
                    "c37_goal : (if beval b s' then aand (atrue b) P else aand (afalse b) P) s'"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) as [  | ] .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) .",
                "tactic_args": [
                    "c36_goal : Hoare (if beval b s' then aand (atrue b) P else aand (afalse b) P)\n  (if beval b s' then c1 else c2) Q",
                    "c5_b : bexp",
                    "c13_s' : store",
                    "c34_Ps : P s'",
                    "c5_IHHoare2 : forall (s : store) (c' : com) (s' : store) (_ : aand (afalse b) P s)\n  (_ : red (pair c2 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair c1 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c1 : com",
                    "c5_c2 : com",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": [
                    "c38_goal : Hoare (aand (atrue b) P) c1 Q",
                    "c39_goal : Hoare (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : Hoare (aand (atrue b) P) c1 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_c2 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c37_goal : (if beval b s' then aand (atrue b) P else aand (afalse b) P) s'",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion",
                    "_global_atrue : forall _ : bexp, assertion",
                    "_global_afalse : forall _ : bexp, assertion"
                ],
                "tactic_res": [
                    "c40_goal : (if beval b s'\n then fun s : store => and (eq (beval b s) true) (P s)\n else fun s : store => and (eq (beval b s) false) (P s)) s'"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) eqn : B .",
                "tactic_args": [
                    "c40_goal : (if beval b s'\n then fun s : store => and (eq (beval b s) true) (P s)\n else fun s : store => and (eq (beval b s) false) (P s)) s'",
                    "c5_b : bexp",
                    "c13_s' : store",
                    "c34_Ps : P s'",
                    "c5_IHHoare2 : forall (s : store) (c' : com) (s' : store) (_ : aand (afalse b) P s)\n  (_ : red (pair c2 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_IHHoare1 : forall (s : store) (c' : com) (s' : store) (_ : aand (atrue b) P s)\n  (_ : red (pair c1 s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_P : assertion"
                ],
                "tactic_res": [
                    "c41_goal : and (eq (beval b s') true) (P s')",
                    "c41_B : eq (beval b s') true",
                    "c42_goal : and (eq (beval b s') false) (P s')",
                    "c42_B : eq (beval b s') false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : and (eq (beval b s') true) (P s')",
                    "c41_B : eq (beval b s') true",
                    "c34_Ps : P s'",
                    "c13_s' : store",
                    "c5_b : bexp",
                    "c5_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : and (eq (beval b s') false) (P s')",
                    "c42_B : eq (beval b s') false",
                    "c34_Ps : P s'",
                    "c13_s' : store",
                    "c5_b : bexp",
                    "c5_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : ex\n  (fun P' : assertion => and (Hoare P' c' (aand (afalse b) P)) (P' s'))",
                    "c14_RED : red (pair (WHILE b c) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c43_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' SKIP (aand (afalse b) P)) (P' s'))",
                    "c43_H1 : eq (beval b s') false",
                    "c43_Ps : P s'",
                    "c44_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (SEQ c (WHILE b c)) (aand (afalse b) P)) (P' s'))",
                    "c44_H1 : eq (beval b s') true",
                    "c44_Ps : P s'"
                ]
            },
            {
                "tactic_sig": "exists ( afalse _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "exists ( afalse _i //\\\\ _i ) .",
                "tactic_args": [
                    "c43_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' SKIP (aand (afalse b) P)) (P' s'))",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": [
                    "c45_goal : and (Hoare (aand (afalse b) P) SKIP (aand (afalse b) P))\n  (aand (afalse b) P s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c45_goal : and (Hoare (aand (afalse b) P) SKIP (aand (afalse b) P))\n  (aand (afalse b) P s')"
                ],
                "tactic_res": [
                    "c46_goal : Hoare (aand (afalse b) P) SKIP (aand (afalse b) P)",
                    "c47_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c46_goal : Hoare (aand (afalse b) P) SKIP (aand (afalse b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c47_goal : aand (afalse b) P s'",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion",
                    "_global_afalse : forall _ : bexp, assertion"
                ],
                "tactic_res": [
                    "c48_goal : and (eq (beval b s') false) (P s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : and (eq (beval b s') false) (P s')",
                    "c43_H1 : eq (beval b s') false",
                    "c43_Ps : P s'",
                    "c14_s' : store",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( atrue _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "exists ( atrue _i //\\\\ _i ) .",
                "tactic_args": [
                    "c44_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (SEQ c (WHILE b c)) (aand (afalse b) P)) (P' s'))",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": [
                    "c49_goal : and (Hoare (aand (atrue b) P) (SEQ c (WHILE b c)) (aand (afalse b) P))\n  (aand (atrue b) P s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c49_goal : and (Hoare (aand (atrue b) P) (SEQ c (WHILE b c)) (aand (afalse b) P))\n  (aand (atrue b) P s')"
                ],
                "tactic_res": [
                    "c50_goal : Hoare (aand (atrue b) P) (SEQ c (WHILE b c)) (aand (afalse b) P)",
                    "c51_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c50_goal : Hoare (aand (atrue b) P) (SEQ c (WHILE b c)) (aand (afalse b) P)",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "c6_P : assertion"
                ],
                "tactic_res": [
                    "c52_goal : Hoare (aand (atrue b) P) c P",
                    "c53_goal : Hoare P (WHILE b c) (aand (afalse b) P)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c52_goal : Hoare (aand (atrue b) P) c P",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c53_goal : Hoare P (WHILE b c) (aand (afalse b) P)",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c54_goal : Hoare (aand (atrue b) P) c P"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : Hoare (aand (atrue b) P) c P",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c51_goal : aand (atrue b) P s'",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion",
                    "_global_atrue : forall _ : bexp, assertion"
                ],
                "tactic_res": [
                    "c55_goal : and (eq (beval b s') true) (P s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : and (eq (beval b s') true) (P s')",
                    "c44_H1 : eq (beval b s') true",
                    "c44_Ps : P s'",
                    "c14_s' : store",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c15_RED : red (pair (HAVOC x) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c56_goal : ex (fun P' : assertion => and (Hoare P' SKIP Q) (P' (update x n s)))",
                    "c56_n : Z"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c56_goal : ex (fun P' : assertion => and (Hoare P' SKIP Q) (P' (update x n s)))",
                    "c7_Q : assertion"
                ],
                "tactic_res": [
                    "c57_goal : and (Hoare Q SKIP Q) (Q (update x n s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c57_goal : and (Hoare Q SKIP Q) (Q (update x n s))"
                ],
                "tactic_res": [
                    "c58_goal : Hoare Q SKIP Q",
                    "c59_goal : Q (update x n s)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c58_goal : Hoare Q SKIP Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c59_goal : Q (update x n s)",
                    "c15_Ps : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ Ps1 Ps2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Ps1 Ps2 ] .",
                "tactic_args": [
                    "c16_Ps : aand (atrue b) P s",
                    "c16_RED : red (pair (ASSERT b) s) (pair c' s')",
                    "c16_s' : store",
                    "c16_c' : com",
                    "c8_b : bexp",
                    "c8_P : assertion"
                ],
                "tactic_res": [
                    "c16_Ps2 : P s",
                    "c16_Ps1 : atrue b s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : ex (fun P' : assertion => and (Hoare P' c' (aand (atrue b) P)) (P' s'))",
                    "c16_RED : red (pair (ASSERT b) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c60_goal : ex\n  (fun P' : assertion => and (Hoare P' SKIP (aand (atrue b) P)) (P' s'))",
                    "c60_H0 : eq (beval b s') true",
                    "c60_Ps1 : atrue b s'",
                    "c60_Ps2 : P s'"
                ]
            },
            {
                "tactic_sig": "exists ( atrue _i //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "exists ( atrue _i //\\\\ _i ) .",
                "tactic_args": [
                    "c60_goal : ex\n  (fun P' : assertion => and (Hoare P' SKIP (aand (atrue b) P)) (P' s'))",
                    "c8_b : bexp",
                    "c8_P : assertion"
                ],
                "tactic_res": [
                    "c61_goal : and (Hoare (aand (atrue b) P) SKIP (aand (atrue b) P))\n  (aand (atrue b) P s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c61_goal : and (Hoare (aand (atrue b) P) SKIP (aand (atrue b) P))\n  (aand (atrue b) P s')"
                ],
                "tactic_res": [
                    "c62_goal : Hoare (aand (atrue b) P) SKIP (aand (atrue b) P)",
                    "c63_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c62_goal : Hoare (aand (atrue b) P) SKIP (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c63_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c64_goal : atrue b s'",
                    "c65_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c64_goal : atrue b s'",
                    "c16_s' : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c65_goal : P s'",
                    "c60_Ps2 : P s'",
                    "c16_s' : store",
                    "c8_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c9_H0 : aimp P' P",
                    "c17_Ps : P' s"
                ],
                "tactic_res": [
                    "c17_Ps : P s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _ _ _ _i _i ) as ( R & HO & Rs' ) .",
                "tactic_sig_no_out_arg": "destruct ( _i _ _ _ _i _i ) as ( R & HO & Rs' ) .",
                "tactic_args": [
                    "c9_IHHoare : forall (s : store) (c' : com) (s' : store) (_ : P s)\n  (_ : red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c17_Ps : P s",
                    "c17_RED : red (pair c s) (pair c' s')",
                    "c17_s' : store",
                    "c17_c' : com",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : Hoare P c Q",
                    "c9_Q' : assertion"
                ],
                "tactic_res": [
                    "c17_Rs' : R s'",
                    "c17_HO : Hoare R c' Q",
                    "c17_R : assertion"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c17_goal : ex (fun P' : assertion => and (Hoare P' c' Q') (P' s'))",
                    "c17_R : assertion"
                ],
                "tactic_res": [
                    "c66_goal : and (Hoare R c' Q') (R s')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c66_goal : and (Hoare R c' Q') (R s')"
                ],
                "tactic_res": [
                    "c67_goal : Hoare R c' Q'",
                    "c68_goal : R s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c68_goal : R s'",
                    "c17_Rs' : R s'",
                    "c17_R : assertion",
                    "c17_s' : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c67_goal : Hoare R c' Q'",
                    "_global_Hoare_consequence_post : forall (P Q Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp Q Q'), Hoare P c Q'",
                    "c9_Q : assertion"
                ],
                "tactic_res": [
                    "c69_goal : Hoare R c' Q",
                    "c70_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c69_goal : Hoare R c' Q",
                    "c17_HO : Hoare R c' Q",
                    "c17_R : assertion",
                    "c17_c' : com",
                    "c9_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c70_goal : aimp Q Q'",
                    "c9_H1 : aimp Q Q'",
                    "c9_Q : assertion",
                    "c9_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_steps",
        "proof": [
            {
                "tactic_sig": "Corollary Hoare_steps : forall P Q c s c' s' , \u2983 P \u2984 c \u2983 Q \u2984 -> P s -> star red ( c , s ) ( c' , s' ) -> exists P' , \u2983 P' \u2984 c' \u2983 Q \u2984 /\\ P' s' .",
                "tactic_sig_no_out_arg": "Corollary Hoare_steps : forall P Q c s c' s' , \u2983 P \u2984 c \u2983 Q \u2984 -> P s -> star red ( c , s ) ( c' , s' ) -> exists P' , \u2983 P' \u2984 c' \u2983 Q \u2984 /\\ P' s' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : Hoare P c Q) (_ : P s)\n  (_ : star red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall cs cs' , star red cs cs' -> forall P Q , Hoare P ( fst cs ) Q -> P ( snd cs ) -> exists P' , Hoare P' ( fst cs' ) Q /\\ P' ( snd cs' ) ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall cs cs' , star red cs cs' -> forall P Q , Hoare P ( fst cs ) Q -> P ( snd cs ) -> exists P' , Hoare P' ( fst cs' ) Q /\\ P' ( snd cs' ) ) .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : Hoare P c Q) (_ : P s)\n  (_ : star red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ],
                "tactic_res": [
                    "c2_goal : forall (cs cs' : prod com store) (_ : star red cs cs')\n  (P Q : assertion) (_ : Hoare P (fst cs) Q) (_ : P (snd cs)),\nex (fun P' : assertion => and (Hoare P' (fst cs') Q) (P' (snd cs')))",
                    "c3_goal : forall (P Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : Hoare P c Q) (_ : P s)\n  (_ : star red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c3_REC : forall (cs cs' : prod com store) (_ : star red cs cs')\n  (P Q : assertion) (_ : Hoare P (fst cs) Q) (_ : P (snd cs)),\nex (fun P' : assertion => and (Hoare P' (fst cs') Q) (P' (snd cs')))"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c2_goal : forall (cs cs' : prod com store) (_ : star red cs cs')\n  (P Q : assertion) (_ : Hoare P (fst cs) Q) (_ : P (snd cs)),\nex (fun P' : assertion => and (Hoare P' (fst cs') Q) (P' (snd cs')))"
                ],
                "tactic_res": [
                    "c4_goal : forall (P Q : assertion) (_ : Hoare P (fst a) Q) (_ : P (snd a)),\nex (fun P' : assertion => and (Hoare P' (fst a) Q) (P' (snd a)))",
                    "c4_a : prod com store",
                    "c5_goal : forall (P Q : assertion) (_ : Hoare P (fst a) Q) (_ : P (snd a)),\nex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))",
                    "c5_IHstar : forall (P Q : assertion) (_ : Hoare P (fst b) Q) (_ : P (snd b)),\nex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))",
                    "c5_H0 : star red b c",
                    "c5_H : red a b",
                    "c5_c : prod com store",
                    "c5_b : prod com store",
                    "c5_a : prod com store"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (P Q : assertion) (_ : Hoare P (fst a) Q) (_ : P (snd a)),\nex (fun P' : assertion => and (Hoare P' (fst a) Q) (P' (snd a)))"
                ],
                "tactic_res": [
                    "c6_goal : ex (fun P' : assertion => and (Hoare P' (fst a) Q) (P' (snd a)))",
                    "c6_P : assertion",
                    "c6_Q : assertion",
                    "c6_H : Hoare P (fst a) Q",
                    "c6_H0 : P (snd a)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (P Q : assertion) (_ : Hoare P (fst a) Q) (_ : P (snd a)),\nex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))"
                ],
                "tactic_res": [
                    "c7_goal : ex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))",
                    "c7_P : assertion",
                    "c7_Q : assertion",
                    "c7_H1 : Hoare P (fst a) Q",
                    "c7_H2 : P (snd a)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c6_goal : ex (fun P' : assertion => and (Hoare P' (fst a) Q) (P' (snd a)))",
                    "c6_P : assertion"
                ],
                "tactic_res": [
                    "c8_goal : and (Hoare P (fst a) Q) (P (snd a))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (Hoare P (fst a) Q) (P (snd a))",
                    "c6_H0 : P (snd a)",
                    "c6_H : Hoare P (fst a) Q",
                    "c6_P : assertion",
                    "c6_Q : assertion",
                    "c4_a : prod com store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ c1 s1 ] , _i as [ c2 s2 ] , _i as [ c3 s3 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ c1 s1 ] , _i as [ c2 s2 ] , _i as [ c3 s3 ] .",
                "tactic_args": [
                    "c7_goal : ex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))",
                    "c5_a : prod com store",
                    "c5_b : prod com store",
                    "c5_c : prod com store",
                    "c7_H2 : P (snd a)",
                    "c7_H1 : Hoare P (fst a) Q",
                    "c7_Q : assertion",
                    "c5_IHstar : forall (P Q : assertion) (_ : Hoare P (fst b) Q) (_ : P (snd b)),\nex (fun P' : assertion => and (Hoare P' (fst c) Q) (P' (snd c)))",
                    "c5_H0 : star red b c",
                    "c5_H : red a b"
                ],
                "tactic_res": [
                    "c9_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (fst (pair c3 s3)) Q) (P' (snd (pair c3 s3))))",
                    "c9_H2 : P (snd (pair c1 s1))",
                    "c9_H1 : Hoare P (fst (pair c1 s1)) Q",
                    "c9_IHstar : forall (P Q : assertion) (_ : Hoare P (fst (pair c2 s2)) Q)\n  (_ : P (snd (pair c2 s2))),\nex\n  (fun P' : assertion =>\n   and (Hoare P' (fst (pair c3 s3)) Q) (P' (snd (pair c3 s3))))",
                    "c9_H0 : star red (pair c2 s2) (pair c3 s3)",
                    "c9_H : red (pair c1 s1) (pair c2 s2)",
                    "c9_s3 : store",
                    "c9_c3 : com",
                    "c9_s2 : store",
                    "c9_c2 : com",
                    "c9_s1 : store",
                    "c9_c1 : com"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun P' : assertion =>\n   and (Hoare P' (fst (pair c3 s3)) Q) (P' (snd (pair c3 s3))))"
                ],
                "tactic_res": [
                    "c10_goal : ex (fun P' : assertion => and (Hoare P' c3 Q) (P' s3))",
                    "c10_H2 : P s1",
                    "c10_H1 : Hoare P c1 Q",
                    "c10_IHstar : forall (P Q : assertion) (_ : Hoare P c2 Q) (_ : P s2),\nex (fun P' : assertion => and (Hoare P' c3 Q) (P' s3))"
                ]
            },
            {
                "tactic_sig": "destruct ( Hoare_step _ _ _ _i _ _ _ _i _i ) as ( R & HO & Rs2 ) .",
                "tactic_sig_no_out_arg": "destruct ( Hoare_step _ _ _ _i _ _ _ _i _i ) as ( R & HO & Rs2 ) .",
                "tactic_args": [
                    "c10_H1 : Hoare P c1 Q",
                    "c10_H2 : P s1",
                    "c9_H : red (pair c1 s1) (pair c2 s2)",
                    "c7_Q : assertion",
                    "c10_IHstar : forall (P Q : assertion) (_ : Hoare P c2 Q) (_ : P s2),\nex (fun P' : assertion => and (Hoare P' c3 Q) (P' s3))",
                    "c9_H0 : star red (pair c2 s2) (pair c3 s3)",
                    "c9_s3 : store",
                    "c9_c3 : com"
                ],
                "tactic_res": [
                    "c10_Rs2 : R s2",
                    "c10_HO : Hoare R c2 Q",
                    "c10_R : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : ex (fun P' : assertion => and (Hoare P' c3 Q) (P' s3))",
                    "c10_IHstar : forall (P Q : assertion) (_ : Hoare P c2 Q) (_ : P s2),\nex (fun P' : assertion => and (Hoare P' c3 Q) (P' s3))"
                ],
                "tactic_res": [
                    "c11_goal : Hoare ?P c2 Q",
                    "c12_goal : R s2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : Hoare ?P c2 Q",
                    "c10_HO : Hoare R c2 Q",
                    "c7_Q : assertion",
                    "c9_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : R s2",
                    "c10_Rs2 : R s2",
                    "c10_R : assertion",
                    "c9_s2 : store"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (P Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : Hoare P c Q) (_ : P s)\n  (_ : star red (pair c s) (pair c' s')),\nex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))"
                ],
                "tactic_res": [
                    "c13_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c13_P : assertion",
                    "c13_Q : assertion",
                    "c13_c : com",
                    "c13_s : store",
                    "c13_c' : com",
                    "c13_s' : store",
                    "c13_H : Hoare P c Q",
                    "c13_H0 : P s",
                    "c13_H1 : star red (pair c s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "eapply ( _i ( _i , _i ) ( _i , _i ) ) .",
                "tactic_sig_no_out_arg": "eapply ( _i ( _i , _i ) ( _i , _i ) ) .",
                "tactic_args": [
                    "c13_goal : ex (fun P' : assertion => and (Hoare P' c' Q) (P' s'))",
                    "c3_REC : forall (cs cs' : prod com store) (_ : star red cs cs')\n  (P Q : assertion) (_ : Hoare P (fst cs) Q) (_ : P (snd cs)),\nex (fun P' : assertion => and (Hoare P' (fst cs') Q) (P' (snd cs')))",
                    "c13_c : com",
                    "c13_s : store",
                    "c13_c' : com",
                    "c13_s' : store"
                ],
                "tactic_res": [
                    "c14_goal : star red (pair c s) (pair c' s')",
                    "c15_goal : Hoare ?P (fst (pair c s)) Q",
                    "c16_goal : P (snd (pair c s))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : star red (pair c s) (pair c' s')",
                    "c13_H1 : star red (pair c s) (pair c' s')",
                    "c13_s' : store",
                    "c13_c' : com",
                    "c13_s : store",
                    "c13_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : Hoare ?P (fst (pair c s)) Q",
                    "c13_H : Hoare P c Q",
                    "c13_s : store",
                    "c13_c : com",
                    "c13_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : P (snd (pair c s))",
                    "c13_H0 : P s",
                    "c13_s : store",
                    "c13_c : com",
                    "c13_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_sound",
        "proof": [
            {
                "tactic_sig": "Corollary Hoare_sound : forall P c Q s , \u2983 P \u2984 c \u2983 Q \u2984 -> P s -> ~ goeswrong c s /\\ ( forall s' , terminates c s s' -> Q s' ) .",
                "tactic_sig_no_out_arg": "Corollary Hoare_sound : forall P c Q s , \u2983 P \u2984 c \u2983 Q \u2984 -> P s -> ~ goeswrong c s /\\ ( forall s' , terminates c s s' -> Q s' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (s : store)\n  (_ : Hoare P c Q) (_ : P s),\nand (not (goeswrong c s))\n  (forall (s' : store) (_ : terminates c s s'), Q s')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P c Q s HO Ps .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (s : store)\n  (_ : Hoare P c Q) (_ : P s),\nand (not (goeswrong c s))\n  (forall (s' : store) (_ : terminates c s s'), Q s')"
                ],
                "tactic_res": [
                    "c2_goal : and (not (goeswrong c s))\n  (forall (s' : store) (_ : terminates c s s'), Q s')",
                    "c2_P : assertion",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_s : store",
                    "c2_HO : Hoare P c Q",
                    "c2_Ps : P s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : and (not (goeswrong c s))\n  (forall (s' : store) (_ : terminates c s s'), Q s')"
                ],
                "tactic_res": [
                    "c3_goal : not (goeswrong c s)",
                    "c4_goal : forall (s' : store) (_ : terminates c s s'), Q s'"
                ]
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( c' & s' & RED & STUCK ) .",
                "tactic_args": [
                    "c3_goal : not (goeswrong c s)"
                ],
                "tactic_res": [
                    "c5_goal : False",
                    "c5_c' : com",
                    "c5_s' : store",
                    "c5_RED : star red (pair c s) (pair c' s')",
                    "c5_STUCK : error c' s'"
                ]
            },
            {
                "tactic_sig": "destruct ( Hoare_steps _ _ _ _ _ _ _i _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_sig_no_out_arg": "destruct ( Hoare_steps _ _ _ _ _ _ _i _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_args": [
                    "c2_HO : Hoare P c Q",
                    "c2_Ps : P s",
                    "c5_RED : star red (pair c s) (pair c' s')",
                    "c5_STUCK : error c' s'"
                ],
                "tactic_res": [
                    "c5_Ps' : P' s'",
                    "c5_HO' : Hoare P' c' Q",
                    "c5_P' : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c5_goal : False",
                    "_global_Hoare_safe : forall (P : assertion) (c : com) (Q : assertion) \n         (_ : Hoare P c Q) (s : store) (_ : P s), \n       not (error c s)"
                ],
                "tactic_res": [
                    "c6_goal : Hoare ?P ?c ?Q",
                    "c7_goal : P' ?s",
                    "c8_goal : error c' s'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : Hoare ?P ?c ?Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : P' ?s",
                    "c5_Ps' : P' s'",
                    "c5_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : error c' s'",
                    "c5_STUCK : error c' s'",
                    "c5_s' : store",
                    "c5_c' : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros s' ( c' & RED & TERM ) .",
                "tactic_args": [
                    "c4_goal : forall (s' : store) (_ : terminates c s s'), Q s'"
                ],
                "tactic_res": [
                    "c9_goal : Q s'",
                    "c9_s' : store",
                    "c9_c' : com",
                    "c9_RED : star red (pair c s) (pair c' s')",
                    "c9_TERM : terminated c'"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c9_TERM : terminated c'"
                ],
                "tactic_res": [
                    "c9_TERM : eq c' SKIP"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c9_c' : com",
                    "c9_TERM : eq c' SKIP"
                ],
                "tactic_res": [
                    "c9_RED : star red (pair c s) (pair SKIP s')"
                ]
            },
            {
                "tactic_sig": "destruct ( Hoare_steps _ _ _ _ _ _ _i _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_sig_no_out_arg": "destruct ( Hoare_steps _ _ _ _ _ _ _i _i _i ) as ( P' & HO' & Ps' ) .",
                "tactic_args": [
                    "c2_HO : Hoare P c Q",
                    "c2_Ps : P s",
                    "c9_RED : star red (pair c s) (pair SKIP s')",
                    "c9_s' : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c9_Ps' : P' s'",
                    "c9_HO' : Hoare P' SKIP Q",
                    "c9_P' : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c9_goal : Q s'",
                    "_global_Hoare_skip_inv : forall (P Q : assertion) (_ : Hoare P SKIP Q), aimp P Q"
                ],
                "tactic_res": [
                    "c10_goal : Hoare ?P SKIP Q",
                    "c11_goal : P' s'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c10_goal : Hoare ?P SKIP Q",
                    "c9_HO' : Hoare P' SKIP Q",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : P' s'",
                    "c9_Ps' : P' s'",
                    "c9_P' : assertion",
                    "c9_s' : store"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_skip",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_skip : forall P , \u301a\u301a P \u301b\u301b SKIP \u301a\u301a P \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_skip : forall P , \u301a\u301a P \u301b\u301b SKIP \u301a\u301a P \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : assertion, Triple P SKIP P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P s PRE .",
                "tactic_args": [
                    "c1_goal : forall P : assertion, Triple P SKIP P"
                ],
                "tactic_res": [
                    "c2_goal : safe P SKIP s",
                    "c2_P : assertion",
                    "c2_s : store",
                    "c2_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe P SKIP s",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : terminated SKIP",
                    "c4_goal : P s"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : terminated SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P s",
                    "c2_PRE : P s",
                    "c2_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_assign",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_assign : forall P x a , \u301a\u301a aupdate x a P \u301b\u301b ASSIGN x a \u301a\u301a P \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_assign : forall P x a , \u301a\u301a aupdate x a P \u301b\u301b ASSIGN x a \u301a\u301a P \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\nTriple (aupdate x a P) (ASSIGN x a) P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P x a s PRE .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\nTriple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": [
                    "c2_goal : safe P (ASSIGN x a) s",
                    "c2_P : assertion",
                    "c2_x : ident",
                    "c2_a : aexp",
                    "c2_s : store",
                    "c2_PRE : aupdate x a P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe P (ASSIGN x a) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : not (terminated (ASSIGN x a))",
                    "c4_goal : not (error (ASSIGN x a) s)",
                    "c5_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : not (terminated (ASSIGN x a))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c6_goal : not (eq (ASSIGN x a) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c6_goal : not (eq (ASSIGN x a) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c4_goal : not (error (ASSIGN x a) s)"
                ],
                "tactic_res": [
                    "c7_goal : not False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c7_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c5_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P c' s'"
                ],
                "tactic_res": [
                    "c8_goal : safe P c' s'",
                    "c8_c' : com",
                    "c8_s' : store",
                    "c8_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : safe P c' s'",
                    "c8_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c9_goal : safe P SKIP (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : safe P SKIP (update x (aeval a s) s)",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c10_goal : terminated SKIP",
                    "c11_goal : P (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c10_goal : terminated SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c11_goal : P (update x (aeval a s) s)",
                    "c2_PRE : aupdate x a P s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_seq",
        "proof": [
            {
                "tactic_sig": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) , ( forall s , Q s -> safe R c' s ) -> forall c s , safe Q c s -> safe R ( c ; ; c' ) s .",
                "tactic_sig_no_out_arg": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) , ( forall s , Q s -> safe R c' s ) -> forall c s , safe Q c s -> safe R ( c ; ; c' ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q R : assertion) (c' : com)\n  (_ : forall (s : store) (_ : Q s), safe R c' s) \n  (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q R c2 QR .",
                "tactic_args": [
                    "c1_goal : forall (Q R : assertion) (c' : com)\n  (_ : forall (s : store) (_ : Q s), safe R c' s) \n  (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c2 : com",
                    "c2_QR : forall (s : store) (_ : Q s), safe R c2 s"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s"
                ],
                "tactic_res": [
                    "c3_goal : safe R (SEQ c c2) s",
                    "c3_H0 : Q s",
                    "c3_H : terminated c",
                    "c3_s : store",
                    "c3_c : com",
                    "c4_goal : safe R (SEQ c c2) s",
                    "c4_H2 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe R (SEQ c' c2) s'",
                    "c4_H1 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c4_H0 : not (error c s)",
                    "c4_H : not (terminated c)",
                    "c4_s : store",
                    "c4_c : com"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : safe R (SEQ c c2) s",
                    "c3_H : terminated c"
                ],
                "tactic_res": [
                    "c5_goal : safe R (SEQ SKIP c2) s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe R (SEQ SKIP c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (SEQ SKIP c2))",
                    "c7_goal : not (error (SEQ SKIP c2) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ SKIP c2) s) (pair c' s')), safe R c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (SEQ SKIP c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (SEQ SKIP c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (SEQ SKIP c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (SEQ SKIP c2) s)"
                ],
                "tactic_res": [
                    "c10_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ SKIP c2) s) (pair c' s')), safe R c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe R c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : safe R c' s'",
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe R c' s'",
                    "c12_H0 : Q s'",
                    "c12_QR : forall (s : store) (_ : Q s), safe R c' s",
                    "c13_goal : safe R (SEQ c3 c2) s'",
                    "c13_H2 : red (pair SKIP s) (pair c3 s')",
                    "c13_c3 : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe R c' s'",
                    "c12_QR : forall (s : store) (_ : Q s), safe R c' s"
                ],
                "tactic_res": [
                    "c14_goal : Q s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Q s'",
                    "c12_H0 : Q s'",
                    "c11_s' : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : safe R (SEQ c3 c2) s'",
                    "c13_H2 : red (pair SKIP s) (pair c3 s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe R (SEQ c c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c15_goal : not (terminated (SEQ c c2))",
                    "c16_goal : not (error (SEQ c c2) s)",
                    "c17_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c15_goal : not (terminated (SEQ c c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c18_goal : not (eq (SEQ c c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c18_goal : not (eq (SEQ c c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c16_goal : not (error (SEQ c c2) s)"
                ],
                "tactic_res": [
                    "c19_goal : not (error c s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : not (error c s)",
                    "c4_H0 : not (error c s)",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c17_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R c' s'"
                ],
                "tactic_res": [
                    "c20_goal : safe R c' s'",
                    "c20_c' : com",
                    "c20_s' : store",
                    "c20_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c20_goal : safe R c' s'",
                    "c20_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c21_goal : safe R c' s'",
                    "c21_H : not (terminated SKIP)",
                    "c21_H2 : forall (c'0 : com) (s'0 : store)\n  (_ : red (pair SKIP s') (pair c'0 s'0)), safe R (SEQ c'0 c') s'0",
                    "c21_H1 : forall (c' : com) (s'0 : store) (_ : red (pair SKIP s') (pair c' s'0)),\nsafe Q c' s'0",
                    "c21_H0 : not (error SKIP s')",
                    "c21_QR : forall (s : store) (_ : Q s), safe R c' s",
                    "c22_goal : safe R (SEQ c3 c2) s'",
                    "c22_H4 : red (pair c s) (pair c3 s')",
                    "c22_c3 : com"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c21_goal : safe R c' s'",
                    "c21_H : not (terminated SKIP)"
                ],
                "tactic_res": [
                    "c23_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c23_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c24_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : safe R (SEQ c3 c2) s'",
                    "c4_H2 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe R (SEQ c' c2) s'"
                ],
                "tactic_res": [
                    "c25_goal : red (pair c s) (pair c3 s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : red (pair c s) (pair c3 s')",
                    "c22_H4 : red (pair c s) (pair c3 s')",
                    "c22_c3 : com",
                    "c20_s' : store",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_seq",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_seq : forall P Q R c1 c2 , \u301a\u301a P \u301b\u301b c1 \u301a\u301a Q \u301b\u301b -> \u301a\u301a Q \u301b\u301b c2 \u301a\u301a R \u301b\u301b -> \u301a\u301a P \u301b\u301b c1 ; ; c2 \u301a\u301a R \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_seq : forall P Q R c1 c2 , \u301a\u301a P \u301b\u301b c1 \u301a\u301a Q \u301b\u301b -> \u301a\u301a Q \u301b\u301b c2 \u301a\u301a R \u301b\u301b -> \u301a\u301a P \u301b\u301b c1 ; ; c2 \u301a\u301a R \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : Triple P c1 Q)\n  (_ : Triple Q c2 R), Triple P (SEQ c1 c2) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : Triple P c1 Q)\n  (_ : Triple Q c2 R), Triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c2_goal : Triple P (SEQ c1 c2) R",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : Triple P c1 Q",
                    "c2_H0 : Triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : Triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c3_goal : safe R (SEQ c1 c2) s",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe R (SEQ c1 c2) s",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com)\n         (_ : forall (s : store) (_ : Q s), safe R c' s) \n         (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c4_goal : forall (s : store) (_ : Q s), safe R c2 s",
                    "c5_goal : safe Q c1 s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (s : store) (_ : Q s), safe R c2 s",
                    "c2_H0 : Triple Q c2 R",
                    "c2_c2 : com",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe Q c1 s",
                    "c3_PRE : P s",
                    "c3_s : store",
                    "c2_H : Triple P c1 Q",
                    "c2_c1 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_ifthenelse : forall P Q b c1 c2 , \u301a\u301a atrue b //\\\\ P \u301b\u301b c1 \u301a\u301a Q \u301b\u301b -> \u301a\u301a afalse b //\\\\ P \u301b\u301b c2 \u301a\u301a Q \u301b\u301b -> \u301a\u301a P \u301b\u301b IFTHENELSE b c1 c2 \u301a\u301a Q \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_ifthenelse : forall P Q b c1 c2 , \u301a\u301a atrue b //\\\\ P \u301b\u301b c1 \u301a\u301a Q \u301b\u301b -> \u301a\u301a afalse b //\\\\ P \u301b\u301b c2 \u301a\u301a Q \u301b\u301b -> \u301a\u301a P \u301b\u301b IFTHENELSE b c1 c2 \u301a\u301a Q \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : Triple (aand (atrue b) P) c1 Q)\n  (_ : Triple (aand (afalse b) P) c2 Q),\nTriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : Triple (aand (atrue b) P) c1 Q)\n  (_ : Triple (aand (afalse b) P) c2 Q),\nTriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : Triple P (IFTHENELSE b c1 c2) Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_b : bexp",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : Triple (aand (atrue b) P) c1 Q",
                    "c2_H0 : Triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : Triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q (IFTHENELSE b c1 c2) s",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe Q (IFTHENELSE b c1 c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "c5_goal : not (error (IFTHENELSE b c1 c2) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (IFTHENELSE b c1 c2) s)"
                ],
                "tactic_res": [
                    "c8_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe Q c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe Q c' s'",
                    "c9_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe Q (if beval b s' then c1 else c2) s'",
                    "c10_PRE : P s'"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) eqn : B .",
                "tactic_args": [
                    "c10_goal : safe Q (if beval b s' then c1 else c2) s'",
                    "c2_b : bexp",
                    "c9_s' : store",
                    "c10_PRE : P s'",
                    "c2_H0 : Triple (aand (afalse b) P) c2 Q",
                    "c2_H : Triple (aand (atrue b) P) c1 Q",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c11_goal : safe Q c1 s'",
                    "c11_B : eq (beval b s') true",
                    "c12_goal : safe Q c2 s'",
                    "c12_B : eq (beval b s') false"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : safe Q c1 s'",
                    "c2_H : Triple (aand (atrue b) P) c1 Q"
                ],
                "tactic_res": [
                    "c13_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c14_goal : atrue b s'",
                    "c15_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : atrue b s'",
                    "c11_B : eq (beval b s') true",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : P s'",
                    "c10_PRE : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe Q c2 s'",
                    "c2_H0 : Triple (aand (afalse b) P) c2 Q"
                ],
                "tactic_res": [
                    "c16_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c17_goal : afalse b s'",
                    "c18_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : afalse b s'",
                    "c12_B : eq (beval b s') false",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : P s'",
                    "c10_PRE : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_while",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_while : forall P variant b c , ( forall v , \u301a\u301a atrue b //\\\\ aequal variant v //\\\\ P \u301b\u301b c \u301a\u301a alessthan variant v //\\\\ P \u301b\u301b ) -> \u301a\u301a P \u301b\u301b WHILE b c \u301a\u301a afalse b //\\\\ P \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_while : forall P variant b c , ( forall v , \u301a\u301a atrue b //\\\\ aequal variant v //\\\\ P \u301b\u301b c \u301a\u301a alessthan variant v //\\\\ P \u301b\u301b ) -> \u301a\u301a P \u301b\u301b WHILE b c \u301a\u301a afalse b //\\\\ P \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (variant : aexp) (b : bexp) \n  (c : com)\n  (_ : forall v : Z,\n       Triple (aand (atrue b) (aand (aequal variant v) P)) c\n         (aand (alessthan variant v) P)),\nTriple P (WHILE b c) (aand (afalse b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P variant b c T .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (variant : aexp) (b : bexp) \n  (c : com)\n  (_ : forall v : Z,\n       Triple (aand (atrue b) (aand (aequal variant v) P)) c\n         (aand (alessthan variant v) P)),\nTriple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c2_goal : Triple P (WHILE b c) (aand (afalse b) P)",
                    "c2_P : assertion",
                    "c2_variant : aexp",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_T : forall v : Z,\nTriple (aand (atrue b) (aand (aequal variant v) P)) c\n  (aand (alessthan variant v) P)"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall v s , _i s -> aeval _i s = v -> safe ( afalse _i //\\\\ _i ) ( WHILE _i _i ) s ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall v s , _i s -> aeval _i s = v -> safe ( afalse _i //\\\\ _i ) ( WHILE _i _i ) s ) .",
                "tactic_args": [
                    "c2_goal : Triple P (WHILE b c) (aand (afalse b) P)",
                    "c2_P : assertion",
                    "c2_variant : aexp",
                    "c2_b : bexp",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (v : Z) (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "c4_goal : Triple P (WHILE b c) (aand (afalse b) P)",
                    "c4_REC : forall (v : Z) (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro v .",
                "tactic_args": [
                    "c3_goal : forall (v : Z) (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "c5_v : Z"
                ]
            },
            {
                "tactic_sig": "induction _i using ( well_founded_induction ( Z.lt_wf 0 ) ) .",
                "tactic_sig_no_out_arg": "induction _i using ( well_founded_induction ( Z.lt_wf 0 ) ) .",
                "tactic_args": [
                    "c5_v : Z"
                ],
                "tactic_res": [
                    "c5_H : forall (y : Z) (_ : and (Z.le 0 y) (Z.lt y v)) (s : store) \n  (_ : P s) (_ : eq (aeval variant s) y),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c6_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c6_s : store",
                    "c6_H0 : P s",
                    "c6_H1 : eq (aeval variant s) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c7_goal : not (terminated (WHILE b c))",
                    "c8_goal : not (error (WHILE b c) s)",
                    "c9_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : not (terminated (WHILE b c))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (WHILE b c) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (WHILE b c) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c8_goal : not (error (WHILE b c) s)"
                ],
                "tactic_res": [
                    "c11_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c9_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) c' s'"
                ],
                "tactic_res": [
                    "c12_goal : safe (aand (afalse b) P) c' s'",
                    "c12_c' : com",
                    "c12_s' : store",
                    "c12_RED : red (pair (WHILE b c) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : safe (aand (afalse b) P) c' s'",
                    "c12_RED : red (pair (WHILE b c) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c13_goal : safe (aand (afalse b) P) SKIP s'",
                    "c13_H3 : eq (beval b s') false",
                    "c13_H : forall (y : Z) (_ : and (Z.le 0 y) (Z.lt y (aeval variant s')))\n  (s : store) (_ : P s) (_ : eq (aeval variant s) y),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "c13_H0 : P s'",
                    "c14_goal : safe (aand (afalse b) P) (SEQ c (WHILE b c)) s'",
                    "c14_H3 : eq (beval b s') true",
                    "c14_H : forall (y : Z) (_ : and (Z.le 0 y) (Z.lt y (aeval variant s')))\n  (s : store) (_ : P s) (_ : eq (aeval variant s) y),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "c14_H0 : P s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : safe (aand (afalse b) P) SKIP s'",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c15_goal : terminated SKIP",
                    "c16_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c15_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c17_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c18_goal : afalse b s'",
                    "c19_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : afalse b s'",
                    "c13_H3 : eq (beval b s') false",
                    "c12_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : P s'",
                    "c13_H0 : P s'",
                    "c12_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i ( _i _i _i ) //\\\\ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ( _i _i _i ) //\\\\ _i ) .",
                "tactic_args": [
                    "c14_goal : safe (aand (afalse b) P) (SEQ c (WHILE b c)) s'",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com)\n         (_ : forall (s : store) (_ : Q s), safe R c' s) \n         (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s",
                    "_global_alessthan : forall (_ : aexp) (_ : Z), assertion",
                    "c2_variant : aexp",
                    "_global_aeval : forall (_ : aexp) (_ : store), Z",
                    "c2_variant : aexp",
                    "c12_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c20_goal : forall (s : store)\n  (_ : aand (alessthan variant (aeval variant s')) P s),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "c21_goal : safe (aand (alessthan variant (aeval variant s')) P) c s'"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s'' [ PRE1 PRE2 ] .",
                "tactic_args": [
                    "c20_goal : forall (s : store)\n  (_ : aand (alessthan variant (aeval variant s')) P s),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c22_goal : safe (aand (afalse b) P) (WHILE b c) s''",
                    "c22_s'' : store",
                    "c22_PRE1 : alessthan variant (aeval variant s') s''",
                    "c22_PRE2 : P s''"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c22_PRE1 : alessthan variant (aeval variant s') s''"
                ],
                "tactic_res": [
                    "c22_PRE1 : and (Z.le 0 (aeval variant s''))\n  (Z.lt (aeval variant s'') (aeval variant s'))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c22_goal : safe (aand (afalse b) P) (WHILE b c) s''",
                    "c14_H : forall (y : Z) (_ : and (Z.le 0 y) (Z.lt y (aeval variant s')))\n  (s : store) (_ : P s) (_ : eq (aeval variant s) y),\nsafe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c23_goal : and (Z.le 0 ?y) (Z.lt ?y (aeval variant s'))",
                    "c24_goal : P s''",
                    "c25_goal : eq (aeval variant s'') (aeval variant s'')"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c23_goal : and (Z.le 0 ?y) (Z.lt ?y (aeval variant s'))",
                    "c22_PRE1 : and (Z.le 0 (aeval variant s''))\n  (Z.lt (aeval variant s'') (aeval variant s'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c24_goal : P s''",
                    "c22_PRE2 : P s''"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq (aeval variant s'') (aeval variant s'')",
                    "c22_s'' : store",
                    "c2_variant : aexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : safe (aand (alessthan variant (aeval variant s')) P) c s'",
                    "c2_T : forall v : Z,\nTriple (aand (atrue b) (aand (aequal variant v) P)) c\n  (aand (alessthan variant v) P)"
                ],
                "tactic_res": [
                    "c26_goal : aand (atrue b) (aand (aequal variant (aeval variant s')) P) s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c26_goal : aand (atrue b) (aand (aequal variant (aeval variant s')) P) s'"
                ],
                "tactic_res": [
                    "c27_goal : atrue b s'",
                    "c28_goal : aand (aequal variant (aeval variant s')) P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : atrue b s'",
                    "c14_H3 : eq (beval b s') true",
                    "c12_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c28_goal : aand (aequal variant (aeval variant s')) P s'"
                ],
                "tactic_res": [
                    "c29_goal : aequal variant (aeval variant s') s'",
                    "c30_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : P s'",
                    "c14_H0 : P s'",
                    "c12_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c29_goal : aequal variant (aeval variant s') s'"
                ],
                "tactic_res": [
                    "c31_goal : eq (aeval variant s') (aeval variant s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : eq (aeval variant s') (aeval variant s')",
                    "c12_s' : store",
                    "c2_variant : aexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c4_goal : Triple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c32_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c32_s : store",
                    "c32_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c32_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c4_REC : forall (v : Z) (s : store) (_ : P s) (_ : eq (aeval variant s) v),\nsafe (aand (afalse b) P) (WHILE b c) s",
                    "_global_aeval : forall (_ : aexp) (_ : store), Z",
                    "c2_variant : aexp",
                    "c32_s : store"
                ],
                "tactic_res": [
                    "c33_goal : P s",
                    "c34_goal : eq (aeval variant s) (aeval variant s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : P s",
                    "c32_PRE : P s",
                    "c32_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : eq (aeval variant s) (aeval variant s)",
                    "c32_s : store",
                    "c2_variant : aexp"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_havoc",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_havoc : forall x Q , \u301a\u301a aforall ( fun n => aupdate x ( CONST n ) Q ) \u301b\u301b HAVOC x \u301a\u301a Q \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_havoc : forall x Q , \u301a\u301a aforall ( fun n => aupdate x ( CONST n ) Q ) \u301b\u301b HAVOC x \u301a\u301a Q \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (Q : assertion),\nTriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (Q : assertion),\nTriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c2_goal : Triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c2_x : ident",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : Triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q (HAVOC x) s",
                    "c3_s : store",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe Q (HAVOC x) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (HAVOC x))",
                    "c5_goal : not (error (HAVOC x) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (HAVOC x))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (HAVOC x) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (HAVOC x) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (HAVOC x) s)"
                ],
                "tactic_res": [
                    "c8_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe Q c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (HAVOC x) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe Q c' s'",
                    "c9_RED : red (pair (HAVOC x) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe Q SKIP (update x n s)",
                    "c10_n : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : safe Q SKIP (update x n s)"
                ],
                "tactic_res": [
                    "c11_goal : terminated SKIP",
                    "c12_goal : Q (update x n s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c13_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Q (update x n s)",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_assert",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_assert : forall b P , \u301a\u301a atrue b //\\\\ P \u301b\u301b ASSERT b \u301a\u301a atrue b //\\\\ P \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_assert : forall b P , \u301a\u301a atrue b //\\\\ P \u301b\u301b ASSERT b \u301a\u301a atrue b //\\\\ P \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (P : assertion),\nTriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (P : assertion),\nTriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c2_goal : Triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c2_b : bexp",
                    "c2_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ PRE1 PRE2 ] .",
                "tactic_args": [
                    "c2_goal : Triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c3_goal : safe (aand (atrue b) P) (ASSERT b) s",
                    "c3_s : store",
                    "c3_PRE1 : atrue b s",
                    "c3_PRE2 : P s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_PRE1 : atrue b s"
                ],
                "tactic_res": [
                    "c3_PRE1 : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe (aand (atrue b) P) (ASSERT b) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (ASSERT b))",
                    "c5_goal : not (error (ASSERT b) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (ASSERT b))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (ASSERT b) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (ASSERT b) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c8_goal : not (eq (beval b s) false)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c8_goal : not (eq (beval b s) false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe (aand (atrue b) P) c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (ASSERT b) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe (aand (atrue b) P) c' s'",
                    "c9_RED : red (pair (ASSERT b) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe (aand (atrue b) P) SKIP s'",
                    "c10_H0 : eq (beval b s') true",
                    "c10_PRE1 : eq (beval b s') true",
                    "c10_PRE2 : P s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe (aand (atrue b) P) SKIP s'",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c11_goal : terminated SKIP",
                    "c12_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c13_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c14_goal : atrue b s'",
                    "c15_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : atrue b s'",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : P s'",
                    "c10_PRE2 : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Triple_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma Triple_consequence : forall P Q P' Q' c , \u301a\u301a P \u301b\u301b c \u301a\u301a Q \u301b\u301b -> P' -->> P -> Q -->> Q' -> \u301a\u301a P' \u301b\u301b c \u301a\u301a Q' \u301b\u301b .",
                "tactic_sig_no_out_arg": "Lemma Triple_consequence : forall P Q P' Q' c , \u301a\u301a P \u301b\u301b c \u301a\u301a Q \u301b\u301b -> P' -->> P -> Q -->> Q' -> \u301a\u301a P' \u301b\u301b c \u301a\u301a Q' \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : Triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), Triple P' c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : Triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), Triple P' c Q'"
                ],
                "tactic_res": [
                    "c2_goal : Triple P' c Q'",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_P' : assertion",
                    "c2_Q' : assertion",
                    "c2_c : com",
                    "c2_H : Triple P c Q",
                    "c2_H0 : aimp P' P",
                    "c2_H1 : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall _i s , safe _i _i s -> safe _i _i s ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall _i s , safe _i _i s -> safe _i _i s ) .",
                "tactic_args": [
                    "c2_goal : Triple P' c Q'",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_Q' : assertion",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c4_goal : Triple P' c Q'",
                    "c4_REC : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s"
                ],
                "tactic_res": [
                    "c5_goal : safe Q' c0 s",
                    "c5_H3 : Q s",
                    "c5_H2 : terminated c0",
                    "c5_s : store",
                    "c5_c0 : com",
                    "c6_goal : safe Q' c0 s",
                    "c6_H5 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'",
                    "c6_H4 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q c' s'",
                    "c6_H3 : not (error c0 s)",
                    "c6_H2 : not (terminated c0)",
                    "c6_s : store",
                    "c6_c0 : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe Q' c0 s",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c7_goal : terminated c0",
                    "c8_goal : Q' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : terminated c0",
                    "c5_H2 : terminated c0",
                    "c5_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Q' s",
                    "c5_H3 : Q s",
                    "c5_s : store",
                    "c2_H1 : aimp Q Q'",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe Q' c0 s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c9_goal : not (terminated c0)",
                    "c10_goal : not (error c0 s)",
                    "c11_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : not (terminated c0)",
                    "c6_H2 : not (terminated c0)",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not (error c0 s)",
                    "c6_H3 : not (error c0 s)",
                    "c6_s : store",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'",
                    "c6_H5 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'",
                    "c6_s : store",
                    "c6_c0 : com",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : Triple P' c Q'"
                ],
                "tactic_res": [
                    "c12_goal : forall (s : store) (_ : P' s), safe Q' c s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (s : store) (_ : P' s), safe Q' c s",
                    "c4_REC : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c2_H0 : aimp P' P",
                    "c2_H : Triple P c Q",
                    "c2_c : com",
                    "c2_P' : assertion",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "HOARE_sound",
        "proof": [
            {
                "tactic_sig": "Theorem HOARE_sound : forall P c Q , \u301a P \u301b c \u301a Q \u301b -> \u301a\u301a P \u301b\u301b c \u301a\u301a Q \u301b\u301b .",
                "tactic_sig_no_out_arg": "Theorem HOARE_sound : forall P c Q , \u301a P \u301b c \u301a Q \u301b -> \u301a\u301a P \u301b\u301b c \u301a\u301a Q \u301b\u301b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q),\nTriple P c Q"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : HOARE P c Q),\nTriple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : Triple P SKIP P",
                    "c2_P : assertion",
                    "c3_goal : Triple (aupdate x a P) (ASSIGN x a) P",
                    "c3_a : aexp",
                    "c3_x : ident",
                    "c3_P : assertion",
                    "c4_goal : Triple P (SEQ c1 c2) R",
                    "c4_IHHOARE2 : Triple Q c2 R",
                    "c4_IHHOARE1 : Triple P c1 Q",
                    "c4_H0 : HOARE Q c2 R",
                    "c4_H : HOARE P c1 Q",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_R : assertion",
                    "c4_Q : assertion",
                    "c4_P : assertion",
                    "c5_goal : Triple P (IFTHENELSE b c1 c2) Q",
                    "c5_IHHOARE2 : Triple (aand (afalse b) P) c2 Q",
                    "c5_IHHOARE1 : Triple (aand (atrue b) P) c1 Q",
                    "c5_H0 : HOARE (aand (afalse b) P) c2 Q",
                    "c5_H : HOARE (aand (atrue b) P) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_Q : assertion",
                    "c5_P : assertion",
                    "c6_goal : Triple P (WHILE b c) (aand (afalse b) P)",
                    "c6_H0 : forall v : Z,\nTriple (aand (atrue b) (aand (aequal a v) P)) c\n  (aand (alessthan a v) P)",
                    "c6_H : forall v : Z,\nHOARE (aand (atrue b) (aand (aequal a v) P)) c (aand (alessthan a v) P)",
                    "c6_a : aexp",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion",
                    "c7_goal : Triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c7_Q : assertion",
                    "c7_x : ident",
                    "c8_goal : Triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c8_b : bexp",
                    "c8_P : assertion",
                    "c9_goal : Triple P' c Q'",
                    "c9_IHHOARE : Triple P c Q",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : HOARE P c Q",
                    "c9_c : com",
                    "c9_Q' : assertion",
                    "c9_P' : assertion",
                    "c9_Q : assertion",
                    "c9_P : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Triple P SKIP P",
                    "_global_Triple_skip : forall P : assertion, Triple P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Triple (aupdate x a P) (ASSIGN x a) P",
                    "_global_Triple_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Triple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : Triple P (SEQ c1 c2) R",
                    "_global_Triple_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Triple P c1 Q)\n         (_ : Triple Q c2 R), Triple P (SEQ c1 c2) R",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c10_goal : Triple P c1 Q",
                    "c11_goal : Triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Triple P c1 Q",
                    "c4_IHHOARE1 : Triple P c1 Q",
                    "c4_c1 : com",
                    "c4_P : assertion",
                    "c4_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Triple Q c2 R",
                    "c4_IHHOARE2 : Triple Q c2 R",
                    "c4_c2 : com",
                    "c4_Q : assertion",
                    "c4_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Triple P (IFTHENELSE b c1 c2) Q",
                    "_global_Triple_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Triple (aand (atrue b) P) c1 Q)\n         (_ : Triple (aand (afalse b) P) c2 Q),\n       Triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c12_goal : Triple (aand (atrue b) P) c1 Q",
                    "c13_goal : Triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Triple (aand (atrue b) P) c1 Q",
                    "c5_IHHOARE1 : Triple (aand (atrue b) P) c1 Q",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Triple (aand (afalse b) P) c2 Q",
                    "c5_IHHOARE2 : Triple (aand (afalse b) P) c2 Q",
                    "c5_c2 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c6_goal : Triple P (WHILE b c) (aand (afalse b) P)",
                    "_global_Triple_while : forall (P : assertion) (variant : aexp) (b : bexp) \n         (c : com)\n         (_ : forall v : Z,\n              Triple (aand (atrue b) (aand (aequal variant v) P)) c\n                (aand (alessthan variant v) P)),\n       Triple P (WHILE b c) (aand (afalse b) P)",
                    "c6_a : aexp"
                ],
                "tactic_res": [
                    "c14_goal : forall v : Z,\nTriple (aand (atrue b) (aand (aequal a v) P)) c\n  (aand (alessthan a v) P)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall v : Z,\nTriple (aand (atrue b) (aand (aequal a v) P)) c\n  (aand (alessthan a v) P)",
                    "c6_H0 : forall v : Z,\nTriple (aand (atrue b) (aand (aequal a v) P)) c\n  (aand (alessthan a v) P)",
                    "c6_a : aexp",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "_global_Triple_havoc : forall (x : ident) (Q : assertion),\n       Triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "_global_Triple_assert : forall (b : bexp) (P : assertion),\n       Triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c9_goal : Triple P' c Q'",
                    "_global_Triple_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Triple P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Triple P' c Q'",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": [
                    "c15_goal : Triple P c Q",
                    "c16_goal : aimp P' P",
                    "c17_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Triple P c Q",
                    "c9_IHHOARE : Triple P c Q",
                    "c9_c : com",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : aimp P' P",
                    "c9_H0 : aimp P' P",
                    "c9_P : assertion",
                    "c9_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : aimp Q Q'",
                    "c9_H1 : aimp Q Q'",
                    "c9_Q : assertion",
                    "c9_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_terminated_inv",
        "proof": [
            {
                "tactic_sig": "Lemma safe_terminated_inv : forall Q c s , safe Q c s -> terminated c -> Q s .",
                "tactic_sig_no_out_arg": "Lemma safe_terminated_inv : forall Q c s , safe Q c s -> terminated c -> Q s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (_ : safe Q c s)\n  (_ : terminated c), Q s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (_ : safe Q c s)\n  (_ : terminated c), Q s"
                ],
                "tactic_res": [
                    "c2_goal : Q s",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_H : safe Q c s",
                    "c2_H0 : terminated c"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : Q s",
                    "c2_H : safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : Q s",
                    "c3_H2 : Q s",
                    "c3_H1 : terminated c",
                    "c4_goal : Q s",
                    "c4_H3 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c4_H2 : not (error c s)",
                    "c4_H1 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Q s",
                    "c3_H2 : Q s",
                    "c2_s : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c4_goal : Q s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_not_stuck",
        "proof": [
            {
                "tactic_sig": "Lemma safe_not_stuck : forall Q c s , safe Q c s -> ~ terminated c -> ~ ( error c s ) .",
                "tactic_sig_no_out_arg": "Lemma safe_not_stuck : forall Q c s , safe Q c s -> ~ terminated c -> ~ ( error c s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (_ : safe Q c s)\n  (_ : not (terminated c)), not (error c s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (_ : safe Q c s)\n  (_ : not (terminated c)), not (error c s)"
                ],
                "tactic_res": [
                    "c2_goal : not (error c s)",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_H : safe Q c s",
                    "c2_H0 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : not (error c s)",
                    "c2_H : safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : not (error c s)",
                    "c3_H2 : Q s",
                    "c3_H1 : terminated c",
                    "c4_goal : not (error c s)",
                    "c4_H3 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c4_H2 : not (error c s)",
                    "c4_H1 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c3_goal : not (error c s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : not (error c s)",
                    "c4_H2 : not (error c s)",
                    "c2_s : store",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_step_inv",
        "proof": [
            {
                "tactic_sig": "Lemma safe_step_inv : forall Q c s c' s' , safe Q c s -> red ( c , s ) ( c' , s' ) -> safe Q c' s' .",
                "tactic_sig_no_out_arg": "Lemma safe_step_inv : forall Q c s c' s' , safe Q c s -> red ( c , s ) ( c' , s' ) -> safe Q c' s' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : safe Q c s) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (c : com) (s : store) (c' : com) \n  (s' : store) (_ : safe Q c s) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'"
                ],
                "tactic_res": [
                    "c2_goal : safe Q c' s'",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_c' : com",
                    "c2_s' : store",
                    "c2_H : safe Q c s",
                    "c2_H0 : red (pair c s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : safe Q c' s'",
                    "c2_H : safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : safe Q c' s'",
                    "c3_H2 : Q s",
                    "c3_H1 : terminated c",
                    "c4_goal : safe Q c' s'",
                    "c4_H3 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c4_H2 : not (error c s)",
                    "c4_H1 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_H1 : terminated c"
                ],
                "tactic_res": [
                    "c3_H1 : eq c SKIP"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_c : com",
                    "c3_H1 : eq c SKIP"
                ],
                "tactic_res": [
                    "c3_H0 : red (pair SKIP s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : safe Q c' s'",
                    "c3_H0 : red (pair SKIP s) (pair c' s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : safe Q c' s'",
                    "c4_H3 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c2_H0 : red (pair c s) (pair c' s')",
                    "c2_s' : store",
                    "c2_c' : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_skip",
        "proof": [
            {
                "tactic_sig": "Lemma triple_skip : forall P , \u2983\u2983 P \u2984\u2984 SKIP \u2983\u2983 P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_skip : forall P , \u2983\u2983 P \u2984\u2984 SKIP \u2983\u2983 P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : assertion, triple P SKIP P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P s PRE .",
                "tactic_args": [
                    "c1_goal : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": [
                    "c2_goal : safe P SKIP s",
                    "c2_P : assertion",
                    "c2_s : store",
                    "c2_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe P SKIP s",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : terminated SKIP",
                    "c4_goal : P s"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : terminated SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P s",
                    "c2_PRE : P s",
                    "c2_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_assign",
        "proof": [
            {
                "tactic_sig": "Lemma triple_assign : forall P x a , \u2983\u2983 aupdate x a P \u2984\u2984 ASSIGN x a \u2983\u2983 P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_assign : forall P x a , \u2983\u2983 aupdate x a P \u2984\u2984 ASSIGN x a \u2983\u2983 P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\ntriple (aupdate x a P) (ASSIGN x a) P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P x a s PRE .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\ntriple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": [
                    "c2_goal : safe P (ASSIGN x a) s",
                    "c2_P : assertion",
                    "c2_x : ident",
                    "c2_a : aexp",
                    "c2_s : store",
                    "c2_PRE : aupdate x a P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe P (ASSIGN x a) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c3_goal : not (terminated (ASSIGN x a))",
                    "c4_goal : not (error (ASSIGN x a) s)",
                    "c5_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : not (terminated (ASSIGN x a))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c6_goal : not (eq (ASSIGN x a) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c6_goal : not (eq (ASSIGN x a) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c4_goal : not (error (ASSIGN x a) s)"
                ],
                "tactic_res": [
                    "c7_goal : not False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c7_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c5_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P c' s'"
                ],
                "tactic_res": [
                    "c8_goal : safe P c' s'",
                    "c8_c' : com",
                    "c8_s' : store",
                    "c8_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : safe P c' s'",
                    "c8_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c9_goal : safe P SKIP (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : safe P SKIP (update x (aeval a s) s)",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c10_goal : terminated SKIP",
                    "c11_goal : P (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c10_goal : terminated SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c11_goal : P (update x (aeval a s) s)",
                    "c2_PRE : aupdate x a P s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_seq",
        "proof": [
            {
                "tactic_sig": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) , ( forall s , Q s -> safe R c' s ) -> forall c s , safe Q c s -> safe R ( c ; ; c' ) s .",
                "tactic_sig_no_out_arg": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) , ( forall s , Q s -> safe R c' s ) -> forall c s , safe Q c s -> safe R ( c ; ; c' ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q R : assertion) (c' : com)\n  (_ : forall (s : store) (_ : Q s), safe R c' s) \n  (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q R c2 QR .",
                "tactic_args": [
                    "c1_goal : forall (Q R : assertion) (c' : com)\n  (_ : forall (s : store) (_ : Q s), safe R c' s) \n  (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c2 : com",
                    "c2_QR : forall (s : store) (_ : Q s), safe R c2 s"
                ]
            },
            {
                "tactic_sig": "destruct 1 as [  _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct 1 .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s",
                    "c2_CHR : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s",
                    "c2_QR : forall (s : store) (_ : Q s), safe R c2 s",
                    "c2_c2 : com",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c3_goal : safe R (SEQ c c2) s",
                    "c3_H0 : Q s",
                    "c3_H : terminated c",
                    "c3_s : store",
                    "c3_c : com",
                    "c4_goal : safe R (SEQ c c2) s",
                    "c4_H1 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'",
                    "c4_H0 : not (error c s)",
                    "c4_H : not (terminated c)",
                    "c4_s : store",
                    "c4_c : com"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : safe R (SEQ c c2) s",
                    "c3_H : terminated c"
                ],
                "tactic_res": [
                    "c5_goal : safe R (SEQ SKIP c2) s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe R (SEQ SKIP c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (SEQ SKIP c2))",
                    "c7_goal : not (error (SEQ SKIP c2) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ SKIP c2) s) (pair c' s')), safe R c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (SEQ SKIP c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (SEQ SKIP c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (SEQ SKIP c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (SEQ SKIP c2) s)"
                ],
                "tactic_res": [
                    "c10_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ SKIP c2) s) (pair c' s')), safe R c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe R c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c11_goal : safe R c' s'",
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe R c' s'",
                    "c12_H5 : eq s s'",
                    "c12_H4 : eq c2 c'",
                    "c12_H3 : eq s0 s",
                    "c12_H2 : eq c0 c2",
                    "c12_s0 : store",
                    "c12_c0 : com",
                    "c13_goal : safe R (SEQ c3 c2) s'",
                    "c13_H6 : eq s2 s'",
                    "c13_H5 : eq (SEQ c3 c2) c'",
                    "c13_H4 : eq s1 s",
                    "c13_H3 : eq c0 c2",
                    "c13_H1 : eq c1 SKIP",
                    "c13_H2 : red (pair SKIP s) (pair c3 s')",
                    "c13_s2 : store",
                    "c13_c3 : com",
                    "c13_s1 : store",
                    "c13_c0 : com",
                    "c13_c1 : com"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c11_RED : red (pair (SEQ SKIP c2) s) (pair c' s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c12_goal : safe R c' s'",
                    "c12_H4 : eq c2 c'"
                ],
                "tactic_res": [
                    "c14_goal : safe R c2 s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : safe R c2 s'",
                    "c2_QR : forall (s : store) (_ : Q s), safe R c2 s"
                ],
                "tactic_res": [
                    "c15_goal : Q s'"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c15_goal : Q s'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : safe R (SEQ c3 c2) s'",
                    "c13_H2 : red (pair SKIP s) (pair c3 s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe R (SEQ c c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c16_goal : not (terminated (SEQ c c2))",
                    "c17_goal : not (error (SEQ c c2) s)",
                    "c18_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c16_goal : not (terminated (SEQ c c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c19_goal : not (eq (SEQ c c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c19_goal : not (eq (SEQ c c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c17_goal : not (error (SEQ c c2) s)"
                ],
                "tactic_res": [
                    "c20_goal : not (error c s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : not (error c s)",
                    "c4_H0 : not (error c s)",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c18_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R c' s'"
                ],
                "tactic_res": [
                    "c21_goal : safe R c' s'",
                    "c21_c' : com",
                    "c21_s' : store",
                    "c21_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c21_goal : safe R c' s'",
                    "c21_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c22_goal : safe R c' s'",
                    "c22_H7 : eq s s'",
                    "c22_H6 : eq c2 c'",
                    "c22_H5 : eq s0 s",
                    "c22_H4 : eq c0 c2",
                    "c22_H3 : eq SKIP c",
                    "c22_s0 : store",
                    "c22_c0 : com",
                    "c23_goal : safe R (SEQ c3 c2) s'",
                    "c23_H7 : eq s2 s'",
                    "c23_H6 : eq (SEQ c3 c2) c'",
                    "c23_H5 : eq s1 s",
                    "c23_H4 : eq c0 c2",
                    "c23_H2 : eq c1 c",
                    "c23_H3 : red (pair c s) (pair c3 s')",
                    "c23_s2 : store",
                    "c23_c3 : com",
                    "c23_s1 : store",
                    "c23_c0 : com",
                    "c23_c1 : com"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c22_goal : safe R c' s'",
                    "c4_H : not (terminated c)"
                ],
                "tactic_res": [
                    "c24_goal : terminated c"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c24_goal : terminated c"
                ],
                "tactic_res": [
                    "c25_goal : eq c SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq c SKIP",
                    "c22_H3 : eq SKIP c",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : safe R (SEQ c3 c2) s'",
                    "c2_CHR : forall (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c2) s"
                ],
                "tactic_res": [
                    "c26_goal : safe Q c3 s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : safe Q c3 s'",
                    "c4_H1 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q c' s'"
                ],
                "tactic_res": [
                    "c27_goal : red (pair c s) (pair c3 s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : red (pair c s) (pair c3 s')",
                    "c23_H3 : red (pair c s) (pair c3 s')",
                    "c23_c3 : com",
                    "c21_s' : store",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_seq",
        "proof": [
            {
                "tactic_sig": "Lemma triple_seq : forall P Q R c1 c2 , \u2983\u2983 P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 Q \u2984\u2984 c2 \u2983\u2983 R \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 c1 ; ; c2 \u2983\u2983 R \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_seq : forall P Q R c1 c2 , \u2983\u2983 P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 Q \u2984\u2984 c2 \u2983\u2983 R \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 c1 ; ; c2 \u2983\u2983 R \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n  (_ : triple Q c2 R), triple P (SEQ c1 c2) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n  (_ : triple Q c2 R), triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c2_goal : triple P (SEQ c1 c2) R",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : triple P c1 Q",
                    "c2_H0 : triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c3_goal : safe R (SEQ c1 c2) s",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe R (SEQ c1 c2) s",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com)\n         (_ : forall (s : store) (_ : Q s), safe R c' s) \n         (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c4_goal : forall (s : store) (_ : Q s), safe R c2 s",
                    "c5_goal : safe Q c1 s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (s : store) (_ : Q s), safe R c2 s",
                    "c2_H0 : triple Q c2 R",
                    "c2_c2 : com",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe Q c1 s",
                    "c3_PRE : P s",
                    "c3_s : store",
                    "c2_H : triple P c1 Q",
                    "c2_c1 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_while",
        "proof": [
            {
                "tactic_sig": "Lemma triple_while : forall P b c , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c \u2983\u2983 P \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 WHILE b c \u2983\u2983 afalse b //\\\\ P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_while : forall P b c , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c \u2983\u2983 P \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 WHILE b c \u2983\u2983 afalse b //\\\\ P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com)\n  (_ : triple (aand (atrue b) P) c P),\ntriple P (WHILE b c) (aand (afalse b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P b c T .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com)\n  (_ : triple (aand (atrue b) P) c P),\ntriple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c2_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_T : triple (aand (atrue b) P) c P"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall s , _i s -> safe ( afalse _i //\\\\ _i ) ( WHILE _i _i ) s ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall s , _i s -> safe ( afalse _i //\\\\ _i ) ( WHILE _i _i ) s ) .",
                "tactic_args": [
                    "c2_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s",
                    "c4_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c4_REC : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c3_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c5_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c5_s : store",
                    "c5_Ps : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (WHILE b c))",
                    "c7_goal : not (error (WHILE b c) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (WHILE b c))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (WHILE b c) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (WHILE b c) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (WHILE b c) s)"
                ],
                "tactic_res": [
                    "c10_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe (aand (afalse b) P) c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (WHILE b c) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c11_goal : safe (aand (afalse b) P) c' s'",
                    "c11_RED : red (pair (WHILE b c) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe (aand (afalse b) P) SKIP s'",
                    "c12_H4 : eq s s'",
                    "c12_H3 : eq SKIP c'",
                    "c12_H2 : eq s0 s",
                    "c12_H1 : eq c0 c",
                    "c12_H : eq b0 b",
                    "c12_H0 : eq (beval b s') false",
                    "c12_s0 : store",
                    "c12_c0 : com",
                    "c12_b0 : bexp",
                    "c13_goal : safe (aand (afalse b) P) (SEQ c (WHILE b c)) s'",
                    "c13_H4 : eq s s'",
                    "c13_H3 : eq (SEQ c (WHILE b c)) c'",
                    "c13_H2 : eq s0 s",
                    "c13_H1 : eq c0 c",
                    "c13_H : eq b0 b",
                    "c13_H0 : eq (beval b s') true",
                    "c13_s0 : store",
                    "c13_c0 : com",
                    "c13_b0 : bexp"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe (aand (afalse b) P) SKIP s'",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c14_goal : terminated SKIP",
                    "c15_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c14_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c16_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c15_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c17_goal : afalse b s'",
                    "c18_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : afalse b s'",
                    "c12_H0 : eq (beval b s') false",
                    "c11_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c18_goal : P s'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c13_goal : safe (aand (afalse b) P) (SEQ c (WHILE b c)) s'",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com)\n         (_ : forall (s : store) (_ : Q s), safe R c' s) \n         (c : com) (s : store) (_ : safe Q c s), safe R (SEQ c c') s",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c19_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s",
                    "c20_goal : safe P c s'"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s'' Ps'' .",
                "tactic_args": [
                    "c19_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c21_goal : safe (aand (afalse b) P) (WHILE b c) s''",
                    "c21_s'' : store",
                    "c21_Ps'' : P s''"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : safe (aand (afalse b) P) (WHILE b c) s''",
                    "c3_CHR : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c22_goal : P s''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : P s''",
                    "c21_Ps'' : P s''",
                    "c21_s'' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : safe P c s'",
                    "c2_T : triple (aand (atrue b) P) c P"
                ],
                "tactic_res": [
                    "c23_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c23_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c24_goal : atrue b s'",
                    "c25_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : atrue b s'",
                    "c13_H0 : eq (beval b s') true",
                    "c11_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c25_goal : P s'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c4_goal : triple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c26_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c26_s : store",
                    "c26_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : safe (aand (afalse b) P) (WHILE b c) s",
                    "c4_REC : forall (s : store) (_ : P s), safe (aand (afalse b) P) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c27_goal : P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : P s",
                    "c26_PRE : P s",
                    "c26_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthenelse : forall P Q b c1 c2 , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 afalse b //\\\\ P \u2984\u2984 c2 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 IFTHENELSE b c1 c2 \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthenelse : forall P Q b c1 c2 , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 afalse b //\\\\ P \u2984\u2984 c2 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 IFTHENELSE b c1 c2 \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : triple (aand (atrue b) P) c1 Q)\n  (_ : triple (aand (afalse b) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : triple (aand (atrue b) P) c1 Q)\n  (_ : triple (aand (afalse b) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_b : bexp",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : triple (aand (atrue b) P) c1 Q",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q (IFTHENELSE b c1 c2) s",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe Q (IFTHENELSE b c1 c2) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "c5_goal : not (error (IFTHENELSE b c1 c2) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (IFTHENELSE b c1 c2) s)"
                ],
                "tactic_res": [
                    "c8_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe Q c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe Q c' s'",
                    "c9_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe Q (if beval b s' then c1 else c2) s'",
                    "c10_PRE : P s'"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) eqn : B .",
                "tactic_args": [
                    "c10_goal : safe Q (if beval b s' then c1 else c2) s'",
                    "c2_b : bexp",
                    "c9_s' : store",
                    "c10_PRE : P s'",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q",
                    "c2_H : triple (aand (atrue b) P) c1 Q",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c11_goal : safe Q c1 s'",
                    "c11_B : eq (beval b s') true",
                    "c12_goal : safe Q c2 s'",
                    "c12_B : eq (beval b s') false"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : safe Q c1 s'",
                    "c2_H : triple (aand (atrue b) P) c1 Q"
                ],
                "tactic_res": [
                    "c13_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c14_goal : atrue b s'",
                    "c15_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : atrue b s'",
                    "c11_B : eq (beval b s') true",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : P s'",
                    "c10_PRE : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe Q c2 s'",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q"
                ],
                "tactic_res": [
                    "c16_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c17_goal : afalse b s'",
                    "c18_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : afalse b s'",
                    "c12_B : eq (beval b s') false",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : P s'",
                    "c10_PRE : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_havoc",
        "proof": [
            {
                "tactic_sig": "Lemma triple_havoc : forall x Q , \u2983\u2983 aforall ( fun n => aupdate x ( CONST n ) Q ) \u2984\u2984 HAVOC x \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_havoc : forall x Q , \u2983\u2983 aforall ( fun n => aupdate x ( CONST n ) Q ) \u2984\u2984 HAVOC x \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (Q : assertion),\ntriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (Q : assertion),\ntriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c2_x : ident",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s PRE .",
                "tactic_args": [
                    "c2_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q (HAVOC x) s",
                    "c3_s : store",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe Q (HAVOC x) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (HAVOC x))",
                    "c5_goal : not (error (HAVOC x) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (HAVOC x))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (HAVOC x) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (HAVOC x) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (HAVOC x) s)"
                ],
                "tactic_res": [
                    "c8_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe Q c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (HAVOC x) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe Q c' s'",
                    "c9_RED : red (pair (HAVOC x) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe Q SKIP (update x n s)",
                    "c10_n : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : safe Q SKIP (update x n s)"
                ],
                "tactic_res": [
                    "c11_goal : terminated SKIP",
                    "c12_goal : Q (update x n s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c13_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Q (update x n s)",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_assert",
        "proof": [
            {
                "tactic_sig": "Lemma triple_assert : forall b P , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 ASSERT b \u2983\u2983 atrue b //\\\\ P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_assert : forall b P , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 ASSERT b \u2983\u2983 atrue b //\\\\ P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (P : assertion),\ntriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (P : assertion),\ntriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c2_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c2_b : bexp",
                    "c2_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ PRE1 PRE2 ] .",
                "tactic_args": [
                    "c2_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c3_goal : safe (aand (atrue b) P) (ASSERT b) s",
                    "c3_s : store",
                    "c3_PRE1 : atrue b s",
                    "c3_PRE2 : P s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_PRE1 : atrue b s"
                ],
                "tactic_res": [
                    "c3_PRE1 : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe (aand (atrue b) P) (ASSERT b) s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c4_goal : not (terminated (ASSERT b))",
                    "c5_goal : not (error (ASSERT b) s)",
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : not (terminated (ASSERT b))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (ASSERT b) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : not (eq (ASSERT b) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c8_goal : not (eq (beval b s) false)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c8_goal : not (eq (beval b s) false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) c' s'"
                ],
                "tactic_res": [
                    "c9_goal : safe (aand (atrue b) P) c' s'",
                    "c9_c' : com",
                    "c9_s' : store",
                    "c9_RED : red (pair (ASSERT b) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe (aand (atrue b) P) c' s'",
                    "c9_RED : red (pair (ASSERT b) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c10_goal : safe (aand (atrue b) P) SKIP s'",
                    "c10_H0 : eq (beval b s') true",
                    "c10_PRE1 : eq (beval b s') true",
                    "c10_PRE2 : P s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe (aand (atrue b) P) SKIP s'",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c11_goal : terminated SKIP",
                    "c12_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c13_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c14_goal : atrue b s'",
                    "c15_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : atrue b s'",
                    "c9_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : P s'",
                    "c10_PRE2 : P s'",
                    "c9_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence : forall P Q P' Q' c , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> P' -->> P -> Q -->> Q' -> \u2983\u2983 P' \u2984\u2984 c \u2983\u2983 Q' \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence : forall P Q P' Q' c , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> P' -->> P -> Q -->> Q' -> \u2983\u2983 P' \u2984\u2984 c \u2983\u2983 Q' \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'"
                ],
                "tactic_res": [
                    "c2_goal : triple P' c Q'",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_P' : assertion",
                    "c2_Q' : assertion",
                    "c2_c : com",
                    "c2_H : triple P c Q",
                    "c2_H0 : aimp P' P",
                    "c2_H1 : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall _i s , safe _i _i s -> safe _i _i s ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall _i s , safe _i _i s -> safe _i _i s ) .",
                "tactic_args": [
                    "c2_goal : triple P' c Q'",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_Q' : assertion",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c4_goal : triple P' c Q'",
                    "c4_REC : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s"
                ]
            },
            {
                "tactic_sig": "destruct 1 as [  _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct 1 .",
                "tactic_args": [
                    "c3_goal : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c3_CH : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c2_H1 : aimp Q Q'",
                    "c2_H0 : aimp P' P",
                    "c2_H : triple P c Q",
                    "c2_Q : assertion",
                    "c2_Q' : assertion"
                ],
                "tactic_res": [
                    "c5_goal : safe Q' c0 s",
                    "c5_H3 : Q s",
                    "c5_H2 : terminated c0",
                    "c5_s : store",
                    "c5_c0 : com",
                    "c6_goal : safe Q' c0 s",
                    "c6_H4 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q c' s'",
                    "c6_H3 : not (error c0 s)",
                    "c6_H2 : not (terminated c0)",
                    "c6_s : store",
                    "c6_c0 : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe Q' c0 s",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c7_goal : terminated c0",
                    "c8_goal : Q' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : terminated c0",
                    "c5_H2 : terminated c0",
                    "c5_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Q' s",
                    "c5_H3 : Q s",
                    "c5_s : store",
                    "c2_H1 : aimp Q Q'",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe Q' c0 s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c9_goal : not (terminated c0)",
                    "c10_goal : not (error c0 s)",
                    "c11_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : not (terminated c0)",
                    "c6_H2 : not (terminated c0)",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not (error c0 s)",
                    "c6_H3 : not (error c0 s)",
                    "c6_s : store",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' c' s'",
                    "c6_H4 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q c' s'",
                    "c6_s : store",
                    "c6_c0 : com",
                    "c3_CH : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : triple P' c Q'"
                ],
                "tactic_res": [
                    "c12_goal : forall (s : store) (_ : P' s), safe Q' c s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (s : store) (_ : P' s), safe Q' c s",
                    "c4_REC : forall (c : com) (s : store) (_ : safe Q c s), safe Q' c s",
                    "c2_H0 : aimp P' P",
                    "c2_H : triple P c Q",
                    "c2_c : com",
                    "c2_P' : assertion",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_sound",
        "proof": [
            {
                "tactic_sig": "Theorem Hoare_sound : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Theorem Hoare_sound : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q),\ntriple P c Q"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q),\ntriple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P SKIP P",
                    "c2_P : assertion",
                    "c3_goal : triple (aupdate x a P) (ASSIGN x a) P",
                    "c3_a : aexp",
                    "c3_x : ident",
                    "c3_P : assertion",
                    "c4_goal : triple P (SEQ c1 c2) R",
                    "c4_IHHoare2 : triple Q c2 R",
                    "c4_IHHoare1 : triple P c1 Q",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_H : Hoare P c1 Q",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_R : assertion",
                    "c4_Q : assertion",
                    "c4_P : assertion",
                    "c5_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c5_IHHoare2 : triple (aand (afalse b) P) c2 Q",
                    "c5_IHHoare1 : triple (aand (atrue b) P) c1 Q",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_Q : assertion",
                    "c5_P : assertion",
                    "c6_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c6_IHHoare : triple (aand (atrue b) P) c P",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion",
                    "c7_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c7_Q : assertion",
                    "c7_x : ident",
                    "c8_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c8_b : bexp",
                    "c8_P : assertion",
                    "c9_goal : triple P' c Q'",
                    "c9_IHHoare : triple P c Q",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : Hoare P c Q",
                    "c9_c : com",
                    "c9_Q' : assertion",
                    "c9_P' : assertion",
                    "c9_Q : assertion",
                    "c9_P : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple P SKIP P",
                    "_global_triple_skip : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (aupdate x a P) (ASSIGN x a) P",
                    "_global_triple_assign : forall (P : assertion) (x : ident) (a : aexp),\n       triple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : triple P (SEQ c1 c2) R",
                    "_global_triple_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n         (_ : triple Q c2 R), triple P (SEQ c1 c2) R",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c10_goal : triple P c1 Q",
                    "c11_goal : triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : triple P c1 Q",
                    "c4_IHHoare1 : triple P c1 Q",
                    "c4_c1 : com",
                    "c4_P : assertion",
                    "c4_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : triple Q c2 R",
                    "c4_IHHoare2 : triple Q c2 R",
                    "c4_c2 : com",
                    "c4_Q : assertion",
                    "c4_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "_global_triple_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : triple (aand (atrue b) P) c1 Q)\n         (_ : triple (aand (afalse b) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c12_goal : triple (aand (atrue b) P) c1 Q",
                    "c13_goal : triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : triple (aand (atrue b) P) c1 Q",
                    "c5_IHHoare1 : triple (aand (atrue b) P) c1 Q",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : triple (aand (afalse b) P) c2 Q",
                    "c5_IHHoare2 : triple (aand (afalse b) P) c2 Q",
                    "c5_c2 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "_global_triple_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : triple (aand (atrue b) P) c P),\n       triple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c14_goal : triple (aand (atrue b) P) c P"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : triple (aand (atrue b) P) c P",
                    "c6_IHHoare : triple (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "_global_triple_havoc : forall (x : ident) (Q : assertion),\n       triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "_global_triple_assert : forall (b : bexp) (P : assertion),\n       triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c9_goal : triple P' c Q'",
                    "_global_triple_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": [
                    "c15_goal : triple P c Q",
                    "c16_goal : aimp P' P",
                    "c17_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : triple P c Q",
                    "c9_IHHoare : triple P c Q",
                    "c9_c : com",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : aimp P' P",
                    "c9_H0 : aimp P' P",
                    "c9_P : assertion",
                    "c9_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : aimp Q Q'",
                    "c9_H1 : aimp Q Q'",
                    "c9_Q : assertion",
                    "c9_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_mono",
        "proof": [
            {
                "tactic_sig": "Lemma safe_mono : forall Q n c s , safe Q n c s -> forall n' , ( n' <= n ) % nat -> safe Q n' c s .",
                "tactic_sig_no_out_arg": "Lemma safe_mono : forall Q n c s , safe Q n c s -> forall n' , ( n' <= n ) % nat -> safe Q n' c s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q n c s) (n' : nat) (_ : le n' n), safe Q n' c s"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q n c s) (n' : nat) (_ : le n' n), safe Q n' c s"
                ],
                "tactic_res": [
                    "c2_goal : forall (n' : nat) (_ : le n' 0), safe Q n' c s",
                    "c2_s : store",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c3_goal : forall (n' : nat) (_ : le n' (S n)), safe Q n' c s",
                    "c3_H0 : Q s",
                    "c3_H : terminated c",
                    "c3_s : store",
                    "c3_c : com",
                    "c3_n : nat",
                    "c3_Q : assertion",
                    "c4_goal : forall (n' : nat) (_ : le n' (S n)), safe Q n' c s",
                    "c4_H2 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s'))\n  (n' : nat) (_ : le n' n), safe Q n' c' s'",
                    "c4_H1 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c4_H0 : not (error c s)",
                    "c4_H : not (terminated c)",
                    "c4_s : store",
                    "c4_c : com",
                    "c4_n : nat",
                    "c4_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (n' : nat) (_ : le n' 0), safe Q n' c s"
                ],
                "tactic_res": [
                    "c5_goal : safe Q n' c s",
                    "c5_n' : nat",
                    "c5_H : le n' 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (n' : nat) (_ : le n' (S n)), safe Q n' c s"
                ],
                "tactic_res": [
                    "c6_goal : safe Q n' c s",
                    "c6_n' : nat",
                    "c6_H1 : le n' (S n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (n' : nat) (_ : le n' (S n)), safe Q n' c s"
                ],
                "tactic_res": [
                    "c7_goal : safe Q n' c s",
                    "c7_n' : nat",
                    "c7_H3 : le n' (S n)"
                ]
            },
            {
                "tactic_sig": "replace _i with O by lia .",
                "tactic_sig_no_out_arg": "replace _i with O by lia .",
                "tactic_args": [
                    "c5_goal : safe Q n' c s",
                    "c5_n' : nat"
                ],
                "tactic_res": [
                    "c8_goal : safe Q 0 c s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : safe Q 0 c s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : safe Q n' c s",
                    "c6_n' : nat",
                    "c6_H1 : le n' (S n)",
                    "c3_H0 : Q s",
                    "c3_H : terminated c",
                    "c3_s : store",
                    "c3_c : com",
                    "c3_Q : assertion"
                ],
                "tactic_res": [
                    "c9_goal : safe Q 0 c s",
                    "c9_H1 : le 0 (S n)",
                    "c10_goal : safe Q (S n') c s",
                    "c10_H1 : le (S n') (S n)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c9_goal : safe Q 0 c s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe Q (S n') c s",
                    "_global_safe_now : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c11_goal : terminated c",
                    "c12_goal : Q s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : terminated c",
                    "c3_H : terminated c",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Q s",
                    "c3_H0 : Q s",
                    "c3_s : store",
                    "c3_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_goal : safe Q n' c s",
                    "c7_n' : nat",
                    "c7_H3 : le n' (S n)",
                    "c4_H2 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s'))\n  (n' : nat) (_ : le n' n), safe Q n' c' s'",
                    "c4_H1 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c4_H0 : not (error c s)",
                    "c4_H : not (terminated c)",
                    "c4_s : store",
                    "c4_c : com",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c13_goal : safe Q 0 c s",
                    "c13_H3 : le 0 (S n)",
                    "c14_goal : safe Q (S n') c s",
                    "c14_H3 : le (S n') (S n)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c13_goal : safe Q 0 c s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : safe Q (S n') c s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c15_goal : not (terminated c)",
                    "c16_goal : not (error c s)",
                    "c17_goal : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n' c' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : not (terminated c)",
                    "c4_H : not (terminated c)",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : not (error c s)",
                    "c4_H0 : not (error c s)",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n' c' s'"
                ],
                "tactic_res": [
                    "c18_goal : safe Q n' c' s'",
                    "c18_c' : com",
                    "c18_s' : store",
                    "c18_H4 : red (pair c s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : safe Q n' c' s'",
                    "c4_H2 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s'))\n  (n' : nat) (_ : le n' n), safe Q n' c' s'"
                ],
                "tactic_res": [
                    "c19_goal : red (pair c s) (pair c' s')",
                    "c20_goal : le n' n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : red (pair c s) (pair c' s')",
                    "c18_H4 : red (pair c s) (pair c' s')",
                    "c18_s' : store",
                    "c18_c' : com",
                    "c4_s : store",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : le n' n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_now'",
        "proof": [
            {
                "tactic_sig": "Lemma safe_now' : forall ( Q : assertion ) n c s , terminated c -> Q s -> safe Q n c s .",
                "tactic_sig_no_out_arg": "Lemma safe_now' : forall ( Q : assertion ) n c s , terminated c -> Q s -> safe Q n c s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : terminated c) (_ : Q s), safe Q n c s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : terminated c) (_ : Q s), safe Q n c s"
                ],
                "tactic_res": [
                    "c2_goal : safe Q n c s",
                    "c2_Q : assertion",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_H : terminated c",
                    "c2_H0 : Q s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe Q n c s",
                    "c2_n : nat",
                    "c2_H0 : Q s",
                    "c2_H : terminated c",
                    "c2_s : store",
                    "c2_c : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : safe Q 0 c s",
                    "c4_goal : safe Q (S n) c s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe Q 0 c s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe Q (S n) c s",
                    "_global_safe_now : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c5_goal : terminated c",
                    "c6_goal : Q s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : terminated c",
                    "c2_H : terminated c",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Q s",
                    "c2_H0 : Q s",
                    "c2_s : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_terminated_inv",
        "proof": [
            {
                "tactic_sig": "Lemma safe_terminated_inv : forall Q n c s , safe Q ( S n ) c s -> terminated c -> Q s .",
                "tactic_sig_no_out_arg": "Lemma safe_terminated_inv : forall Q n c s , safe Q ( S n ) c s -> terminated c -> Q s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q (S n) c s) (_ : terminated c), Q s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q (S n) c s) (_ : terminated c), Q s"
                ],
                "tactic_res": [
                    "c2_goal : Q s",
                    "c2_Q : assertion",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_H : safe Q (S n) c s",
                    "c2_H0 : terminated c"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : Q s",
                    "c2_H : safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c3_goal : Q s",
                    "c3_H3 : Q s",
                    "c3_H2 : terminated c",
                    "c4_goal : Q s",
                    "c4_H4 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c4_H3 : not (error c s)",
                    "c4_H2 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Q s",
                    "c3_H3 : Q s",
                    "c2_s : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c4_goal : Q s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_notstuck",
        "proof": [
            {
                "tactic_sig": "Lemma safe_notstuck : forall Q n c s , safe Q ( S n ) c s -> ~ error c s .",
                "tactic_sig_no_out_arg": "Lemma safe_notstuck : forall Q n c s , safe Q ( S n ) c s -> ~ error c s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q (S n) c s), not (error c s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store)\n  (_ : safe Q (S n) c s), not (error c s)"
                ],
                "tactic_res": [
                    "c2_goal : not (error c s)",
                    "c2_Q : assertion",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_H : safe Q (S n) c s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : not (error c s)",
                    "c2_H : safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c3_goal : not (error c s)",
                    "c3_H2 : Q s",
                    "c3_H1 : terminated c",
                    "c4_goal : not (error c s)",
                    "c4_H3 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c4_H2 : not (error c s)",
                    "c4_H1 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : not (error c s)",
                    "c3_H1 : terminated c"
                ],
                "tactic_res": [
                    "c5_goal : not (error SKIP s)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : not (error SKIP s)"
                ],
                "tactic_res": [
                    "c6_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : not (error c s)",
                    "c4_H2 : not (error c s)",
                    "c2_s : store",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_step_inv",
        "proof": [
            {
                "tactic_sig": "Lemma safe_step_inv : forall Q n c s c' s' , safe Q ( S n ) c s -> red ( c , s ) ( c' , s' ) -> safe Q n c' s' .",
                "tactic_sig_no_out_arg": "Lemma safe_step_inv : forall Q n c s c' s' , safe Q ( S n ) c s -> red ( c , s ) ( c' , s' ) -> safe Q n c' s' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store) \n  (c' : com) (s' : store) (_ : safe Q (S n) c s)\n  (_ : red (pair c s) (pair c' s')), safe Q n c' s'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : assertion) (n : nat) (c : com) (s : store) \n  (c' : com) (s' : store) (_ : safe Q (S n) c s)\n  (_ : red (pair c s) (pair c' s')), safe Q n c' s'"
                ],
                "tactic_res": [
                    "c2_goal : safe Q n c' s'",
                    "c2_Q : assertion",
                    "c2_n : nat",
                    "c2_c : com",
                    "c2_s : store",
                    "c2_c' : com",
                    "c2_s' : store",
                    "c2_H : safe Q (S n) c s",
                    "c2_H0 : red (pair c s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : safe Q n c' s'",
                    "c2_H : safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c3_goal : safe Q n c' s'",
                    "c3_H3 : Q s",
                    "c3_H2 : terminated c",
                    "c4_goal : safe Q n c' s'",
                    "c4_H4 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c4_H3 : not (error c s)",
                    "c4_H2 : not (terminated c)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c3_H2 : terminated c",
                    "c3_H0 : red (pair c s) (pair c' s')"
                ],
                "tactic_res": [
                    "c3_H0 : red (pair SKIP s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : safe Q n c' s'",
                    "c3_H0 : red (pair SKIP s) (pair c' s')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : safe Q n c' s'",
                    "c4_H4 : forall (c' : com) (s' : store) (_ : red (pair c s) (pair c' s')),\nsafe Q n c' s'",
                    "c2_H0 : red (pair c s) (pair c' s')",
                    "c2_s' : store",
                    "c2_c' : com",
                    "c2_n : nat",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_skip",
        "proof": [
            {
                "tactic_sig": "Lemma triple_skip : forall P , \u2983\u2983 P \u2984\u2984 SKIP \u2983\u2983 P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_skip : forall P , \u2983\u2983 P \u2984\u2984 SKIP \u2983\u2983 P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : assertion, triple P SKIP P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P n s PRE .",
                "tactic_args": [
                    "c1_goal : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": [
                    "c2_goal : safe P n SKIP s",
                    "c2_P : assertion",
                    "c2_n : nat",
                    "c2_s : store",
                    "c2_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe P n SKIP s",
                    "_global_safe_now' : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q n c s"
                ],
                "tactic_res": [
                    "c3_goal : terminated SKIP",
                    "c4_goal : P s"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : terminated SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P s",
                    "c2_PRE : P s",
                    "c2_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_assign",
        "proof": [
            {
                "tactic_sig": "Lemma triple_assign : forall P x a , \u2983\u2983 aupdate x a P \u2984\u2984 ASSIGN x a \u2983\u2983 P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_assign : forall P x a , \u2983\u2983 aupdate x a P \u2984\u2984 ASSIGN x a \u2983\u2983 P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\ntriple (aupdate x a P) (ASSIGN x a) P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P x a n s PRE .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (x : ident) (a : aexp),\ntriple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": [
                    "c2_goal : safe P n (ASSIGN x a) s",
                    "c2_P : assertion",
                    "c2_x : ident",
                    "c2_a : aexp",
                    "c2_n : nat",
                    "c2_s : store",
                    "c2_PRE : aupdate x a P s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : safe P n (ASSIGN x a) s",
                    "c2_n : nat",
                    "c2_PRE : aupdate x a P s",
                    "c2_s : store",
                    "c2_a : aexp",
                    "c2_x : ident",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c3_goal : safe P 0 (ASSIGN x a) s",
                    "c4_goal : safe P (S n) (ASSIGN x a) s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe P 0 (ASSIGN x a) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe P (S n) (ASSIGN x a) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c5_goal : not (terminated (ASSIGN x a))",
                    "c6_goal : not (error (ASSIGN x a) s)",
                    "c7_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : not (terminated (ASSIGN x a))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c8_goal : not (eq (ASSIGN x a) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c8_goal : not (eq (ASSIGN x a) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : not (error (ASSIGN x a) s)"
                ],
                "tactic_res": [
                    "c9_goal : not False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c9_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c7_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSIGN x a) s) (pair c' s')), safe P n c' s'"
                ],
                "tactic_res": [
                    "c10_goal : safe P n c' s'",
                    "c10_c' : com",
                    "c10_s' : store",
                    "c10_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe P n c' s'",
                    "c10_RED : red (pair (ASSIGN x a) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c11_goal : safe P n SKIP (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : safe P n SKIP (update x (aeval a s) s)",
                    "_global_triple_skip : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": [
                    "c12_goal : P (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c12_goal : P (update x (aeval a s) s)",
                    "c2_PRE : aupdate x a P s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_seq",
        "proof": [
            {
                "tactic_sig": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) n , ( forall n' s , ( n' < n ) % nat -> Q s -> safe R n' c' s ) -> forall c s , safe Q n c s -> safe R n ( c ; ; c' ) s .",
                "tactic_sig_no_out_arg": "Remark safe_seq : forall ( Q R : assertion ) ( c' : com ) n , ( forall n' s , ( n' < n ) % nat -> Q s -> safe R n' c' s ) -> forall c s , safe Q n c s -> safe R n ( c ; ; c' ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q R : assertion) (c' : com) (n : nat)\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c' s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c') s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q R c2 n .",
                "tactic_args": [
                    "c1_goal : forall (Q R : assertion) (c' : com) (n : nat)\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c' s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c') s"
                ],
                "tactic_res": [
                    "c2_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c2) s",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c2 : com",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c2) s",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' 0) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q 0 c s),\nsafe R 0 (SEQ c c2) s",
                    "c4_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q (S n) c s),\nsafe R (S n) (SEQ c c2) s",
                    "c4_IHn : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c2) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros QR c s SF .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' 0) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q 0 c s),\nsafe R 0 (SEQ c c2) s"
                ],
                "tactic_res": [
                    "c5_goal : safe R 0 (SEQ c c2) s",
                    "c5_QR : forall (n' : nat) (s : store) (_ : lt n' 0) (_ : Q s), safe R n' c2 s",
                    "c5_c : com",
                    "c5_s : store",
                    "c5_SF : safe Q 0 c s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros QR c s SF .",
                "tactic_args": [
                    "c4_goal : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q (S n) c s),\nsafe R (S n) (SEQ c c2) s"
                ],
                "tactic_res": [
                    "c6_goal : safe R (S n) (SEQ c c2) s",
                    "c6_QR : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\nsafe R n' c2 s",
                    "c6_c : com",
                    "c6_s : store",
                    "c6_SF : safe Q (S n) c s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe R 0 (SEQ c c2) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe R (S n) (SEQ c c2) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c7_goal : not (terminated (SEQ c c2))",
                    "c8_goal : not (error (SEQ c c2) s)",
                    "c9_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : not (terminated (SEQ c c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (SEQ c c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (SEQ c c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c8_goal : not (error (SEQ c c2) s)"
                ],
                "tactic_res": [
                    "c11_goal : not (error c s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c11_goal : not (error c s)",
                    "_global_safe_notstuck : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : safe Q (S n) c s), not (error c s)"
                ],
                "tactic_res": [
                    "c12_goal : safe ?Q (S ?n) c s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : safe ?Q (S ?n) c s",
                    "c6_SF : safe Q (S n) c s",
                    "c6_s : store",
                    "c6_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c9_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (SEQ c c2) s) (pair c' s')), safe R n c' s'"
                ],
                "tactic_res": [
                    "c13_goal : safe R n c' s'",
                    "c13_c' : com",
                    "c13_s' : store",
                    "c13_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : safe R n c' s'",
                    "c13_RED : red (pair (SEQ c c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c14_goal : safe R n c' s'",
                    "c14_SF : safe Q (S n) SKIP s'",
                    "c14_IHn : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c' s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c') s",
                    "c14_QR : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\nsafe R n' c' s",
                    "c15_goal : safe R n (SEQ c3 c2) s'",
                    "c15_H0 : red (pair c s) (pair c3 s')",
                    "c15_c3 : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : safe R n c' s'",
                    "c14_QR : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\nsafe R n' c' s"
                ],
                "tactic_res": [
                    "c16_goal : lt n (S n)",
                    "c17_goal : Q s'"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c16_goal : lt n (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c17_goal : Q s'",
                    "_global_safe_terminated_inv : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : safe Q (S n) c s) (_ : terminated c), \n       Q s"
                ],
                "tactic_res": [
                    "c18_goal : safe Q (S ?n) ?c s'",
                    "c19_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : safe Q (S ?n) ?c s'",
                    "c14_SF : safe Q (S n) SKIP s'",
                    "c13_s' : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c19_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c20_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : safe R n (SEQ c3 c2) s'",
                    "c4_IHn : forall\n  (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n       safe R n' c2 s) (c : com) (s : store) (_ : safe Q n c s),\nsafe R n (SEQ c c2) s"
                ],
                "tactic_res": [
                    "c21_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s), safe R n' c2 s",
                    "c22_goal : safe Q n c3 s'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s), safe R n' c2 s"
                ],
                "tactic_res": [
                    "c23_goal : safe R n' c2 s0",
                    "c23_n' : nat",
                    "c23_s0 : store",
                    "c23_H : lt n' n",
                    "c23_H1 : Q s0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : safe R n' c2 s0",
                    "c6_QR : forall (n' : nat) (s : store) (_ : lt n' (S n)) (_ : Q s),\nsafe R n' c2 s"
                ],
                "tactic_res": [
                    "c24_goal : lt n' (S n)",
                    "c25_goal : Q s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : lt n' (S n)",
                    "c23_H : lt n' n",
                    "c23_n' : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Q s0",
                    "c23_H1 : Q s0",
                    "c23_s0 : store",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c22_goal : safe Q n c3 s'",
                    "_global_safe_step_inv : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (c' : com) (s' : store) (_ : safe Q (S n) c s)\n         (_ : red (pair c s) (pair c' s')), safe Q n c' s'"
                ],
                "tactic_res": [
                    "c26_goal : safe Q (S n) ?c ?s",
                    "c27_goal : red (pair c s) (pair c3 s')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : safe Q (S n) ?c ?s",
                    "c6_SF : safe Q (S n) c s",
                    "c2_n : nat",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : red (pair c s) (pair c3 s')",
                    "c15_H0 : red (pair c s) (pair c3 s')",
                    "c15_c3 : com",
                    "c13_s' : store",
                    "c6_s : store",
                    "c6_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_seq",
        "proof": [
            {
                "tactic_sig": "Lemma triple_seq : forall P Q R c1 c2 , \u2983\u2983 P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 Q \u2984\u2984 c2 \u2983\u2983 R \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 c1 ; ; c2 \u2983\u2983 R \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_seq : forall P Q R c1 c2 , \u2983\u2983 P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 Q \u2984\u2984 c2 \u2983\u2983 R \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 c1 ; ; c2 \u2983\u2983 R \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n  (_ : triple Q c2 R), triple P (SEQ c1 c2) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n  (_ : triple Q c2 R), triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c2_goal : triple P (SEQ c1 c2) R",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : triple P c1 Q",
                    "c2_H0 : triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n s PRE .",
                "tactic_args": [
                    "c2_goal : triple P (SEQ c1 c2) R"
                ],
                "tactic_res": [
                    "c3_goal : safe R n (SEQ c1 c2) s",
                    "c3_n : nat",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe R n (SEQ c1 c2) s",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com) (n : nat)\n         (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n              safe R n' c' s) (c : com) (s : store) \n         (_ : safe Q n c s), safe R n (SEQ c c') s",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c4_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s), safe R n' c2 s",
                    "c5_goal : safe Q n c1 s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s), safe R n' c2 s",
                    "c3_n : nat",
                    "c2_H0 : triple Q c2 R",
                    "c2_c2 : com",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe Q n c1 s",
                    "c3_PRE : P s",
                    "c3_s : store",
                    "c3_n : nat",
                    "c2_H : triple P c1 Q",
                    "c2_c1 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_while",
        "proof": [
            {
                "tactic_sig": "Lemma triple_while : forall P b c , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c \u2983\u2983 P \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 WHILE b c \u2983\u2983 afalse b //\\\\ P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_while : forall P b c , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c \u2983\u2983 P \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 WHILE b c \u2983\u2983 afalse b //\\\\ P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com)\n  (_ : triple (aand (atrue b) P) c P),\ntriple P (WHILE b c) (aand (afalse b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P b c T .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (b : bexp) (c : com)\n  (_ : triple (aand (atrue b) P) c P),\ntriple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c2_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c2_P : assertion",
                    "c2_b : bexp",
                    "c2_c : com",
                    "c2_T : triple (aand (atrue b) P) c P"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (s : store) (_ : P s),\nsafe (aand (afalse b) P) n (WHILE b c) s"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (s : store) (_ : P s),\nsafe (aand (afalse b) P) n (WHILE b c) s"
                ],
                "tactic_res": [
                    "c4_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) n (WHILE b c) s",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c4_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) n (WHILE b c) s",
                    "c4_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) 0 (WHILE b c) s",
                    "c6_goal : forall (s : store) (_ : P s),\nsafe (aand (afalse b) P) (S n) (WHILE b c) s",
                    "c6_IHn : forall (s : store) (_ : P s), safe (aand (afalse b) P) n (WHILE b c) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c5_goal : forall (s : store) (_ : P s), safe (aand (afalse b) P) 0 (WHILE b c) s"
                ],
                "tactic_res": [
                    "c7_goal : safe (aand (afalse b) P) 0 (WHILE b c) s",
                    "c7_s : store",
                    "c7_Ps : P s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s Ps .",
                "tactic_args": [
                    "c6_goal : forall (s : store) (_ : P s),\nsafe (aand (afalse b) P) (S n) (WHILE b c) s"
                ],
                "tactic_res": [
                    "c8_goal : safe (aand (afalse b) P) (S n) (WHILE b c) s",
                    "c8_s : store",
                    "c8_Ps : P s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (aand (afalse b) P) 0 (WHILE b c) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : safe (aand (afalse b) P) (S n) (WHILE b c) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c9_goal : not (terminated (WHILE b c))",
                    "c10_goal : not (error (WHILE b c) s)",
                    "c11_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : not (terminated (WHILE b c))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c12_goal : not (eq (WHILE b c) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c12_goal : not (eq (WHILE b c) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c10_goal : not (error (WHILE b c) s)"
                ],
                "tactic_res": [
                    "c13_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c11_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (WHILE b c) s) (pair c' s')),\nsafe (aand (afalse b) P) n c' s'"
                ],
                "tactic_res": [
                    "c14_goal : safe (aand (afalse b) P) n c' s'",
                    "c14_c' : com",
                    "c14_s' : store",
                    "c14_RED : red (pair (WHILE b c) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : safe (aand (afalse b) P) n c' s'",
                    "c14_RED : red (pair (WHILE b c) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c15_goal : safe (aand (afalse b) P) n SKIP s'",
                    "c15_H0 : eq (beval b s') false",
                    "c15_Ps : P s'",
                    "c16_goal : safe (aand (afalse b) P) n (SEQ c (WHILE b c)) s'",
                    "c16_H0 : eq (beval b s') true",
                    "c16_Ps : P s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : safe (aand (afalse b) P) n SKIP s'",
                    "_global_triple_skip : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": [
                    "c17_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c18_goal : afalse b s'",
                    "c19_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : afalse b s'",
                    "c15_H0 : eq (beval b s') false",
                    "c14_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : P s'",
                    "c15_Ps : P s'",
                    "c14_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c16_goal : safe (aand (afalse b) P) n (SEQ c (WHILE b c)) s'",
                    "_global_safe_seq : forall (Q R : assertion) (c' : com) (n : nat)\n         (_ : forall (n' : nat) (s : store) (_ : lt n' n) (_ : Q s),\n              safe R n' c' s) (c : com) (s : store) \n         (_ : safe Q n c s), safe R n (SEQ c c') s",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c20_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : P s),\nsafe (aand (afalse b) P) n' (WHILE b c) s",
                    "c21_goal : safe P n c s'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c20_goal : forall (n' : nat) (s : store) (_ : lt n' n) (_ : P s),\nsafe (aand (afalse b) P) n' (WHILE b c) s"
                ],
                "tactic_res": [
                    "c22_goal : safe (aand (afalse b) P) n' (WHILE b c) s",
                    "c22_n' : nat",
                    "c22_s : store",
                    "c22_H : lt n' n",
                    "c22_H1 : P s"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c22_goal : safe (aand (afalse b) P) n' (WHILE b c) s",
                    "_global_safe_mono : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : safe Q n c s) (n' : nat) \n         (_ : le n' n), safe Q n' c s",
                    "c4_n : nat"
                ],
                "tactic_res": [
                    "c23_goal : safe (aand (afalse b) P) n (WHILE b c) s",
                    "c24_goal : le n' n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : safe (aand (afalse b) P) n (WHILE b c) s",
                    "c6_IHn : forall (s : store) (_ : P s), safe (aand (afalse b) P) n (WHILE b c) s"
                ],
                "tactic_res": [
                    "c25_goal : P s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : P s",
                    "c22_H1 : P s",
                    "c22_s : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c24_goal : le n' n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : safe P n c s'",
                    "c2_T : triple (aand (atrue b) P) c P"
                ],
                "tactic_res": [
                    "c26_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c26_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c27_goal : atrue b s'",
                    "c28_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : atrue b s'",
                    "c16_H0 : eq (beval b s') true",
                    "c14_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : P s'",
                    "c16_Ps : P s'",
                    "c14_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthenelse : forall P Q b c1 c2 , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 afalse b //\\\\ P \u2984\u2984 c2 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 IFTHENELSE b c1 c2 \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthenelse : forall P Q b c1 c2 , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 c1 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 afalse b //\\\\ P \u2984\u2984 c2 \u2983\u2983 Q \u2984\u2984 -> \u2983\u2983 P \u2984\u2984 IFTHENELSE b c1 c2 \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : triple (aand (atrue b) P) c1 Q)\n  (_ : triple (aand (afalse b) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n  (_ : triple (aand (atrue b) P) c1 Q)\n  (_ : triple (aand (afalse b) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_b : bexp",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_H : triple (aand (atrue b) P) c1 Q",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n s PRE .",
                "tactic_args": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q n (IFTHENELSE b c1 c2) s",
                    "c3_n : nat",
                    "c3_s : store",
                    "c3_PRE : P s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : safe Q n (IFTHENELSE b c1 c2) s",
                    "c3_n : nat",
                    "c3_PRE : P s",
                    "c3_s : store",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q",
                    "c2_H : triple (aand (atrue b) P) c1 Q",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_b : bexp",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c4_goal : safe Q 0 (IFTHENELSE b c1 c2) s",
                    "c5_goal : safe Q (S n) (IFTHENELSE b c1 c2) s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe Q 0 (IFTHENELSE b c1 c2) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe Q (S n) (IFTHENELSE b c1 c2) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "c7_goal : not (error (IFTHENELSE b c1 c2) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (IFTHENELSE b c1 c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (IFTHENELSE b c1 c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (IFTHENELSE b c1 c2) s)"
                ],
                "tactic_res": [
                    "c10_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')), \nsafe Q n c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe Q n c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : safe Q n c' s'",
                    "c11_RED : red (pair (IFTHENELSE b c1 c2) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe Q n (if beval b s' then c1 else c2) s'",
                    "c12_PRE : P s'"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) eqn : B .",
                "tactic_args": [
                    "c12_goal : safe Q n (if beval b s' then c1 else c2) s'",
                    "c2_b : bexp",
                    "c11_s' : store",
                    "c12_PRE : P s'",
                    "c3_n : nat",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q",
                    "c2_H : triple (aand (atrue b) P) c1 Q",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c13_goal : safe Q n c1 s'",
                    "c13_B : eq (beval b s') true",
                    "c14_goal : safe Q n c2 s'",
                    "c14_B : eq (beval b s') false"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : safe Q n c1 s'",
                    "c2_H : triple (aand (atrue b) P) c1 Q"
                ],
                "tactic_res": [
                    "c15_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c15_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c16_goal : atrue b s'",
                    "c17_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : atrue b s'",
                    "c13_B : eq (beval b s') true",
                    "c11_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : P s'",
                    "c12_PRE : P s'",
                    "c11_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : safe Q n c2 s'",
                    "c2_H0 : triple (aand (afalse b) P) c2 Q"
                ],
                "tactic_res": [
                    "c18_goal : aand (afalse b) P s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c18_goal : aand (afalse b) P s'"
                ],
                "tactic_res": [
                    "c19_goal : afalse b s'",
                    "c20_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : afalse b s'",
                    "c14_B : eq (beval b s') false",
                    "c11_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : P s'",
                    "c12_PRE : P s'",
                    "c11_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_havoc",
        "proof": [
            {
                "tactic_sig": "Lemma triple_havoc : forall x Q , \u2983\u2983 aforall ( fun n => aupdate x ( CONST n ) Q ) \u2984\u2984 HAVOC x \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_havoc : forall x Q , \u2983\u2983 aforall ( fun n => aupdate x ( CONST n ) Q ) \u2984\u2984 HAVOC x \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : ident) (Q : assertion),\ntriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x : ident) (Q : assertion),\ntriple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c2_x : ident",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n s PRE .",
                "tactic_args": [
                    "c2_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe Q n (HAVOC x) s",
                    "c3_n : nat",
                    "c3_s : store",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : safe Q n (HAVOC x) s",
                    "c3_n : nat",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s",
                    "c3_s : store",
                    "c2_Q : assertion",
                    "c2_x : ident"
                ],
                "tactic_res": [
                    "c4_goal : safe Q 0 (HAVOC x) s",
                    "c5_goal : safe Q (S n) (HAVOC x) s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe Q 0 (HAVOC x) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe Q (S n) (HAVOC x) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (HAVOC x))",
                    "c7_goal : not (error (HAVOC x) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (HAVOC x))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (HAVOC x) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (HAVOC x) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (HAVOC x) s)"
                ],
                "tactic_res": [
                    "c10_goal : not False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (HAVOC x) s) (pair c' s')), safe Q n c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe Q n c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (HAVOC x) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : safe Q n c' s'",
                    "c11_RED : red (pair (HAVOC x) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe Q n SKIP (update x n0 s)",
                    "c12_n0 : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe Q n SKIP (update x n0 s)",
                    "_global_safe_now' : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q n c s"
                ],
                "tactic_res": [
                    "c13_goal : terminated SKIP",
                    "c14_goal : Q (update x n0 s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c15_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Q (update x n0 s)",
                    "c3_PRE : aforall (fun n : Z => aupdate x (CONST n) Q) s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_assert",
        "proof": [
            {
                "tactic_sig": "Lemma triple_assert : forall b P , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 ASSERT b \u2983\u2983 atrue b //\\\\ P \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_assert : forall b P , \u2983\u2983 atrue b //\\\\ P \u2984\u2984 ASSERT b \u2983\u2983 atrue b //\\\\ P \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : bexp) (P : assertion),\ntriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : bexp) (P : assertion),\ntriple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c2_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c2_b : bexp",
                    "c2_P : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros n s [ PRE1 PRE2 ] .",
                "tactic_args": [
                    "c2_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": [
                    "c3_goal : safe (aand (atrue b) P) n (ASSERT b) s",
                    "c3_n : nat",
                    "c3_s : store",
                    "c3_PRE1 : atrue b s",
                    "c3_PRE2 : P s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_PRE1 : atrue b s"
                ],
                "tactic_res": [
                    "c3_PRE1 : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : safe (aand (atrue b) P) n (ASSERT b) s",
                    "c3_n : nat",
                    "c3_PRE2 : P s",
                    "c3_PRE1 : eq (beval b s) true",
                    "c3_s : store",
                    "c2_P : assertion",
                    "c2_b : bexp"
                ],
                "tactic_res": [
                    "c4_goal : safe (aand (atrue b) P) 0 (ASSERT b) s",
                    "c5_goal : safe (aand (atrue b) P) (S n) (ASSERT b) s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (aand (atrue b) P) 0 (ASSERT b) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe (aand (atrue b) P) (S n) (ASSERT b) s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c6_goal : not (terminated (ASSERT b))",
                    "c7_goal : not (error (ASSERT b) s)",
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) n c' s'"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : not (terminated (ASSERT b))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (ASSERT b) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (ASSERT b) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c10_goal : not (eq (beval b s) false)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c10_goal : not (eq (beval b s) false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' s' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (s' : store)\n  (_ : red (pair (ASSERT b) s) (pair c' s')),\nsafe (aand (atrue b) P) n c' s'"
                ],
                "tactic_res": [
                    "c11_goal : safe (aand (atrue b) P) n c' s'",
                    "c11_c' : com",
                    "c11_s' : store",
                    "c11_RED : red (pair (ASSERT b) s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : safe (aand (atrue b) P) n c' s'",
                    "c11_RED : red (pair (ASSERT b) s) (pair c' s')"
                ],
                "tactic_res": [
                    "c12_goal : safe (aand (atrue b) P) n SKIP s'",
                    "c12_H0 : eq (beval b s') true",
                    "c12_PRE1 : eq (beval b s') true",
                    "c12_PRE2 : P s'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : safe (aand (atrue b) P) n SKIP s'",
                    "_global_safe_now' : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q n c s"
                ],
                "tactic_res": [
                    "c13_goal : terminated SKIP",
                    "c14_goal : aand (atrue b) P s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c15_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : aand (atrue b) P s'"
                ],
                "tactic_res": [
                    "c16_goal : atrue b s'",
                    "c17_goal : P s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : atrue b s'",
                    "c11_s' : store",
                    "c2_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : P s'",
                    "c12_PRE2 : P s'",
                    "c11_s' : store",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence : forall P Q P' Q' c , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> P' -->> P -> Q -->> Q' -> \u2983\u2983 P' \u2984\u2984 c \u2983\u2983 Q' \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence : forall P Q P' Q' c , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> P' -->> P -> Q -->> Q' -> \u2983\u2983 P' \u2984\u2984 c \u2983\u2983 Q' \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n  (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'"
                ],
                "tactic_res": [
                    "c2_goal : triple P' c Q'",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_P' : assertion",
                    "c2_Q' : assertion",
                    "c2_c : com",
                    "c2_H : triple P c Q",
                    "c2_H0 : aimp P' P",
                    "c2_H1 : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "assert ( REC : forall n _i s , safe _i n _i s -> safe _i n _i s ) .",
                "tactic_sig_no_out_arg": "assert ( REC : forall n _i s , safe _i n _i s -> safe _i n _i s ) .",
                "tactic_args": [
                    "c2_goal : triple P' c Q'",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_c : com",
                    "c2_Q' : assertion",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (c : com) (s : store) (_ : safe Q n c s),\nsafe Q' n c s",
                    "c4_goal : triple P' c Q'",
                    "c4_REC : forall (n : nat) (c : com) (s : store) (_ : safe Q n c s),\nsafe Q' n c s"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (c : com) (s : store) (_ : safe Q n c s),\nsafe Q' n c s"
                ],
                "tactic_res": [
                    "c5_goal : safe Q' 0 c0 s",
                    "c5_s : store",
                    "c5_c0 : com",
                    "c6_goal : safe Q' (S n) c0 s",
                    "c6_H3 : Q s",
                    "c6_H2 : terminated c0",
                    "c6_s : store",
                    "c6_c0 : com",
                    "c6_n : nat",
                    "c7_goal : safe Q' (S n) c0 s",
                    "c7_H5 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' n c' s'",
                    "c7_H4 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q n c' s'",
                    "c7_H3 : not (error c0 s)",
                    "c7_H2 : not (terminated c0)",
                    "c7_s : store",
                    "c7_c0 : com",
                    "c7_n : nat"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe Q' 0 c0 s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : safe Q' (S n) c0 s",
                    "_global_safe_now : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : terminated c) (_ : Q s), \n       safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c8_goal : terminated c0",
                    "c9_goal : Q' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : terminated c0",
                    "c6_H2 : terminated c0",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Q' s",
                    "c6_H3 : Q s",
                    "c6_s : store",
                    "c2_H1 : aimp Q Q'",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : safe Q' (S n) c0 s",
                    "_global_safe_step : forall (Q : assertion) (n : nat) (c : com) \n         (s : store) (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q n c' s'), safe Q (S n) c s"
                ],
                "tactic_res": [
                    "c10_goal : not (terminated c0)",
                    "c11_goal : not (error c0 s)",
                    "c12_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' n c' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not (terminated c0)",
                    "c7_H2 : not (terminated c0)",
                    "c7_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : not (error c0 s)",
                    "c7_H3 : not (error c0 s)",
                    "c7_s : store",
                    "c7_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' n c' s'",
                    "c7_H5 : forall (c' : com) (s' : store) (_ : red (pair c0 s) (pair c' s')),\nsafe Q' n c' s'",
                    "c7_s : store",
                    "c7_c0 : com",
                    "c7_n : nat",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : triple P' c Q'"
                ],
                "tactic_res": [
                    "c13_goal : forall (n : nat) (s : store) (_ : P' s), safe Q' n c s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall (n : nat) (s : store) (_ : P' s), safe Q' n c s",
                    "c4_REC : forall (n : nat) (c : com) (s : store) (_ : safe Q n c s),\nsafe Q' n c s",
                    "c2_H0 : aimp P' P",
                    "c2_H : triple P c Q",
                    "c2_c : com",
                    "c2_P' : assertion",
                    "c2_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_sound",
        "proof": [
            {
                "tactic_sig": "Theorem Hoare_sound : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 .",
                "tactic_sig_no_out_arg": "Theorem Hoare_sound : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q),\ntriple P c Q"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : Hoare P c Q),\ntriple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P SKIP P",
                    "c2_P : assertion",
                    "c3_goal : triple (aupdate x a P) (ASSIGN x a) P",
                    "c3_a : aexp",
                    "c3_x : ident",
                    "c3_P : assertion",
                    "c4_goal : triple P (SEQ c1 c2) R",
                    "c4_IHHoare2 : triple Q c2 R",
                    "c4_IHHoare1 : triple P c1 Q",
                    "c4_H0 : Hoare Q c2 R",
                    "c4_H : Hoare P c1 Q",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_R : assertion",
                    "c4_Q : assertion",
                    "c4_P : assertion",
                    "c5_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c5_IHHoare2 : triple (aand (afalse b) P) c2 Q",
                    "c5_IHHoare1 : triple (aand (atrue b) P) c1 Q",
                    "c5_H0 : Hoare (aand (afalse b) P) c2 Q",
                    "c5_H : Hoare (aand (atrue b) P) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_Q : assertion",
                    "c5_P : assertion",
                    "c6_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "c6_IHHoare : triple (aand (atrue b) P) c P",
                    "c6_H : Hoare (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion",
                    "c7_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "c7_Q : assertion",
                    "c7_x : ident",
                    "c8_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "c8_b : bexp",
                    "c8_P : assertion",
                    "c9_goal : triple P' c Q'",
                    "c9_IHHoare : triple P c Q",
                    "c9_H1 : aimp Q Q'",
                    "c9_H0 : aimp P' P",
                    "c9_H : Hoare P c Q",
                    "c9_c : com",
                    "c9_Q' : assertion",
                    "c9_P' : assertion",
                    "c9_Q : assertion",
                    "c9_P : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple P SKIP P",
                    "_global_triple_skip : forall P : assertion, triple P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (aupdate x a P) (ASSIGN x a) P",
                    "_global_triple_assign : forall (P : assertion) (x : ident) (a : aexp),\n       triple (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : triple P (SEQ c1 c2) R",
                    "_global_triple_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : triple P c1 Q)\n         (_ : triple Q c2 R), triple P (SEQ c1 c2) R",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c10_goal : triple P c1 Q",
                    "c11_goal : triple Q c2 R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : triple P c1 Q",
                    "c4_IHHoare1 : triple P c1 Q",
                    "c4_c1 : com",
                    "c4_P : assertion",
                    "c4_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : triple Q c2 R",
                    "c4_IHHoare2 : triple Q c2 R",
                    "c4_c2 : com",
                    "c4_Q : assertion",
                    "c4_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "_global_triple_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : triple (aand (atrue b) P) c1 Q)\n         (_ : triple (aand (afalse b) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c12_goal : triple (aand (atrue b) P) c1 Q",
                    "c13_goal : triple (aand (afalse b) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : triple (aand (atrue b) P) c1 Q",
                    "c5_IHHoare1 : triple (aand (atrue b) P) c1 Q",
                    "c5_c1 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : triple (aand (afalse b) P) c2 Q",
                    "c5_IHHoare2 : triple (aand (afalse b) P) c2 Q",
                    "c5_c2 : com",
                    "c5_b : bexp",
                    "c5_P : assertion",
                    "c5_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple P (WHILE b c) (aand (afalse b) P)",
                    "_global_triple_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : triple (aand (atrue b) P) c P),\n       triple P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c14_goal : triple (aand (atrue b) P) c P"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : triple (aand (atrue b) P) c P",
                    "c6_IHHoare : triple (aand (atrue b) P) c P",
                    "c6_c : com",
                    "c6_b : bexp",
                    "c6_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q",
                    "_global_triple_havoc : forall (x : ident) (Q : assertion),\n       triple (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)",
                    "_global_triple_assert : forall (b : bexp) (P : assertion),\n       triple (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c9_goal : triple P' c Q'",
                    "_global_triple_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : triple P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), triple P' c Q'",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": [
                    "c15_goal : triple P c Q",
                    "c16_goal : aimp P' P",
                    "c17_goal : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : triple P c Q",
                    "c9_IHHoare : triple P c Q",
                    "c9_c : com",
                    "c9_P : assertion",
                    "c9_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : aimp P' P",
                    "c9_H0 : aimp P' P",
                    "c9_P : assertion",
                    "c9_P' : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : aimp Q Q'",
                    "c9_H1 : aimp Q Q'",
                    "c9_Q : assertion",
                    "c9_Q' : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "terminated_dec",
        "proof": [
            {
                "tactic_sig": "Lemma terminated_dec : forall c , { terminated c } + { ~ terminated c } .",
                "tactic_sig_no_out_arg": "Lemma terminated_dec : forall c , { terminated c } + { ~ terminated c } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall c : com, sumbool (terminated c) (not (terminated c))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall c : com, sumbool (terminated c) (not (terminated c))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall c : com, sumbool (eq c SKIP) (not (eq c SKIP))"
                ]
            },
            {
                "tactic_sig": "destruct c as [  | _o _o | _o _o | _o _o _o | _o _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct c .",
                "tactic_args": [
                    "c2_goal : forall c : com, sumbool (eq c SKIP) (not (eq c SKIP))"
                ],
                "tactic_res": [
                    "c3_goal : sumbool (eq SKIP SKIP) (not (eq SKIP SKIP))",
                    "c4_goal : sumbool (eq (ASSIGN x a) SKIP) (not (eq (ASSIGN x a) SKIP))",
                    "c4_a : aexp",
                    "c4_x : ident",
                    "c5_goal : sumbool (eq (SEQ c1 c2) SKIP) (not (eq (SEQ c1 c2) SKIP))",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c6_goal : sumbool (eq (IFTHENELSE b c1 c2) SKIP)\n  (not (eq (IFTHENELSE b c1 c2) SKIP))",
                    "c6_c2 : com",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c7_goal : sumbool (eq (WHILE b c) SKIP) (not (eq (WHILE b c) SKIP))",
                    "c7_c : com",
                    "c7_b : bexp",
                    "c8_goal : sumbool (eq (ASSERT b) SKIP) (not (eq (ASSERT b) SKIP))",
                    "c8_b : bexp",
                    "c9_goal : sumbool (eq (HAVOC x) SKIP) (not (eq (HAVOC x) SKIP))",
                    "c9_x : ident"
                ]
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c3_goal : sumbool (eq SKIP SKIP) (not (eq SKIP SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c4_goal : sumbool (eq (ASSIGN x a) SKIP) (not (eq (ASSIGN x a) SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c5_goal : sumbool (eq (SEQ c1 c2) SKIP) (not (eq (SEQ c1 c2) SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c6_goal : sumbool (eq (IFTHENELSE b c1 c2) SKIP)\n  (not (eq (IFTHENELSE b c1 c2) SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c7_goal : sumbool (eq (WHILE b c) SKIP) (not (eq (WHILE b c) SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c8_goal : sumbool (eq (ASSERT b) SKIP) (not (eq (ASSERT b) SKIP))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_sig_no_out_arg": "( left ; reflexivity ) || ( right ; discriminate ) .",
                "tactic_args": [
                    "c9_goal : sumbool (eq (HAVOC x) SKIP) (not (eq (HAVOC x) SKIP))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sem_wp_seq",
        "proof": [
            {
                "tactic_sig": "Lemma sem_wp_seq : forall c1 c2 Q s , sem_wp ( c1 ; ; c2 ) Q s -> sem_wp c1 ( sem_wp c2 Q ) s .",
                "tactic_sig_no_out_arg": "Lemma sem_wp_seq : forall c1 c2 Q s , sem_wp ( c1 ; ; c2 ) Q s -> sem_wp c1 ( sem_wp c2 Q ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : sem_wp (SEQ c1 c2) Q s), sem_wp c1 (sem_wp c2 Q) s"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : sem_wp (SEQ c1 c2) Q s), sem_wp c1 (sem_wp c2 Q) s",
                    "_global_sem_wp : forall (_ : com) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c2_goal : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : safe Q (SEQ c1 c2) s),\nsafe (fun s0 : store => safe Q c2 s0) c1 s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c1 c2 Q s SAFE .",
                "tactic_args": [
                    "c2_goal : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : safe Q (SEQ c1 c2) s),\nsafe (fun s0 : store => safe Q c2 s0) c1 s"
                ],
                "tactic_res": [
                    "c3_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "c3_c1 : com",
                    "c3_c2 : com",
                    "c3_Q : assertion",
                    "c3_s : store",
                    "c3_SAFE : safe Q (SEQ c1 c2) s"
                ]
            },
            {
                "tactic_sig": "destruct ( terminated_dec _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( terminated_dec _i ) .",
                "tactic_args": [
                    "c3_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "c3_c1 : com",
                    "c3_SAFE : safe Q (SEQ c1 c2) s",
                    "c3_s : store",
                    "c3_Q : assertion",
                    "c3_c2 : com",
                    "c2_CH : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : safe Q (SEQ c1 c2) s),\nsafe (fun s0 : store => safe Q c2 s0) c1 s"
                ],
                "tactic_res": [
                    "c4_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "c4_t : terminated c1",
                    "c5_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "c5_n : not (terminated c1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "_global_safe_now : forall (Q : assertion) (c : com) (s : store) \n         (_ : terminated c) (_ : Q s), safe Q c s"
                ],
                "tactic_res": [
                    "c6_goal : terminated c1",
                    "c7_goal : safe Q c2 s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : terminated c1",
                    "c4_t : terminated c1",
                    "c3_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : safe Q c2 s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c8_goal : safe Q ?c ?s",
                    "c9_goal : red (pair (SEQ c1 c2) s) (pair c2 s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : safe Q ?c ?s",
                    "c3_SAFE : safe Q (SEQ c1 c2) s",
                    "c3_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : red (pair (SEQ c1 c2) s) (pair c2 s)",
                    "c4_t : terminated c1"
                ],
                "tactic_res": [
                    "c10_goal : red (pair (SEQ SKIP c2) s) (pair c2 s)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : red (pair (SEQ SKIP c2) s) (pair c2 s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe (fun s : store => safe Q c2 s) c1 s",
                    "_global_safe_step : forall (Q : assertion) (c : com) (s : store) \n         (_ : not (terminated c)) (_ : not (error c s))\n         (_ : forall (c' : com) (s' : store)\n                (_ : red (pair c s) (pair c' s')), \n              safe Q c' s'), safe Q c s"
                ],
                "tactic_res": [
                    "c11_goal : not (terminated c1)",
                    "c12_goal : not (error c1 s)",
                    "c13_goal : forall (c' : com) (s' : store) (_ : red (pair c1 s) (pair c' s')),\nsafe (fun s : store => safe Q c2 s) c' s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : not (terminated c1)",
                    "c5_n : not (terminated c1)",
                    "c3_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change ( ~ ( error ( _i ; ; _i ) _i ) ) .",
                "tactic_sig_no_out_arg": "change ( ~ ( error ( _i ; ; _i ) _i ) ) .",
                "tactic_args": [
                    "c12_goal : not (error c1 s)",
                    "c3_c1 : com",
                    "c3_c2 : com",
                    "c3_s : store"
                ],
                "tactic_res": [
                    "c14_goal : not (error (SEQ c1 c2) s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c14_goal : not (error (SEQ c1 c2) s)",
                    "_global_safe_not_stuck : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : not (terminated c)), \n       not (error c s)"
                ],
                "tactic_res": [
                    "c15_goal : safe ?Q (SEQ c1 c2) s",
                    "c16_goal : not (terminated (SEQ c1 c2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : safe ?Q (SEQ c1 c2) s",
                    "c3_SAFE : safe Q (SEQ c1 c2) s",
                    "c3_s : store",
                    "c3_c1 : com",
                    "c3_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c16_goal : not (terminated (SEQ c1 c2))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c17_goal : not (eq (SEQ c1 c2) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c17_goal : not (eq (SEQ c1 c2) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (c' : com) (s' : store) (_ : red (pair c1 s) (pair c' s')),\nsafe (fun s : store => safe Q c2 s) c' s'"
                ],
                "tactic_res": [
                    "c18_goal : safe (fun s : store => safe Q c2 s) c' s'",
                    "c18_c' : com",
                    "c18_s' : store",
                    "c18_H : red (pair c1 s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : safe (fun s : store => safe Q c2 s) c' s'",
                    "c2_CH : forall (c1 c2 : com) (Q : assertion) (s : store)\n  (_ : safe Q (SEQ c1 c2) s),\nsafe (fun s0 : store => safe Q c2 s0) c1 s"
                ],
                "tactic_res": [
                    "c19_goal : safe Q (SEQ c' c2) s'"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c19_goal : safe Q (SEQ c' c2) s'",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c20_goal : safe Q ?c ?s",
                    "c21_goal : red (pair (SEQ c1 c2) s) (pair (SEQ c' c2) s')"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c20_goal : safe Q ?c ?s",
                    "c3_SAFE : safe Q (SEQ c1 c2) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c21_goal : red (pair (SEQ c1 c2) s) (pair (SEQ c' c2) s')"
                ],
                "tactic_res": [
                    "c22_goal : red (pair c1 s) (pair c' s')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : red (pair c1 s) (pair c' s')",
                    "c18_H : red (pair c1 s) (pair c' s')",
                    "c18_s' : store",
                    "c18_c' : com",
                    "c3_s : store",
                    "c3_c1 : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_sem_wp",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_sem_wp : forall c Q , \u2983 sem_wp c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma Hoare_sem_wp : forall c Q , \u2983 sem_wp c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (Q : assertion), Hoare (sem_wp c Q) c Q"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro c .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (Q : assertion), Hoare (sem_wp c Q) c Q"
                ],
                "tactic_res": [
                    "c2_goal : forall Q : assertion, Hoare (sem_wp c Q) c Q",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall Q : assertion, Hoare (sem_wp c Q) c Q",
                    "c2_c : com"
                ],
                "tactic_res": [
                    "c3_goal : forall Q : assertion, Hoare (sem_wp SKIP Q) SKIP Q",
                    "c4_goal : forall Q : assertion, Hoare (sem_wp (ASSIGN x a) Q) (ASSIGN x a) Q",
                    "c4_a : aexp",
                    "c4_x : ident",
                    "c5_goal : forall Q : assertion, Hoare (sem_wp (SEQ c1 c2) Q) (SEQ c1 c2) Q",
                    "c5_IHc2 : forall Q : assertion, Hoare (sem_wp c2 Q) c2 Q",
                    "c5_IHc1 : forall Q : assertion, Hoare (sem_wp c1 Q) c1 Q",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c6_goal : forall Q : assertion,\nHoare (sem_wp (IFTHENELSE b c1 c2) Q) (IFTHENELSE b c1 c2) Q",
                    "c6_IHc2 : forall Q : assertion, Hoare (sem_wp c2 Q) c2 Q",
                    "c6_IHc1 : forall Q : assertion, Hoare (sem_wp c1 Q) c1 Q",
                    "c6_c2 : com",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c7_goal : forall Q : assertion, Hoare (sem_wp (WHILE b c) Q) (WHILE b c) Q",
                    "c7_IHc : forall Q : assertion, Hoare (sem_wp c Q) c Q",
                    "c7_b : bexp",
                    "c8_goal : forall Q : assertion, Hoare (sem_wp (ASSERT b) Q) (ASSERT b) Q",
                    "c8_b : bexp",
                    "c9_goal : forall Q : assertion, Hoare (sem_wp (HAVOC x) Q) (HAVOC x) Q",
                    "c9_x : ident"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c3_goal : forall Q : assertion, Hoare (sem_wp SKIP Q) SKIP Q"
                ],
                "tactic_res": [
                    "c10_goal : Hoare (sem_wp SKIP Q) SKIP Q",
                    "c10_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c4_goal : forall Q : assertion, Hoare (sem_wp (ASSIGN x a) Q) (ASSIGN x a) Q"
                ],
                "tactic_res": [
                    "c11_goal : Hoare (sem_wp (ASSIGN x a) Q) (ASSIGN x a) Q",
                    "c11_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c5_goal : forall Q : assertion, Hoare (sem_wp (SEQ c1 c2) Q) (SEQ c1 c2) Q"
                ],
                "tactic_res": [
                    "c12_goal : Hoare (sem_wp (SEQ c1 c2) Q) (SEQ c1 c2) Q",
                    "c12_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c6_goal : forall Q : assertion,\nHoare (sem_wp (IFTHENELSE b c1 c2) Q) (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c13_goal : Hoare (sem_wp (IFTHENELSE b c1 c2) Q) (IFTHENELSE b c1 c2) Q",
                    "c13_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c7_goal : forall Q : assertion, Hoare (sem_wp (WHILE b c) Q) (WHILE b c) Q"
                ],
                "tactic_res": [
                    "c14_goal : Hoare (sem_wp (WHILE b c) Q) (WHILE b c) Q",
                    "c14_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c8_goal : forall Q : assertion, Hoare (sem_wp (ASSERT b) Q) (ASSERT b) Q"
                ],
                "tactic_res": [
                    "c15_goal : Hoare (sem_wp (ASSERT b) Q) (ASSERT b) Q",
                    "c15_Q : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Q .",
                "tactic_args": [
                    "c9_goal : forall Q : assertion, Hoare (sem_wp (HAVOC x) Q) (HAVOC x) Q"
                ],
                "tactic_res": [
                    "c16_goal : Hoare (sem_wp (HAVOC x) Q) (HAVOC x) Q",
                    "c16_Q : assertion"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : Hoare (sem_wp SKIP Q) SKIP Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c17_goal : Hoare ?P SKIP Q",
                    "c18_goal : aimp (sem_wp SKIP Q) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Hoare ?P SKIP Q",
                    "_global_Hoare_skip : forall P : assertion, Hoare P SKIP P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s W .",
                "tactic_args": [
                    "c18_goal : aimp (sem_wp SKIP Q) Q"
                ],
                "tactic_res": [
                    "c19_goal : Q s",
                    "c19_s : store",
                    "c19_W : sem_wp SKIP Q s"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c19_goal : Q s",
                    "_global_safe_terminated_inv : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : terminated c), Q s"
                ],
                "tactic_res": [
                    "c20_goal : safe Q ?c s",
                    "c21_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c20_goal : safe Q ?c s",
                    "c19_W : sem_wp SKIP Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c21_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c22_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c11_goal : Hoare (sem_wp (ASSIGN x a) Q) (ASSIGN x a) Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c23_goal : Hoare ?P (ASSIGN x a) Q",
                    "c24_goal : aimp (sem_wp (ASSIGN x a) Q) (aupdate x a Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : Hoare ?P (ASSIGN x a) Q",
                    "_global_Hoare_assign : forall (P : assertion) (x : ident) (a : aexp),\n       Hoare (aupdate x a P) (ASSIGN x a) P"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s W .",
                "tactic_args": [
                    "c24_goal : aimp (sem_wp (ASSIGN x a) Q) (aupdate x a Q)"
                ],
                "tactic_res": [
                    "c25_goal : aupdate x a Q s",
                    "c25_s : store",
                    "c25_W : sem_wp (ASSIGN x a) Q s"
                ]
            },
            {
                "tactic_sig": "assert ( W' : safe _i SKIP ( update _i ( aeval _i _i ) _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( W' : safe _i SKIP ( update _i ( aeval _i _i ) _i ) ) .",
                "tactic_args": [
                    "c25_goal : aupdate x a Q s",
                    "c11_Q : assertion",
                    "c4_x : ident",
                    "c4_a : aexp",
                    "c25_s : store",
                    "c25_s : store"
                ],
                "tactic_res": [
                    "c26_goal : safe Q SKIP (update x (aeval a s) s)",
                    "c27_goal : aupdate x a Q s",
                    "c27_W' : safe Q SKIP (update x (aeval a s) s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c26_goal : safe Q SKIP (update x (aeval a s) s)",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c28_goal : safe Q ?c ?s",
                    "c29_goal : red (pair (ASSIGN x a) s) (pair SKIP (update x (aeval a s) s))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c28_goal : safe Q ?c ?s",
                    "c25_W : sem_wp (ASSIGN x a) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : red (pair (ASSIGN x a) s) (pair SKIP (update x (aeval a s) s))",
                    "_global_red_assign : forall (x : ident) (a : aexp) (s : store),\n       red (pair (ASSIGN x a) s) (pair SKIP (update x (aeval a s) s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c27_goal : aupdate x a Q s",
                    "_global_safe_terminated_inv : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : terminated c), Q s",
                    "c27_W' : safe Q SKIP (update x (aeval a s) s)"
                ],
                "tactic_res": [
                    "c30_goal : aupdate x a Q s",
                    "c30_W' : Q (update x (aeval a s) s)",
                    "c31_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c30_goal : aupdate x a Q s",
                    "c30_W' : Q (update x (aeval a s) s)",
                    "c25_s : store",
                    "c11_Q : assertion",
                    "c4_a : aexp",
                    "c4_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c31_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c32_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c12_goal : Hoare (sem_wp (SEQ c1 c2) Q) (SEQ c1 c2) Q",
                    "_global_Hoare_seq : forall (P Q R : assertion) (c1 c2 : com) (_ : Hoare P c1 Q)\n         (_ : Hoare Q c2 R), Hoare P (SEQ c1 c2) R",
                    "_global_sem_wp : forall (_ : com) (_ : assertion), assertion",
                    "c5_c2 : com",
                    "c12_Q : assertion"
                ],
                "tactic_res": [
                    "c33_goal : Hoare (sem_wp (SEQ c1 c2) Q) c1 (sem_wp c2 Q)",
                    "c34_goal : Hoare (sem_wp c2 Q) c2 Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Hoare (sem_wp c2 Q) c2 Q",
                    "c12_Q : assertion",
                    "c5_IHc2 : forall Q : assertion, Hoare (sem_wp c2 Q) c2 Q",
                    "c5_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c33_goal : Hoare (sem_wp (SEQ c1 c2) Q) c1 (sem_wp c2 Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c35_goal : Hoare ?P c1 (sem_wp c2 Q)",
                    "c36_goal : aimp (sem_wp (SEQ c1 c2) Q) (sem_wp c1 (sem_wp c2 Q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c35_goal : Hoare ?P c1 (sem_wp c2 Q)",
                    "c5_IHc1 : forall Q : assertion, Hoare (sem_wp c1 Q) c1 Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c36_goal : aimp (sem_wp (SEQ c1 c2) Q) (sem_wp c1 (sem_wp c2 Q))"
                ],
                "tactic_res": [
                    "c37_goal : forall _ : sem_wp (SEQ c1 c2) Q s, sem_wp c1 (sem_wp c2 Q) s",
                    "c37_s : store"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : forall _ : sem_wp (SEQ c1 c2) Q s, sem_wp c1 (sem_wp c2 Q) s",
                    "_global_sem_wp_seq : forall (c1 c2 : com) (Q : assertion) (s : store)\n         (_ : sem_wp (SEQ c1 c2) Q s), sem_wp c1 (sem_wp c2 Q) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Hoare (sem_wp (IFTHENELSE b c1 c2) Q) (IFTHENELSE b c1 c2) Q",
                    "_global_Hoare_ifthenelse : forall (P Q : assertion) (b : bexp) (c1 c2 : com)\n         (_ : Hoare (aand (atrue b) P) c1 Q)\n         (_ : Hoare (aand (afalse b) P) c2 Q), Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c38_goal : Hoare (aand (atrue b) (sem_wp (IFTHENELSE b c1 c2) Q)) c1 Q",
                    "c39_goal : Hoare (aand (afalse b) (sem_wp (IFTHENELSE b c1 c2) Q)) c2 Q"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c38_goal : Hoare (aand (atrue b) (sem_wp (IFTHENELSE b c1 c2) Q)) c1 Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c40_goal : Hoare ?P c1 Q",
                    "c41_goal : aimp (aand (atrue b) (sem_wp (IFTHENELSE b c1 c2) Q)) (sem_wp c1 Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : Hoare ?P c1 Q",
                    "c6_IHc1 : forall Q : assertion, Hoare (sem_wp c1 Q) c1 Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ P1 P2 ] .",
                "tactic_args": [
                    "c41_goal : aimp (aand (atrue b) (sem_wp (IFTHENELSE b c1 c2) Q)) (sem_wp c1 Q)"
                ],
                "tactic_res": [
                    "c42_goal : sem_wp c1 Q s",
                    "c42_s : store",
                    "c42_P1 : atrue b s",
                    "c42_P2 : sem_wp (IFTHENELSE b c1 c2) Q s"
                ]
            },
            {
                "tactic_sig": "replace _i with ( if beval _i _i then _i else _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( if beval _i _i then _i else _i ) .",
                "tactic_args": [
                    "c42_goal : sem_wp c1 Q s",
                    "c6_c1 : com",
                    "c6_b : bexp",
                    "c42_s : store",
                    "c6_c1 : com",
                    "c6_c2 : com"
                ],
                "tactic_res": [
                    "c43_goal : sem_wp (if beval b s then c1 else c2) Q s",
                    "c44_goal : eq (if beval b s then c1 else c2) c1"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c43_goal : sem_wp (if beval b s then c1 else c2) Q s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c45_goal : safe Q ?c ?s",
                    "c46_goal : red (pair (IFTHENELSE b c1 c2) s)\n  (pair (if beval b s then c1 else c2) s)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c45_goal : safe Q ?c ?s",
                    "c42_P2 : sem_wp (IFTHENELSE b c1 c2) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c46_goal : red (pair (IFTHENELSE b c1 c2) s)\n  (pair (if beval b s then c1 else c2) s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c44_goal : eq (if beval b s then c1 else c2) c1",
                    "c42_P1 : atrue b s"
                ],
                "tactic_res": [
                    "c47_goal : eq c1 c1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : eq c1 c1",
                    "c6_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c39_goal : Hoare (aand (afalse b) (sem_wp (IFTHENELSE b c1 c2) Q)) c2 Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c48_goal : Hoare ?P c2 Q",
                    "c49_goal : aimp (aand (afalse b) (sem_wp (IFTHENELSE b c1 c2) Q)) (sem_wp c2 Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c48_goal : Hoare ?P c2 Q",
                    "c6_IHc2 : forall Q : assertion, Hoare (sem_wp c2 Q) c2 Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ P1 P2 ] .",
                "tactic_args": [
                    "c49_goal : aimp (aand (afalse b) (sem_wp (IFTHENELSE b c1 c2) Q)) (sem_wp c2 Q)"
                ],
                "tactic_res": [
                    "c50_goal : sem_wp c2 Q s",
                    "c50_s : store",
                    "c50_P1 : afalse b s",
                    "c50_P2 : sem_wp (IFTHENELSE b c1 c2) Q s"
                ]
            },
            {
                "tactic_sig": "replace _i with ( if beval _i _i then _i else _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( if beval _i _i then _i else _i ) .",
                "tactic_args": [
                    "c50_goal : sem_wp c2 Q s",
                    "c6_c2 : com",
                    "c6_b : bexp",
                    "c50_s : store",
                    "c6_c1 : com",
                    "c6_c2 : com"
                ],
                "tactic_res": [
                    "c51_goal : sem_wp (if beval b s then c1 else c2) Q s",
                    "c52_goal : eq (if beval b s then c1 else c2) c2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c51_goal : sem_wp (if beval b s then c1 else c2) Q s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c53_goal : safe Q ?c ?s",
                    "c54_goal : red (pair (IFTHENELSE b c1 c2) s)\n  (pair (if beval b s then c1 else c2) s)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c53_goal : safe Q ?c ?s",
                    "c50_P2 : sem_wp (IFTHENELSE b c1 c2) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c54_goal : red (pair (IFTHENELSE b c1 c2) s)\n  (pair (if beval b s then c1 else c2) s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c52_goal : eq (if beval b s then c1 else c2) c2",
                    "c50_P1 : afalse b s"
                ],
                "tactic_res": [
                    "c55_goal : eq c2 c2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : eq c2 c2",
                    "c6_c2 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c14_goal : Hoare (sem_wp (WHILE b c) Q) (WHILE b c) Q",
                    "_global_Hoare_consequence_post : forall (P Q Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp Q Q'), Hoare P c Q'"
                ],
                "tactic_res": [
                    "c56_goal : Hoare (sem_wp (WHILE b c) Q) (WHILE b c) ?Q",
                    "c57_goal : aimp (aand (afalse b) (sem_wp (WHILE b c) Q)) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c56_goal : Hoare (sem_wp (WHILE b c) Q) (WHILE b c) ?Q",
                    "_global_Hoare_while : forall (P : assertion) (b : bexp) (c : com)\n         (_ : Hoare (aand (atrue b) P) c P),\n       Hoare P (WHILE b c) (aand (afalse b) P)"
                ],
                "tactic_res": [
                    "c58_goal : Hoare (aand (atrue b) (sem_wp (WHILE b c) Q)) c (sem_wp (WHILE b c) Q)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c58_goal : Hoare (aand (atrue b) (sem_wp (WHILE b c) Q)) c (sem_wp (WHILE b c) Q)",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c59_goal : Hoare ?P c (sem_wp (WHILE b c) Q)",
                    "c60_goal : aimp (aand (atrue b) (sem_wp (WHILE b c) Q)) ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c59_goal : Hoare ?P c (sem_wp (WHILE b c) Q)",
                    "c7_IHc : forall Q : assertion, Hoare (sem_wp c Q) c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ P1 P2 ] .",
                "tactic_args": [
                    "c60_goal : aimp (aand (atrue b) (sem_wp (WHILE b c) Q))\n  (sem_wp c (sem_wp (WHILE b c) Q))"
                ],
                "tactic_res": [
                    "c61_goal : sem_wp c (sem_wp (WHILE b c) Q) s",
                    "c61_s : store",
                    "c61_P1 : atrue b s",
                    "c61_P2 : sem_wp (WHILE b c) Q s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c61_goal : sem_wp c (sem_wp (WHILE b c) Q) s",
                    "_global_sem_wp_seq : forall (c1 c2 : com) (Q : assertion) (s : store)\n         (_ : sem_wp (SEQ c1 c2) Q s), sem_wp c1 (sem_wp c2 Q) s"
                ],
                "tactic_res": [
                    "c62_goal : sem_wp (SEQ c (WHILE b c)) Q s"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c62_goal : sem_wp (SEQ c (WHILE b c)) Q s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c63_goal : safe Q ?c ?s",
                    "c64_goal : red (pair (WHILE b c) s) (pair (SEQ c (WHILE b c)) s)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c63_goal : safe Q ?c ?s",
                    "c61_P2 : sem_wp (WHILE b c) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c64_goal : red (pair (WHILE b c) s) (pair (SEQ c (WHILE b c)) s)"
                ],
                "tactic_res": [
                    "c65_goal : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c65_goal : eq (beval b s) true",
                    "c61_P1 : atrue b s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros s [ P1 P2 ] .",
                "tactic_args": [
                    "c57_goal : aimp (aand (afalse b) (sem_wp (WHILE b c) Q)) Q"
                ],
                "tactic_res": [
                    "c66_goal : Q s",
                    "c66_s : store",
                    "c66_P1 : afalse b s",
                    "c66_P2 : sem_wp (WHILE b c) Q s"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c66_goal : Q s",
                    "_global_safe_terminated_inv : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : terminated c), Q s"
                ],
                "tactic_res": [
                    "c67_goal : safe Q ?c s",
                    "c68_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c67_goal : safe Q ?c s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c69_goal : safe Q ?c0 ?s",
                    "c70_goal : red (pair (WHILE b c) s) (pair ?c s)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c69_goal : safe Q ?c0 ?s",
                    "c66_P2 : sem_wp (WHILE b c) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c70_goal : red (pair (WHILE b c) s) (pair ?c s)",
                    "_global_red_while_done : forall (b : bexp) (c : com) (s : store) (_ : eq (beval b s) false),\n       red (pair (WHILE b c) s) (pair SKIP s)"
                ],
                "tactic_res": [
                    "c71_goal : eq (beval b s) false"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c71_goal : eq (beval b s) false",
                    "c66_P1 : afalse b s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c68_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c72_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c72_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c15_goal : Hoare (sem_wp (ASSERT b) Q) (ASSERT b) Q",
                    "_global_Hoare_consequence : forall (P Q P' Q' : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P) (_ : aimp Q Q'), Hoare P' c Q'"
                ],
                "tactic_res": [
                    "c73_goal : Hoare ?P (ASSERT b) ?Q",
                    "c74_goal : aimp (sem_wp (ASSERT b) Q) (aand (atrue b) ?P)",
                    "c75_goal : aimp (aand (atrue b) Q) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c73_goal : Hoare ?P (ASSERT b) ?Q",
                    "_global_Hoare_assert : forall (P : assertion) (b : bexp),\n       Hoare (aand (atrue b) P) (ASSERT b) (aand (atrue b) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros s SAFE .",
                "tactic_args": [
                    "c74_goal : aimp (sem_wp (ASSERT b) Q) (aand (atrue b) ?P)"
                ],
                "tactic_res": [
                    "c76_goal : aand (atrue b) ?P s",
                    "c76_s : store",
                    "c76_SAFE : sem_wp (ASSERT b) Q s"
                ]
            },
            {
                "tactic_sig": "assert ( NOTSTUCK : ~ ( error ( ASSERT _i ) _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( NOTSTUCK : ~ ( error ( ASSERT _i ) _i ) ) .",
                "tactic_args": [
                    "c76_goal : aand (atrue b) ?P s",
                    "c8_b : bexp",
                    "c76_s : store"
                ],
                "tactic_res": [
                    "c77_goal : not (error (ASSERT b) s)",
                    "c78_goal : aand (atrue b) ?P s",
                    "c78_NOTSTUCK : not (error (ASSERT b) s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c77_goal : not (error (ASSERT b) s)",
                    "_global_safe_not_stuck : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : not (terminated c)), \n       not (error c s)"
                ],
                "tactic_res": [
                    "c79_goal : safe ?Q (ASSERT b) s",
                    "c80_goal : not (terminated (ASSERT b))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c79_goal : safe ?Q (ASSERT b) s",
                    "c76_SAFE : sem_wp (ASSERT b) Q s",
                    "c76_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c80_goal : not (terminated (ASSERT b))",
                    "_global_terminated : forall _ : com, Prop"
                ],
                "tactic_res": [
                    "c81_goal : not (eq (ASSERT b) SKIP)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c81_goal : not (eq (ASSERT b) SKIP)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( B : beval _i _i = true ) .",
                "tactic_sig_no_out_arg": "assert ( B : beval _i _i = true ) .",
                "tactic_args": [
                    "c78_goal : aand (atrue b) ?P s",
                    "c8_b : bexp",
                    "c76_s : store"
                ],
                "tactic_res": [
                    "c82_goal : eq (beval b s) true",
                    "c83_goal : aand (atrue b) ?P s",
                    "c83_B : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c82_NOTSTUCK : not (error (ASSERT b) s)"
                ],
                "tactic_res": [
                    "c82_NOTSTUCK : not (eq (beval b s) false)"
                ]
            },
            {
                "tactic_sig": "destruct ( beval _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( beval _i _i ) .",
                "tactic_args": [
                    "c82_goal : eq (beval b s) true",
                    "c8_b : bexp",
                    "c76_s : store",
                    "c82_NOTSTUCK : not (eq (beval b s) false)",
                    "c76_SAFE : sem_wp (ASSERT b) Q s"
                ],
                "tactic_res": [
                    "c84_goal : eq true true",
                    "c84_NOTSTUCK : not (eq true false)",
                    "c85_goal : eq false true",
                    "c85_NOTSTUCK : not (eq false false)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c84_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c85_goal : eq false true",
                    "c85_NOTSTUCK : not (eq false false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( FINAL : _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( FINAL : _i _i ) .",
                "tactic_args": [
                    "c83_goal : aand (atrue b) ?P s",
                    "c15_Q : assertion",
                    "c76_s : store"
                ],
                "tactic_res": [
                    "c86_goal : Q s",
                    "c87_goal : aand (atrue b) ?P s",
                    "c87_FINAL : Q s"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c86_goal : Q s",
                    "_global_safe_terminated_inv : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : terminated c), Q s"
                ],
                "tactic_res": [
                    "c88_goal : safe Q ?c s",
                    "c89_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c88_goal : safe Q ?c s",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c90_goal : safe Q ?c0 ?s",
                    "c91_goal : red (pair (ASSERT b) s) (pair ?c s)"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c90_goal : safe Q ?c0 ?s",
                    "c76_SAFE : sem_wp (ASSERT b) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c91_goal : red (pair (ASSERT b) s) (pair ?c s)"
                ],
                "tactic_res": [
                    "c92_goal : eq (beval b s) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c92_goal : eq (beval b s) true",
                    "c83_B : eq (beval b s) true",
                    "c76_s : store",
                    "c8_b : bexp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c89_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c93_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c93_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c87_goal : aand (atrue b) ?P s"
                ],
                "tactic_res": [
                    "c94_goal : atrue b s",
                    "c95_goal : ?P s"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c94_goal : atrue b s",
                    "c83_B : eq (beval b s) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c95_goal : ?P s",
                    "c87_FINAL : Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c75_goal : aimp (aand (atrue b) Q) Q"
                ],
                "tactic_res": [
                    "c96_goal : forall _ : aand (atrue b) Q s, Q s",
                    "c96_s : store"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c96_goal : forall _ : aand (atrue b) Q s, Q s",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c97_goal : forall _ : and (atrue b s) (Q s), Q s"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c97_goal : forall _ : and (atrue b s) (Q s), Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c16_goal : Hoare (sem_wp (HAVOC x) Q) (HAVOC x) Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q"
                ],
                "tactic_res": [
                    "c98_goal : Hoare ?P (HAVOC x) Q",
                    "c99_goal : aimp (sem_wp (HAVOC x) Q) ?P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c98_goal : Hoare ?P (HAVOC x) Q",
                    "_global_Hoare_havoc : forall (x : ident) (Q : assertion),\n       Hoare (aforall (fun n : Z => aupdate x (CONST n) Q)) (HAVOC x) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s W n .",
                "tactic_args": [
                    "c99_goal : aimp (sem_wp (HAVOC x) Q)\n  (aforall (fun n : Z => aupdate x (CONST n) Q))"
                ],
                "tactic_res": [
                    "c100_goal : aupdate x (CONST n) Q s",
                    "c100_s : store",
                    "c100_W : sem_wp (HAVOC x) Q s",
                    "c100_n : Z"
                ]
            },
            {
                "tactic_sig": "assert ( W' : safe _i SKIP ( update _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( W' : safe _i SKIP ( update _i _i _i ) ) .",
                "tactic_args": [
                    "c100_goal : aupdate x (CONST n) Q s",
                    "c16_Q : assertion",
                    "c9_x : ident",
                    "c100_n : Z",
                    "c100_s : store"
                ],
                "tactic_res": [
                    "c101_goal : safe Q SKIP (update x n s)",
                    "c102_goal : aupdate x (CONST n) Q s",
                    "c102_W' : safe Q SKIP (update x n s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c101_goal : safe Q SKIP (update x n s)",
                    "_global_safe_step_inv : forall (Q : assertion) (c : com) (s : store) \n         (c' : com) (s' : store) (_ : safe Q c s)\n         (_ : red (pair c s) (pair c' s')), safe Q c' s'"
                ],
                "tactic_res": [
                    "c103_goal : safe Q ?c ?s",
                    "c104_goal : red (pair (HAVOC x) s) (pair SKIP (update x n s))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c103_goal : safe Q ?c ?s",
                    "c100_W : sem_wp (HAVOC x) Q s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c104_goal : red (pair (HAVOC x) s) (pair SKIP (update x n s))",
                    "_global_red_havoc : forall (x : ident) (s : store) (n : Z),\n       red (pair (HAVOC x) s) (pair SKIP (update x n s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c102_goal : aupdate x (CONST n) Q s",
                    "_global_safe_terminated_inv : forall (Q : assertion) (c : com) (s : store) \n         (_ : safe Q c s) (_ : terminated c), Q s",
                    "c102_W' : safe Q SKIP (update x n s)"
                ],
                "tactic_res": [
                    "c105_goal : aupdate x (CONST n) Q s",
                    "c105_W' : Q (update x n s)",
                    "c106_goal : terminated SKIP"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c105_goal : aupdate x (CONST n) Q s",
                    "c105_W' : Q (update x n s)",
                    "c100_n : Z",
                    "c100_s : store",
                    "c16_Q : assertion",
                    "c9_x : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c106_goal : terminated SKIP"
                ],
                "tactic_res": [
                    "c107_goal : eq SKIP SKIP"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c107_goal : eq SKIP SKIP"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_complete",
        "proof": [
            {
                "tactic_sig": "Theorem Hoare_complete : forall P c Q , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Theorem Hoare_complete : forall P c Q , \u2983\u2983 P \u2984\u2984 c \u2983\u2983 Q \u2984\u2984 -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : triple P c Q),\nHoare P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (c : com) (Q : assertion) (_ : triple P c Q),\nHoare P c Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P c Q",
                    "c2_P : assertion",
                    "c2_c : com",
                    "c2_Q : assertion",
                    "c2_H : triple P c Q"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : Hoare P c Q",
                    "_global_Hoare_consequence_pre : forall (P P' Q : assertion) (c : com) (_ : Hoare P c Q)\n         (_ : aimp P' P), Hoare P' c Q",
                    "_global_sem_wp : forall (_ : com) (_ : assertion), assertion",
                    "c2_c : com",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (sem_wp c Q) c Q",
                    "c4_goal : aimp P (sem_wp c Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Hoare (sem_wp c Q) c Q",
                    "_global_Hoare_sem_wp : forall (c : com) (Q : assertion), Hoare (sem_wp c Q) c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c4_goal : aimp P (sem_wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : P s, sem_wp c Q s",
                    "c5_s : store"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : forall _ : P s, sem_wp c Q s",
                    "c2_H : triple P c Q"
                ],
                "tactic_res": []
            }
        ]
    }
]