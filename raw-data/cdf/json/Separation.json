[
    {
        "lemma_name": "heap_extensionality",
        "proof": [
            {
                "tactic_sig": "Lemma heap_extensionality : forall ( h1 h2 : heap ) , ( forall l , h1 l = h2 l ) -> h1 = h2 .",
                "tactic_sig_no_out_arg": "Lemma heap_extensionality : forall ( h1 h2 : heap ) , ( forall l , h1 l = h2 l ) -> h1 = h2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)), eq h1 h2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)), eq h1 h2"
                ],
                "tactic_res": [
                    "c2_goal : eq h1 h2",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H : forall l : addr, eq (h1 l) (h2 l)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ c1 fin1 ] , _i as [ c2 fin2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ c1 fin1 ] , _i as [ c2 fin2 ] .",
                "tactic_args": [
                    "c2_goal : eq h1 h2",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H : forall l : addr, eq (h1 l) (h2 l)"
                ],
                "tactic_res": [
                    "c3_goal : eq {| contents := c1; isfinite := fin1 |}\n  {| contents := c2; isfinite := fin2 |}",
                    "c3_H : forall l : addr,\neq ({| contents := c1; isfinite := fin1 |} l)\n  ({| contents := c2; isfinite := fin2 |} l)",
                    "c3_fin2 : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq (c2 j) None)",
                    "c3_c2 : forall _ : addr, option Z",
                    "c3_fin1 : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq (c1 j) None)",
                    "c3_c1 : forall _ : addr, option Z"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) by ( apply functional_extensionality ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) by ( apply functional_extensionality ; auto ) .",
                "tactic_args": [
                    "c3_c1 : forall _ : addr, option Z",
                    "c3_c2 : forall _ : addr, option Z",
                    "c3_H : forall l : addr,\neq ({| contents := c1; isfinite := fin1 |} l)\n  ({| contents := c2; isfinite := fin2 |} l)",
                    "c3_fin2 : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq (c2 j) None)",
                    "c3_fin1 : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq (c1 j) None)"
                ],
                "tactic_res": [
                    "c3_H0 : eq c1 c2"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq {| contents := c1; isfinite := fin1 |}\n  {| contents := c2; isfinite := fin2 |}",
                    "c3_c2 : forall _ : addr, option Z",
                    "c3_H0 : eq c1 c2"
                ],
                "tactic_res": [
                    "c4_goal : eq {| contents := c1; isfinite := fin1 |}\n  {| contents := c1; isfinite := fin2 |}",
                    "c4_H : forall l : addr,\neq ({| contents := c1; isfinite := fin1 |} l)\n  ({| contents := c1; isfinite := fin2 |} l)",
                    "c4_fin2 : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq (c1 j) None)"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c4_goal : eq {| contents := c1; isfinite := fin1 |}\n  {| contents := c1; isfinite := fin2 |}"
                ],
                "tactic_res": [
                    "c5_goal : eq fin1 fin2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq fin1 fin2",
                    "_global_proof_irrelevance : forall (P : Prop) (p1 p2 : P), eq p1 p2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "Next Obligation .",
                "tactic_sig_no_out_arg": "Next Obligation .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq None None)"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c1_goal : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq None None)"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le 0 j), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le 0 j), eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hempty_dup",
        "proof": [
            {
                "tactic_sig": "Lemma hempty_dup A : exists i : Z , forall j : Z , i <= j -> @None A = None .",
                "tactic_sig_no_out_arg": "Lemma hempty_dup A : exists i : Z , forall j : Z , i <= j -> @None A = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq None None)",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c1_goal : ex (fun i : Z => forall (j : Z) (_ : Z.le i j), eq None None)"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le 0 j), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le 0 j), eq None None",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "Next Obligation .",
                "tactic_sig_no_out_arg": "Next Obligation .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then Some v else h j) None)",
                    "c1_h : heap",
                    "c1_v : Z",
                    "c1_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_args": [
                    "c1_h : heap",
                    "c1_v : Z",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_i : Z"
                ]
            },
            {
                "tactic_sig": "exists ( Z.max _i ( _i + 1 ) ) .",
                "tactic_sig_no_out_arg": "exists ( Z.max _i ( _i + 1 ) ) .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then Some v else h j) None)",
                    "c1_i : Z",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i (Z.add l 1)) j),\neq (if Z.eq_dec l j then Some v else h j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i (Z.add l 1)) j),\neq (if Z.eq_dec l j then Some v else h j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l j then Some v else h j) None",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i (Z.add l 1)) j"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l j then Some v else h j) None",
                    "c1_l : addr",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i (Z.add l 1)) j",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap",
                    "c1_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq (Some v) None",
                    "c4_e : eq l j",
                    "c5_goal : eq (h j) None",
                    "c5_n : not (eq l j)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c4_goal : eq (Some v) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (h j) None",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None"
                ],
                "tactic_res": [
                    "c6_goal : Z.le i j"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c6_goal : Z.le i j"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hupdate_dup",
        "proof": [
            {
                "tactic_sig": "Lemma hupdate_dup ( l : addr ) ( v : Z ) ( h : heap ) : exists i : Z , forall j : Z , i <= j -> ( if Z.eq_dec l j then Some v else h j ) = None .",
                "tactic_sig_no_out_arg": "Lemma hupdate_dup ( l : addr ) ( v : Z ) ( h : heap ) : exists i : Z , forall j : Z , i <= j -> ( if Z.eq_dec l j then Some v else h j ) = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then Some v else h j) None)",
                    "c1_h : heap",
                    "c1_v : Z",
                    "c1_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_args": [
                    "c1_h : heap",
                    "c1_v : Z",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_i : Z"
                ]
            },
            {
                "tactic_sig": "exists ( Z.max _i ( _i + 1 ) ) .",
                "tactic_sig_no_out_arg": "exists ( Z.max _i ( _i + 1 ) ) .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then Some v else h j) None)",
                    "c1_i : Z",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i (Z.add l 1)) j),\neq (if Z.eq_dec l j then Some v else h j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i (Z.add l 1)) j),\neq (if Z.eq_dec l j then Some v else h j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l j then Some v else h j) None",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i (Z.add l 1)) j"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l j then Some v else h j) None",
                    "c1_l : addr",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i (Z.add l 1)) j",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap",
                    "c1_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq (Some v) None",
                    "c4_e : eq l j",
                    "c5_goal : eq (h j) None",
                    "c5_n : not (eq l j)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c4_goal : eq (Some v) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (h j) None",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None"
                ],
                "tactic_res": [
                    "c6_goal : Z.le i j"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c6_goal : Z.le i j"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hupdate_same",
        "proof": [
            {
                "tactic_sig": "Lemma hupdate_same : forall l v h , ( hupdate l v h ) l = Some v .",
                "tactic_sig_no_out_arg": "Lemma hupdate_same : forall l v h , ( hupdate l v h ) l = Some v .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l v h .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": [
                    "c2_goal : eq (hupdate l v h l) (Some v)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_h : heap"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c2_goal : eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l l then Some v else h l) (Some v)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l l then Some v else h l) (Some v)",
                    "c2_l : addr",
                    "c2_l : addr",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq (Some v) (Some v)",
                    "c4_e : eq l l",
                    "c5_goal : eq (h l) (Some v)",
                    "c5_n : not (eq l l)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : eq (Some v) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c5_goal : eq (h l) (Some v)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hupdate_other",
        "proof": [
            {
                "tactic_sig": "Lemma hupdate_other : forall l v h l' , l <> l' -> ( hupdate l v h ) l' = h l' .",
                "tactic_sig_no_out_arg": "Lemma hupdate_other : forall l v h l' , l <> l' -> ( hupdate l v h ) l' = h l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z) (h : heap) (l' : addr) (_ : not (eq l l')),\neq (hupdate l v h l') (h l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l v h l' H .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z) (h : heap) (l' : addr) (_ : not (eq l l')),\neq (hupdate l v h l') (h l')"
                ],
                "tactic_res": [
                    "c2_goal : eq (hupdate l v h l') (h l')",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_l' : addr",
                    "c2_H : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c2_goal : eq (hupdate l v h l') (h l')"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l l' then Some v else h l') (h l')"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l l' then Some v else h l') (h l')",
                    "c2_l : addr",
                    "c2_l' : addr",
                    "c2_H : not (eq l l')",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq (Some v) (h l')",
                    "c4_e : eq l l'",
                    "c5_goal : eq (h l') (h l')",
                    "c5_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : eq (Some v) (h l')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c5_goal : eq (h l') (h l')"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "Next Obligation .",
                "tactic_sig_no_out_arg": "Next Obligation .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then None else h j) None)",
                    "c1_h : heap",
                    "c1_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_args": [
                    "c1_h : heap",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_i : Z"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then None else h j) None)",
                    "c1_i : Z"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le i j),\neq (if Z.eq_dec l j then None else h j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le i j),\neq (if Z.eq_dec l j then None else h j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l j then None else h j) None",
                    "c3_j : Z",
                    "c3_H : Z.le i j"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l j then None else h j) None",
                    "c1_l : addr",
                    "c3_j : Z",
                    "c3_H : Z.le i j",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap"
                ],
                "tactic_res": [
                    "c4_goal : eq None None",
                    "c4_e : eq l j",
                    "c5_goal : eq (h j) None",
                    "c5_n : not (eq l j)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (h j) None",
                    "c3_H : Z.le i j",
                    "c3_j : Z",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hfree_dup",
        "proof": [
            {
                "tactic_sig": "Lemma hfree_dup ( l : addr ) ( h : heap ) : exists i : Z , forall j : Z , i <= j -> ( if Z.eq_dec l j then None else h j ) = None .",
                "tactic_sig_no_out_arg": "Lemma hfree_dup ( l : addr ) ( h : heap ) : exists i : Z , forall j : Z , i <= j -> ( if Z.eq_dec l j then None else h j ) = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then None else h j) None)",
                    "c1_h : heap",
                    "c1_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i & fin ) .",
                "tactic_args": [
                    "c1_h : heap",
                    "c1_l : addr"
                ],
                "tactic_res": [
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_i : Z"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j),\n   eq (if Z.eq_dec l j then None else h j) None)",
                    "c1_i : Z"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le i j),\neq (if Z.eq_dec l j then None else h j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le i j),\neq (if Z.eq_dec l j then None else h j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if Z.eq_dec l j then None else h j) None",
                    "c3_j : Z",
                    "c3_H : Z.le i j"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (if Z.eq_dec l j then None else h j) None",
                    "c1_l : addr",
                    "c3_j : Z",
                    "c3_H : Z.le i j",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap"
                ],
                "tactic_res": [
                    "c4_goal : eq None None",
                    "c4_e : eq l j",
                    "c5_goal : eq (h j) None",
                    "c5_n : not (eq l j)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (h j) None",
                    "c3_H : Z.le i j",
                    "c3_j : Z",
                    "c1_fin : forall (j : Z) (_ : Z.le i j), eq (h j) None",
                    "c1_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hinit_inside",
        "proof": [
            {
                "tactic_sig": "Lemma hinit_inside : forall h sz l l' , l <= l' < l + Z.of_nat sz -> hinit l sz h l' = Some 0 .",
                "tactic_sig_no_out_arg": "Lemma hinit_inside : forall h sz l l' , l <= l' < l + Z.of_nat sz -> hinit l sz h l' = Some 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h : heap) (sz : nat) (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h sz .",
                "tactic_args": [
                    "c1_goal : forall (h : heap) (sz : nat) (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)"
                ],
                "tactic_res": [
                    "c2_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)",
                    "c2_h : heap",
                    "c2_sz : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat 0%nat)))),\neq (hinit l 0 h l') (Some 0)",
                    "c4_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat (S sz))))),\neq (hinit l (S sz) h l') (Some 0)",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat 0%nat)))),\neq (hinit l 0 h l') (Some 0)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hinit l 0 h l') (Some 0)",
                    "c5_l : Z",
                    "c5_l' : Z",
                    "c5_H : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat 0%nat)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat (S sz))))),\neq (hinit l (S sz) h l') (Some 0)"
                ],
                "tactic_res": [
                    "c6_goal : eq (hinit l (S sz) h l') (Some 0)",
                    "c6_l : Z",
                    "c6_l' : Z",
                    "c6_H : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat (S sz))))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c5_goal : eq (hinit l 0 h l') (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : eq (hinit l (S sz) h l') (Some 0)"
                ],
                "tactic_res": [
                    "c7_goal : eq (if Z.eq_dec l l' then Some 0 else hinit (Z.add l 1) sz h l')\n  (Some 0)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c7_goal : eq (if Z.eq_dec l l' then Some 0 else hinit (Z.add l 1) sz h l')\n  (Some 0)",
                    "c6_l : Z",
                    "c6_l' : Z",
                    "c6_H : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat (S sz))))",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)",
                    "c2_sz : nat",
                    "c2_h : heap"
                ],
                "tactic_res": [
                    "c8_goal : eq (Some 0) (Some 0)",
                    "c8_e : eq l l'",
                    "c9_goal : eq (hinit (Z.add l 1) sz h l') (Some 0)",
                    "c9_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : eq (hinit (Z.add l 1) sz h l') (Some 0)",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\neq (hinit l sz h l') (Some 0)"
                ],
                "tactic_res": [
                    "c10_goal : and (Z.le (Z.add l 1) l') (Z.lt l' (Z.add (Z.add l 1) (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c10_goal : and (Z.le (Z.add l 1) l') (Z.lt l' (Z.add (Z.add l 1) (Z.of_nat sz)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hinit_outside",
        "proof": [
            {
                "tactic_sig": "Lemma hinit_outside : forall h sz l l' , l' < l \\/ l + Z.of_nat sz <= l' -> hinit l sz h l' = h l' .",
                "tactic_sig_no_out_arg": "Lemma hinit_outside : forall h sz l l' , l' < l \\/ l + Z.of_nat sz <= l' -> hinit l sz h l' = h l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h : heap) (sz : nat) (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h sz .",
                "tactic_args": [
                    "c1_goal : forall (h : heap) (sz : nat) (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c2_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')",
                    "c2_h : heap",
                    "c2_sz : nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat 0%nat)) l')),\neq (hinit l 0 h l') (h l')",
                    "c4_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat (S sz))) l')),\neq (hinit l (S sz) h l') (h l')",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat 0%nat)) l')),\neq (hinit l 0 h l') (h l')"
                ],
                "tactic_res": [
                    "c5_goal : eq (hinit l 0 h l') (h l')",
                    "c5_l : Z",
                    "c5_l' : Z",
                    "c5_H : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat 0%nat)) l')"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : eq (hinit l 0 h l') (h l')"
                ],
                "tactic_res": [
                    "c6_goal : eq (h l') (h l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat (S sz))) l')),\neq (hinit l (S sz) h l') (h l')"
                ],
                "tactic_res": [
                    "c7_goal : eq (hinit l (S sz) h l') (h l')",
                    "c7_l : Z",
                    "c7_l' : Z",
                    "c7_H : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat (S sz))) l')"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : eq (hinit l (S sz) h l') (h l')"
                ],
                "tactic_res": [
                    "c8_goal : eq (if Z.eq_dec l l' then Some 0 else hinit (Z.add l 1) sz h l') (h l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (h l') (h l')",
                    "c5_l' : Z",
                    "c2_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c8_goal : eq (if Z.eq_dec l l' then Some 0 else hinit (Z.add l 1) sz h l') (h l')",
                    "c7_l : Z",
                    "c7_l' : Z",
                    "c7_H : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat (S sz))) l')",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')",
                    "c2_sz : nat",
                    "c2_h : heap"
                ],
                "tactic_res": [
                    "c9_goal : eq (Some 0) (h l')",
                    "c9_e : eq l l'",
                    "c10_goal : eq (hinit (Z.add l 1) sz h l') (h l')",
                    "c10_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c9_goal : eq (Some 0) (h l')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (hinit (Z.add l 1) sz h l') (h l')",
                    "c4_IHsz : forall (l l' : Z)\n  (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\neq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c11_goal : or (Z.lt l' (Z.add l 1)) (Z.le (Z.add (Z.add l 1) (Z.of_nat sz)) l')"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c11_goal : or (Z.lt l' (Z.add l 1)) (Z.le (Z.add (Z.add l 1) (Z.of_nat sz)) l')"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hdisjoint_sym",
        "proof": [
            {
                "tactic_sig": "Lemma hdisjoint_sym : forall h1 h2 , hdisjoint h1 h2 <- > hdisjoint h2 h1 .",
                "tactic_sig_no_out_arg": "Lemma hdisjoint_sym : forall h1 h2 , hdisjoint h1 h2 <- > hdisjoint h2 h1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)",
                    "_global_hdisjoint : forall (_ : heap) (_ : heap), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall h1 h2 : heap,\niff (forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 .",
                "tactic_args": [
                    "c2_goal : forall h1 h2 : heap,\niff (forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))"
                ],
                "tactic_res": [
                    "c3_goal : iff (forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : iff (forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))"
                ],
                "tactic_res": [
                    "c4_goal : forall (_ : forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (l : addr), or (eq (h2 l) None) (eq (h1 l) None)",
                    "c5_goal : forall (_ : forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))\n  (l : addr), or (eq (h1 l) None) (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H l .",
                "tactic_args": [
                    "c4_goal : forall (_ : forall l : addr, or (eq (h1 l) None) (eq (h2 l) None))\n  (l : addr), or (eq (h2 l) None) (eq (h1 l) None)"
                ],
                "tactic_res": [
                    "c6_goal : or (eq (h2 l) None) (eq (h1 l) None)",
                    "c6_H : forall l : addr, or (eq (h1 l) None) (eq (h2 l) None)",
                    "c6_l : addr"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c6_H : forall l : addr, or (eq (h1 l) None) (eq (h2 l) None)",
                    "c6_l : addr"
                ],
                "tactic_res": [
                    "c6_H : or (eq (h1 l) None) (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c6_goal : or (eq (h2 l) None) (eq (h1 l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H l .",
                "tactic_args": [
                    "c5_goal : forall (_ : forall l : addr, or (eq (h2 l) None) (eq (h1 l) None))\n  (l : addr), or (eq (h1 l) None) (eq (h2 l) None)"
                ],
                "tactic_res": [
                    "c7_goal : or (eq (h1 l) None) (eq (h2 l) None)",
                    "c7_H : forall l : addr, or (eq (h2 l) None) (eq (h1 l) None)",
                    "c7_l : addr"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c7_H : forall l : addr, or (eq (h2 l) None) (eq (h1 l) None)",
                    "c7_l : addr"
                ],
                "tactic_res": [
                    "c7_H : or (eq (h2 l) None) (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c7_goal : or (eq (h1 l) None) (eq (h2 l) None)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "Next Obligation .",
                "tactic_sig_no_out_arg": "Next Obligation .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j), eq (if h1 j then h1 j else h2 j) None)",
                    "c1_h2 : heap",
                    "c1_h1 : heap"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i1 & fin1 ) , ( isfinite _i ) as ( i2 & fin2 ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i1 & fin1 ) , ( isfinite _i ) as ( i2 & fin2 ) .",
                "tactic_args": [
                    "c1_h1 : heap",
                    "c1_h2 : heap"
                ],
                "tactic_res": [
                    "c1_fin2 : forall (j : Z) (_ : Z.le i2 j), eq (h2 j) None",
                    "c1_i2 : Z",
                    "c1_fin1 : forall (j : Z) (_ : Z.le i1 j), eq (h1 j) None",
                    "c1_i1 : Z"
                ]
            },
            {
                "tactic_sig": "exists ( Z.max _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Z.max _i _i ) .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j), eq (if h1 j then h1 j else h2 j) None)",
                    "c1_i1 : Z",
                    "c1_i2 : Z"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i1 i2) j),\neq (if h1 j then h1 j else h2 j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i1 i2) j),\neq (if h1 j then h1 j else h2 j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if h1 j then h1 j else h2 j) None",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i1 i2) j"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i , _i by lia .",
                "tactic_args": [
                    "c3_goal : eq (if h1 j then h1 j else h2 j) None",
                    "c1_fin1 : forall (j : Z) (_ : Z.le i1 j), eq (h1 j) None",
                    "c1_fin2 : forall (j : Z) (_ : Z.le i2 j), eq (h2 j) None"
                ],
                "tactic_res": [
                    "c4_goal : eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_dup",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_dup ( h1 h2 : heap ) : exists i : Z , forall j : Z , i <= j -> ( if h1 j then h1 j else h2 j ) = None .",
                "tactic_sig_no_out_arg": "Lemma hunion_dup ( h1 h2 : heap ) : exists i : Z , forall j : Z , i <= j -> ( if h1 j then h1 j else h2 j ) = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j), eq (if h1 j then h1 j else h2 j) None)",
                    "c1_h2 : heap",
                    "c1_h1 : heap"
                ]
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( i1 & fin1 ) , ( isfinite _i ) as ( i2 & fin2 ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( i1 & fin1 ) , ( isfinite _i ) as ( i2 & fin2 ) .",
                "tactic_args": [
                    "c1_h1 : heap",
                    "c1_h2 : heap"
                ],
                "tactic_res": [
                    "c1_fin2 : forall (j : Z) (_ : Z.le i2 j), eq (h2 j) None",
                    "c1_i2 : Z",
                    "c1_fin1 : forall (j : Z) (_ : Z.le i1 j), eq (h1 j) None",
                    "c1_i1 : Z"
                ]
            },
            {
                "tactic_sig": "exists ( Z.max _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Z.max _i _i ) .",
                "tactic_args": [
                    "c1_goal : ex\n  (fun i : Z =>\n   forall (j : Z) (_ : Z.le i j), eq (if h1 j then h1 j else h2 j) None)",
                    "c1_i1 : Z",
                    "c1_i2 : Z"
                ],
                "tactic_res": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i1 i2) j),\neq (if h1 j then h1 j else h2 j) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (j : Z) (_ : Z.le (Z.max i1 i2) j),\neq (if h1 j then h1 j else h2 j) None"
                ],
                "tactic_res": [
                    "c3_goal : eq (if h1 j then h1 j else h2 j) None",
                    "c3_j : Z",
                    "c3_H : Z.le (Z.max i1 i2) j"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i , _i by lia .",
                "tactic_args": [
                    "c3_goal : eq (if h1 j then h1 j else h2 j) None",
                    "c1_fin1 : forall (j : Z) (_ : Z.le i1 j), eq (h1 j) None",
                    "c1_fin2 : forall (j : Z) (_ : Z.le i2 j), eq (h2 j) None"
                ],
                "tactic_res": [
                    "c4_goal : eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_comm",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_comm : forall h1 h2 , hdisjoint h1 h2 -> hunion h2 h1 = hunion h1 h2 .",
                "tactic_sig_no_out_arg": "Lemma hunion_comm : forall h1 h2 , hdisjoint h1 h2 -> hunion h2 h1 = hunion h1 h2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\neq (hunion h2 h1) (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 H .",
                "tactic_args": [
                    "c1_goal : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\neq (hunion h2 h1) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c2_goal : eq (hunion h2 h1) (hunion h1 h2)",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr, eq (hunion h2 h1 l) (hunion h1 h2 l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr, eq (hunion h2 h1 l) (hunion h1 h2 l)"
                ],
                "tactic_res": [
                    "c4_goal : eq (hunion h2 h1 l) (hunion h1 h2 l)",
                    "c4_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c4_goal : eq (hunion h2 h1 l) (hunion h1 h2 l)"
                ],
                "tactic_res": [
                    "c5_goal : eq (if h2 l then h2 l else h1 l) (if h1 l then h1 l else h2 l)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c5_H : hdisjoint h1 h2",
                    "c4_l : addr"
                ],
                "tactic_res": [
                    "c5_H : or (eq (h1 l) None) (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] , ( _i _i ) as [ z'| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] , ( _i _i ) as [ z'| ] .",
                "tactic_args": [
                    "c5_goal : eq (if h2 l then h2 l else h1 l) (if h1 l then h1 l else h2 l)",
                    "c2_h1 : heap",
                    "c4_l : addr",
                    "c2_h2 : heap",
                    "c4_l : addr",
                    "c5_H : or (eq (h1 l) None) (eq (h2 l) None)"
                ],
                "tactic_res": [
                    "c6_goal : eq (Some z') (Some z)",
                    "c6_H : or (eq (Some z) None) (eq (Some z') None)",
                    "c6_z' : Z",
                    "c6_z : Z",
                    "c7_goal : eq (Some z) (Some z)",
                    "c7_H : or (eq (Some z) None) (eq None None)",
                    "c7_z : Z",
                    "c8_goal : eq (Some z') (Some z')",
                    "c8_H : or (eq None None) (eq (Some z') None)",
                    "c8_z' : Z",
                    "c9_goal : eq None None",
                    "c9_H : or (eq None None) (eq None None)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c6_goal : eq (Some z') (Some z)",
                    "c6_H : or (eq (Some z) None) (eq (Some z') None)",
                    "c6_z : Z",
                    "c6_z' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c7_goal : eq (Some z) (Some z)",
                    "c7_z : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c8_goal : eq (Some z') (Some z')",
                    "c8_z' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c9_goal : eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_assoc",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_assoc : forall h1 h2 h3 , hunion ( hunion h1 h2 ) h3 = hunion h1 ( hunion h2 h3 ) .",
                "tactic_sig_no_out_arg": "Lemma hunion_assoc : forall h1 h2 h3 , hunion ( hunion h1 h2 ) h3 = hunion h1 ( hunion h2 h3 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall h1 h2 h3 : heap,\neq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 h3 .",
                "tactic_args": [
                    "c1_goal : forall h1 h2 h3 : heap,\neq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c2_goal : eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h3 : heap"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr,\neq (hunion (hunion h1 h2) h3 l) (hunion h1 (hunion h2 h3) l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr,\neq (hunion (hunion h1 h2) h3 l) (hunion h1 (hunion h2 h3) l)"
                ],
                "tactic_res": [
                    "c4_goal : eq (hunion (hunion h1 h2) h3 l) (hunion h1 (hunion h2 h3) l)",
                    "c4_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c4_goal : eq (hunion (hunion h1 h2) h3 l) (hunion h1 (hunion h2 h3) l)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (if if h1 l then h1 l else h2 l\n   then if h1 l then h1 l else h2 l\n   else h3 l) (if h1 l then h1 l else if h2 l then h2 l else h3 l)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c5_goal : eq\n  (if if h1 l then h1 l else h2 l\n   then if h1 l then h1 l else h2 l\n   else h3 l) (if h1 l then h1 l else if h2 l then h2 l else h3 l)",
                    "c2_h1 : heap",
                    "c4_l : addr",
                    "c2_h2 : heap",
                    "c2_h3 : heap"
                ],
                "tactic_res": [
                    "c6_goal : eq (Some z) (Some z)",
                    "c6_z : Z",
                    "c7_goal : eq (if h2 l then h2 l else h3 l) (if h2 l then h2 l else h3 l)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (Some z) (Some z)",
                    "c6_z : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (if h2 l then h2 l else h3 l) (if h2 l then h2 l else h3 l)",
                    "c4_l : addr",
                    "c2_h2 : heap",
                    "c2_h3 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_empty",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_empty : forall h , hunion hempty h = h .",
                "tactic_sig_no_out_arg": "Lemma hunion_empty : forall h , hunion hempty h = h .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall h : heap, eq (hunion hempty h) h"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c1_goal : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c2_goal : eq (hunion hempty h) h",
                    "c2_h : heap"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (hunion hempty h) h",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr, eq (hunion hempty h l) (h l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr, eq (hunion hempty h l) (h l)"
                ],
                "tactic_res": [
                    "c4_goal : eq (hunion hempty h l) (h l)",
                    "c4_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c4_goal : eq (hunion hempty h l) (h l)"
                ],
                "tactic_res": [
                    "c5_goal : eq (h l) (h l)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (h l) (h l)",
                    "c4_l : addr",
                    "c2_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hdisjoint_union_l",
        "proof": [
            {
                "tactic_sig": "Lemma hdisjoint_union_l : forall h1 h2 h3 , hdisjoint ( hunion h1 h2 ) h3 <- > hdisjoint h1 h3 /\\ hdisjoint h2 h3 .",
                "tactic_sig_no_out_arg": "Lemma hdisjoint_union_l : forall h1 h2 h3 , hdisjoint ( hunion h1 h2 ) h3 <- > hdisjoint h1 h3 /\\ hdisjoint h2 h3 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall h1 h2 h3 : heap,\niff (hdisjoint (hunion h1 h2) h3)\n  (and (hdisjoint h1 h3) (hdisjoint h2 h3))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall h1 h2 h3 : heap,\niff (hdisjoint (hunion h1 h2) h3)\n  (and (hdisjoint h1 h3) (hdisjoint h2 h3))",
                    "_global_hdisjoint : forall (_ : heap) (_ : heap), Prop",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap"
                ],
                "tactic_res": [
                    "c2_goal : forall h1 h2 h3 : heap,\niff\n  (forall l : addr,\n   or\n     (eq\n        ({|\n           contents := fun l0 : addr => if h1 l0 then h1 l0 else h2 l0;\n           isfinite := hunion_obligation_1 h1 h2\n         |} l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c2_goal : forall h1 h2 h3 : heap,\niff\n  (forall l : addr,\n   or\n     (eq\n        ({|\n           contents := fun l0 : addr => if h1 l0 then h1 l0 else h2 l0;\n           isfinite := hunion_obligation_1 h1 h2\n         |} l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))"
                ],
                "tactic_res": [
                    "c3_goal : forall h1 h2 h3 : heap,\niff\n  (forall l : addr,\n   or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 h3 .",
                "tactic_args": [
                    "c3_goal : forall h1 h2 h3 : heap,\niff\n  (forall l : addr,\n   or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))"
                ],
                "tactic_res": [
                    "c4_goal : iff\n  (forall l : addr,\n   or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff\n  (forall l : addr,\n   or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None))\n  (and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n     (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  _ : forall l : addr,\n      or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None),\nand (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None))",
                    "c6_goal : forall\n  (_ : and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n         (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))\n  (l : addr),\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros D .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : forall l : addr,\n      or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None),\nand (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None))"
                ],
                "tactic_res": [
                    "c7_goal : and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None))",
                    "c7_D : forall l : addr,\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n  (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None))"
                ],
                "tactic_res": [
                    "c8_goal : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)",
                    "c9_goal : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c8_goal : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)"
                ],
                "tactic_res": [
                    "c10_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c10_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c10_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c7_D : forall l : addr,\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c10_l : addr",
                    "c4_h1 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c11_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c11_z : eq (if h1 l then h1 l else h2 l) None",
                    "c12_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c12_H : eq (h3 l) None"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_args": [
                    "c11_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c4_h1 : heap",
                    "c10_l : addr",
                    "c11_z : eq (if h1 l then h1 l else h2 l) None",
                    "c7_D : forall l : addr,\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c13_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c13_z : eq (Some z') None",
                    "c13_z' : Z",
                    "c14_goal : or (eq None None) (eq (h3 l) None)",
                    "c14_z : eq (h2 l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c13_z : eq (Some z') None",
                    "c13_z' : Z",
                    "c10_l : addr",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : or (eq None None) (eq (h3 l) None)",
                    "c10_l : addr",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : or (eq (h1 l) None) (eq (h3 l) None)",
                    "c12_H : eq (h3 l) None",
                    "c10_l : addr",
                    "c4_h1 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c9_goal : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)"
                ],
                "tactic_res": [
                    "c15_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c15_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c15_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c7_D : forall l : addr,\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c15_l : addr",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c16_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c16_z : eq (if h1 l then h1 l else h2 l) None",
                    "c17_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c17_H : eq (h3 l) None"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z'| ] .",
                "tactic_args": [
                    "c16_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c4_h1 : heap",
                    "c15_l : addr",
                    "c16_z : eq (if h1 l then h1 l else h2 l) None",
                    "c7_D : forall l : addr,\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c18_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c18_z : eq (Some z') None",
                    "c18_z' : Z",
                    "c19_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c19_z : eq (h2 l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c19_z : eq (h2 l) None",
                    "c15_l : addr",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c17_H : eq (h3 l) None",
                    "c15_l : addr",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c18_goal : or (eq (h2 l) None) (eq (h3 l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] _o .",
                "tactic_sig_no_out_arg": "intros [ D1 D2 ] l .",
                "tactic_args": [
                    "c6_goal : forall\n  (_ : and (forall l : addr, or (eq (h1 l) None) (eq (h3 l) None))\n         (forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)))\n  (l : addr),\nor (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)"
                ],
                "tactic_res": [
                    "c20_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c20_D1 : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)",
                    "c20_D2 : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)",
                    "c20_l : addr"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c20_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c20_D2 : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)",
                    "c20_l : addr",
                    "c20_D1 : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c21_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c21_z : eq (h2 l) None",
                    "c22_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c22_H : eq (h3 l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c22_H : eq (h3 l) None",
                    "c20_l : addr",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z'| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z'| ] eqn : H1 .",
                "tactic_args": [
                    "c21_goal : or (eq (if h1 l then h1 l else h2 l) None) (eq (h3 l) None)",
                    "c4_h1 : heap",
                    "c20_l : addr",
                    "c21_z : eq (h2 l) None",
                    "c20_D2 : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)",
                    "c20_D1 : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c23_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c23_H1 : eq (h1 l) (Some z')",
                    "c23_z' : Z",
                    "c24_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c24_H1 : eq (h1 l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : or (eq (h2 l) None) (eq (h3 l) None)",
                    "c20_l : addr",
                    "c4_h2 : heap",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z''| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z''| ] .",
                "tactic_args": [
                    "c23_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c20_D1 : forall l : addr, or (eq (h1 l) None) (eq (h3 l) None)",
                    "c20_l : addr",
                    "c23_H1 : eq (h1 l) (Some z')",
                    "c23_z' : Z",
                    "c21_z : eq (h2 l) None",
                    "c20_D2 : forall l : addr, or (eq (h2 l) None) (eq (h3 l) None)",
                    "c4_h3 : heap"
                ],
                "tactic_res": [
                    "c25_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c25_z'' : eq (h1 l) None",
                    "c26_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c26_H : eq (h3 l) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : or (eq (Some z') None) (eq (h3 l) None)",
                    "c26_H : eq (h3 l) None",
                    "c23_z' : Z",
                    "c20_l : addr",
                    "c4_h3 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c25_goal : or (eq (Some z') None) (eq (h3 l) None)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hdisjoint_union_r",
        "proof": [
            {
                "tactic_sig": "Lemma hdisjoint_union_r : forall h1 h2 h3 , hdisjoint h1 ( hunion h2 h3 ) <- > hdisjoint h1 h2 /\\ hdisjoint h1 h3 .",
                "tactic_sig_no_out_arg": "Lemma hdisjoint_union_r : forall h1 h2 h3 , hdisjoint h1 ( hunion h2 h3 ) <- > hdisjoint h1 h2 /\\ hdisjoint h1 h3 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall h1 h2 h3 : heap,\niff (hdisjoint h1 (hunion h2 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall h1 h2 h3 : heap,\niff (hdisjoint h1 (hunion h2 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ],
                "tactic_res": [
                    "c2_goal : iff (hdisjoint h1 (hunion h2 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h3 : heap"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : iff (hdisjoint h1 (hunion h2 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))",
                    "_global_hdisjoint_sym : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)"
                ],
                "tactic_res": [
                    "c3_goal : iff (hdisjoint (hunion h2 h3) h1)\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : iff (hdisjoint (hunion h2 h3) h1)\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))",
                    "_global_hdisjoint_union_l : forall h1 h2 h3 : heap,\n       iff (hdisjoint (hunion h1 h2) h3)\n         (and (hdisjoint h1 h3) (hdisjoint h2 h3))"
                ],
                "tactic_res": [
                    "c4_goal : iff (and (hdisjoint h2 h1) (hdisjoint h3 h1))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_args": [
                    "c4_goal : iff (and (hdisjoint h2 h1) (hdisjoint h3 h1))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))",
                    "_global_hdisjoint_sym : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)",
                    "c2_h2 : heap",
                    "_global_hdisjoint_sym : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)",
                    "c2_h3 : heap"
                ],
                "tactic_res": [
                    "c5_goal : iff (and (hdisjoint h1 h2) (hdisjoint h1 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c5_goal : iff (and (hdisjoint h1 h2) (hdisjoint h1 h3))\n  (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_invert_r",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_invert_r : forall h1 h2 h , hunion h h1 = hunion h h2 -> hdisjoint h h1 -> hdisjoint h h2 -> h1 = h2 .",
                "tactic_sig_no_out_arg": "Lemma hunion_invert_r : forall h1 h2 h , hunion h h1 = hunion h h2 -> hdisjoint h h1 -> hdisjoint h h2 -> h1 = h2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h1 h2 h : heap) (_ : eq (hunion h h1) (hunion h h2))\n  (_ : hdisjoint h h1) (_ : hdisjoint h h2), eq h1 h2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (h1 h2 h : heap) (_ : eq (hunion h h1) (hunion h h2))\n  (_ : hdisjoint h h1) (_ : hdisjoint h h2), eq h1 h2"
                ],
                "tactic_res": [
                    "c2_goal : eq h1 h2",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h : heap",
                    "c2_H : eq (hunion h h1) (hunion h h2)",
                    "c2_H0 : hdisjoint h h1",
                    "c2_H1 : hdisjoint h h2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq h1 h2",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr, eq (h1 l) (h2 l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr, eq (h1 l) (h2 l)"
                ],
                "tactic_res": [
                    "c4_goal : eq (h1 l) (h2 l)",
                    "c4_l : addr"
                ]
            },
            {
                "tactic_sig": "assert ( hunion _i _i _i = hunion _i _i _i ) by congruence .",
                "tactic_sig_no_out_arg": "assert ( hunion _i _i _i = hunion _i _i _i ) by congruence .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c4_l : addr",
                    "c2_h : heap",
                    "c2_h2 : heap",
                    "c4_l : addr"
                ],
                "tactic_res": [
                    "c4_H2 : eq (hunion h h1 l) (hunion h h2 l)"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c4_H2 : eq (hunion h h1 l) (hunion h h2 l)"
                ],
                "tactic_res": [
                    "c4_H2 : eq (if h l then h l else h1 l) (if h l then h l else h2 l)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c4_H0 : hdisjoint h h1",
                    "c4_l : addr"
                ],
                "tactic_res": [
                    "c4_H0 : or (eq (h l) None) (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c4_H1 : hdisjoint h h2",
                    "c4_l : addr"
                ],
                "tactic_res": [
                    "c4_H1 : or (eq (h l) None) (eq (h2 l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c4_goal : eq (h1 l) (h2 l)",
                    "c2_h : heap",
                    "c4_l : addr",
                    "c4_H2 : eq (if h l then h l else h1 l) (if h l then h l else h2 l)",
                    "c4_H1 : or (eq (h l) None) (eq (h2 l) None)",
                    "c4_H0 : or (eq (h l) None) (eq (h1 l) None)",
                    "c2_H : eq (hunion h h1) (hunion h h2)",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c5_goal : eq (h1 l) (h2 l)",
                    "c5_H2 : eq (Some z) (Some z)",
                    "c5_H1 : or (eq (Some z) None) (eq (h2 l) None)",
                    "c5_H0 : or (eq (Some z) None) (eq (h1 l) None)",
                    "c5_z : Z",
                    "c6_goal : eq (h1 l) (h2 l)",
                    "c6_H2 : eq (h1 l) (h2 l)",
                    "c6_H1 : or (eq None None) (eq (h2 l) None)",
                    "c6_H0 : or (eq None None) (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c5_goal : eq (h1 l) (h2 l)",
                    "c5_H1 : or (eq (Some z) None) (eq (h2 l) None)",
                    "c5_H0 : or (eq (Some z) None) (eq (h1 l) None)",
                    "c4_l : addr",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c6_goal : eq (h1 l) (h2 l)",
                    "c6_H2 : eq (h1 l) (h2 l)",
                    "c4_l : addr",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "hunion_invert_l",
        "proof": [
            {
                "tactic_sig": "Lemma hunion_invert_l : forall h1 h2 h , hunion h1 h = hunion h2 h -> hdisjoint h1 h -> hdisjoint h2 h -> h1 = h2 .",
                "tactic_sig_no_out_arg": "Lemma hunion_invert_l : forall h1 h2 h , hunion h1 h = hunion h2 h -> hdisjoint h1 h -> hdisjoint h2 h -> h1 = h2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h1 h2 h : heap) (_ : eq (hunion h1 h) (hunion h2 h))\n  (_ : hdisjoint h1 h) (_ : hdisjoint h2 h), eq h1 h2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (h1 h2 h : heap) (_ : eq (hunion h1 h) (hunion h2 h))\n  (_ : hdisjoint h1 h) (_ : hdisjoint h2 h), eq h1 h2"
                ],
                "tactic_res": [
                    "c2_goal : eq h1 h2",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h : heap",
                    "c2_H : eq (hunion h1 h) (hunion h2 h)",
                    "c2_H0 : hdisjoint h1 h",
                    "c2_H1 : hdisjoint h2 h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c2_goal : eq h1 h2",
                    "_global_hunion_invert_r : forall (h1 h2 h : heap) (_ : eq (hunion h h1) (hunion h h2))\n         (_ : hdisjoint h h1) (_ : hdisjoint h h2), \n       eq h1 h2",
                    "c2_h : heap"
                ],
                "tactic_res": [
                    "c3_goal : eq (hunion h h1) (hunion h h2)",
                    "c4_goal : hdisjoint h h1",
                    "c5_goal : hdisjoint h h2"
                ]
            },
            {
                "tactic_sig": "rewrite <- ! ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- ! ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c3_goal : eq (hunion h h1) (hunion h h2)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c2_h : heap",
                    "c2_H1 : hdisjoint h2 h",
                    "c2_H0 : hdisjoint h1 h",
                    "c2_H : eq (hunion h1 h) (hunion h2 h)",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c6_goal : eq (hunion h1 h) (hunion h2 h)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (hunion h1 h) (hunion h2 h)",
                    "c2_H : eq (hunion h1 h) (hunion h2 h)",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c4_goal : hdisjoint h h1",
                    "c2_H0 : hdisjoint h1 h",
                    "c2_h1 : heap",
                    "c2_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c5_goal : hdisjoint h h2",
                    "c2_H1 : hdisjoint h2 h",
                    "c2_h2 : heap",
                    "c2_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "assertion_extensionality",
        "proof": [
            {
                "tactic_sig": "Lemma assertion_extensionality : forall ( P Q : assertion ) , ( forall h , P h <- > Q h ) -> P = Q .",
                "tactic_sig_no_out_arg": "Lemma assertion_extensionality : forall ( P Q : assertion ) , ( forall h , P h <- > Q h ) -> P = Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)), eq P Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)), eq P Q"
                ],
                "tactic_res": [
                    "c2_goal : eq P Q",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : forall h : heap, iff (P h) (Q h)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq P Q",
                    "_global_functional_extensionality : forall (f g : forall _ : ?A, ?B) (_ : forall x : ?A, eq (f x) (g x)),\n       eq f g\nwhere\n?A : [P : assertion  Q : assertion  H : forall h : heap, iff (P h) (Q h)\n     |- Type]\n?B : [P : assertion  Q : assertion  H : forall h : heap, iff (P h) (Q h)\n     |- Type]"
                ],
                "tactic_res": [
                    "c3_goal : forall x : heap, eq (P x) (Q x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall x : heap, eq (P x) (Q x)"
                ],
                "tactic_res": [
                    "c4_goal : eq (P h) (Q h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : eq (P h) (Q h)",
                    "_global_propositional_extensionality : forall (P Q : Prop) (_ : iff P Q), eq P Q"
                ],
                "tactic_res": [
                    "c5_goal : iff (P h) (Q h)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : iff (P h) (Q h)",
                    "c4_h : heap",
                    "c2_H : forall h : heap, iff (P h) (Q h)",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_comm",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_comm : forall P Q , P ** Q = Q ** P .",
                "tactic_sig_no_out_arg": "Lemma sepconj_comm : forall P Q , P ** Q = Q ** P .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ]
            },
            {
                "tactic_sig": "assert ( forall P Q h , ( P ** Q ) h -> ( Q ** P ) h ) .",
                "tactic_sig_no_out_arg": "assert ( forall P Q h , ( P ** Q ) h -> ( Q ** P ) h ) .",
                "tactic_args": [
                    "c1_goal : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c2_goal : forall (P Q : assertion) (h : heap) (_ : sepconj P Q h), sepconj Q P h",
                    "c3_goal : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "c3_H : forall (P Q : assertion) (h : heap) (_ : sepconj P Q h), sepconj Q P h"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros P Q h ( h1 & h2 & P1 & Q2 & EQ & DISJ ) .",
                "tactic_args": [
                    "c2_goal : forall (P Q : assertion) (h : heap) (_ : sepconj P Q h), sepconj Q P h"
                ],
                "tactic_res": [
                    "c4_goal : sepconj Q P h",
                    "c4_P : assertion",
                    "c4_Q : assertion",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_P1 : P h1",
                    "c4_Q2 : Q h2",
                    "c4_EQ : hdisjoint h1 h2",
                    "c4_DISJ : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_goal : sepconj Q P h",
                    "c4_h : heap",
                    "c4_DISJ : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c5_goal : sepconj Q P (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c5_goal : sepconj Q P (hunion h1 h2)",
                    "c4_h2 : heap",
                    "c4_h1 : heap"
                ],
                "tactic_res": [
                    "c6_goal : and (Q h2)\n  (and (P h1)\n     (and (hdisjoint h2 h1) (eq (hunion h1 h2) (hunion h2 h1))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c6_goal : and (Q h2)\n  (and (P h1)\n     (and (hdisjoint h2 h1) (eq (hunion h1 h2) (hunion h2 h1))))",
                    "c4_EQ : hdisjoint h1 h2",
                    "c4_Q2 : Q h2",
                    "c4_P1 : P h1",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_P : assertion",
                    "c4_Q : assertion"
                ],
                "tactic_res": [
                    "c7_goal : hdisjoint h2 h1",
                    "c8_goal : eq (hunion h1 h2) (hunion h2 h1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : hdisjoint h2 h1",
                    "_global_hdisjoint_sym : forall h1 h2 : heap, iff (hdisjoint h1 h2) (hdisjoint h2 h1)"
                ],
                "tactic_res": [
                    "c9_goal : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : hdisjoint h1 h2",
                    "c4_EQ : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c8_goal : eq (hunion h1 h2) (hunion h2 h1)"
                ],
                "tactic_res": [
                    "c10_goal : eq (hunion h2 h1) (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c11_goal : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : hdisjoint h1 h2",
                    "c4_EQ : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros P Q .",
                "tactic_args": [
                    "c3_goal : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c12_goal : eq (sepconj P Q) (sepconj Q P)",
                    "c12_P : assertion",
                    "c12_Q : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eq (sepconj P Q) (sepconj Q P)",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c13_goal : forall h : heap, iff (sepconj P Q h) (sepconj Q P h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c13_goal : forall h : heap, iff (sepconj P Q h) (sepconj Q P h)"
                ],
                "tactic_res": [
                    "c14_goal : iff (sepconj P Q h) (sepconj Q P h)",
                    "c14_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : iff (sepconj P Q h) (sepconj Q P h)"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : sepconj P Q h, sepconj Q P h",
                    "c16_goal : forall _ : sepconj Q P h, sepconj P Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : forall _ : sepconj P Q h, sepconj Q P h",
                    "c14_h : heap",
                    "c12_P : assertion",
                    "c12_Q : assertion",
                    "c3_H : forall (P Q : assertion) (h : heap) (_ : sepconj P Q h), sepconj Q P h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : forall _ : sepconj Q P h, sepconj P Q h",
                    "c14_h : heap",
                    "c12_P : assertion",
                    "c12_Q : assertion",
                    "c3_H : forall (P Q : assertion) (h : heap) (_ : sepconj P Q h), sepconj Q P h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_assoc",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_assoc : forall P Q R , ( P ** Q ) ** R = P ** ( Q ** R ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_assoc : forall P Q R , ( P ** Q ) ** R = P ** ( Q ** R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q R : assertion,\neq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q R .",
                "tactic_args": [
                    "c1_goal : forall P Q R : assertion,\neq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap,\niff (sepconj (sepconj P Q) R h) (sepconj P (sepconj Q R) h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap,\niff (sepconj (sepconj P Q) R h) (sepconj P (sepconj Q R) h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (sepconj (sepconj P Q) R h) (sepconj P (sepconj Q R) h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (sepconj (sepconj P Q) R h) (sepconj P (sepconj Q R) h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : sepconj (sepconj P Q) R h, sepconj P (sepconj Q R) h",
                    "c6_goal : forall _ : sepconj P (sepconj Q R) h, sepconj (sepconj P Q) R h"
                ]
            },
            {
                "tactic_sig": "intros ( _o & _o & ( _o & _o & _o & _o & _o & _o ) & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( hx & h3 & ( h1 & h2 & P1 & Q2 & EQ & DISJ ) & R3 & EQ' & DISJ' ) .",
                "tactic_args": [
                    "c5_goal : forall _ : sepconj (sepconj P Q) R h, sepconj P (sepconj Q R) h"
                ],
                "tactic_res": [
                    "c7_goal : sepconj P (sepconj Q R) h",
                    "c7_hx : heap",
                    "c7_h3 : heap",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c7_P1 : P h1",
                    "c7_Q2 : Q h2",
                    "c7_EQ : hdisjoint h1 h2",
                    "c7_DISJ : eq hx (hunion h1 h2)",
                    "c7_R3 : R h3",
                    "c7_EQ' : hdisjoint hx h3",
                    "c7_DISJ' : eq h (hunion hx h3)"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c7_goal : sepconj P (sepconj Q R) h",
                    "c7_hx : heap",
                    "c4_h : heap",
                    "c7_DISJ' : eq h (hunion hx h3)",
                    "c7_DISJ : eq hx (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c8_goal : sepconj P (sepconj Q R) (hunion (hunion h1 h2) h3)",
                    "c8_EQ' : hdisjoint (hunion h1 h2) h3"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hdisjoint_union_l : forall h1 h2 h3 : heap,\n       iff (hdisjoint (hunion h1 h2) h3)\n         (and (hdisjoint h1 h3) (hdisjoint h2 h3))",
                    "c8_EQ' : hdisjoint (hunion h1 h2) h3"
                ],
                "tactic_res": [
                    "c8_EQ' : and (hdisjoint h1 h3) (hdisjoint h2 h3)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : sepconj P (sepconj Q R) (hunion (hunion h1 h2) h3)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c9_goal : sepconj P (sepconj Q R) (hunion h1 (hunion h2 h3))"
                ]
            },
            {
                "tactic_sig": "exists _i , ( hunion _i _i ) .",
                "tactic_sig_no_out_arg": "exists _i , ( hunion _i _i ) .",
                "tactic_args": [
                    "c9_goal : sepconj P (sepconj Q R) (hunion h1 (hunion h2 h3))",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c7_h3 : heap"
                ],
                "tactic_res": [
                    "c10_goal : and (P h1)\n  (and (sepconj Q R (hunion h2 h3))\n     (and (hdisjoint h1 (hunion h2 h3))\n        (eq (hunion h1 (hunion h2 h3)) (hunion h1 (hunion h2 h3)))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c10_goal : and (P h1)\n  (and (sepconj Q R (hunion h2 h3))\n     (and (hdisjoint h1 (hunion h2 h3))\n        (eq (hunion h1 (hunion h2 h3)) (hunion h1 (hunion h2 h3)))))",
                    "c8_EQ' : and (hdisjoint h1 h3) (hdisjoint h2 h3)",
                    "c7_R3 : R h3",
                    "c7_EQ : hdisjoint h1 h2",
                    "c7_Q2 : Q h2",
                    "c7_P1 : P h1",
                    "c7_h3 : heap",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c11_goal : sepconj Q R (hunion h2 h3)",
                    "c11_H0 : hdisjoint h2 h3",
                    "c11_H : hdisjoint h1 h3",
                    "c12_goal : hdisjoint h1 (hunion h2 h3)",
                    "c12_H0 : hdisjoint h2 h3",
                    "c12_H : hdisjoint h1 h3"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c11_goal : sepconj Q R (hunion h2 h3)",
                    "c7_h2 : heap",
                    "c7_h3 : heap"
                ],
                "tactic_res": [
                    "c13_goal : and (Q h2)\n  (and (R h3)\n     (and (hdisjoint h2 h3) (eq (hunion h2 h3) (hunion h2 h3))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c13_goal : and (Q h2)\n  (and (R h3)\n     (and (hdisjoint h2 h3) (eq (hunion h2 h3) (hunion h2 h3))))",
                    "c11_H0 : hdisjoint h2 h3",
                    "c7_R3 : R h3",
                    "c7_Q2 : Q h2",
                    "c7_h3 : heap",
                    "c7_h2 : heap",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : hdisjoint h1 (hunion h2 h3)",
                    "_global_hdisjoint_union_r : forall h1 h2 h3 : heap,\n       iff (hdisjoint h1 (hunion h2 h3))\n         (and (hdisjoint h1 h2) (hdisjoint h1 h3))"
                ],
                "tactic_res": [
                    "c14_goal : and (hdisjoint h1 h2) (hdisjoint h1 h3)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c14_goal : and (hdisjoint h1 h2) (hdisjoint h1 h3)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & ( _o & _o & _o & _o & _o & _o ) & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( h1 & hx & P1 & ( h2 & h3 & Q2 & R3 & EQ & DISJ ) & EQ' & DISJ' ) .",
                "tactic_args": [
                    "c6_goal : forall _ : sepconj P (sepconj Q R) h, sepconj (sepconj P Q) R h"
                ],
                "tactic_res": [
                    "c15_goal : sepconj (sepconj P Q) R h",
                    "c15_h1 : heap",
                    "c15_hx : heap",
                    "c15_P1 : P h1",
                    "c15_h2 : heap",
                    "c15_h3 : heap",
                    "c15_Q2 : Q h2",
                    "c15_R3 : R h3",
                    "c15_EQ : hdisjoint h2 h3",
                    "c15_DISJ : eq hx (hunion h2 h3)",
                    "c15_EQ' : hdisjoint h1 hx",
                    "c15_DISJ' : eq h (hunion h1 hx)"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c15_goal : sepconj (sepconj P Q) R h",
                    "c15_hx : heap",
                    "c4_h : heap",
                    "c15_DISJ' : eq h (hunion h1 hx)",
                    "c15_DISJ : eq hx (hunion h2 h3)"
                ],
                "tactic_res": [
                    "c16_goal : sepconj (sepconj P Q) R (hunion h1 (hunion h2 h3))",
                    "c16_EQ' : hdisjoint h1 (hunion h2 h3)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_hdisjoint_union_r : forall h1 h2 h3 : heap,\n       iff (hdisjoint h1 (hunion h2 h3))\n         (and (hdisjoint h1 h2) (hdisjoint h1 h3))",
                    "c16_EQ' : hdisjoint h1 (hunion h2 h3)"
                ],
                "tactic_res": [
                    "c16_EQ' : and (hdisjoint h1 h2) (hdisjoint h1 h3)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c16_goal : sepconj (sepconj P Q) R (hunion h1 (hunion h2 h3))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c17_goal : sepconj (sepconj P Q) R (hunion (hunion h1 h2) h3)"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c17_goal : sepconj (sepconj P Q) R (hunion (hunion h1 h2) h3)",
                    "c15_h1 : heap",
                    "c15_h2 : heap",
                    "c15_h3 : heap"
                ],
                "tactic_res": [
                    "c18_goal : and (sepconj P Q (hunion h1 h2))\n  (and (R h3)\n     (and (hdisjoint (hunion h1 h2) h3)\n        (eq (hunion (hunion h1 h2) h3) (hunion (hunion h1 h2) h3))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c18_goal : and (sepconj P Q (hunion h1 h2))\n  (and (R h3)\n     (and (hdisjoint (hunion h1 h2) h3)\n        (eq (hunion (hunion h1 h2) h3) (hunion (hunion h1 h2) h3))))",
                    "c16_EQ' : and (hdisjoint h1 h2) (hdisjoint h1 h3)",
                    "c15_EQ : hdisjoint h2 h3",
                    "c15_R3 : R h3",
                    "c15_Q2 : Q h2",
                    "c15_h2 : heap",
                    "c15_h3 : heap",
                    "c15_P1 : P h1",
                    "c15_h1 : heap",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c19_goal : sepconj P Q (hunion h1 h2)",
                    "c19_H0 : hdisjoint h1 h3",
                    "c19_H : hdisjoint h1 h2",
                    "c20_goal : hdisjoint (hunion h1 h2) h3",
                    "c20_H0 : hdisjoint h1 h3",
                    "c20_H : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c19_goal : sepconj P Q (hunion h1 h2)",
                    "c15_h1 : heap",
                    "c15_h2 : heap"
                ],
                "tactic_res": [
                    "c21_goal : and (P h1)\n  (and (Q h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c21_goal : and (P h1)\n  (and (Q h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))",
                    "c19_H : hdisjoint h1 h2",
                    "c15_Q2 : Q h2",
                    "c15_h2 : heap",
                    "c15_P1 : P h1",
                    "c15_h1 : heap",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : hdisjoint (hunion h1 h2) h3",
                    "_global_hdisjoint_union_l : forall h1 h2 h3 : heap,\n       iff (hdisjoint (hunion h1 h2) h3)\n         (and (hdisjoint h1 h3) (hdisjoint h2 h3))"
                ],
                "tactic_res": [
                    "c22_goal : and (hdisjoint h1 h3) (hdisjoint h2 h3)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c22_goal : and (hdisjoint h1 h3) (hdisjoint h2 h3)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_emp",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_emp : forall P , emp ** P = P .",
                "tactic_sig_no_out_arg": "Lemma sepconj_emp : forall P , emp ** P = P .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : assertion, eq (sepconj emp P) P"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros P .",
                "tactic_args": [
                    "c1_goal : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj emp P) P",
                    "c2_P : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj emp P) P",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap, iff (sepconj emp P h) (P h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap, iff (sepconj emp P h) (P h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (sepconj emp P h) (P h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (sepconj emp P h) (P h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : sepconj emp P h, P h",
                    "c6_goal : forall _ : P h, sepconj emp P h"
                ]
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( h1 & h2 & EMP1 & P2 & EQ & DISJ ) .",
                "tactic_args": [
                    "c5_goal : forall _ : sepconj emp P h, P h"
                ],
                "tactic_res": [
                    "c7_goal : P h",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c7_EMP1 : emp h1",
                    "c7_P2 : P h2",
                    "c7_EQ : hdisjoint h1 h2",
                    "c7_DISJ : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c7_EMP1 : emp h1"
                ],
                "tactic_res": [
                    "c7_EMP1 : eq h1 hempty"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c7_goal : P h",
                    "c4_h : heap",
                    "c7_h1 : heap",
                    "c7_DISJ : eq h (hunion h1 h2)",
                    "c7_EMP1 : eq h1 hempty"
                ],
                "tactic_res": [
                    "c8_goal : P (hunion hempty h2)",
                    "c8_EQ : hdisjoint hempty h2"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : P (hunion hempty h2)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c9_goal : P h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P h2",
                    "c7_P2 : P h2",
                    "c7_h2 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall _ : P h, sepconj emp P h"
                ],
                "tactic_res": [
                    "c10_goal : sepconj emp P h",
                    "c10_H : P h"
                ]
            },
            {
                "tactic_sig": "exists hempty , _i .",
                "tactic_sig_no_out_arg": "exists hempty , _i .",
                "tactic_args": [
                    "c10_goal : sepconj emp P h",
                    "c4_h : heap"
                ],
                "tactic_res": [
                    "c11_goal : and (emp hempty)\n  (and (P h) (and (hdisjoint hempty h) (eq h (hunion hempty h))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c11_goal : and (emp hempty)\n  (and (P h) (and (hdisjoint hempty h) (eq h (hunion hempty h))))",
                    "c10_H : P h",
                    "c4_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c12_goal : emp hempty",
                    "c13_goal : hdisjoint hempty h",
                    "c14_goal : eq h (hunion hempty h)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c12_goal : emp hempty"
                ],
                "tactic_res": [
                    "c15_goal : eq hempty hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq hempty hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : hdisjoint hempty h"
                ],
                "tactic_res": [
                    "c16_goal : forall l : addr, or (eq (hempty l) None) (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : forall l : addr, or (eq (hempty l) None) (eq (h l) None)",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : eq h (hunion hempty h)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c17_goal : eq h h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq h h",
                    "c4_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_imp_l",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_imp_l : forall P Q R , ( P -->> Q ) -> ( P ** R -->> Q ** R ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_imp_l : forall P Q R , ( P -->> Q ) -> ( P ** R -->> Q ** R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp P Q),\naimp (sepconj P R) (sepconj Q R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros P Q R IMP h ( h1 & h2 & P1 & Q2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp P Q),\naimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c2_goal : sepconj Q R h",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_IMP : aimp P Q",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_P1 : P h1",
                    "c2_Q2 : R h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c2_goal : sepconj Q R h",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c3_goal : and (Q h1) (and (R h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c3_goal : and (Q h1) (and (R h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c2_U : eq h (hunion h1 h2)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_Q2 : R h2",
                    "c2_P1 : P h1",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_IMP : aimp P Q",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_imp_r",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_imp_r : forall P Q R , ( P -->> Q ) -> ( R ** P -->> R ** Q ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_imp_r : forall P Q R , ( P -->> Q ) -> ( R ** P -->> R ** Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp P Q),\naimp (sepconj R P) (sepconj R Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp P Q),\naimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj R P) (sepconj R Q)",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_H : aimp P Q"
                ]
            },
            {
                "tactic_sig": "rewrite ! ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ! ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj R P) (sepconj R Q)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c3_goal : aimp (sepconj P R) (sepconj Q R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : aimp (sepconj P R) (sepconj Q R)",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c4_goal : aimp P Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : aimp P Q",
                    "c2_H : aimp P Q",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pure_sep",
        "proof": [
            {
                "tactic_sig": "Lemma pure_sep : forall P Q , pure ( P /\\ Q ) = pure P ** pure Q .",
                "tactic_sig_no_out_arg": "Lemma pure_sep : forall P Q , pure ( P /\\ Q ) = pure P ** pure Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q : Prop, eq (pure (and P Q)) (sepconj (pure P) (pure Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros P Q .",
                "tactic_args": [
                    "c1_goal : forall P Q : Prop, eq (pure (and P Q)) (sepconj (pure P) (pure Q))"
                ],
                "tactic_res": [
                    "c2_goal : eq (pure (and P Q)) (sepconj (pure P) (pure Q))",
                    "c2_P : Prop",
                    "c2_Q : Prop"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (pure (and P Q)) (sepconj (pure P) (pure Q))",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap, iff (pure (and P Q) h) (sepconj (pure P) (pure Q) h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap, iff (pure (and P Q) h) (sepconj (pure P) (pure Q) h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (pure (and P Q) h) (sepconj (pure P) (pure Q) h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : iff (pure (and P Q) h) (sepconj (pure P) (pure Q) h)",
                    "_global_pure : forall _ : Prop, assertion",
                    "_global_sepconj : forall (_ : assertion) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c5_goal : iff (and (and P Q) (eq h hempty))\n  (ex\n     (fun h1 : heap =>\n      ex\n        (fun h2 : heap =>\n         and (and P (eq h1 hempty))\n           (and (and Q (eq h2 hempty))\n              (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : iff (and (and P Q) (eq h hempty))\n  (ex\n     (fun h1 : heap =>\n      ex\n        (fun h2 : heap =>\n         and (and P (eq h1 hempty))\n           (and (and Q (eq h2 hempty))\n              (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : and (and P Q) (eq h hempty),\nex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))",
                    "c7_goal : forall\n  _ : ex\n        (fun h1 : heap =>\n         ex\n           (fun h2 : heap =>\n            and (and P (eq h1 hempty))\n              (and (and Q (eq h2 hempty))\n                 (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))),\nand (and P Q) (eq h hempty)"
                ]
            },
            {
                "tactic_sig": "intros ( ( _o & _o ) & _o ) .",
                "tactic_sig_no_out_arg": "intros ( ( A & B ) & C ) .",
                "tactic_args": [
                    "c6_goal : forall _ : and (and P Q) (eq h hempty),\nex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))",
                    "c8_A : P",
                    "c8_B : Q",
                    "c8_C : eq h hempty"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))",
                    "c4_h : heap",
                    "c8_C : eq h hempty"
                ],
                "tactic_res": [
                    "c9_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq hempty (hunion h1 h2))))))"
                ]
            },
            {
                "tactic_sig": "exists hempty , hempty .",
                "tactic_sig_no_out_arg": "exists hempty , hempty .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (and Q (eq h2 hempty))\n           (and (hdisjoint h1 h2) (eq hempty (hunion h1 h2))))))"
                ],
                "tactic_res": [
                    "c10_goal : and (and P (eq hempty hempty))\n  (and (and Q (eq hempty hempty))\n     (and (hdisjoint hempty hempty) (eq hempty (hunion hempty hempty))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c10_goal : and (and P (eq hempty hempty))\n  (and (and Q (eq hempty hempty))\n     (and (hdisjoint hempty hempty) (eq hempty (hunion hempty hempty))))",
                    "c8_B : Q",
                    "c8_A : P",
                    "c2_P : Prop",
                    "c2_Q : Prop"
                ],
                "tactic_res": [
                    "c11_goal : hdisjoint hempty hempty",
                    "c12_goal : eq hempty (hunion hempty hempty)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c11_goal : hdisjoint hempty hempty"
                ],
                "tactic_res": [
                    "c13_goal : or (eq (hempty l) None) (eq (hempty l) None)",
                    "c13_l : addr"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : or (eq (hempty l) None) (eq (hempty l) None)",
                    "c13_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : eq hempty (hunion hempty hempty)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c14_goal : eq hempty hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : eq hempty hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & ( _o & _o ) & ( _o & _o ) & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( h1 & h2 & ( PP & E1 ) & ( QQ & E2 ) & C & D ) .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : ex\n        (fun h1 : heap =>\n         ex\n           (fun h2 : heap =>\n            and (and P (eq h1 hempty))\n              (and (and Q (eq h2 hempty))\n                 (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))),\nand (and P Q) (eq h hempty)"
                ],
                "tactic_res": [
                    "c15_goal : and (and P Q) (eq h hempty)",
                    "c15_h1 : heap",
                    "c15_h2 : heap",
                    "c15_PP : P",
                    "c15_E1 : eq h1 hempty",
                    "c15_QQ : Q",
                    "c15_E2 : eq h2 hempty",
                    "c15_C : hdisjoint h1 h2",
                    "c15_D : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i _i .",
                "tactic_args": [
                    "c15_goal : and (and P Q) (eq h hempty)",
                    "c4_h : heap",
                    "c15_h1 : heap",
                    "c15_h2 : heap",
                    "c15_D : eq h (hunion h1 h2)",
                    "c15_E2 : eq h2 hempty",
                    "c15_E1 : eq h1 hempty"
                ],
                "tactic_res": [
                    "c16_goal : and (and P Q) (eq (hunion hempty hempty) hempty)",
                    "c16_C : hdisjoint hempty hempty"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : and (and P Q) (eq (hunion hempty hempty) hempty)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c17_goal : and (and P Q) (eq hempty hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : and (and P Q) (eq hempty hempty)",
                    "c15_QQ : Q",
                    "c15_PP : P",
                    "c2_P : Prop",
                    "c2_Q : Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pureconj_sepconj",
        "proof": [
            {
                "tactic_sig": "Lemma pureconj_sepconj : forall P Q , pure P ** Q = P //\\\\ Q .",
                "tactic_sig_no_out_arg": "Lemma pureconj_sepconj : forall P Q , pure P ** Q = P //\\\\ Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : Prop) (Q : assertion),\neq (sepconj (pure P) Q) (pureconj P Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros P Q .",
                "tactic_args": [
                    "c1_goal : forall (P : Prop) (Q : assertion),\neq (sepconj (pure P) Q) (pureconj P Q)"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj (pure P) Q) (pureconj P Q)",
                    "c2_P : Prop",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj (pure P) Q) (pureconj P Q)",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap, iff (sepconj (pure P) Q h) (pureconj P Q h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap, iff (sepconj (pure P) Q h) (pureconj P Q h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (sepconj (pure P) Q h) (pureconj P Q h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c4_goal : iff (sepconj (pure P) Q h) (pureconj P Q h)",
                    "_global_pure : forall _ : Prop, assertion",
                    "_global_sepconj : forall (_ : assertion) (_ : assertion), assertion",
                    "_global_pureconj : forall (_ : Prop) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c5_goal : iff\n  (ex\n     (fun h1 : heap =>\n      ex\n        (fun h2 : heap =>\n         and (and P (eq h1 hempty))\n           (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))))\n  (and P (Q h))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : iff\n  (ex\n     (fun h1 : heap =>\n      ex\n        (fun h2 : heap =>\n         and (and P (eq h1 hempty))\n           (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))))\n  (and P (Q h))"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : ex\n        (fun h1 : heap =>\n         ex\n           (fun h2 : heap =>\n            and (and P (eq h1 hempty))\n              (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))),\nand P (Q h)",
                    "c7_goal : forall _ : and P (Q h),\nex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))"
                ]
            },
            {
                "tactic_sig": "intros ( _o & _o & ( _o & _o ) & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( h1 & h2 & ( A & B ) & C & D & E ) .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : ex\n        (fun h1 : heap =>\n         ex\n           (fun h2 : heap =>\n            and (and P (eq h1 hempty))\n              (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2)))))),\nand P (Q h)"
                ],
                "tactic_res": [
                    "c8_goal : and P (Q h)",
                    "c8_h1 : heap",
                    "c8_h2 : heap",
                    "c8_A : P",
                    "c8_B : eq h1 hempty",
                    "c8_C : Q h2",
                    "c8_D : hdisjoint h1 h2",
                    "c8_E : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : and P (Q h)"
                ],
                "tactic_res": [
                    "c9_goal : P",
                    "c10_goal : Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P",
                    "c8_A : P",
                    "c2_P : Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c10_goal : Q h",
                    "c4_h : heap",
                    "c8_h1 : heap",
                    "c8_E : eq h (hunion h1 h2)",
                    "c8_B : eq h1 hempty"
                ],
                "tactic_res": [
                    "c11_goal : Q (hunion hempty h2)",
                    "c11_D : hdisjoint hempty h2"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Q (hunion hempty h2)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c12_goal : Q h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Q h2",
                    "c8_C : Q h2",
                    "c8_h2 : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( A & B ) .",
                "tactic_args": [
                    "c7_goal : forall _ : and P (Q h),\nex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))",
                    "c13_A : P",
                    "c13_B : Q h"
                ]
            },
            {
                "tactic_sig": "exists hempty , _i .",
                "tactic_sig_no_out_arg": "exists hempty , _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun h1 : heap =>\n   ex\n     (fun h2 : heap =>\n      and (and P (eq h1 hempty))\n        (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))))",
                    "c4_h : heap"
                ],
                "tactic_res": [
                    "c14_goal : and (and P (eq hempty hempty))\n  (and (Q h) (and (hdisjoint hempty h) (eq h (hunion hempty h))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c14_goal : and (and P (eq hempty hempty))\n  (and (Q h) (and (hdisjoint hempty h) (eq h (hunion hempty h))))",
                    "c13_B : Q h",
                    "c13_A : P",
                    "c4_h : heap",
                    "c2_Q : assertion",
                    "c2_P : Prop"
                ],
                "tactic_res": [
                    "c15_goal : hdisjoint hempty h",
                    "c16_goal : eq h (hunion hempty h)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro l .",
                "tactic_args": [
                    "c15_goal : hdisjoint hempty h"
                ],
                "tactic_res": [
                    "c17_goal : or (eq (hempty l) None) (eq (h l) None)",
                    "c17_l : addr"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : or (eq (hempty l) None) (eq (h l) None)",
                    "c17_l : addr",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : eq h (hunion hempty h)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c18_goal : eq h h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq h h",
                    "c4_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lift_pureconj",
        "proof": [
            {
                "tactic_sig": "Lemma lift_pureconj : forall P Q R , ( P //\\\\ Q ) ** R = P //\\\\ ( Q ** R ) .",
                "tactic_sig_no_out_arg": "Lemma lift_pureconj : forall P Q R , ( P //\\\\ Q ) ** R = P //\\\\ ( Q ** R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : Prop) (Q R : assertion),\neq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : Prop) (Q R : assertion),\neq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "c2_P : Prop",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite <- ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_pureconj_sepconj : forall (P : Prop) (Q : assertion),\n       eq (sepconj (pure P) Q) (pureconj P Q)"
                ],
                "tactic_res": [
                    "c3_goal : eq (sepconj (sepconj (pure P) Q) R) (sepconj (pure P) (sepconj Q R))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq (sepconj (sepconj (pure P) Q) R) (sepconj (pure P) (sepconj Q R))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c4_goal : eq (sepconj (pure P) (sepconj Q R)) (sepconj (pure P) (sepconj Q R))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (sepconj (pure P) (sepconj Q R)) (sepconj (pure P) (sepconj Q R))",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_P : Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lift_aexists",
        "proof": [
            {
                "tactic_sig": "Lemma lift_aexists : forall ( A : Type ) ( P : A -> assertion ) Q , aexists P ** Q = aexists ( fun x => P x ** Q ) .",
                "tactic_sig_no_out_arg": "Lemma lift_aexists : forall ( A : Type ) ( P : A -> assertion ) Q , aexists P ** Q = aexists ( fun x => P x ** Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\neq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros A P Q .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\neq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))",
                    "c2_A : Type",
                    "c2_P : forall _ : A, assertion",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap,\niff (sepconj (aexists P) Q h)\n  (aexists (fun x : A => sepconj (P x) Q) h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap,\niff (sepconj (aexists P) Q h)\n  (aexists (fun x : A => sepconj (P x) Q) h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (sepconj (aexists P) Q h)\n  (aexists (fun x : A => sepconj (P x) Q) h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (sepconj (aexists P) Q h)\n  (aexists (fun x : A => sepconj (P x) Q) h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : sepconj (aexists P) Q h,\naexists (fun x : A => sepconj (P x) Q) h",
                    "c6_goal : forall _ : aexists (fun x : A => sepconj (P x) Q) h,\nsepconj (aexists P) Q h"
                ]
            },
            {
                "tactic_sig": "intros ( _o & _o & ( _o & _o ) & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( h1 & h2 & ( a & P1 ) & Q2 & DISJ & EQ ) .",
                "tactic_args": [
                    "c5_goal : forall _ : sepconj (aexists P) Q h,\naexists (fun x : A => sepconj (P x) Q) h"
                ],
                "tactic_res": [
                    "c7_goal : aexists (fun x : A => sepconj (P x) Q) h",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c7_a : A",
                    "c7_P1 : P a h1",
                    "c7_Q2 : Q h2",
                    "c7_DISJ : hdisjoint h1 h2",
                    "c7_EQ : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i , _i .",
                "tactic_args": [
                    "c7_goal : aexists (fun x : A => sepconj (P x) Q) h",
                    "c7_a : A",
                    "c7_h1 : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": [
                    "c8_goal : and (P a h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (P a h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c7_EQ : eq h (hunion h1 h2)",
                    "c7_DISJ : hdisjoint h1 h2",
                    "c7_Q2 : Q h2",
                    "c7_P1 : P a h1",
                    "c7_a : A",
                    "c4_h : heap",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c2_Q : assertion",
                    "c2_P : forall _ : A, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( a & h1 & h2 & P1 & Q2 & DISJ & EQ ) .",
                "tactic_args": [
                    "c6_goal : forall _ : aexists (fun x : A => sepconj (P x) Q) h,\nsepconj (aexists P) Q h"
                ],
                "tactic_res": [
                    "c9_goal : sepconj (aexists P) Q h",
                    "c9_a : A",
                    "c9_h1 : heap",
                    "c9_h2 : heap",
                    "c9_P1 : P a h1",
                    "c9_Q2 : Q h2",
                    "c9_DISJ : hdisjoint h1 h2",
                    "c9_EQ : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c9_goal : sepconj (aexists P) Q h",
                    "c9_h1 : heap",
                    "c9_h2 : heap"
                ],
                "tactic_res": [
                    "c10_goal : and (aexists P h1)\n  (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c10_goal : and (aexists P h1)\n  (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c9_EQ : eq h (hunion h1 h2)",
                    "c9_DISJ : hdisjoint h1 h2",
                    "c9_Q2 : Q h2",
                    "c9_P1 : P a h1",
                    "c9_h1 : heap",
                    "c9_h2 : heap",
                    "c4_h : heap",
                    "c2_Q : assertion",
                    "c2_P : forall _ : A, assertion",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c11_goal : aexists P h1"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : aexists P h1",
                    "c9_a : A"
                ],
                "tactic_res": [
                    "c12_goal : P a h1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : P a h1",
                    "c9_P1 : P a h1",
                    "c9_h1 : heap",
                    "c9_a : A",
                    "c2_P : forall _ : A, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_swap3",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_swap3 : forall R P Q , P ** Q ** R = R ** P ** Q .",
                "tactic_sig_no_out_arg": "Lemma sepconj_swap3 : forall R P Q , P ** Q ** R = R ** P ** Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall R P Q : assertion,\neq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall R P Q : assertion,\neq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))",
                    "c2_R : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c3_goal : eq (sepconj R (sepconj P Q)) (sepconj R (sepconj P Q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (sepconj R (sepconj P Q)) (sepconj R (sepconj P Q))",
                    "c2_R : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_swap4",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_swap4 : forall S P Q R , P ** Q ** R ** S = S ** P ** Q ** R .",
                "tactic_sig_no_out_arg": "Lemma sepconj_swap4 : forall S P Q R , P ** Q ** R ** S = S ** P ** Q ** R .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall S P Q R : assertion,\neq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj S (sepconj P (sepconj Q R)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall S P Q R : assertion,\neq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj S (sepconj P (sepconj Q R)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj S (sepconj P (sepconj Q R)))",
                    "c2_S : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i , _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj S (sepconj P (sepconj Q R)))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_swap3 : forall R P Q : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c3_goal : eq (sepconj S (sepconj P (sepconj Q R)))\n  (sepconj S (sepconj P (sepconj Q R)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (sepconj S (sepconj P (sepconj Q R)))\n  (sepconj S (sepconj P (sepconj Q R)))",
                    "c2_S : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_pick2",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_pick2 : forall Q P R , P ** Q ** R = Q ** P ** R .",
                "tactic_sig_no_out_arg": "Lemma sepconj_pick2 : forall Q P R , P ** Q ** R = Q ** P ** R .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall Q P R : assertion,\neq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall Q P R : assertion,\neq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "c2_Q : assertion",
                    "c2_P : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , <- _i , _i .",
                "tactic_args": [
                    "c2_goal : eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "c2_Q : assertion",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c3_goal : eq (sepconj Q (sepconj P R)) (sepconj Q (sepconj P R))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (sepconj Q (sepconj P R)) (sepconj Q (sepconj P R))",
                    "c2_Q : assertion",
                    "c2_P : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_pick3",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_pick3 : forall R P Q S , P ** Q ** R ** S = R ** P ** Q ** S .",
                "tactic_sig_no_out_arg": "Lemma sepconj_pick3 : forall R P Q S , P ** Q ** R ** S = R ** P ** Q ** S .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall R P Q S : assertion,\neq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj R (sepconj P (sepconj Q S)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall R P Q S : assertion,\neq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj R (sepconj P (sepconj Q S)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj R (sepconj P (sepconj Q S)))",
                    "c2_R : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_S : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (sepconj P (sepconj Q (sepconj R S)))\n  (sepconj R (sepconj P (sepconj Q S)))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "c2_R : assertion",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "c2_P : assertion"
                ],
                "tactic_res": [
                    "c3_goal : eq (sepconj P (sepconj R (sepconj Q S)))\n  (sepconj P (sepconj R (sepconj Q S)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (sepconj P (sepconj R (sepconj Q S)))\n  (sepconj P (sepconj R (sepconj Q S)))",
                    "c2_R : assertion",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_S : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_intro",
        "proof": [
            {
                "tactic_sig": "Lemma wand_intro : forall P Q R , P ** Q -->> R -> P -->> Q --* R .",
                "tactic_sig_no_out_arg": "Lemma wand_intro : forall P Q R , P ** Q -->> R -> P -->> Q --* R .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp (sepconj P Q) R),\naimp P (wand Q R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q R IMP h Ph h' DISJ Qh' .",
                "tactic_args": [
                    "c1_goal : forall (P Q R : assertion) (_ : aimp (sepconj P Q) R),\naimp P (wand Q R)"
                ],
                "tactic_res": [
                    "c2_goal : R (hunion h h')",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion",
                    "c2_IMP : aimp (sepconj P Q) R",
                    "c2_h : heap",
                    "c2_Ph : P h",
                    "c2_h' : heap",
                    "c2_DISJ : hdisjoint h h'",
                    "c2_Qh' : Q h'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : R (hunion h h')",
                    "c2_IMP : aimp (sepconj P Q) R"
                ],
                "tactic_res": [
                    "c3_goal : sepconj P Q (hunion h h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c3_goal : sepconj P Q (hunion h h')",
                    "c2_h : heap",
                    "c2_h' : heap"
                ],
                "tactic_res": [
                    "c4_goal : and (P h)\n  (and (Q h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : and (P h)\n  (and (Q h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))",
                    "c2_Qh' : Q h'",
                    "c2_DISJ : hdisjoint h h'",
                    "c2_h' : heap",
                    "c2_Ph : P h",
                    "c2_h : heap",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_cancel",
        "proof": [
            {
                "tactic_sig": "Lemma wand_cancel : forall P Q , P ** ( P --* Q ) -->> Q .",
                "tactic_sig_no_out_arg": "Lemma wand_cancel : forall P Q , P ** ( P --* Q ) -->> Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q : assertion, aimp (sepconj P (wand P Q)) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros P Q h ( h1 & h2 & Ph1 & Wh2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall P Q : assertion, aimp (sepconj P (wand P Q)) Q"
                ],
                "tactic_res": [
                    "c2_goal : Q h",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_Ph1 : P h1",
                    "c2_Wh2 : wand P Q h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_goal : Q h",
                    "c2_h : heap",
                    "c2_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c3_goal : Q (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "assert ( D' : hdisjoint _i _i ) by ( apply hdisjoint_sym ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( D' : hdisjoint _i _i ) by ( apply hdisjoint_sym ; auto ) .",
                "tactic_args": [
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c2_D : hdisjoint h1 h2",
                    "c2_Wh2 : wand P Q h2",
                    "c2_Ph1 : P h1",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_D' : hdisjoint h2 h1"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c3_goal : Q (hunion h1 h2)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c3_D' : hdisjoint h2 h1",
                    "c2_D : hdisjoint h1 h2",
                    "c2_Wh2 : wand P Q h2",
                    "c2_Ph1 : P h1",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c4_goal : Q (hunion h2 h1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Q (hunion h2 h1)",
                    "c2_Wh2 : wand P Q h2"
                ],
                "tactic_res": [
                    "c5_goal : hdisjoint h2 h1",
                    "c6_goal : P h1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : hdisjoint h2 h1",
                    "c3_D' : hdisjoint h2 h1",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : P h1",
                    "c2_Ph1 : P h1",
                    "c2_h1 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_charact",
        "proof": [
            {
                "tactic_sig": "Lemma wand_charact : forall P Q , ( P --* Q ) = ( aexists ( fun R => ( P ** R -->> Q ) //\\\\ R ) ) .",
                "tactic_sig_no_out_arg": "Lemma wand_charact : forall P Q , ( P --* Q ) = ( aexists ( fun R => ( P ** R -->> Q ) //\\\\ R ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q : assertion,\neq (wand P Q)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros P Q .",
                "tactic_args": [
                    "c1_goal : forall P Q : assertion,\neq (wand P Q)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R))"
                ],
                "tactic_res": [
                    "c2_goal : eq (wand P Q)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R))",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (wand P Q)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R))",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap,\niff (wand P Q h)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap,\niff (wand P Q h)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (wand P Q h)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (wand P Q h)\n  (aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : wand P Q h,\naexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h",
                    "c6_goal : forall\n  _ : aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R)\n        h, wand P Q h"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros W .",
                "tactic_args": [
                    "c5_goal : forall _ : wand P Q h,\naexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h"
                ],
                "tactic_res": [
                    "c7_goal : aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h",
                    "c7_W : wand P Q h"
                ]
            },
            {
                "tactic_sig": "exists ( _i --* _i ) .",
                "tactic_sig_no_out_arg": "exists ( _i --* _i ) .",
                "tactic_args": [
                    "c7_goal : aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R) h",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c8_goal : pureconj (aimp (sepconj P (wand P Q)) Q) (wand P Q) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : pureconj (aimp (sepconj P (wand P Q)) Q) (wand P Q) h"
                ],
                "tactic_res": [
                    "c9_goal : aimp (sepconj P (wand P Q)) Q",
                    "c10_goal : wand P Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : wand P Q h",
                    "c7_W : wand P Q h",
                    "c4_h : heap",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : aimp (sepconj P (wand P Q)) Q",
                    "_global_wand_cancel : forall P Q : assertion, aimp (sepconj P (wand P Q)) Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o ) _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( R & A & B ) h' D Ph' .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : aexists (fun R : assertion => pureconj (aimp (sepconj P R) Q) R)\n        h, wand P Q h"
                ],
                "tactic_res": [
                    "c11_goal : Q (hunion h h')",
                    "c11_R : assertion",
                    "c11_A : aimp (sepconj P R) Q",
                    "c11_B : R h",
                    "c11_h' : heap",
                    "c11_D : hdisjoint h h'",
                    "c11_Ph' : P h'"
                ]
            },
            {
                "tactic_sig": "assert ( D' : hdisjoint _i _i ) by ( apply hdisjoint_sym ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( D' : hdisjoint _i _i ) by ( apply hdisjoint_sym ; auto ) .",
                "tactic_args": [
                    "c11_h' : heap",
                    "c4_h : heap",
                    "c11_Ph' : P h'",
                    "c11_D : hdisjoint h h'",
                    "c11_B : R h",
                    "c11_A : aimp (sepconj P R) Q",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c11_D' : hdisjoint h' h"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c11_goal : Q (hunion h h')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c11_D' : hdisjoint h' h",
                    "c11_Ph' : P h'",
                    "c11_D : hdisjoint h h'",
                    "c11_h' : heap",
                    "c11_B : R h",
                    "c11_A : aimp (sepconj P R) Q",
                    "c4_h : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c12_goal : Q (hunion h' h)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Q (hunion h' h)",
                    "c11_A : aimp (sepconj P R) Q"
                ],
                "tactic_res": [
                    "c13_goal : sepconj P R (hunion h' h)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c13_goal : sepconj P R (hunion h' h)",
                    "c11_h' : heap",
                    "c4_h : heap"
                ],
                "tactic_res": [
                    "c14_goal : and (P h')\n  (and (R h) (and (hdisjoint h' h) (eq (hunion h' h) (hunion h' h))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : and (P h')\n  (and (R h) (and (hdisjoint h' h) (eq (hunion h' h) (hunion h' h))))",
                    "c11_D' : hdisjoint h' h",
                    "c11_Ph' : P h'",
                    "c11_h' : heap",
                    "c11_B : R h",
                    "c11_R : assertion",
                    "c4_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_equiv",
        "proof": [
            {
                "tactic_sig": "Lemma wand_equiv : forall P Q R , ( P -->> ( Q --* R ) ) <- > ( P ** Q -->> R ) .",
                "tactic_sig_no_out_arg": "Lemma wand_equiv : forall P Q R , ( P -->> ( Q --* R ) ) <- > ( P ** Q -->> R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q R : assertion,\niff (aimp P (wand Q R)) (aimp (sepconj P Q) R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q R .",
                "tactic_args": [
                    "c1_goal : forall P Q R : assertion,\niff (aimp P (wand Q R)) (aimp (sepconj P Q) R)"
                ],
                "tactic_res": [
                    "c2_goal : iff (aimp P (wand Q R)) (aimp (sepconj P Q) R)",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : iff (aimp P (wand Q R)) (aimp (sepconj P Q) R)"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : aimp P (wand Q R), aimp (sepconj P Q) R",
                    "c4_goal : forall _ : aimp (sepconj P Q) R, aimp P (wand Q R)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c3_goal : forall _ : aimp P (wand Q R), aimp (sepconj P Q) R"
                ],
                "tactic_res": [
                    "c5_goal : aimp (sepconj P Q) R",
                    "c5_H : aimp P (wand Q R)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c4_goal : forall _ : aimp (sepconj P Q) R, aimp P (wand Q R)"
                ],
                "tactic_res": [
                    "c6_goal : aimp P (wand Q R)",
                    "c6_H : aimp (sepconj P Q) R"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( h1 & h2 & Ph1 & Wh2 & D & U ) .",
                "tactic_args": [
                    "c5_goal : aimp (sepconj P Q) R"
                ],
                "tactic_res": [
                    "c7_goal : R h",
                    "c7_h : heap",
                    "c7_h1 : heap",
                    "c7_h2 : heap",
                    "c7_Ph1 : P h1",
                    "c7_Wh2 : Q h2",
                    "c7_D : hdisjoint h1 h2",
                    "c7_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c7_goal : R h",
                    "c7_h : heap",
                    "c7_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c8_goal : R (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : R (hunion h1 h2)",
                    "c5_H : aimp P (wand Q R)"
                ],
                "tactic_res": [
                    "c9_goal : P h1",
                    "c10_goal : hdisjoint h1 h2",
                    "c11_goal : Q h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P h1",
                    "c7_Ph1 : P h1",
                    "c7_h1 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : hdisjoint h1 h2",
                    "c7_D : hdisjoint h1 h2",
                    "c7_h1 : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Q h2",
                    "c7_Wh2 : Q h2",
                    "c7_h2 : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : aimp P (wand Q R)",
                    "_global_wand_intro : forall (P Q R : assertion) (_ : aimp (sepconj P Q) R),\n       aimp P (wand Q R)"
                ],
                "tactic_res": [
                    "c12_goal : aimp (sepconj P Q) R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : aimp (sepconj P Q) R",
                    "c6_H : aimp (sepconj P Q) R",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_imp_l",
        "proof": [
            {
                "tactic_sig": "Lemma wand_imp_l : forall P P' Q , ( P' -->> P ) -> ( P --* Q -->> P' --* Q ) .",
                "tactic_sig_no_out_arg": "Lemma wand_imp_l : forall P P' Q , ( P' -->> P ) -> ( P --* Q -->> P' --* Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P P' Q : assertion) (_ : aimp P' P),\naimp (wand P Q) (wand P' Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P P' Q : assertion) (_ : aimp P' P),\naimp (wand P Q) (wand P' Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (wand P Q) (wand P' Q)",
                    "c2_P : assertion",
                    "c2_P' : assertion",
                    "c2_Q : assertion",
                    "c2_H : aimp P' P"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h W h' DISJ P'h' .",
                "tactic_args": [
                    "c2_goal : aimp (wand P Q) (wand P' Q)"
                ],
                "tactic_res": [
                    "c3_goal : Q (hunion h h')",
                    "c3_h : heap",
                    "c3_W : wand P Q h",
                    "c3_h' : heap",
                    "c3_DISJ : hdisjoint h h'",
                    "c3_P'h' : P' h'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Q (hunion h h')",
                    "c3_W : wand P Q h"
                ],
                "tactic_res": [
                    "c4_goal : hdisjoint h h'",
                    "c5_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : hdisjoint h h'",
                    "c3_DISJ : hdisjoint h h'",
                    "c3_h' : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P h'",
                    "c3_P'h' : P' h'",
                    "c3_h' : heap",
                    "c2_H : aimp P' P",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_imp_r",
        "proof": [
            {
                "tactic_sig": "Lemma wand_imp_r : forall P Q Q' , ( Q -->> Q' ) -> ( P --* Q -->> P --* Q' ) .",
                "tactic_sig_no_out_arg": "Lemma wand_imp_r : forall P Q Q' , ( Q -->> Q' ) -> ( P --* Q -->> P --* Q' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q Q' : assertion) (_ : aimp Q Q'),\naimp (wand P Q) (wand P Q')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q Q' : assertion) (_ : aimp Q Q'),\naimp (wand P Q) (wand P Q')"
                ],
                "tactic_res": [
                    "c2_goal : aimp (wand P Q) (wand P Q')",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_Q' : assertion",
                    "c2_H : aimp Q Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h W h' DISJ Ph' .",
                "tactic_args": [
                    "c2_goal : aimp (wand P Q) (wand P Q')"
                ],
                "tactic_res": [
                    "c3_goal : Q' (hunion h h')",
                    "c3_h : heap",
                    "c3_W : wand P Q h",
                    "c3_h' : heap",
                    "c3_DISJ : hdisjoint h h'",
                    "c3_Ph' : P h'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Q' (hunion h h')",
                    "c2_H : aimp Q Q'"
                ],
                "tactic_res": [
                    "c4_goal : Q (hunion h h')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Q (hunion h h')",
                    "c3_W : wand P Q h"
                ],
                "tactic_res": [
                    "c5_goal : hdisjoint h h'",
                    "c6_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : hdisjoint h h'",
                    "c3_DISJ : hdisjoint h h'",
                    "c3_h' : heap",
                    "c3_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : P h'",
                    "c3_Ph' : P h'",
                    "c3_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_idem",
        "proof": [
            {
                "tactic_sig": "Lemma wand_idem : forall P , emp -->> P --* P .",
                "tactic_sig_no_out_arg": "Lemma wand_idem : forall P , emp -->> P --* P .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : assertion, aimp emp (wand P P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P h E .",
                "tactic_args": [
                    "c1_goal : forall P : assertion, aimp emp (wand P P)"
                ],
                "tactic_res": [
                    "c2_goal : wand P P h",
                    "c2_P : assertion",
                    "c2_h : heap",
                    "c2_E : emp h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : wand P P h",
                    "c2_E : emp h"
                ],
                "tactic_res": [
                    "c3_goal : wand P P hempty"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : wand P P hempty"
                ],
                "tactic_res": [
                    "c4_goal : forall (h' : heap) (_ : hdisjoint hempty h') (_ : P h'),\nP (hunion hempty h')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (h' : heap) (_ : hdisjoint hempty h') (_ : P h'),\nP (hunion hempty h')"
                ],
                "tactic_res": [
                    "c5_goal : P (hunion hempty h')",
                    "c5_h' : heap",
                    "c5_H : hdisjoint hempty h'",
                    "c5_H0 : P h'"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : P (hunion hempty h')",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h"
                ],
                "tactic_res": [
                    "c6_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : P h'",
                    "c5_H0 : P h'",
                    "c5_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_pure_l",
        "proof": [
            {
                "tactic_sig": "Lemma wand_pure_l : forall ( P : Prop ) Q , P -> ( pure P --* Q ) = Q .",
                "tactic_sig_no_out_arg": "Lemma wand_pure_l : forall ( P : Prop ) Q , P -> ( pure P --* Q ) = Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : Prop) (Q : assertion) (_ : P), eq (wand (pure P) Q) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q PP .",
                "tactic_args": [
                    "c1_goal : forall (P : Prop) (Q : assertion) (_ : P), eq (wand (pure P) Q) Q"
                ],
                "tactic_res": [
                    "c2_goal : eq (wand (pure P) Q) Q",
                    "c2_P : Prop",
                    "c2_Q : assertion",
                    "c2_PP : P"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (wand (pure P) Q) Q",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap, iff (wand (pure P) Q h) (Q h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap, iff (wand (pure P) Q h) (Q h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (wand (pure P) Q h) (Q h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (wand (pure P) Q h) (Q h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : wand (pure P) Q h, Q h",
                    "c6_goal : forall _ : Q h, wand (pure P) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros W .",
                "tactic_args": [
                    "c5_goal : forall _ : wand (pure P) Q h, Q h"
                ],
                "tactic_res": [
                    "c7_goal : Q h",
                    "c7_W : wand (pure P) Q h"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i by HDISJ .",
                "tactic_args": [
                    "c7_goal : Q h",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c7_W : wand (pure P) Q h",
                    "c4_h : heap",
                    "c2_PP : P",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c8_goal : Q (hunion h hempty)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Q (hunion h hempty)",
                    "c7_W : wand (pure P) Q h"
                ],
                "tactic_res": [
                    "c9_goal : hdisjoint h hempty",
                    "c10_goal : pure P hempty"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c9_goal : hdisjoint h hempty",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c10_goal : pure P hempty"
                ],
                "tactic_res": [
                    "c11_goal : P",
                    "c12_goal : eq hempty hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : P",
                    "c2_PP : P",
                    "c2_P : Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq hempty hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros Qh h' DISJ ( Ph' & E ) .",
                "tactic_args": [
                    "c6_goal : forall _ : Q h, wand (pure P) Q h"
                ],
                "tactic_res": [
                    "c13_goal : Q (hunion h h')",
                    "c13_Qh : Q h",
                    "c13_h' : heap",
                    "c13_DISJ : hdisjoint h h'",
                    "c13_Ph' : P",
                    "c13_E : eq h' hempty"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c13_goal : Q (hunion h h')",
                    "c13_h' : heap",
                    "c13_E : eq h' hempty"
                ],
                "tactic_res": [
                    "c14_goal : Q (hunion h hempty)",
                    "c14_DISJ : hdisjoint h hempty"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i , _i by HDISJ .",
                "tactic_args": [
                    "c14_goal : Q (hunion h hempty)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "c13_Ph' : P",
                    "c14_DISJ : hdisjoint h hempty",
                    "c13_Qh : Q h",
                    "c4_h : heap",
                    "c2_PP : P",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c15_goal : Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Q h",
                    "c13_Qh : Q h",
                    "c4_h : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_curry",
        "proof": [
            {
                "tactic_sig": "Lemma wand_curry : forall P Q R , ( P ** Q --* R ) = ( P --* Q --* R ) .",
                "tactic_sig_no_out_arg": "Lemma wand_curry : forall P Q R , ( P ** Q --* R ) = ( P --* Q --* R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q R : assertion, eq (wand (sepconj P Q) R) (wand P (wand Q R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros P Q R .",
                "tactic_args": [
                    "c1_goal : forall P Q R : assertion, eq (wand (sepconj P Q) R) (wand P (wand Q R))"
                ],
                "tactic_res": [
                    "c2_goal : eq (wand (sepconj P Q) R) (wand P (wand Q R))",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : eq (wand (sepconj P Q) R) (wand P (wand Q R))",
                    "_global_assertion_extensionality : forall (P Q : assertion) (_ : forall h : heap, iff (P h) (Q h)),\n       eq P Q"
                ],
                "tactic_res": [
                    "c3_goal : forall h : heap, iff (wand (sepconj P Q) R h) (wand P (wand Q R) h)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall h : heap, iff (wand (sepconj P Q) R h) (wand P (wand Q R) h)"
                ],
                "tactic_res": [
                    "c4_goal : iff (wand (sepconj P Q) R h) (wand P (wand Q R) h)",
                    "c4_h : heap"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (wand (sepconj P Q) R h) (wand P (wand Q R) h)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : wand (sepconj P Q) R h, wand P (wand Q R) h",
                    "c6_goal : forall _ : wand P (wand Q R) h, wand (sepconj P Q) R h"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros W h1 D1 Ph1 h2 D2 Qh2 .",
                "tactic_args": [
                    "c5_goal : forall _ : wand (sepconj P Q) R h, wand P (wand Q R) h"
                ],
                "tactic_res": [
                    "c7_goal : R (hunion (hunion h h1) h2)",
                    "c7_W : wand (sepconj P Q) R h",
                    "c7_h1 : heap",
                    "c7_D1 : hdisjoint h h1",
                    "c7_Ph1 : P h1",
                    "c7_h2 : heap",
                    "c7_D2 : hdisjoint (hunion h h1) h2",
                    "c7_Qh2 : Q h2"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : R (hunion (hunion h h1) h2)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c8_goal : R (hunion h (hunion h1 h2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : R (hunion h (hunion h1 h2))",
                    "c7_W : wand (sepconj P Q) R h"
                ],
                "tactic_res": [
                    "c9_goal : hdisjoint h (hunion h1 h2)",
                    "c10_goal : sepconj P Q (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c9_goal : hdisjoint h (hunion h1 h2)",
                    "c7_D2 : hdisjoint (hunion h h1) h2",
                    "c7_h2 : heap",
                    "c7_D1 : hdisjoint h h1",
                    "c7_h1 : heap",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c10_goal : sepconj P Q (hunion h1 h2)",
                    "c7_h1 : heap",
                    "c7_h2 : heap"
                ],
                "tactic_res": [
                    "c11_goal : and (P h1)\n  (and (Q h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c11_goal : and (P h1)\n  (and (Q h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))",
                    "c7_Qh2 : Q h2",
                    "c7_D2 : hdisjoint (hunion h h1) h2",
                    "c7_h2 : heap",
                    "c7_Ph1 : P h1",
                    "c7_D1 : hdisjoint h h1",
                    "c7_h1 : heap",
                    "c7_W : wand (sepconj P Q) R h",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c12_goal : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c12_goal : hdisjoint h1 h2",
                    "c7_D2 : hdisjoint (hunion h h1) h2",
                    "c7_h2 : heap",
                    "c7_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros W h' D ( h1 & h2 & Ph1 & Qh2 & D12 & U12 ) .",
                "tactic_args": [
                    "c6_goal : forall _ : wand P (wand Q R) h, wand (sepconj P Q) R h"
                ],
                "tactic_res": [
                    "c13_goal : R (hunion h h')",
                    "c13_W : wand P (wand Q R) h",
                    "c13_h' : heap",
                    "c13_D : hdisjoint h h'",
                    "c13_h1 : heap",
                    "c13_h2 : heap",
                    "c13_Ph1 : P h1",
                    "c13_Qh2 : Q h2",
                    "c13_D12 : hdisjoint h1 h2",
                    "c13_U12 : eq h' (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c13_goal : R (hunion h h')",
                    "c13_h' : heap",
                    "c13_U12 : eq h' (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c14_goal : R (hunion h (hunion h1 h2))",
                    "c14_D : hdisjoint h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c14_goal : R (hunion h (hunion h1 h2))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c15_goal : R (hunion (hunion h h1) h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : R (hunion (hunion h h1) h2)",
                    "c13_W : wand P (wand Q R) h"
                ],
                "tactic_res": [
                    "c16_goal : hdisjoint h h1",
                    "c17_goal : P h1",
                    "c18_goal : hdisjoint (hunion h h1) h2",
                    "c19_goal : Q h2"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c16_goal : hdisjoint h h1",
                    "c14_D : hdisjoint h (hunion h1 h2)",
                    "c13_h1 : heap",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : P h1",
                    "c13_Ph1 : P h1",
                    "c13_h1 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c18_goal : hdisjoint (hunion h h1) h2",
                    "c13_D12 : hdisjoint h1 h2",
                    "c14_D : hdisjoint h (hunion h1 h2)",
                    "c13_h1 : heap",
                    "c13_h2 : heap",
                    "c4_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Q h2",
                    "c13_Qh2 : Q h2",
                    "c13_h2 : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wand_star",
        "proof": [
            {
                "tactic_sig": "Lemma wand_star : forall P Q R , ( ( P --* Q ) ** R ) -->> ( P --* ( Q ** R ) ) .",
                "tactic_sig_no_out_arg": "Lemma wand_star : forall P Q R , ( ( P --* Q ) ** R ) -->> ( P --* ( Q ** R ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P Q R : assertion,\naimp (sepconj (wand P Q) R) (wand P (sepconj Q R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall P Q R : assertion,\naimp (sepconj (wand P Q) R) (wand P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (wand P Q) R) (wand P (sepconj Q R))",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( h1 & h2 & W1 & R2 & D & U ) .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (wand P Q) R) (wand P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c3_goal : wand P (sepconj Q R) h",
                    "c3_h : heap",
                    "c3_h1 : heap",
                    "c3_h2 : heap",
                    "c3_W1 : wand P Q h1",
                    "c3_R2 : R h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : wand P (sepconj Q R) h",
                    "c3_h : heap",
                    "c3_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c4_goal : wand P (sepconj Q R) (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h' D' Ph' .",
                "tactic_args": [
                    "c4_goal : wand P (sepconj Q R) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c5_goal : sepconj Q R (hunion (hunion h1 h2) h')",
                    "c5_h' : heap",
                    "c5_D' : hdisjoint (hunion h1 h2) h'",
                    "c5_Ph' : P h'"
                ]
            },
            {
                "tactic_sig": "exists ( hunion _i _i ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hunion _i _i ) , _i .",
                "tactic_args": [
                    "c5_goal : sepconj Q R (hunion (hunion h1 h2) h')",
                    "c3_h1 : heap",
                    "c5_h' : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": [
                    "c6_goal : and (Q (hunion h1 h'))\n  (and (R h2)\n     (and (hdisjoint (hunion h1 h') h2)\n        (eq (hunion (hunion h1 h2) h') (hunion (hunion h1 h') h2))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c6_goal : and (Q (hunion h1 h'))\n  (and (R h2)\n     (and (hdisjoint (hunion h1 h') h2)\n        (eq (hunion (hunion h1 h2) h') (hunion (hunion h1 h') h2))))",
                    "c5_Ph' : P h'",
                    "c5_D' : hdisjoint (hunion h1 h2) h'",
                    "c5_h' : heap",
                    "c3_D : hdisjoint h1 h2",
                    "c3_R2 : R h2",
                    "c3_W1 : wand P Q h1",
                    "c3_h1 : heap",
                    "c3_h2 : heap",
                    "c2_Q : assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c7_goal : Q (hunion h1 h')",
                    "c8_goal : hdisjoint (hunion h1 h') h2",
                    "c9_goal : eq (hunion (hunion h1 h2) h') (hunion (hunion h1 h') h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Q (hunion h1 h')",
                    "c3_W1 : wand P Q h1"
                ],
                "tactic_res": [
                    "c10_goal : hdisjoint h1 h'",
                    "c11_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : P h'",
                    "c5_Ph' : P h'",
                    "c5_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c10_goal : hdisjoint h1 h'",
                    "c5_D' : hdisjoint (hunion h1 h2) h'",
                    "c5_h' : heap",
                    "c3_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c8_goal : hdisjoint (hunion h1 h') h2",
                    "c5_D' : hdisjoint (hunion h1 h2) h'",
                    "c5_h' : heap",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c9_goal : eq (hunion (hunion h1 h2) h') (hunion (hunion h1 h') h2)",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c12_goal : eq (hunion h1 (hunion h2 h')) (hunion h1 (hunion h' h2))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c12_goal : eq (hunion h1 (hunion h2 h')) (hunion h1 (hunion h' h2))"
                ],
                "tactic_res": [
                    "c13_goal : eq (hunion h2 h') (hunion h' h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eq (hunion h2 h') (hunion h' h2)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c14_goal : hdisjoint h' h2"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c14_goal : hdisjoint h' h2",
                    "c5_D' : hdisjoint (hunion h1 h2) h'",
                    "c5_h' : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "param_precise_precise",
        "proof": [
            {
                "tactic_sig": "Remark param_precise_precise : forall ( X : Type ) ( P : X -> assertion ) , param_precise P -> forall x , precise ( P x ) .",
                "tactic_sig_no_out_arg": "Remark param_precise_precise : forall ( X : Type ) ( P : X -> assertion ) , param_precise P -> forall x , precise ( P x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P)\n  (x : X), precise (P x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros X P H x .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P)\n  (x : X), precise (P x)"
                ],
                "tactic_res": [
                    "c2_goal : precise (P x)",
                    "c2_X : Type",
                    "c2_P : forall _ : X, assertion",
                    "c2_H : param_precise P",
                    "c2_x : X"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : precise (P x)"
                ],
                "tactic_res": [
                    "c3_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : P x h1) (_ : P x h1'), eq h1 h1'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 h1' h2' H0 H1 H2 H3 H4 .",
                "tactic_args": [
                    "c3_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : P x h1) (_ : P x h1'), eq h1 h1'"
                ],
                "tactic_res": [
                    "c4_goal : eq h1 h1'",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H3 : P x h1",
                    "c4_H4 : P x h1'"
                ]
            },
            {
                "tactic_sig": "edestruct ( _i _i _i _i _i _i _i ) as [  | | | | | _o _o ] .",
                "tactic_sig_no_out_arg": "edestruct ( _i _i _i _i _i _i _i ) .",
                "tactic_args": [
                    "c4_goal : eq h1 h1'",
                    "c2_H : param_precise P",
                    "c2_x : X",
                    "c2_x : X",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": [
                    "c5_goal : hdisjoint h1 h2",
                    "c6_goal : hdisjoint h1' h2'",
                    "c7_goal : eq (hunion h1 h2) (hunion h1' h2')",
                    "c8_goal : P x h1",
                    "c9_goal : P x h1'",
                    "c10_goal : eq h1 h1'",
                    "c10_H6 : eq h1 h1'",
                    "c10_H5 : eq x x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c5_goal : hdisjoint h1 h2",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : hdisjoint h1' h2'",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_h1' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : P x h1",
                    "c4_H3 : P x h1",
                    "c4_h1 : heap",
                    "c2_x : X",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c9_goal : P x h1'",
                    "c4_H4 : P x h1'",
                    "c4_h1' : heap",
                    "c2_x : X",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c10_goal : eq h1 h1'",
                    "c10_H6 : eq h1 h1'",
                    "c4_h1 : heap",
                    "c4_h1' : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "precise_param_precise",
        "proof": [
            {
                "tactic_sig": "Remark precise_param_precise : forall P , precise P -> param_precise ( fun _ : unit => P ) .",
                "tactic_sig_no_out_arg": "Remark precise_param_precise : forall P , precise P -> param_precise ( fun _ : unit => P ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (_ : precise P),\nparam_precise (fun _ : unit => P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros P H .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (_ : precise P),\nparam_precise (fun _ : unit => P)"
                ],
                "tactic_res": [
                    "c2_goal : param_precise (fun _ : unit => P)",
                    "c2_P : assertion",
                    "c2_H : precise P"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : param_precise (fun _ : unit => P)"
                ],
                "tactic_res": [
                    "c3_goal : forall (x1 x2 : unit) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : P h1) (_ : P h1'), and (eq x1 x2) (eq h1 h1')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x1 x2 h1 h2 h1' h2' H0 H1 H2 H3 H4 .",
                "tactic_args": [
                    "c3_goal : forall (x1 x2 : unit) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : P h1) (_ : P h1'), and (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c4_goal : and (eq x1 x2) (eq h1 h1')",
                    "c4_x1 : unit",
                    "c4_x2 : unit",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H3 : P h1",
                    "c4_H4 : P h1'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : and (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c5_goal : eq x1 x2",
                    "c6_goal : eq h1 h1'"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [  ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "c5_goal : eq x1 x2",
                    "c4_x1 : unit",
                    "c4_x2 : unit",
                    "c4_H4 : P h1'",
                    "c4_H3 : P h1",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H0 : hdisjoint h1 h2",
                    "c2_H : precise P"
                ],
                "tactic_res": [
                    "c7_goal : eq tt tt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq tt tt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : eq h1 h1'",
                    "c4_H4 : P h1'",
                    "c4_H3 : P h1",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h1' : heap",
                    "c2_H : precise P"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pure_precise",
        "proof": [
            {
                "tactic_sig": "Lemma pure_precise : forall P , precise ( pure P ) .",
                "tactic_sig_no_out_arg": "Lemma pure_precise : forall P , precise ( pure P ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P : Prop, precise (pure P)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall P : Prop, precise (pure P)",
                    "_global_pure : forall _ : Prop, assertion"
                ],
                "tactic_res": [
                    "c2_goal : forall P : Prop, precise (fun h : heap => and P (eq h hempty))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros P .",
                "tactic_args": [
                    "c2_goal : forall P : Prop, precise (fun h : heap => and P (eq h hempty))"
                ],
                "tactic_res": [
                    "c3_goal : precise (fun h : heap => and P (eq h hempty))",
                    "c3_P : Prop"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : precise (fun h : heap => and P (eq h hempty))"
                ],
                "tactic_res": [
                    "c4_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : and P (eq h1 hempty)) (_ : and P (eq h1' hempty)), \neq h1 h1'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 h1' h2' H H0 H1 H2 H3 .",
                "tactic_args": [
                    "c4_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : and P (eq h1 hempty)) (_ : and P (eq h1' hempty)), \neq h1 h1'"
                ],
                "tactic_res": [
                    "c5_goal : eq h1 h1'",
                    "c5_h1 : heap",
                    "c5_h2 : heap",
                    "c5_h1' : heap",
                    "c5_h2' : heap",
                    "c5_H : hdisjoint h1 h2",
                    "c5_H0 : hdisjoint h1' h2'",
                    "c5_H1 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c5_H2 : and P (eq h1 hempty)",
                    "c5_H3 : and P (eq h1' hempty)"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "c5_H2 : and P (eq h1 hempty)",
                    "c5_H3 : and P (eq h1' hempty)",
                    "c5_H1 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c5_H0 : hdisjoint h1' h2'",
                    "c5_H : hdisjoint h1 h2",
                    "c5_h1 : heap",
                    "c5_h1' : heap"
                ],
                "tactic_res": [
                    "c5_H5 : eq h1' hempty",
                    "c5_H3 : P",
                    "c5_H4 : eq h1 hempty",
                    "c5_H2 : P"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c5_goal : eq h1 h1'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pure_param_precise",
        "proof": [
            {
                "tactic_sig": "Lemma pure_param_precise : forall ( X : Type ) ( P : X -> Prop ) , ( forall x1 x2 , P x1 -> P x2 -> x1 = x2 ) -> param_precise ( fun x => pure ( P x ) ) .",
                "tactic_sig_no_out_arg": "Lemma pure_param_precise : forall ( X : Type ) ( P : X -> Prop ) , ( forall x1 x2 , P x1 -> P x2 -> x1 = x2 ) -> param_precise ( fun x => pure ( P x ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, Prop)\n  (_ : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2),\nparam_precise (fun x : X => pure (P x))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, Prop)\n  (_ : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2),\nparam_precise (fun x : X => pure (P x))",
                    "_global_pure : forall _ : Prop, assertion"
                ],
                "tactic_res": [
                    "c2_goal : forall (X : Type) (P : forall _ : X, Prop)\n  (_ : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2),\nparam_precise (fun (x : X) (h : heap) => and (P x) (eq h hempty))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros X P H .",
                "tactic_args": [
                    "c2_goal : forall (X : Type) (P : forall _ : X, Prop)\n  (_ : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2),\nparam_precise (fun (x : X) (h : heap) => and (P x) (eq h hempty))"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (fun (x : X) (h : heap) => and (P x) (eq h hempty))",
                    "c3_X : Type",
                    "c3_P : forall _ : X, Prop",
                    "c3_H : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : param_precise (fun (x : X) (h : heap) => and (P x) (eq h hempty))"
                ],
                "tactic_res": [
                    "c4_goal : forall (x1 x2 : X) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : and (P x1) (eq h1 hempty)) (_ : and (P x2) (eq h1' hempty)),\nand (eq x1 x2) (eq h1 h1')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x1 x2 h1 h2 h1' h2' H0 H1 H2 H3 H4 .",
                "tactic_args": [
                    "c4_goal : forall (x1 x2 : X) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : and (P x1) (eq h1 hempty)) (_ : and (P x2) (eq h1' hempty)),\nand (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c5_goal : and (eq x1 x2) (eq h1 h1')",
                    "c5_x1 : X",
                    "c5_x2 : X",
                    "c5_h1 : heap",
                    "c5_h2 : heap",
                    "c5_h1' : heap",
                    "c5_h2' : heap",
                    "c5_H0 : hdisjoint h1 h2",
                    "c5_H1 : hdisjoint h1' h2'",
                    "c5_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c5_H3 : and (P x1) (eq h1 hempty)",
                    "c5_H4 : and (P x2) (eq h1' hempty)"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "c5_H3 : and (P x1) (eq h1 hempty)",
                    "c5_H4 : and (P x2) (eq h1' hempty)",
                    "c5_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c5_H1 : hdisjoint h1' h2'",
                    "c5_H0 : hdisjoint h1 h2",
                    "c5_h1 : heap",
                    "c5_h1' : heap",
                    "c5_x1 : X",
                    "c5_x2 : X",
                    "c3_H : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2",
                    "c3_X : Type"
                ],
                "tactic_res": [
                    "c5_H6 : eq h1' hempty",
                    "c5_H4 : P x2",
                    "c5_H5 : eq h1 hempty",
                    "c5_H3 : P x1"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c6_goal : eq x1 x2",
                    "c7_goal : eq h1 h1'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq x1 x2",
                    "c5_H4 : P x2",
                    "c5_H3 : P x1",
                    "c5_x1 : X",
                    "c5_x2 : X",
                    "c3_H : forall (x1 x2 : X) (_ : P x1) (_ : P x2), eq x1 x2",
                    "c3_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c7_goal : eq h1 h1'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "contains_param_precise",
        "proof": [
            {
                "tactic_sig": "Lemma contains_param_precise : forall l , param_precise ( fun v => contains l v ) .",
                "tactic_sig_no_out_arg": "Lemma contains_param_precise : forall l , param_precise ( fun v => contains l v ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall l : addr, param_precise (fun v : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall l : addr, param_precise (fun v : Z => contains l v)",
                    "_global_contains : forall (_ : addr) (_ : Z), assertion"
                ],
                "tactic_res": [
                    "c2_goal : forall l : addr,\nparam_precise (fun (v : Z) (h : heap) => eq h (hupdate l v hempty))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c2_goal : forall l : addr,\nparam_precise (fun (v : Z) (h : heap) => eq h (hupdate l v hempty))"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (fun (v : Z) (h : heap) => eq h (hupdate l v hempty))",
                    "c3_l : addr"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : param_precise (fun (v : Z) (h : heap) => eq h (hupdate l v hempty))"
                ],
                "tactic_res": [
                    "c4_goal : forall (x1 x2 : Z) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : eq h1 (hupdate l x1 hempty)) (_ : eq h1' (hupdate l x2 hempty)),\nand (eq x1 x2) (eq h1 h1')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x1 x2 h1 h2 h1' h2' H H0 H1 H2 H3 .",
                "tactic_args": [
                    "c4_goal : forall (x1 x2 : Z) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : eq h1 (hupdate l x1 hempty)) (_ : eq h1' (hupdate l x2 hempty)),\nand (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c5_goal : and (eq x1 x2) (eq h1 h1')",
                    "c5_x1 : Z",
                    "c5_x2 : Z",
                    "c5_h1 : heap",
                    "c5_h2 : heap",
                    "c5_h1' : heap",
                    "c5_h2' : heap",
                    "c5_H : hdisjoint h1 h2",
                    "c5_H0 : hdisjoint h1' h2'",
                    "c5_H1 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c5_H2 : eq h1 (hupdate l x1 hempty)",
                    "c5_H3 : eq h1' (hupdate l x2 hempty)"
                ]
            },
            {
                "tactic_sig": "assert ( E : hunion _i _i _i = hunion _i _i _i ) by congruence .",
                "tactic_sig_no_out_arg": "assert ( E : hunion _i _i _i = hunion _i _i _i ) by congruence .",
                "tactic_args": [
                    "c5_h1 : heap",
                    "c5_h2 : heap",
                    "c3_l : addr",
                    "c5_h1' : heap",
                    "c5_h2' : heap",
                    "c3_l : addr"
                ],
                "tactic_res": [
                    "c5_E : eq (hunion h1 h2 l) (hunion h1' h2' l)"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c5_E : eq (hunion h1 h2 l) (hunion h1' h2' l)"
                ],
                "tactic_res": [
                    "c5_E : eq (if h1 l then h1 l else h2 l) (if h1' l then h1' l else h2' l)"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c5_goal : and (eq x1 x2) (eq h1 h1')",
                    "c5_h1 : heap",
                    "c5_h1' : heap",
                    "c5_H3 : eq h1' (hupdate l x2 hempty)",
                    "c5_H2 : eq h1 (hupdate l x1 hempty)"
                ],
                "tactic_res": [
                    "c6_goal : and (eq x1 x2) (eq (hupdate l x1 hempty) (hupdate l x2 hempty))",
                    "c6_E : eq (if hupdate l x1 hempty l then hupdate l x1 hempty l else h2 l)\n  (if hupdate l x2 hempty l then hupdate l x2 hempty l else h2' l)",
                    "c6_H0 : hdisjoint (hupdate l x2 hempty) h2'",
                    "c6_H1 : eq (hunion (hupdate l x1 hempty) h2) (hunion (hupdate l x2 hempty) h2')",
                    "c6_H : hdisjoint (hupdate l x1 hempty) h2"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i in _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i in _i .",
                "tactic_args": [
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)",
                    "c6_E : eq (if hupdate l x1 hempty l then hupdate l x1 hempty l else h2 l)\n  (if hupdate l x2 hempty l then hupdate l x2 hempty l else h2' l)"
                ],
                "tactic_res": [
                    "c6_E : eq (Some x1) (Some x2)"
                ]
            },
            {
                "tactic_sig": "replace _i with _i by congruence .",
                "tactic_sig_no_out_arg": "replace _i with _i by congruence .",
                "tactic_args": [
                    "c6_goal : and (eq x1 x2) (eq (hupdate l x1 hempty) (hupdate l x2 hempty))",
                    "c5_x2 : Z",
                    "c5_x1 : Z"
                ],
                "tactic_res": [
                    "c7_goal : and (eq x1 x1) (eq (hupdate l x1 hempty) (hupdate l x1 hempty))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : and (eq x1 x1) (eq (hupdate l x1 hempty) (hupdate l x1 hempty))",
                    "c5_x1 : Z",
                    "c3_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "contains_precise",
        "proof": [
            {
                "tactic_sig": "Lemma contains_precise : forall l v , precise ( contains l v ) .",
                "tactic_sig_no_out_arg": "Lemma contains_precise : forall l v , precise ( contains l v ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z), precise (contains l v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z), precise (contains l v)"
                ],
                "tactic_res": [
                    "c2_goal : precise (contains l v)",
                    "c2_l : addr",
                    "c2_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : precise (contains l v)",
                    "_global_param_precise_precise : forall (X : Type) (P : forall _ : X, assertion) \n         (_ : param_precise P) (x : X), precise (P x)"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (contains l)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : param_precise (contains l)",
                    "_global_contains_param_precise : forall l : addr, param_precise (fun v : Z => contains l v)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "aexists_precise",
        "proof": [
            {
                "tactic_sig": "Lemma aexists_precise : forall ( X : Type ) ( P : X -> assertion ) , param_precise P -> precise ( aexists P ) .",
                "tactic_sig_no_out_arg": "Lemma aexists_precise : forall ( X : Type ) ( P : X -> assertion ) , param_precise P -> precise ( aexists P ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P),\nprecise (aexists P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros X P H .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P),\nprecise (aexists P)"
                ],
                "tactic_res": [
                    "c2_goal : precise (aexists P)",
                    "c2_X : Type",
                    "c2_P : forall _ : X, assertion",
                    "c2_H : param_precise P"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : precise (aexists P)"
                ],
                "tactic_res": [
                    "c3_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : aexists P h1) (_ : aexists P h1'), eq h1 h1'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h1 h2 h1' h2' H0 H1 H2 H3 H4 .",
                "tactic_args": [
                    "c3_goal : forall (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : aexists P h1) (_ : aexists P h1'), eq h1 h1'"
                ],
                "tactic_res": [
                    "c4_goal : eq h1 h1'",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H3 : aexists P h1",
                    "c4_H4 : aexists P h1'"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( x1 & P1 ) , _i as ( x2 & P2 ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( x1 & P1 ) , _i as ( x2 & P2 ) .",
                "tactic_args": [
                    "c4_H3 : aexists P h1",
                    "c4_H4 : aexists P h1'",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h1' : heap",
                    "c2_H : param_precise P"
                ],
                "tactic_res": [
                    "c4_P2 : P x2 h1'",
                    "c4_x2 : X",
                    "c4_P1 : P x1 h1",
                    "c4_x1 : X"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c4_goal : eq h1 h1'",
                    "c2_H : param_precise P"
                ],
                "tactic_res": [
                    "c5_goal : hdisjoint h1 ?h2",
                    "c6_goal : hdisjoint h1' ?h2'",
                    "c7_goal : eq (hunion h1 h2) (hunion h1' h2')",
                    "c8_goal : P ?x1 h1",
                    "c9_goal : P ?x2 h1'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c5_goal : hdisjoint h1 ?h2",
                    "c4_H0 : hdisjoint h1 h2",
                    "c4_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : hdisjoint h1' ?h2'",
                    "c4_H1 : hdisjoint h1' h2'",
                    "c4_h1' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H2 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : P ?x1 h1",
                    "c4_P1 : P x1 h1",
                    "c4_h1 : heap",
                    "c2_P : forall _ : X, assertion",
                    "c2_X : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c9_goal : P ?x2 h1'",
                    "c4_P2 : P x2 h1'",
                    "c4_h1' : heap",
                    "c2_P : forall _ : X, assertion",
                    "c2_X : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_precise",
        "proof": [
            {
                "tactic_sig": "Lemma valid_precise : forall l , precise ( valid l ) .",
                "tactic_sig_no_out_arg": "Lemma valid_precise : forall l , precise ( valid l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall l : addr, precise (valid l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c1_goal : forall l : addr, precise (valid l)"
                ],
                "tactic_res": [
                    "c2_goal : precise (valid l)",
                    "c2_l : addr"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : precise (valid l)",
                    "_global_aexists_precise : forall (X : Type) (P : forall _ : X, assertion) (_ : param_precise P),\n       precise (aexists P)"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (contains l)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : param_precise (contains l)",
                    "_global_contains_param_precise : forall l : addr, param_precise (fun v : Z => contains l v)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_param_precise",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_param_precise : forall ( X : Type ) ( P Q : X -> assertion ) , param_precise P -> ( forall x , precise ( Q x ) ) -> param_precise ( fun x => P x ** Q x ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_param_precise : forall ( X : Type ) ( P Q : X -> assertion ) , param_precise P -> ( forall x , precise ( Q x ) ) -> param_precise ( fun x => P x ** Q x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (P Q : forall _ : X, assertion) \n  (_ : param_precise P) (_ : forall x : X, precise (Q x)),\nparam_precise (fun x : X => sepconj (P x) (Q x))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros X P Q H H0 .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (P Q : forall _ : X, assertion) \n  (_ : param_precise P) (_ : forall x : X, precise (Q x)),\nparam_precise (fun x : X => sepconj (P x) (Q x))"
                ],
                "tactic_res": [
                    "c2_goal : param_precise (fun x : X => sepconj (P x) (Q x))",
                    "c2_X : Type",
                    "c2_P : forall _ : X, assertion",
                    "c2_Q : forall _ : X, assertion",
                    "c2_H : param_precise P",
                    "c2_H0 : forall x : X, precise (Q x)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : param_precise (fun x : X => sepconj (P x) (Q x))"
                ],
                "tactic_res": [
                    "c3_goal : forall (x1 x2 : X) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : sepconj (P x1) (Q x1) h1) (_ : sepconj (P x2) (Q x2) h1'),\nand (eq x1 x2) (eq h1 h1')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x1 x2 h1 h2 h1' h2' H1 H2 H3 H4 H5 .",
                "tactic_args": [
                    "c3_goal : forall (x1 x2 : X) (h1 h2 h1' h2' : heap) (_ : hdisjoint h1 h2)\n  (_ : hdisjoint h1' h2') (_ : eq (hunion h1 h2) (hunion h1' h2'))\n  (_ : sepconj (P x1) (Q x1) h1) (_ : sepconj (P x2) (Q x2) h1'),\nand (eq x1 x2) (eq h1 h1')"
                ],
                "tactic_res": [
                    "c4_goal : and (eq x1 x2) (eq h1 h1')",
                    "c4_x1 : X",
                    "c4_x2 : X",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_h1' : heap",
                    "c4_h2' : heap",
                    "c4_H1 : hdisjoint h1 h2",
                    "c4_H2 : hdisjoint h1' h2'",
                    "c4_H3 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H4 : sepconj (P x1) (Q x1) h1",
                    "c4_H5 : sepconj (P x2) (Q x2) h1'"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( h3 & h4 & P3 & Q4 & D & E ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( h3 & h4 & P3 & Q4 & D & E ) .",
                "tactic_args": [
                    "c4_H4 : sepconj (P x1) (Q x1) h1",
                    "c4_H5 : sepconj (P x2) (Q x2) h1'",
                    "c4_H3 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H2 : hdisjoint h1' h2'",
                    "c4_H1 : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h1' : heap",
                    "c4_x1 : X",
                    "c4_x2 : X",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c2_H : param_precise P",
                    "c2_X : Type"
                ],
                "tactic_res": [
                    "c4_E : eq h1 (hunion h3 h4)",
                    "c4_D : hdisjoint h3 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_P3 : P x1 h3",
                    "c4_h4 : heap",
                    "c4_h3 : heap"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( h3' & h4' & P3' & Q4' & D' & E' ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( h3' & h4' & P3' & Q4' & D' & E' ) .",
                "tactic_args": [
                    "c4_H5 : sepconj (P x2) (Q x2) h1'",
                    "c4_E : eq h1 (hunion h3 h4)",
                    "c4_D : hdisjoint h3 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_P3 : P x1 h3",
                    "c4_H3 : eq (hunion h1 h2) (hunion h1' h2')",
                    "c4_H2 : hdisjoint h1' h2'",
                    "c4_H1 : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h1' : heap",
                    "c4_x1 : X",
                    "c4_x2 : X",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c2_H : param_precise P",
                    "c2_X : Type"
                ],
                "tactic_res": [
                    "c4_E' : eq h1' (hunion h3' h4')",
                    "c4_D' : hdisjoint h3' h4'",
                    "c4_Q4' : Q x2 h4'",
                    "c4_P3' : P x2 h3'",
                    "c4_h4' : heap",
                    "c4_h3' : heap"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c4_goal : and (eq x1 x2) (eq h1 h1')",
                    "c4_h1 : heap",
                    "c4_h1' : heap",
                    "c4_E' : eq h1' (hunion h3' h4')",
                    "c4_E : eq h1 (hunion h3 h4)"
                ],
                "tactic_res": [
                    "c5_goal : and (eq x1 x2) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i /\\ _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i /\\ _i = _i ) .",
                "tactic_args": [
                    "c5_goal : and (eq x1 x2) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c4_x1 : X",
                    "c4_x2 : X",
                    "c4_h3 : heap",
                    "c4_h3' : heap"
                ],
                "tactic_res": [
                    "c6_goal : and (eq x1 x2) (eq h3 h3')",
                    "c7_goal : and (eq x1 x2) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c7_H4 : and (eq x1 x2) (eq h3 h3')"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_args": [
                    "c6_goal : and (eq x1 x2) (eq h3 h3')",
                    "c2_H : param_precise P",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c4_h4 : heap",
                    "c4_h2 : heap",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c4_h4' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": [
                    "c8_goal : hdisjoint h3 (hunion h4 h2)",
                    "c9_goal : hdisjoint h3' (hunion h4' h2')",
                    "c10_goal : eq (hunion h3 (hunion h4 h2)) (hunion h3' (hunion h4' h2'))",
                    "c11_goal : P x1 h3",
                    "c12_goal : P x2 h3'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : P x1 h3",
                    "c4_P3 : P x1 h3",
                    "c4_h3 : heap",
                    "c4_x1 : X",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : P x2 h3'",
                    "c4_P3' : P x2 h3'",
                    "c4_h3' : heap",
                    "c4_x2 : X",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c8_goal : hdisjoint h3 (hunion h4 h2)",
                    "c4_D : hdisjoint h3 h4",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2",
                    "c4_h2 : heap",
                    "c4_h3 : heap",
                    "c4_h4 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c9_goal : hdisjoint h3' (hunion h4' h2')",
                    "c4_D' : hdisjoint h3' h4'",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i .",
                "tactic_args": [
                    "c10_goal : eq (hunion h3 (hunion h4 h2)) (hunion h3' (hunion h4' h2'))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c13_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c4_h2 : heap",
                    "c4_h2' : heap",
                    "c4_h3 : heap",
                    "c4_h4 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_H4 : and (eq x1 x2) (eq h3 h3')",
                    "c4_D' : hdisjoint h3' h4'",
                    "c4_Q4' : Q x2 h4'",
                    "c4_P3' : P x2 h3'",
                    "c4_D : hdisjoint h3 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_P3 : P x1 h3",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2",
                    "c4_h3 : heap",
                    "c4_h4 : heap",
                    "c4_x1 : X",
                    "c4_x2 : X",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c2_H : param_precise P",
                    "c2_X : Type"
                ],
                "tactic_res": [
                    "c7_H5 : eq h3 h3'",
                    "c7_H4 : eq x1 x2"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c7_goal : and (eq x1 x2) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c4_x2 : X",
                    "c7_H4 : eq x1 x2"
                ],
                "tactic_res": [
                    "c14_goal : and (eq x1 x1) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c14_P3' : P x1 h3'",
                    "c14_Q4' : Q x1 h4'"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c14_goal : and (eq x1 x1) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c4_h4 : heap",
                    "c4_h4' : heap"
                ],
                "tactic_res": [
                    "c15_goal : eq h4 h4'",
                    "c16_goal : and (eq x1 x1) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c16_H4 : eq h4 h4'"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) with ( _i _i _i ) ( _i _i _i ) .",
                "tactic_args": [
                    "c15_goal : eq h4 h4'",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c4_x1 : X",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c4_h3 : heap",
                    "c4_h2 : heap",
                    "_global_hunion : forall (_ : heap) (_ : heap), heap",
                    "c4_h3' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": [
                    "c17_goal : hdisjoint h4 (hunion h3 h2)",
                    "c18_goal : hdisjoint h4' (hunion h3' h2')",
                    "c19_goal : eq (hunion h4 (hunion h3 h2)) (hunion h4' (hunion h3' h2'))",
                    "c20_goal : Q x1 h4",
                    "c21_goal : Q x1 h4'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Q x1 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_h4 : heap",
                    "c4_x1 : X",
                    "c2_Q : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Q x1 h4'",
                    "c14_Q4' : Q x1 h4'",
                    "c4_h4' : heap",
                    "c4_x1 : X",
                    "c2_Q : forall _ : X, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c17_goal : hdisjoint h4 (hunion h3 h2)",
                    "c4_D : hdisjoint h3 h4",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2",
                    "c4_h2 : heap",
                    "c4_h3 : heap",
                    "c4_h4 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c18_goal : hdisjoint h4' (hunion h3' h2')",
                    "c4_D' : hdisjoint h3' h4'",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i .",
                "tactic_args": [
                    "c19_goal : eq (hunion h4 (hunion h3 h2)) (hunion h4' (hunion h3' h2'))",
                    "_global_hunion_assoc : forall h1 h2 h3 : heap,\n       eq (hunion (hunion h1 h2) h3) (hunion h1 (hunion h2 h3))"
                ],
                "tactic_res": [
                    "c22_goal : eq (hunion (hunion h4 h3) h2) (hunion (hunion h4' h3') h2')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c22_goal : eq (hunion (hunion h4 h3) h2) (hunion (hunion h4' h3') h2')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c4_h3 : heap",
                    "c7_H5 : eq h3 h3'",
                    "c4_D' : hdisjoint h3' h4'",
                    "c14_P3' : P x1 h3'",
                    "c14_Q4' : Q x1 h4'",
                    "c4_D : hdisjoint h3 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_P3 : P x1 h3",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2",
                    "c4_h2 : heap",
                    "c4_h2' : heap",
                    "c4_h4 : heap",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c2_H : param_precise P"
                ],
                "tactic_res": [
                    "c23_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h4' h3') h2')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) by HDISJ .",
                "tactic_args": [
                    "c23_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h4' h3') h2')",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c4_h3' : heap",
                    "c7_H5 : eq h3 h3'",
                    "c4_D' : hdisjoint h3' h4'",
                    "c14_P3' : P x1 h3'",
                    "c14_Q4' : Q x1 h4'",
                    "c4_D : hdisjoint h3 h4",
                    "c4_Q4 : Q x1 h4",
                    "c4_P3 : P x1 h3",
                    "c5_H2 : hdisjoint (hunion h3' h4') h2'",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c4_h4' : heap",
                    "c5_H1 : hdisjoint (hunion h3 h4) h2",
                    "c4_h2 : heap",
                    "c4_h2' : heap",
                    "c4_h3 : heap",
                    "c4_h4 : heap",
                    "c2_H0 : forall x : X, precise (Q x)",
                    "c2_H : param_precise P"
                ],
                "tactic_res": [
                    "c24_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c5_H3 : eq (hunion (hunion h3 h4) h2) (hunion (hunion h3' h4') h2')",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c4_h2 : heap",
                    "c4_h2' : heap",
                    "c4_h3 : heap",
                    "c4_h4 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c16_goal : and (eq x1 x1) (eq (hunion h3 h4) (hunion h3' h4'))",
                    "c4_h3 : heap",
                    "c4_h4 : heap",
                    "c16_H4 : eq h4 h4'",
                    "c7_H5 : eq h3 h3'"
                ],
                "tactic_res": [
                    "c25_goal : and (eq x1 x1) (eq (hunion h3' h4') (hunion h3' h4'))",
                    "c25_Q4 : Q x1 h4'",
                    "c25_D : hdisjoint h3' h4'",
                    "c25_P3 : P x1 h3'",
                    "c25_H1 : hdisjoint (hunion h3' h4') h2",
                    "c25_H3 : eq (hunion (hunion h3' h4') h2) (hunion (hunion h3' h4') h2')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : and (eq x1 x1) (eq (hunion h3' h4') (hunion h3' h4'))",
                    "c4_h3' : heap",
                    "c4_h4' : heap",
                    "c4_x1 : X",
                    "c2_X : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_precise",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_precise : forall P Q , precise P -> precise Q -> precise ( P ** Q ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_precise : forall P Q , precise P -> precise Q -> precise ( P ** Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P Q : assertion) (_ : precise P) (_ : precise Q),\nprecise (sepconj P Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P Q : assertion) (_ : precise P) (_ : precise Q),\nprecise (sepconj P Q)"
                ],
                "tactic_res": [
                    "c2_goal : precise (sepconj P Q)",
                    "c2_P : assertion",
                    "c2_Q : assertion",
                    "c2_H : precise P",
                    "c2_H0 : precise Q"
                ]
            },
            {
                "tactic_sig": "assert ( param_precise ( fun _ : unit => _i ** _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( param_precise ( fun _ : unit => _i ** _i ) ) .",
                "tactic_args": [
                    "c2_goal : precise (sepconj P Q)",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c3_goal : param_precise (fun _ : unit => sepconj P Q)",
                    "c4_goal : precise (sepconj P Q)",
                    "c4_H1 : param_precise (fun _ : unit => sepconj P Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : param_precise (fun _ : unit => sepconj P Q)",
                    "_global_sepconj_param_precise : forall (X : Type) (P Q : forall _ : X, assertion)\n         (_ : param_precise P) (_ : forall x : X, precise (Q x)),\n       param_precise (fun x : X => sepconj (P x) (Q x))"
                ],
                "tactic_res": [
                    "c5_goal : param_precise (fun _ : unit => P)",
                    "c6_goal : forall _ : unit, precise Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : param_precise (fun _ : unit => P)",
                    "_global_precise_param_precise : forall (P : assertion) (_ : precise P),\n       param_precise (fun _ : unit => P)"
                ],
                "tactic_res": [
                    "c7_goal : precise P"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : precise P",
                    "c2_H : precise P",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall _ : unit, precise Q",
                    "c2_H0 : precise Q",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c4_goal : precise (sepconj P Q)",
                    "_global_param_precise_precise : forall (X : Type) (P : forall _ : X, assertion) \n         (_ : param_precise P) (x : X), precise (P x)",
                    "c4_H1 : param_precise (fun _ : unit => sepconj P Q)"
                ],
                "tactic_res": [
                    "c8_goal : precise (sepconj P Q)",
                    "c8_H1 : precise (sepconj P Q)",
                    "c9_goal : unit"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : precise (sepconj P Q)",
                    "c8_H1 : precise (sepconj P Q)",
                    "c2_P : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact tt .",
                "tactic_sig_no_out_arg": "exact tt .",
                "tactic_args": [
                    "c9_goal : unit"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_and_distr_1",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_and_distr_1 : forall P1 P2 Q , aand P1 P2 ** Q -->> aand ( P1 ** Q ) ( P2 ** Q ) .",
                "tactic_sig_no_out_arg": "Lemma sepconj_and_distr_1 : forall P1 P2 Q , aand P1 P2 ** Q -->> aand ( P1 ** Q ) ( P2 ** Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall P1 P2 Q : assertion,\naimp (sepconj (aand P1 P2) Q) (aand (sepconj P1 Q) (sepconj P2 Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o ( _o & _o & ( _o & _o ) & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros P1 P2 Q h ( h1 & h2 & ( P11 & P21 ) & Q2 & D & E ) .",
                "tactic_args": [
                    "c1_goal : forall P1 P2 Q : assertion,\naimp (sepconj (aand P1 P2) Q) (aand (sepconj P1 Q) (sepconj P2 Q))"
                ],
                "tactic_res": [
                    "c2_goal : aand (sepconj P1 Q) (sepconj P2 Q) h",
                    "c2_P1 : assertion",
                    "c2_P2 : assertion",
                    "c2_Q : assertion",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_P11 : P1 h1",
                    "c2_P21 : P2 h1",
                    "c2_Q2 : Q h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_E : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : aand (sepconj P1 Q) (sepconj P2 Q) h"
                ],
                "tactic_res": [
                    "c3_goal : sepconj P1 Q h",
                    "c4_goal : sepconj P2 Q h"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c3_goal : sepconj P1 Q h",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c5_goal : and (P1 h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : and (P1 h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c2_E : eq h (hunion h1 h2)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_Q2 : Q h2",
                    "c2_P11 : P1 h1",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_P1 : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c4_goal : sepconj P2 Q h",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c6_goal : and (P2 h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : and (P2 h1) (and (Q h2) (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c2_E : eq h (hunion h1 h2)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_Q2 : Q h2",
                    "c2_P21 : P2 h1",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_P2 : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_and_distr_2",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_and_distr_2 : forall P1 P2 Q , precise Q -> aand ( P1 ** Q ) ( P2 ** Q ) -->> aand P1 P2 ** Q .",
                "tactic_sig_no_out_arg": "Lemma sepconj_and_distr_2 : forall P1 P2 Q , precise Q -> aand ( P1 ** Q ) ( P2 ** Q ) -->> aand P1 P2 ** Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P1 P2 Q : assertion) (_ : precise Q),\naimp (aand (sepconj P1 Q) (sepconj P2 Q)) (sepconj (aand P1 P2) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P1 P2 Q PQ .",
                "tactic_args": [
                    "c1_goal : forall (P1 P2 Q : assertion) (_ : precise Q),\naimp (aand (sepconj P1 Q) (sepconj P2 Q)) (sepconj (aand P1 P2) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (aand (sepconj P1 Q) (sepconj P2 Q)) (sepconj (aand P1 P2) Q)",
                    "c2_P1 : assertion",
                    "c2_P2 : assertion",
                    "c2_Q : assertion",
                    "c2_PQ : precise Q"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : aimp (aand (sepconj P1 Q) (sepconj P2 Q)) (sepconj (aand P1 P2) Q)",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "c2_P1 : assertion",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "c2_P2 : assertion"
                ],
                "tactic_res": [
                    "c3_goal : aimp (aand (sepconj Q P1) (sepconj Q P2)) (sepconj (aand P1 P2) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o ( ( _o & _o & _o & _o & _o & _o ) & ( _o & _o & _o & _o & _o & _o ) ) .",
                "tactic_sig_no_out_arg": "intros h ( ( h1 & h2 & Q1 & P12 & D & E ) & ( h1' & h2' & Q1' & P22 & D' & E' ) ) .",
                "tactic_args": [
                    "c3_goal : aimp (aand (sepconj Q P1) (sepconj Q P2)) (sepconj (aand P1 P2) Q)"
                ],
                "tactic_res": [
                    "c4_goal : sepconj (aand P1 P2) Q h",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_Q1 : Q h1",
                    "c4_P12 : P1 h2",
                    "c4_D : hdisjoint h1 h2",
                    "c4_E : eq h (hunion h1 h2)",
                    "c4_h1' : heap",
                    "c4_h2' : heap",
                    "c4_Q1' : Q h1'",
                    "c4_P22 : P2 h2'",
                    "c4_D' : hdisjoint h1' h2'",
                    "c4_E' : eq h (hunion h1' h2')"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c4_goal : sepconj (aand P1 P2) Q h",
                    "c4_h1 : heap",
                    "c4_h1' : heap"
                ],
                "tactic_res": [
                    "c5_goal : eq h1 h1'",
                    "c6_goal : sepconj (aand P1 P2) Q h",
                    "c6_H : eq h1 h1'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c5_goal : eq h1 h1'",
                    "c2_PQ : precise Q",
                    "c4_h2 : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": [
                    "c7_goal : hdisjoint h1 h2",
                    "c8_goal : hdisjoint h1' h2'",
                    "c9_goal : eq (hunion h1 h2) (hunion h1' h2')",
                    "c10_goal : Q h1",
                    "c11_goal : Q h1'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : hdisjoint h1 h2",
                    "c4_D : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : hdisjoint h1' h2'",
                    "c4_D' : hdisjoint h1' h2'",
                    "c4_h1' : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Q h1",
                    "c4_Q1 : Q h1",
                    "c4_h1 : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Q h1'",
                    "c4_Q1' : Q h1'",
                    "c4_h1' : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : eq (hunion h1 h2) (hunion h1' h2')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_h1' : heap",
                    "c6_H : eq h1 h1'"
                ],
                "tactic_res": [
                    "c6_D' : hdisjoint h1 h2'",
                    "c6_E' : eq h (hunion h1 h2')",
                    "c6_Q1' : Q h1"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c6_goal : sepconj (aand P1 P2) Q h",
                    "c4_h2 : heap",
                    "c4_h2' : heap"
                ],
                "tactic_res": [
                    "c12_goal : eq h2 h2'",
                    "c13_goal : sepconj (aand P1 P2) Q h",
                    "c13_H : eq h2 h2'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c12_goal : eq h2 h2'",
                    "_global_hunion_invert_r : forall (h1 h2 h : heap) (_ : eq (hunion h h1) (hunion h h2))\n         (_ : hdisjoint h h1) (_ : hdisjoint h h2), \n       eq h1 h2",
                    "c4_h1 : heap"
                ],
                "tactic_res": [
                    "c14_goal : eq (hunion h1 h2) (hunion h1 h2')",
                    "c15_goal : hdisjoint h1 h2",
                    "c16_goal : hdisjoint h1 h2'"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c14_goal : eq (hunion h1 h2) (hunion h1 h2')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : hdisjoint h1 h2",
                    "c4_D : hdisjoint h1 h2",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : hdisjoint h1 h2'",
                    "c6_D' : hdisjoint h1 h2'",
                    "c4_h2' : heap",
                    "c4_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_h2' : heap",
                    "c13_H : eq h2 h2'"
                ],
                "tactic_res": [
                    "c13_P22 : P2 h2",
                    "c13_E' : eq h (hunion h1 h2)",
                    "c13_D' : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c13_goal : sepconj (aand P1 P2) Q h",
                    "_global_aand : forall (_ : assertion) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c17_goal : sepconj (fun h : heap => and (P1 h) (P2 h)) Q h"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c17_goal : sepconj (fun h : heap => and (P1 h) (P2 h)) Q h",
                    "c4_h2 : heap",
                    "c4_h1 : heap"
                ],
                "tactic_res": [
                    "c18_goal : and (and (P1 h2) (P2 h2))\n  (and (Q h1) (and (hdisjoint h2 h1) (eq h (hunion h2 h1))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c18_goal : and (and (P1 h2) (P2 h2))\n  (and (Q h1) (and (hdisjoint h2 h1) (eq h (hunion h2 h1))))",
                    "c13_P22 : P2 h2",
                    "c13_E' : eq h (hunion h1 h2)",
                    "c13_D' : hdisjoint h1 h2",
                    "c6_Q1' : Q h1",
                    "c4_E : eq h (hunion h1 h2)",
                    "c4_D : hdisjoint h1 h2",
                    "c4_P12 : P1 h2",
                    "c4_Q1 : Q h1",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c2_PQ : precise Q",
                    "c2_P1 : assertion",
                    "c2_P2 : assertion",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c19_goal : hdisjoint h2 h1",
                    "c20_goal : eq h (hunion h2 h1)"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c19_goal : hdisjoint h2 h1",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i by HDISJ .",
                "tactic_args": [
                    "c20_goal : eq h (hunion h2 h1)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "c13_P22 : P2 h2",
                    "c13_E' : eq h (hunion h1 h2)",
                    "c13_D' : hdisjoint h1 h2",
                    "c6_Q1' : Q h1",
                    "c4_E : eq h (hunion h1 h2)",
                    "c4_D : hdisjoint h1 h2",
                    "c4_P12 : P1 h2",
                    "c4_Q1 : Q h1",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c2_PQ : precise Q"
                ],
                "tactic_res": [
                    "c21_goal : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : eq h (hunion h1 h2)",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sepconj_self",
        "proof": [
            {
                "tactic_sig": "Lemma sepconj_self : forall P , precise P -> P ** P -->> P .",
                "tactic_sig_no_out_arg": "Lemma sepconj_self : forall P , precise P -> P ** P -->> P .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (_ : precise P), aimp (sepconj P P) P"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (_ : precise P), aimp (sepconj P P) P"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj P P) P",
                    "c2_P : assertion",
                    "c2_H : precise P"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( h1 & h2 & P1 & P2 & D & E ) .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj P P) P"
                ],
                "tactic_res": [
                    "c3_goal : P h",
                    "c3_h : heap",
                    "c3_h1 : heap",
                    "c3_h2 : heap",
                    "c3_P1 : P h1",
                    "c3_P2 : P h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_E : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c3_goal : P h",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": [
                    "c4_goal : eq h1 h2",
                    "c5_goal : P h",
                    "c5_H0 : eq h1 h2"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c4_goal : eq h1 h2",
                    "c2_H : precise P",
                    "c3_h2 : heap",
                    "c3_h1 : heap"
                ],
                "tactic_res": [
                    "c6_goal : hdisjoint h1 h2",
                    "c7_goal : hdisjoint h2 h1",
                    "c8_goal : eq (hunion h1 h2) (hunion h2 h1)",
                    "c9_goal : P h1",
                    "c10_goal : P h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : hdisjoint h1 h2",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P h1",
                    "c3_P1 : P h1",
                    "c3_h1 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : P h2",
                    "c3_P2 : P h2",
                    "c3_h2 : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c7_goal : hdisjoint h2 h1",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq (hunion h1 h2) (hunion h2 h1)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c11_goal : hdisjoint h2 h1"
                ]
            },
            {
                "tactic_sig": "HDISJ .",
                "tactic_sig_no_out_arg": "HDISJ .",
                "tactic_args": [
                    "c11_goal : hdisjoint h2 h1",
                    "c3_D : hdisjoint h1 h2",
                    "c3_h1 : heap",
                    "c3_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_h2 : heap",
                    "c5_H0 : eq h1 h2"
                ],
                "tactic_res": [
                    "c5_P2 : P h1",
                    "c5_D : hdisjoint h1 h1",
                    "c5_E : eq h (hunion h1 h1)"
                ]
            },
            {
                "tactic_sig": "assert ( _i = _i ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) .",
                "tactic_args": [
                    "c5_goal : P h",
                    "c3_h : heap",
                    "c3_h1 : heap"
                ],
                "tactic_res": [
                    "c12_goal : eq h h1",
                    "c13_goal : P h",
                    "c13_H0 : eq h h1"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eq h h1",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c14_goal : forall l : addr, eq (h l) (h1 l)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c14_goal : forall l : addr, eq (h l) (h1 l)"
                ],
                "tactic_res": [
                    "c15_goal : eq (h l) (h1 l)",
                    "c15_l : addr"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : eq (h l) (h1 l)",
                    "c5_E : eq h (hunion h1 h1)"
                ],
                "tactic_res": [
                    "c16_goal : eq (hunion h1 h1 l) (h1 l)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c16_goal : eq (hunion h1 h1 l) (h1 l)"
                ],
                "tactic_res": [
                    "c17_goal : eq (if h1 l then h1 l else h1 l) (h1 l)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c17_goal : eq (if h1 l then h1 l else h1 l) (h1 l)",
                    "c3_h1 : heap",
                    "c15_l : addr",
                    "c5_P2 : P h1",
                    "c5_D : hdisjoint h1 h1",
                    "c5_E : eq h (hunion h1 h1)",
                    "c3_P1 : P h1",
                    "c2_H : precise P"
                ],
                "tactic_res": [
                    "c18_goal : eq (Some z) (Some z)",
                    "c18_z : Z",
                    "c19_goal : eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq (Some z) (Some z)",
                    "c18_z : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c13_goal : P h"
                ],
                "tactic_res": []
            }
        ]
    }
]