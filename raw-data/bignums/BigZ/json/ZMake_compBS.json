[
    {
        "lemma_name": "spec_of_Z",
        "proof": [
            {
                "tactic_sig": "Theorem spec_of_Z : forall x , to_Z ( of_Z x ) = x .",
                "tactic_sig_no_out_arg": "Theorem spec_of_Z : forall x , to_Z ( of_Z x ) = x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : Z, eq (to_Z (of_Z x)) x"
                ]
            },
            {
                "tactic_sig": "custom2 x .",
                "tactic_sig_no_out_arg": "custom2 x .",
                "tactic_args": [
                    "c1_goal : forall x : Z, eq (to_Z (of_Z x)) x"
                ],
                "tactic_res": [
                    "c2_goal : eq (to_Z (of_Z 0)) 0",
                    "c2_x : Z",
                    "c3_goal : forall p : positive, eq (to_Z (of_Z (Zpos p))) (Zpos p)",
                    "c3_x : Z",
                    "c4_goal : forall p : positive, eq (to_Z (of_Z (Zneg p))) (Zneg p)",
                    "c4_x : Z"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c2_goal : eq (to_Z (of_Z 0)) 0",
                    "_global_to_Z : forall _ : t_, Z",
                    "_global_of_Z : forall _ : Z, t_",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c5_goal : eq (NN.to_Z NN.zero) 0"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c3_goal : forall p : positive, eq (to_Z (of_Z (Zpos p))) (Zpos p)",
                    "_global_to_Z : forall _ : t_, Z",
                    "_global_of_Z : forall _ : Z, t_",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c6_goal : forall p : positive, eq (NN.to_Z (NN.of_N (Npos p))) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c4_goal : forall p : positive, eq (to_Z (of_Z (Zneg p))) (Zneg p)",
                    "_global_to_Z : forall _ : t_, Z",
                    "_global_of_Z : forall _ : Z, t_",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c7_goal : forall p : positive, eq (Z.opp (NN.to_Z (NN.of_N (Npos p)))) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "exact NN.spec_0 .",
                "tactic_sig_no_out_arg": "exact NN.spec_0 .",
                "tactic_args": [
                    "c5_goal : eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall p : positive, eq (NN.to_Z (NN.of_N (Npos p))) (Zpos p)"
                ],
                "tactic_res": [
                    "c8_goal : eq (NN.to_Z (NN.of_N (Npos p))) (Zpos p)",
                    "c8_p : positive"
                ]
            },
            {
                "tactic_sig": "custom0 NN.spec_of_N .",
                "tactic_sig_no_out_arg": "custom0 NN.spec_of_N .",
                "tactic_args": [
                    "c8_goal : eq (NN.to_Z (NN.of_N (Npos p))) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall p : positive, eq (Z.opp (NN.to_Z (NN.of_N (Npos p)))) (Zneg p)"
                ],
                "tactic_res": [
                    "c9_goal : eq (Z.opp (NN.to_Z (NN.of_N (Npos p)))) (Zneg p)",
                    "c9_p : positive"
                ]
            },
            {
                "tactic_sig": "custom0 NN.spec_of_N .",
                "tactic_sig_no_out_arg": "custom0 NN.spec_of_N .",
                "tactic_args": [
                    "c9_goal : eq (Z.opp (NN.to_Z (NN.of_N (Npos p)))) (Zneg p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_0 : to_Z zero = 0 .",
                "tactic_sig_no_out_arg": "Theorem spec_0 : to_Z zero = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z zero) 0"
                ]
            },
            {
                "tactic_sig": "exact NN.spec_0 .",
                "tactic_sig_no_out_arg": "exact NN.spec_0 .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_1",
        "proof": [
            {
                "tactic_sig": "Theorem spec_1 : to_Z one = 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_1 : to_Z one = 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z one) 1"
                ]
            },
            {
                "tactic_sig": "exact NN.spec_1 .",
                "tactic_sig_no_out_arg": "exact NN.spec_1 .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z one) 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_2",
        "proof": [
            {
                "tactic_sig": "Theorem spec_2 : to_Z two = 2 .",
                "tactic_sig_no_out_arg": "Theorem spec_2 : to_Z two = 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z two) 2"
                ]
            },
            {
                "tactic_sig": "exact NN.spec_2 .",
                "tactic_sig_no_out_arg": "exact NN.spec_2 .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z two) 2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_m1",
        "proof": [
            {
                "tactic_sig": "Theorem spec_m1 : to_Z minus_one = - 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_m1 : to_Z minus_one = - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z minus_one) (-1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z minus_one) (-1)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Z.opp (NN.to_Z NN.one)) (-1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Z.opp (NN.to_Z NN.one)) (-1)",
                    "_global_NN.spec_1 : Logic.eq (NN.to_Z NN.one) 1"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Z.opp 1) (-1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Z.opp 1) (-1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_compare",
        "proof": [
            {
                "tactic_sig": "Theorem spec_compare : forall x y , compare x y = Z.compare ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Theorem spec_compare : forall x y , compare x y = Z.compare ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_compare : forall (_ : t_) (_ : t_), comparison",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match x with\n  | Pos nx =>\n      match y with\n      | Pos ny => NN.compare nx ny\n      | Neg ny =>\n          match NN.compare nx NN.zero with\n          | Gt => Gt\n          | _ => NN.compare ny NN.zero\n          end\n      end\n  | Neg nx =>\n      match y with\n      | Pos ny =>\n          match NN.compare NN.zero nx with\n          | Lt => Lt\n          | _ => NN.compare NN.zero ny\n          end\n      | Neg ny => NN.compare ny nx\n      end\n  end\n  (Z.compare\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "destruct x as [ x|x ] , y as [ y|y ] .",
                "tactic_sig_no_out_arg": "destruct x as [ x|x ] , y as [ y|y ] .",
                "tactic_args": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match x with\n  | Pos nx =>\n      match y with\n      | Pos ny => NN.compare nx ny\n      | Neg ny =>\n          match NN.compare nx NN.zero with\n          | Gt => Gt\n          | _ => NN.compare ny NN.zero\n          end\n      end\n  | Neg nx =>\n      match y with\n      | Pos ny =>\n          match NN.compare NN.zero nx with\n          | Lt => Lt\n          | _ => NN.compare NN.zero ny\n          end\n      | Neg ny => NN.compare ny nx\n      end\n  end\n  (Z.compare\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))",
                    "c3_y : NN.t",
                    "c3_x : NN.t",
                    "c4_goal : Logic.eq\n  match NN.compare x NN.zero with\n  | Gt => Gt\n  | _ => NN.compare y NN.zero\n  end (Z.compare (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_y : NN.t",
                    "c4_x : NN.t",
                    "c5_goal : Logic.eq\n  match NN.compare NN.zero x with\n  | Lt => Lt\n  | _ => NN.compare NN.zero y\n  end (Z.compare (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_y : NN.t",
                    "c5_x : NN.t",
                    "c6_goal : Logic.eq (NN.compare y x)\n  (Z.compare (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c6_y : NN.t",
                    "c6_x : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_args": [
                    "c3_goal : Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.compare (NN.to_Z x) (NN.to_Z y))\n  (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.compare (NN.to_Z x) (NN.to_Z y))\n  (Z.compare (NN.to_Z x) (NN.to_Z y))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  match NN.compare x NN.zero with\n  | Gt => Gt\n  | _ => NN.compare y NN.zero\n  end (Z.compare (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  match Z.compare (NN.to_Z x) 0 with\n  | Gt => Gt\n  | _ => Z.compare (NN.to_Z y) 0\n  end (Z.compare (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "assert ( Hx := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hx := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c4_x : NN.t"
                ],
                "tactic_res": [
                    "c8_Hx : Z.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "assert ( Hy := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hy := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c8_Hy : Z.le 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "set ( X := NN.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( X := NN.to_Z _i ) in * .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  match Z.compare (NN.to_Z x) 0 with\n  | Gt => Gt\n  | _ => Z.compare (NN.to_Z y) 0\n  end (Z.compare (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_x : NN.t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq\n  match Z.compare X 0 with\n  | Gt => Gt\n  | _ => Z.compare (NN.to_Z y) 0\n  end (Z.compare X (Z.opp (NN.to_Z y)))",
                    "c9_Hx : Z.le 0 X",
                    "c9_X : Z"
                ]
            },
            {
                "tactic_sig": "set ( Y := NN.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( Y := NN.to_Z _i ) in * .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  match Z.compare X 0 with\n  | Gt => Gt\n  | _ => Z.compare (NN.to_Z y) 0\n  end (Z.compare X (Z.opp (NN.to_Z y)))",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq match Z.compare X 0 with\n         | Gt => Gt\n         | _ => Z.compare Y 0\n         end (Z.compare X (Z.opp Y))",
                    "c10_Hy : Z.le 0 Y",
                    "c10_Y : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i _i .",
                "tactic_sig_no_out_arg": "clearbody _i _i .",
                "tactic_args": [
                    "c9_X : Z",
                    "c10_Y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  match NN.compare NN.zero x with\n  | Lt => Lt\n  | _ => NN.compare NN.zero y\n  end (Z.compare (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  match Z.compare 0 (NN.to_Z x) with\n  | Lt => Lt\n  | _ => Z.compare 0 (NN.to_Z y)\n  end (Z.compare (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "assert ( Hx := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hx := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c5_x : NN.t"
                ],
                "tactic_res": [
                    "c11_Hx : Z.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "assert ( Hy := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hy := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c11_Hy : Z.le 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "set ( X := NN.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( X := NN.to_Z _i ) in * .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  match Z.compare 0 (NN.to_Z x) with\n  | Lt => Lt\n  | _ => Z.compare 0 (NN.to_Z y)\n  end (Z.compare (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_x : NN.t"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  match Z.compare 0 X with\n  | Lt => Lt\n  | _ => Z.compare 0 (NN.to_Z y)\n  end (Z.compare (Z.opp X) (NN.to_Z y))",
                    "c12_Hx : Z.le 0 X",
                    "c12_X : Z"
                ]
            },
            {
                "tactic_sig": "set ( Y := NN.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( Y := NN.to_Z _i ) in * .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  match Z.compare 0 X with\n  | Lt => Lt\n  | _ => Z.compare 0 (NN.to_Z y)\n  end (Z.compare (Z.opp X) (NN.to_Z y))",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq match Z.compare 0 X with\n         | Lt => Lt\n         | _ => Z.compare 0 Y\n         end (Z.compare (Z.opp X) Y)",
                    "c13_Hy : Z.le 0 Y",
                    "c13_Y : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i _i .",
                "tactic_sig_no_out_arg": "clearbody _i _i .",
                "tactic_args": [
                    "c12_X : Z",
                    "c13_Y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_compare , ?NN.spec_0 , ?Z.compare_opp .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.compare y x)\n  (Z.compare (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.compare (NN.to_Z y) (NN.to_Z x))\n  (Z.compare (NN.to_Z y) (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.compare (NN.to_Z y) (NN.to_Z x))\n  (Z.compare (NN.to_Z y) (NN.to_Z x))",
                    "c6_x : NN.t",
                    "c6_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Z.compare_spec _i 0 ) as [ EQ|LT|GT ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.compare_spec _i 0 ) as [ EQ|LT|GT ] .",
                "tactic_args": [
                    "c10_goal : Logic.eq match Z.compare X 0 with\n         | Gt => Gt\n         | _ => Z.compare Y 0\n         end (Z.compare X (Z.opp Y))",
                    "c9_X : Z",
                    "c10_Hy : Z.le 0 Y",
                    "c10_Y : Z",
                    "c9_Hx : Z.le 0 X",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.compare Y 0) (Z.compare X (Z.opp Y))",
                    "c15_EQ : Logic.eq X 0",
                    "c16_goal : Logic.eq (Z.compare Y 0) (Z.compare X (Z.opp Y))",
                    "c16_LT : Z.lt X 0",
                    "c17_goal : Logic.eq Gt (Z.compare X (Z.opp Y))",
                    "c17_GT : Z.lt 0 X"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_Z.opp_0 : Logic.eq (Z.opp 0) 0",
                    "c15_EQ : Logic.eq X 0"
                ],
                "tactic_res": [
                    "c15_EQ : Logic.eq X (Z.opp 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite _i , Z.compare_opp .",
                "tactic_sig_no_out_arg": "now rewrite _i , Z.compare_opp .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.compare Y 0) (Z.compare X (Z.opp Y))",
                    "c15_EQ : Logic.eq X (Z.opp 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.compare Y 0) (Z.compare X (Z.opp Y))"
                ],
                "tactic_res": [
                    "c18_goal : False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c18_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c17_goal : Logic.eq Gt (Z.compare X (Z.opp Y))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.compare X (Z.opp Y)) Gt"
                ]
            },
            {
                "tactic_sig": "change ( _i > - _i ) .",
                "tactic_sig_no_out_arg": "change ( _i > - _i ) .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.compare X (Z.opp Y)) Gt",
                    "c9_X : Z",
                    "c10_Y : Z"
                ],
                "tactic_res": [
                    "c20_goal : Z.gt X (Z.opp Y)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : Z.gt X (Z.opp Y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Z.compare_spec 0 _i ) as [ EQ|LT|GT ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.compare_spec 0 _i ) as [ EQ|LT|GT ] .",
                "tactic_args": [
                    "c13_goal : Logic.eq match Z.compare 0 X with\n         | Lt => Lt\n         | _ => Z.compare 0 Y\n         end (Z.compare (Z.opp X) Y)",
                    "c12_X : Z",
                    "c13_Hy : Z.le 0 Y",
                    "c13_Y : Z",
                    "c12_Hx : Z.le 0 X",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (Z.compare 0 Y) (Z.compare (Z.opp X) Y)",
                    "c21_EQ : Logic.eq 0 X",
                    "c22_goal : Logic.eq Lt (Z.compare (Z.opp X) Y)",
                    "c22_LT : Z.lt 0 X",
                    "c23_goal : Logic.eq (Z.compare 0 Y) (Z.compare (Z.opp X) Y)",
                    "c23_GT : Z.lt X 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c21_goal : Logic.eq (Z.compare 0 Y) (Z.compare (Z.opp X) Y)",
                    "c21_EQ : Logic.eq 0 X",
                    "_global_Z.opp_0 : Logic.eq (Z.opp 0) 0"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (Z.compare 0 Y) (Z.compare 0 Y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Logic.eq (Z.compare 0 Y) (Z.compare 0 Y)",
                    "c13_Y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c22_goal : Logic.eq Lt (Z.compare (Z.opp X) Y)"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq (Z.compare (Z.opp X) Y) Lt"
                ]
            },
            {
                "tactic_sig": "change ( - _i < _i ) .",
                "tactic_sig_no_out_arg": "change ( - _i < _i ) .",
                "tactic_args": [
                    "c25_goal : Logic.eq (Z.compare (Z.opp X) Y) Lt",
                    "c12_X : Z",
                    "c13_Y : Z"
                ],
                "tactic_res": [
                    "c26_goal : Z.lt (Z.opp X) Y"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : Z.lt (Z.opp X) Y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c23_goal : Logic.eq (Z.compare 0 Y) (Z.compare (Z.opp X) Y)"
                ],
                "tactic_res": [
                    "c27_goal : False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c27_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_eqb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_eqb x y : eqb x y = Z.eqb ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Theorem spec_eqb x y : eqb x y = Z.eqb ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "c1_y : t_",
                    "c1_x : t_"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "_global_Bool.eq_iff_eq_true : forall b1 b2 : bool,\n       iff (Logic.eq b1 b2) (iff (Logic.eq b1 true) (Logic.eq b2 true))"
                ],
                "tactic_res": [
                    "c2_goal : iff (Logic.eq (eqb x y) true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : iff (Logic.eq (eqb x y) true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)",
                    "_global_eqb : forall (_ : t_) (_ : t_), bool"
                ],
                "tactic_res": [
                    "c3_goal : iff\n  (Logic.eq match compare x y with\n            | Eq => true\n            | _ => false\n            end true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i , _i .",
                "tactic_args": [
                    "c3_goal : iff\n  (Logic.eq match compare x y with\n            | Eq => true\n            | _ => false\n            end true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)",
                    "_global_Z.eqb_eq : forall n m : Z, iff (Logic.eq (Z.eqb n m) true) (Logic.eq n m)",
                    "_global_Z.compare_eq_iff : forall n m : Z, iff (Logic.eq (Z.compare n m) Eq) (Logic.eq n m)",
                    "_global_spec_compare : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq)"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Eq => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq",
                    "c6_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => true\n  | _ => false\n  end true"
                ]
            },
            {
                "tactic_sig": "now destruct Z.compare .",
                "tactic_sig_no_out_arg": "now destruct Z.compare .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Eq => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq",
                    "c1_x : t_",
                    "c1_y : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now intros -> .",
                "tactic_sig_no_out_arg": "now intros -> .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => true\n  | _ => false\n  end true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ltb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_ltb x y : ltb x y = Z.ltb ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Theorem spec_ltb x y : ltb x y = Z.ltb ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))",
                    "_global_Bool.eq_iff_eq_true : forall b1 b2 : bool,\n       iff (Logic.eq b1 b2) (iff (Logic.eq b1 true) (Logic.eq b2 true))"
                ],
                "tactic_res": [
                    "c2_goal : iff (Logic.eq (ltb x y) true) (Logic.eq (Z.ltb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : iff (Logic.eq (ltb x y) true) (Logic.eq (Z.ltb (to_Z x) (to_Z y)) true)",
                    "_global_Z.ltb_lt : forall n m : Z, iff (Logic.eq (Z.ltb n m) true) (Z.lt n m)"
                ],
                "tactic_res": [
                    "c3_goal : iff (Logic.eq (ltb x y) true) (Z.lt (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : iff (Logic.eq (ltb x y) true) (Z.lt (to_Z x) (to_Z y))",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop",
                    "_global_ltb : forall (_ : t) (_ : t), bool"
                ],
                "tactic_res": [
                    "c4_goal : iff\n  (Logic.eq match compare x y with\n            | Lt => true\n            | _ => false\n            end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : iff\n  (Logic.eq match compare x y with\n            | Lt => true\n            | _ => false\n            end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)",
                    "_global_spec_compare : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Lt => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt",
                    "c7_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Lt => true\n  | _ => false\n  end true"
                ]
            },
            {
                "tactic_sig": "now destruct Z.compare .",
                "tactic_sig_no_out_arg": "now destruct Z.compare .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Lt => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now intros -> .",
                "tactic_sig_no_out_arg": "now intros -> .",
                "tactic_args": [
                    "c7_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Lt => true\n  | _ => false\n  end true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_leb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_leb x y : leb x y = Z.leb ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Theorem spec_leb x y : leb x y = Z.leb ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "custom6 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_sig_no_out_arg": "custom6 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                    "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
            },
            {
                "tactic_sig": "now destruct Z.compare .",
                "tactic_sig_no_out_arg": "now destruct Z.compare .",
                "tactic_args": [
                    "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_min",
        "proof": [
            {
                "tactic_sig": "Theorem spec_min : forall n m , to_Z ( min n m ) = Z.min ( to_Z n ) ( to_Z m ) .",
                "tactic_sig_no_out_arg": "Theorem spec_min : forall n m , to_Z ( min n m ) = Z.min ( to_Z n ) ( to_Z m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t_, Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall n m : t_, Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))",
                    "_global_min : forall (_ : t_) (_ : t_), t_",
                    "_global_Z.min : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c2_goal : forall n m : t_,\nLogic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall n m : t_,\nLogic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end",
                    "c3_n : t_",
                    "c3_m : t_"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end",
                    "_global_spec_compare : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Gt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct Z.compare as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct Z.compare .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Gt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end",
                    "c3_n : t_",
                    "c3_m : t_"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c6_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c7_goal : Logic.eq (to_Z m) (to_Z m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c3_n : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c3_n : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z m) (to_Z m)",
                    "c3_m : t_"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_max",
        "proof": [
            {
                "tactic_sig": "Theorem spec_max : forall n m , to_Z ( max n m ) = Z.max ( to_Z n ) ( to_Z m ) .",
                "tactic_sig_no_out_arg": "Theorem spec_max : forall n m , to_Z ( max n m ) = Z.max ( to_Z n ) ( to_Z m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t_, Logic.eq (to_Z (max n m)) (Z.max (to_Z n) (to_Z m))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall n m : t_, Logic.eq (to_Z (max n m)) (Z.max (to_Z n) (to_Z m))",
                    "_global_max : forall (_ : t_) (_ : t_), t_",
                    "_global_Z.max : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c2_goal : forall n m : t_,\nLogic.eq (to_Z match compare n m with\n               | Lt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall n m : t_,\nLogic.eq (to_Z match compare n m with\n               | Lt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Lt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end",
                    "c3_n : t_",
                    "c3_m : t_"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Lt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end",
                    "_global_spec_compare : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Lt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct Z.compare as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct Z.compare .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Lt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Lt => to_Z m\n  | _ => to_Z n\n  end",
                    "c3_n : t_",
                    "c3_m : t_"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c6_goal : Logic.eq (to_Z m) (to_Z m)",
                    "c7_goal : Logic.eq (to_Z n) (to_Z n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c3_n : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z m) (to_Z m)",
                    "c3_m : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c3_n : t_"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_abs",
        "proof": [
            {
                "tactic_sig": "Theorem spec_abs : forall x , to_Z ( abs x ) = Z.abs ( to_Z x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_abs : forall x , to_Z ( abs x ) = Z.abs ( to_Z x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (abs x)) (Z.abs (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (abs x)) (Z.abs (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (abs x)) (Z.abs (to_Z x))",
                    "c2_x : t_"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (abs x)) (Z.abs (to_Z x))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c3_goal : forall t : NN.t, Logic.eq (to_Z (abs (Pos t))) (Z.abs (to_Z (Pos t)))",
                    "c4_goal : forall t : NN.t, Logic.eq (to_Z (abs (Neg t))) (Z.abs (to_Z (Neg t)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c3_goal : forall t : NN.t, Logic.eq (to_Z (abs (Pos t))) (Z.abs (to_Z (Pos t)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (abs (Pos x))) (Z.abs (to_Z (Pos x)))",
                    "c5_x : NN.t"
                ]
            },
            {
                "tactic_sig": "assert ( F := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( F := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c5_x : NN.t"
                ],
                "tactic_res": [
                    "c5_F : Z.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c4_goal : forall t : NN.t, Logic.eq (to_Z (abs (Neg t))) (Z.abs (to_Z (Neg t)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (abs (Neg x))) (Z.abs (to_Z (Neg x)))",
                    "c6_x : NN.t"
                ]
            },
            {
                "tactic_sig": "assert ( F := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( F := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c6_x : NN.t"
                ],
                "tactic_res": [
                    "c6_F : Z.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (abs (Pos x))) (Z.abs (to_Z (Pos x)))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (NN.to_Z x) (Z.abs (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (NN.to_Z x) (Z.abs (NN.to_Z x))",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z x) (NN.to_Z x)",
                    "c9_goal : Z.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z x) (NN.to_Z x)",
                    "c5_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Z.le 0 (NN.to_Z x)",
                    "c5_F : Z.le 0 (NN.to_Z x)",
                    "c5_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (abs (Neg x))) (Z.abs (to_Z (Neg x)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (NN.to_Z x) (Z.abs (Z.opp (NN.to_Z x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (NN.to_Z x) (Z.abs (Z.opp (NN.to_Z x)))",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (NN.to_Z x) (Z.opp (Z.opp (NN.to_Z x)))",
                    "c12_goal : Z.le (Z.opp (NN.to_Z x)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Logic.eq (NN.to_Z x) (Z.opp (Z.opp (NN.to_Z x)))",
                    "c6_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.opp (NN.to_Z x)) 0",
                    "c6_F : Z.le 0 (NN.to_Z x)",
                    "c6_x : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_opp",
        "proof": [
            {
                "tactic_sig": "Theorem spec_opp : forall x , to_Z ( opp x ) = - to_Z x .",
                "tactic_sig_no_out_arg": "Theorem spec_opp : forall x , to_Z ( opp x ) = - to_Z x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ]
            },
            {
                "tactic_sig": "custom2 x .",
                "tactic_sig_no_out_arg": "custom2 x .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                    "c2_x : t_",
                    "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                    "c3_x : t_"
                ]
            },
            {
                "tactic_sig": "custom10 .",
                "tactic_sig_no_out_arg": "custom10 .",
                "tactic_args": [
                    "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom10 .",
                "tactic_sig_no_out_arg": "custom10 .",
                "tactic_args": [
                    "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_succ",
        "proof": [
            {
                "tactic_sig": "Theorem spec_succ : forall n , to_Z ( succ n ) = to_Z n + 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_succ : forall n , to_Z ( succ n ) = to_Z n + 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : t_, Logic.eq (to_Z (succ n)) (Z.add (to_Z n) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall n : t_, Logic.eq (to_Z (succ n)) (Z.add (to_Z n) 1)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (succ x)) (Z.add (to_Z x) 1)",
                    "c2_x : t_"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (succ x)) (Z.add (to_Z x) 1)",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c3_goal : forall t : NN.t,\nLogic.eq (to_Z (succ (Pos t))) (Z.add (to_Z (Pos t)) 1)",
                    "c4_goal : forall t : NN.t,\nLogic.eq (to_Z (succ (Neg t))) (Z.add (to_Z (Neg t)) 1)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c3_goal : forall t : NN.t,\nLogic.eq (to_Z (succ (Pos t))) (Z.add (to_Z (Pos t)) 1)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (succ (Pos x))) (Z.add (to_Z (Pos x)) 1)",
                    "c5_x : NN.t"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c4_goal : forall t : NN.t,\nLogic.eq (to_Z (succ (Neg t))) (Z.add (to_Z (Neg t)) 1)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (succ (Neg x))) (Z.add (to_Z (Neg x)) 1)",
                    "c6_x : NN.t"
                ]
            },
            {
                "tactic_sig": "exact ( NN.spec_succ _i ) .",
                "tactic_sig_no_out_arg": "exact ( NN.spec_succ _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (succ (Pos x))) (Z.add (to_Z (Pos x)) 1)",
                    "c5_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (succ (Neg x))) (Z.add (to_Z (Neg x)) 1)"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (to_Z\n     match NN.compare NN.zero x with\n     | Lt => Neg (NN.pred x)\n     | _ => one\n     end) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (to_Z\n     match NN.compare NN.zero x with\n     | Lt => Neg (NN.pred x)\n     | _ => one\n     end) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match Z.compare (NN.to_Z NN.zero) (NN.to_Z x) with\n     | Lt => Neg (NN.pred x)\n     | _ => one\n     end) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match Z.compare (NN.to_Z NN.zero) (NN.to_Z x) with\n     | Lt => Neg (NN.pred x)\n     | _ => one\n     end) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Logic.eq (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c10_goal : forall _ : Z.lt (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (to_Z (Neg (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c11_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z NN.zero),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 .",
                "tactic_args": [
                    "c9_goal : forall _ : Logic.eq (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (to_Z (Neg (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (to_Z (Neg (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (to_Z (Neg (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z NN.zero),\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Z.lt (NN.to_Z x) 0,\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall _ : Z.lt (NN.to_Z x) 0,\nLogic.eq (to_Z one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) 0,\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c13_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c18_HH : Logic.eq 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c18_HH : Logic.eq 0 (NN.to_Z x)"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (NN.to_Z NN.one) (Z.add (Z.opp 0) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq (NN.to_Z NN.one) (Z.add (Z.opp 0) 1)",
                    "_global_NN.spec_1 : Logic.eq (NN.to_Z NN.one) 1"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq 1 (Z.add (Z.opp 0) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c20_goal : Logic.eq 1 (Z.add (Z.opp 0) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (Z.opp (NN.to_Z (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c21_HH : Z.lt 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c21_goal : Logic.eq (Z.opp (NN.to_Z (NN.pred x))) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "_global_NN.spec_pred : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.pred x)) (Z.max 0 (Z.sub (NN.to_Z x) 1))",
                    "_global_Z.max_r : forall (n m : Z) (_ : Z.le n m), Logic.eq (Z.max n m) m"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.opp (Z.sub (NN.to_Z x) 1)) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c23_goal : Z.le 0 (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.opp (Z.sub (NN.to_Z x) 1)) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c6_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : Z.le 0 (Z.sub (NN.to_Z x) 1)",
                    "c21_HH : Z.lt 0 (NN.to_Z x)",
                    "c6_x : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) 0,\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c6_x : NN.t"
                ],
                "tactic_res": [
                    "c24_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt (NN.to_Z x) 0),\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt (NN.to_Z x) 0),\nLogic.eq (NN.to_Z NN.one) (Z.add (Z.opp (NN.to_Z x)) 1)",
                    "c6_x : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add : forall x y , to_Z ( add x y ) = to_Z x + to_Z y .",
                "tactic_sig_no_out_arg": "Theorem spec_add : forall x y , to_Z ( add x y ) = to_Z x + to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))",
                    "_global_add : forall (_ : t_) (_ : t_), t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny => Pos (NN.add nx ny)\n        | Neg ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Neg (NN.sub ny nx)\n            | Gt => Pos (NN.sub nx ny)\n            end\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Pos (NN.sub ny nx)\n            | Gt => Neg (NN.sub nx ny)\n            end\n        | Neg ny => Neg (NN.add nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.add\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ y | y ] .",
                "tactic_args": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny => Pos (NN.add nx ny)\n        | Neg ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Neg (NN.sub ny nx)\n            | Gt => Pos (NN.sub nx ny)\n            end\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Pos (NN.sub ny nx)\n            | Gt => Neg (NN.sub nx ny)\n            end\n        | Neg ny => Neg (NN.add nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.add\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.add x y)) (Z.add (NN.to_Z x) (NN.to_Z y))",
                    "c6_x : NN.t",
                    "c6_y : NN.t",
                    "c6_goal : Logic.eq (Z.opp (NN.to_Z (NN.add x y)))\n  (Z.add (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ]
            },
            {
                "tactic_sig": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.add x y)) (Z.add (NN.to_Z x) (NN.to_Z y))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c9_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (NN.to_Z (NN.sub y x)))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c10_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.sub x y)) (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c11_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c9_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (NN.to_Z (NN.sub y x)))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x))))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x))))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.sub x y)) (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))\n  (Z.add (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z (NN.sub y x)) (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c18_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.sub x y)))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z (NN.sub y x)) (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x)))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c21_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x)))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c18_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.sub x y)))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y))))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c22_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y))))\n  (Z.add (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.opp (NN.to_Z (NN.add x y)))\n  (Z.add (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c6_x : NN.t",
                    "c6_y : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pred",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pred : forall x , to_Z ( pred x ) = to_Z x - 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_pred : forall x , to_Z ( pred x ) = to_Z x - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)",
                    "_global_pred : forall _ : t_, t_",
                    "_global_to_Z : forall _ : t_, Z",
                    "_global_minus_one : t_"
                ],
                "tactic_res": [
                    "c2_goal : forall x : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match NN.compare NN.zero nx with\n        | Lt => Pos (NN.pred nx)\n        | _ => Neg NN.one\n        end\n    | Neg nx => Neg (NN.succ nx)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.sub\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end 1)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] .",
                "tactic_args": [
                    "c2_goal : forall x : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match NN.compare NN.zero nx with\n        | Lt => Pos (NN.pred nx)\n        | _ => Neg NN.one\n        end\n    | Neg nx => Neg (NN.succ nx)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.sub\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end 1)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  match\n    match NN.compare NN.zero x with\n    | Lt => Pos (NN.pred x)\n    | _ => Neg NN.one\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) 1)",
                    "c4_x : NN.t",
                    "c4_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ x))) (Z.sub (Z.opp (NN.to_Z x)) 1)",
                    "c3_x : NN.t"
                ]
            },
            {
                "tactic_sig": "try ( rewrite NN.spec_succ ; ring ) .",
                "tactic_sig_no_out_arg": "try ( rewrite NN.spec_succ ; ring ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ x))) (Z.sub (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  match\n    match NN.compare NN.zero x with\n    | Lt => Pos (NN.pred x)\n    | _ => Neg NN.one\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) 1)",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z NN.zero) (NN.to_Z x) with\n    | Lt => Pos (NN.pred x)\n    | _ => Neg NN.one\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z NN.zero) (NN.to_Z x) with\n    | Lt => Pos (NN.pred x)\n    | _ => Neg NN.one\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Logic.eq (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z NN.one)) (Z.sub (NN.to_Z x) 1)",
                    "c7_goal : forall _ : Z.lt (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.pred x)) (Z.sub (NN.to_Z x) 1)",
                    "c8_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z NN.zero),\nLogic.eq (Z.opp (NN.to_Z NN.one)) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z NN.one)) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c9_goal : forall _ : Logic.eq 0 (NN.to_Z x),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)",
                    "c3_x : NN.t"
                ],
                "tactic_res": [
                    "c10_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Logic.eq 0 (NN.to_Z x)),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c10_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Logic.eq 0 (NN.to_Z x)),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_args": [
                    "c7_goal : forall _ : Z.lt (NN.to_Z NN.zero) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.pred x)) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) 1)) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt 0 (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) 1)) (Z.sub (NN.to_Z x) 1)",
                    "c3_x : NN.t"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt 0 (NN.to_Z x)),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) 1)) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt 0 (NN.to_Z x)),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) 1)) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_1 , ?NN.spec_pred .",
                "tactic_args": [
                    "c8_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z NN.zero),\nLogic.eq (Z.opp (NN.to_Z NN.one)) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) 0, Logic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) 0, Logic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)",
                    "c3_x : NN.t"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt (NN.to_Z x) 0),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c14_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.lt (NN.to_Z x) 0),\nLogic.eq (Z.opp 1) (Z.sub (NN.to_Z x) 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub : forall x y , to_Z ( sub x y ) = to_Z x - to_Z y .",
                "tactic_sig_no_out_arg": "Theorem spec_sub : forall x y , to_Z ( sub x y ) = to_Z x - to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))",
                    "_global_sub : forall (_ : t_) (_ : t_), t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Neg (NN.sub ny nx)\n            | Gt => Pos (NN.sub nx ny)\n            end\n        | Neg ny => Pos (NN.add nx ny)\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny => Neg (NN.add nx ny)\n        | Neg ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Pos (NN.sub ny nx)\n            | Gt => Neg (NN.sub nx ny)\n            end\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.sub\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ y | y ] .",
                "tactic_args": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Neg (NN.sub ny nx)\n            | Gt => Pos (NN.sub nx ny)\n            end\n        | Neg ny => Pos (NN.add nx ny)\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny => Neg (NN.add nx ny)\n        | Neg ny =>\n            match NN.compare nx ny with\n            | Eq => zero\n            | Lt => Pos (NN.sub ny nx)\n            | Gt => Neg (NN.sub nx ny)\n            end\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.sub\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))",
                    "c6_x : NN.t",
                    "c6_y : NN.t",
                    "c6_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z (NN.add x y)))\n  (Z.sub (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : Logic.eq (NN.to_Z (NN.add x y)) (Z.sub (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Neg (NN.sub y x)\n    | Gt => Pos (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))",
                    "c9_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (NN.to_Z (NN.sub y x))) (Z.sub (NN.to_Z x) (NN.to_Z y))",
                    "c10_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.sub x y)) (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (NN.to_Z x) (NN.to_Z y))",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c11_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero) (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c9_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (NN.to_Z (NN.sub y x))) (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x))))\n  (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x))))\n  (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (NN.to_Z (NN.sub x y)) (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))\n  (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))\n  (Z.sub (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z (NN.add x y)) (Z.sub (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "try ( rewrite NN.spec_add ; auto with zarith ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z (NN.add x y)))\n  (Z.sub (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  match\n    match NN.compare x y with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "_global_NN.spec_compare : forall x y : NN.t,\n       Logic.eq (NN.compare x y) (Z.compare (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  match\n    match Z.compare (NN.to_Z x) (NN.to_Z y) with\n    | Eq => zero\n    | Lt => Pos (NN.sub y x)\n    | Gt => Neg (NN.sub x y)\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z (NN.sub y x))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c18_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.sub x y)))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq\n  match zero with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "_global_zero : t_"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero)\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z NN.zero)\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z x) (NN.to_Z y),\nLogic.eq 0 (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (NN.to_Z (NN.sub y x))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x)))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c21_goal : forall _ : Z.lt (NN.to_Z x) (NN.to_Z y),\nLogic.eq (Z.max 0 (Z.sub (NN.to_Z y) (NN.to_Z x)))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_zero : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_0 , ?NN.spec_sub .",
                "tactic_args": [
                    "c18_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (NN.to_Z (NN.sub x y)))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y))))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c22_goal : forall _ : Z.lt (NN.to_Z y) (NN.to_Z x),\nLogic.eq (Z.opp (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y))))\n  (Z.sub (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul : forall x y , to_Z ( mul x y ) = to_Z x * to_Z y .",
                "tactic_sig_no_out_arg": "Theorem spec_mul : forall x y , to_Z ( mul x y ) = to_Z x * to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))",
                    "_global_mul : forall (_ : t_) (_ : t_), t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny => Pos (NN.mul nx ny)\n        | Neg ny => Neg (NN.mul nx ny)\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny => Neg (NN.mul nx ny)\n        | Neg ny => Pos (NN.mul nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.mul\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ y | y ] .",
                "tactic_args": [
                    "c2_goal : forall x y : t_,\nLogic.eq\n  match\n    match x with\n    | Pos nx =>\n        match y with\n        | Pos ny => Pos (NN.mul nx ny)\n        | Neg ny => Neg (NN.mul nx ny)\n        end\n    | Neg nx =>\n        match y with\n        | Pos ny => Neg (NN.mul nx ny)\n        | Neg ny => Pos (NN.mul nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.mul\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))",
                    "c6_x : NN.t",
                    "c6_y : NN.t",
                    "c6_goal : Logic.eq (NN.to_Z (NN.mul x y))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z (NN.mul x y)))\n  (Z.mul (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : Logic.eq (Z.opp (NN.to_Z (NN.mul x y)))\n  (Z.mul (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_mul : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z y))\n  (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z y))\n  (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.opp (NN.to_Z (NN.mul x y)))\n  (Z.mul (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "_global_NN.spec_mul : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x) (NN.to_Z y)))\n  (Z.mul (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x) (NN.to_Z y)))\n  (Z.mul (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z (NN.mul x y)))\n  (Z.mul (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "_global_NN.spec_mul : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x) (NN.to_Z y)))\n  (Z.mul (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x) (NN.to_Z y)))\n  (Z.mul (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.to_Z (NN.mul x y))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "_global_NN.spec_mul : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.mul x y)) (Z.mul (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z y))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z y))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_square",
        "proof": [
            {
                "tactic_sig": "Theorem spec_square : forall x , to_Z ( square x ) = to_Z x * to_Z x .",
                "tactic_sig_no_out_arg": "Theorem spec_square : forall x , to_Z ( square x ) = to_Z x * to_Z x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))",
                    "_global_square : forall _ : t_, t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x : t_,\nLogic.eq\n  match match x with\n        | Pos nx | Neg nx => Pos (NN.square nx)\n        end with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.mul\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] .",
                "tactic_args": [
                    "c2_goal : forall x : t_,\nLogic.eq\n  match match x with\n        | Pos nx | Neg nx => Pos (NN.square nx)\n        end with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.mul\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))",
                    "c4_x : NN.t",
                    "c4_goal : Logic.eq (NN.to_Z (NN.square x))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z x)))",
                    "c3_x : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))",
                    "_global_NN.spec_square : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z x))\n  (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z x))\n  (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z (NN.square x))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z x)))",
                    "_global_NN.spec_square : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z x))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z x)))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.mul (NN.to_Z x) (NN.to_Z x))\n  (Z.mul (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z x)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow_pos : forall x n , to_Z ( pow_pos x n ) = to_Z x ^ Zpos n .",
                "tactic_sig_no_out_arg": "Theorem spec_pow_pos : forall x n , to_Z ( pow_pos x n ) = to_Z x ^ Zpos n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t_) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ]
            },
            {
                "tactic_sig": "assert ( F0 : forall x , ( - x ) ^ 2 = x ^ 2 ) .",
                "tactic_sig_no_out_arg": "assert ( F0 : forall x , ( - x ) ^ 2 = x ^ 2 ) .",
                "tactic_args": [
                    "c1_goal : forall (x : t_) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c2_goal : forall x : Z, Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)",
                    "c3_goal : forall (x : t_) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))",
                    "c3_F0 : forall x : Z, Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c2_goal : forall x : Z, Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)",
                    "c4_x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)",
                    "_global_Z.pow_2_r : forall a : Z, Logic.eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.mul (Z.opp x) (Z.opp x)) (Z.pow x 2)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.mul (Z.opp x) (Z.opp x)) (Z.pow x 2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : forall (x : t_) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))",
                    "_global_pow_pos : forall (_ : t_) (_ : positive), t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c6_goal : forall (x : t_) (n : positive),\nLogic.eq\n  match\n    match x with\n    | Pos nx => Pos (NN.pow_pos nx n)\n    | Neg nx =>\n        match n with\n        | xI _ => Neg (NN.pow_pos nx n)\n        | xO _ => Pos (NN.pow_pos nx n)\n        | 1%positive => x\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.pow\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end (Zpos n))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o | ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ p | p | ] .",
                "tactic_args": [
                    "c6_goal : forall (x : t_) (n : positive),\nLogic.eq\n  match\n    match x with\n    | Pos nx => Pos (NN.pow_pos nx n)\n    | Neg nx =>\n        match n with\n        | xI _ => Neg (NN.pow_pos nx n)\n        | xO _ => Pos (NN.pow_pos nx n)\n        | 1%positive => x\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  (Z.pow\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end (Zpos n))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xI p)))\n  (Z.pow (NN.to_Z x) (Zpos (xI p)))",
                    "c12_x : NN.t",
                    "c12_goal : Logic.eq (Z.opp (NN.to_Z x)) (Z.pow (Z.opp (NN.to_Z x)) 1)",
                    "c11_x : NN.t",
                    "c11_p : positive",
                    "c11_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))",
                    "c10_x : NN.t",
                    "c10_p : positive",
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.pow_pos x (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))",
                    "c9_x : NN.t",
                    "c9_goal : Logic.eq (NN.to_Z (NN.pow_pos x 1)) (Z.pow (NN.to_Z x) 1)",
                    "c8_x : NN.t",
                    "c8_p : positive",
                    "c8_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xO p)))\n  (Z.pow (NN.to_Z x) (Zpos (xO p)))",
                    "c7_x : NN.t",
                    "c7_p : positive"
                ]
            },
            {
                "tactic_sig": "try rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "try rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c7_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xI p)))\n  (Z.pow (NN.to_Z x) (Zpos (xI p)))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xI p)))\n  (Z.pow (NN.to_Z x) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xI p)))\n  (Z.pow (NN.to_Z x) (Zpos (xI p)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "try rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xO p)))\n  (Z.pow (NN.to_Z x) (Zpos (xO p)))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (NN.to_Z x) (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (NN.to_Z x) (Zpos (xO p)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "try rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c9_goal : Logic.eq (NN.to_Z (NN.pow_pos x 1)) (Z.pow (NN.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.pow (NN.to_Z x) 1) (Z.pow (NN.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.pow (NN.to_Z x) 1) (Z.pow (NN.to_Z x) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "try rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.pow_pos x (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Zpos (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "try rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "try rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c11_goal : Logic.eq (NN.to_Z (NN.pow_pos x (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.opp (NN.to_Z x)) (Z.pow (Z.opp (NN.to_Z x)) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F : 0 <= 2 * Zpos _i ) .",
                "tactic_sig_no_out_arg": "assert ( F : 0 <= 2 * Zpos _i ) .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Zpos (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))",
                    "c10_p : positive"
                ],
                "tactic_res": [
                    "c18_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c19_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Zpos (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))",
                    "c19_F : Z.le 0 (Z.mul 2 (Zpos p))"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= Zpos _i ) .",
                "tactic_sig_no_out_arg": "assert ( 0 <= Zpos _i ) .",
                "tactic_args": [
                    "c18_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c10_p : positive"
                ],
                "tactic_res": [
                    "c20_goal : Z.le 0 (Zpos p)",
                    "c21_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c21_H : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Zpos p)",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Zpos (xI p))))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xI p)))",
                    "_global_Pos2Z.inj_xI : forall p : positive,\n       Logic.eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Z.add (Z.mul 2 (Zpos p)) 1)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Z.add (Z.mul 2 (Zpos p)) 1))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite Zpower_exp .",
                "tactic_sig_no_out_arg": "repeat rewrite Zpower_exp .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.opp (Z.pow (NN.to_Z x) (Z.add (Z.mul 2 (Zpos p)) 1)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Z.add (Z.mul 2 (Zpos p)) 1))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (NN.to_Z x) (Z.mul 2 (Zpos p)))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.opp (NN.to_Z x)) (Z.mul 2 (Zpos p)))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))",
                    "c24_goal : Z.ge (Z.mul 2 (Zpos p)) 0",
                    "c25_goal : Z.ge 1 0",
                    "c26_goal : Z.ge (Z.mul 2 (Zpos p)) 0",
                    "c27_goal : Z.ge 1 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : Z.ge (Z.mul 2 (Zpos p)) 0",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : Z.ge 1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c26_goal : Z.ge (Z.mul 2 (Zpos p)) 0",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c27_goal : Z.ge 1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat rewrite Z.pow_mul_r .",
                "tactic_sig_no_out_arg": "repeat rewrite Z.pow_mul_r .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (NN.to_Z x) (Z.mul 2 (Zpos p)))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.opp (NN.to_Z x)) (Z.mul 2 (Zpos p)))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.pow (Z.opp (NN.to_Z x)) 2) (Zpos p))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))",
                    "c29_goal : Z.le 0 2",
                    "c30_goal : Z.le 0 (Zpos p)",
                    "c31_goal : Z.le 0 2",
                    "c32_goal : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c29_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c30_goal : Z.le 0 (Zpos p)",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c32_goal : Z.le 0 (Zpos p)",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.pow (Z.opp (NN.to_Z x)) 2) (Zpos p))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))",
                    "c3_F0 : forall x : Z, Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c33_goal : Logic.eq\n  (Z.opp\n     (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n        (Z.pow (NN.to_Z x) 1)))\n  (Z.mul (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n     (Z.pow (Z.opp (NN.to_Z x)) 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F : 0 <= 2 * Zpos _i ) .",
                "tactic_sig_no_out_arg": "assert ( F : 0 <= 2 * Zpos _i ) .",
                "tactic_args": [
                    "c17_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))",
                    "c11_p : positive"
                ],
                "tactic_res": [
                    "c34_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c35_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))",
                    "c35_F : Z.le 0 (Z.mul 2 (Zpos p))"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= Zpos _i ) .",
                "tactic_sig_no_out_arg": "assert ( 0 <= Zpos _i ) .",
                "tactic_args": [
                    "c34_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c11_p : positive"
                ],
                "tactic_res": [
                    "c36_goal : Z.le 0 (Zpos p)",
                    "c37_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c37_H : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c36_goal : Z.le 0 (Zpos p)",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c37_goal : Z.le 0 (Z.mul 2 (Zpos p))",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c35_goal : Logic.eq (Z.pow (NN.to_Z x) (Zpos (xO p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Zpos (xO p)))",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c38_goal : Logic.eq (Z.pow (NN.to_Z x) (Z.mul 2 (Zpos p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Z.mul 2 (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite Z.pow_mul_r .",
                "tactic_sig_no_out_arg": "repeat rewrite Z.pow_mul_r .",
                "tactic_args": [
                    "c38_goal : Logic.eq (Z.pow (NN.to_Z x) (Z.mul 2 (Zpos p)))\n  (Z.pow (Z.opp (NN.to_Z x)) (Z.mul 2 (Zpos p)))"
                ],
                "tactic_res": [
                    "c39_goal : Logic.eq (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n  (Z.pow (Z.pow (Z.opp (NN.to_Z x)) 2) (Zpos p))",
                    "c40_goal : Z.le 0 2",
                    "c41_goal : Z.le 0 (Zpos p)",
                    "c42_goal : Z.le 0 2",
                    "c43_goal : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c40_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c41_goal : Z.le 0 (Zpos p)",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c42_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c43_goal : Z.le 0 (Zpos p)",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c39_goal : Logic.eq (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n  (Z.pow (Z.pow (Z.opp (NN.to_Z x)) 2) (Zpos p))",
                    "c3_F0 : forall x : Z, Logic.eq (Z.pow (Z.opp x) 2) (Z.pow x 2)"
                ],
                "tactic_res": [
                    "c44_goal : Logic.eq (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n  (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c44_goal : Logic.eq (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))\n  (Z.pow (Z.pow (NN.to_Z x) 2) (Zpos p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow_N",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow_N : forall x n , to_Z ( pow_N x n ) = to_Z x ^ Z.of_N n .",
                "tactic_sig_no_out_arg": "Theorem spec_pow_N : forall x n , to_Z ( pow_N x n ) = to_Z x ^ Z.of_N n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t_) (n : N),\nLogic.eq (to_Z (pow_N x n)) (Z.pow (to_Z x) (Z.of_N n))"
                ]
            },
            {
                "tactic_sig": "destruct n as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct n .",
                "tactic_args": [
                    "c1_goal : forall (x : t_) (n : N),\nLogic.eq (to_Z (pow_N x n)) (Z.pow (to_Z x) (Z.of_N n))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pow_N x 0)) (Z.pow (to_Z x) (Z.of_N 0%N))",
                    "c2_x : t_",
                    "c3_goal : Logic.eq (to_Z (pow_N x (Npos p))) (Z.pow (to_Z x) (Z.of_N (Npos p)))",
                    "c3_p : positive",
                    "c3_x : t_"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pow_N x 0)) (Z.pow (to_Z x) (Z.of_N 0%N))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (NN.to_Z NN.one) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (pow_N x (Npos p))) (Z.pow (to_Z x) (Z.of_N (Npos p)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z NN.one) 1",
                    "_global_NN.spec_1 : Logic.eq (NN.to_Z NN.one) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)",
                    "_global_spec_pow_pos : forall (x : t_) (n : positive),\n       Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow : forall x y , to_Z ( pow x y ) = to_Z x ^ to_Z y .",
                "tactic_sig_no_out_arg": "Theorem spec_pow : forall x y , to_Z ( pow x y ) = to_Z x ^ to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))",
                    "_global_pow : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match to_Z y with\n     | 0 => one\n     | Zpos p => pow_pos x p\n     | Zneg _ => zero\n     end) (Z.pow (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "destruct ( to_Z _i ) as [  | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( to_Z _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match to_Z y with\n     | 0 => one\n     | Zpos p => pow_pos x p\n     | Zneg _ => zero\n     end) (Z.pow (to_Z x) (to_Z y))",
                    "c2_y : t_",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Z one) (Z.pow (to_Z x) 0)",
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c5_p : positive",
                    "c6_goal : Logic.eq (to_Z zero) (Z.pow (to_Z x) (Zneg p))",
                    "c6_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z one) (Z.pow (to_Z x) 0)"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (NN.to_Z NN.one) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z zero) (Z.pow (to_Z x) (Zneg p))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (NN.to_Z NN.zero) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (NN.to_Z NN.one) 1",
                    "_global_NN.spec_1 : Logic.eq (NN.to_Z NN.one) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)",
                    "_global_spec_pow_pos : forall (x : t_) (n : positive),\n       Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (NN.to_Z NN.zero) 0",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_log2",
        "proof": [
            {
                "tactic_sig": "Theorem spec_log2 : forall x , to_Z ( log2 x ) = Z.log2 ( to_Z x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_log2 : forall x , to_Z ( log2 x ) = Z.log2 ( to_Z x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c2_x : t_"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ p|p ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ p|p ] .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (log2 (Pos p))) (Z.log2 (to_Z (Pos p)))",
                    "c3_p : NN.t",
                    "c4_goal : Logic.eq (to_Z (log2 (Neg p))) (Z.log2 (to_Z (Neg p)))",
                    "c4_p : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (log2 (Pos p))) (Z.log2 (to_Z (Pos p)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (NN.to_Z (NN.log2 p)) (Z.log2 (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (log2 (Neg p))) (Z.log2 (to_Z (Neg p)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (NN.to_Z NN.zero) (Z.log2 (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (NN.to_Z (NN.log2 p)) (Z.log2 (NN.to_Z p))",
                    "_global_NN.spec_log2 : forall x : NN.t, Logic.eq (NN.to_Z (NN.log2 x)) (Z.log2 (NN.to_Z x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.to_Z NN.zero) (Z.log2 (Z.opp (NN.to_Z p)))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z_le_lt_eq_dec _ _ ( NN.spec_pos _i ) ) as [ LT|EQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z_le_lt_eq_dec _ _ ( NN.spec_pos _i ) ) as [ LT|EQ ] .",
                "tactic_args": [
                    "c7_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))",
                    "c4_p : NN.t"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))",
                    "c8_LT : Z.lt 0 (NN.to_Z p)",
                    "c9_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))",
                    "c9_EQ : Logic.eq 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))",
                    "_global_Z.log2_nonpos : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.log2 n) 0"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq 0 0",
                    "c11_goal : Z.le (Z.opp (NN.to_Z p)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Logic.eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.le (Z.opp (NN.to_Z p)) 0",
                    "c8_LT : Z.lt 0 (NN.to_Z p)",
                    "c4_p : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite <- _i .",
                "tactic_sig_no_out_arg": "now rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq 0 (Z.log2 (Z.opp (NN.to_Z p)))",
                    "c9_EQ : Logic.eq 0 (NN.to_Z p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sqrt",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sqrt : forall x , to_Z ( sqrt x ) = Z.sqrt ( to_Z x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_sqrt : forall x , to_Z ( sqrt x ) = Z.sqrt ( to_Z x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))"
                ]
            },
            {
                "tactic_sig": "destruct x as [ p|p ] .",
                "tactic_sig_no_out_arg": "destruct x as [ p|p ] .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (sqrt (Pos p))) (Z.sqrt (to_Z (Pos p)))",
                    "c2_p : NN.t",
                    "c3_goal : Logic.eq (to_Z (sqrt (Neg p))) (Z.sqrt (to_Z (Neg p)))",
                    "c3_p : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (sqrt (Pos p))) (Z.sqrt (to_Z (Pos p)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (NN.to_Z (NN.sqrt p)) (Z.sqrt (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (sqrt (Neg p))) (Z.sqrt (to_Z (Neg p)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z NN.zero)) (Z.sqrt (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z (NN.sqrt p)) (Z.sqrt (NN.to_Z p))",
                    "_global_NN.spec_sqrt : forall x : NN.t, Logic.eq (NN.to_Z (NN.sqrt x)) (Z.sqrt (NN.to_Z x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.opp (NN.to_Z NN.zero)) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z_le_lt_eq_dec _ _ ( NN.spec_pos _i ) ) as [ LT|EQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z_le_lt_eq_dec _ _ ( NN.spec_pos _i ) ) as [ LT|EQ ] .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "c3_p : NN.t"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "c7_LT : Z.lt 0 (NN.to_Z p)",
                    "c8_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "c8_EQ : Logic.eq 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "_global_Z.sqrt_neg : forall (n : Z) (_ : Z.lt n 0), Logic.eq (Z.sqrt n) 0"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.opp 0) 0",
                    "c10_goal : Z.lt (Z.opp (NN.to_Z p)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.opp 0) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Z.lt (Z.opp (NN.to_Z p)) 0",
                    "c7_LT : Z.lt 0 (NN.to_Z p)",
                    "c3_p : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite <- _i .",
                "tactic_sig_no_out_arg": "now rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.opp 0) (Z.sqrt (Z.opp (NN.to_Z p)))",
                    "c8_EQ : Logic.eq 0 (NN.to_Z p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_eucl",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_eucl : forall x y , let ( q , r ) := div_eucl x y in ( to_Z q , to_Z r ) = Z.div_eucl ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Theorem spec_div_eucl : forall x y , let ( q , r ) := div_eucl x y in ( to_Z q , to_Z r ) = Z.div_eucl ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_,\nlet (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t_,\nlet (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "_global_div_eucl : forall (_ : t_) (_ : t_), prod t_ t_",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t_,\nlet (q, r) :=\n  match x with\n  | Pos nx =>\n      match y with\n      | Pos ny =>\n          let (q, r) := NN.div_eucl nx ny in pair (Pos q) (Pos r)\n      | Neg ny =>\n          let (q, r) := NN.div_eucl nx ny in\n          if NN.eqb NN.zero r\n          then pair (Neg q) zero\n          else\n           if NN.eqb NN.zero ny\n           then pair zero x\n           else pair (Neg (NN.succ q)) (Neg (NN.sub ny r))\n      end\n  | Neg nx =>\n      match y with\n      | Pos ny =>\n          let (q, r) := NN.div_eucl nx ny in\n          if NN.eqb NN.zero r\n          then pair (Neg q) zero\n          else\n           if NN.eqb NN.zero ny\n           then pair zero x\n           else pair (Neg (NN.succ q)) (Pos (NN.sub ny r))\n      | Neg ny =>\n          let (q, r) := NN.div_eucl nx ny in pair (Pos q) (Neg r)\n      end\n  end in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (Z.div_eucl\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ y | y ] .",
                "tactic_args": [
                    "c2_goal : forall x y : t_,\nlet (q, r) :=\n  match x with\n  | Pos nx =>\n      match y with\n      | Pos ny =>\n          let (q, r) := NN.div_eucl nx ny in pair (Pos q) (Pos r)\n      | Neg ny =>\n          let (q, r) := NN.div_eucl nx ny in\n          if NN.eqb NN.zero r\n          then pair (Neg q) zero\n          else\n           if NN.eqb NN.zero ny\n           then pair zero x\n           else pair (Neg (NN.succ q)) (Neg (NN.sub ny r))\n      end\n  | Neg nx =>\n      match y with\n      | Pos ny =>\n          let (q, r) := NN.div_eucl nx ny in\n          if NN.eqb NN.zero r\n          then pair (Neg q) zero\n          else\n           if NN.eqb NN.zero ny\n           then pair zero x\n           else pair (Neg (NN.succ q)) (Pos (NN.sub ny r))\n      | Neg ny =>\n          let (q, r) := NN.div_eucl nx ny in pair (Pos q) (Neg r)\n      end\n  end in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (Z.div_eucl\n     match x with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match y with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)"
                ],
                "tactic_res": [
                    "c3_goal : let (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Pos r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (NN.to_Z y))",
                    "c6_x : NN.t",
                    "c6_y : NN.t",
                    "c6_goal : let (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Neg r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : let (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : let (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c3_goal : let (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Pos r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (NN.to_Z y))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Pos r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.div_eucl _i _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( NN.div_eucl _i _i ) .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Pos r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (NN.to_Z y))",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  _ : Logic.eq (pair (NN.to_Z t0) (NN.to_Z t1))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z t0) (NN.to_Z t1))\n  (Z.div_eucl (NN.to_Z x) (NN.to_Z y))",
                    "c8_t1 : NN.t",
                    "c8_t0 : NN.t"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : forall\n  _ : Logic.eq (pair (NN.to_Z t0) (NN.to_Z t1))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z t0) (NN.to_Z t1))\n  (Z.div_eucl (NN.to_Z x) (NN.to_Z y))",
                    "c3_x : NN.t",
                    "c3_y : NN.t",
                    "c8_t0 : NN.t",
                    "c8_t1 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c4_goal : let (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c9_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_sig_no_out_arg": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_args": [
                    "c9_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c10_r : NN.t",
                    "c10_q : NN.t"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i px EQx .",
                "tactic_sig_no_out_arg": "break_nonneg _i px EQx .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c4_x : NN.t"
                ],
                "tactic_res": [
                    "c11_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (NN.to_Z y)))",
                    "c11_EQx : Logic.eq (NN.to_Z x) 0",
                    "c12_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (NN.to_Z y)))",
                    "c12_EQx : Logic.eq (NN.to_Z x) (Zpos px)",
                    "c12_px : positive"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c11_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (NN.to_Z y)))",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))",
                    "c13_EQy : Logic.eq (NN.to_Z y) 0",
                    "c14_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))",
                    "c14_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c14_py : positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp 0))"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c18_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c19_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c19_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl 0 (Z.opp (Zpos py)))"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c12_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (NN.to_Z y)))",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))",
                    "c21_EQy : Logic.eq (NN.to_Z y) 0",
                    "c22_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))",
                    "c22_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c22_py : positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c23_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c24_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp 0))"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 (Zpos px)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zpos px))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c26_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb (NN.to_Z NN.zero) (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c27_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c27_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Zpos px) (Z.opp (Zpos py)))"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (let (q0, r0) := Z.pos_div_eucl px (Zpos py) in\n   match r0 with\n   | 0 => pair (Z.opp q0) 0\n   | _ =>\n       pair (Z.opp (Z.add q0 1))\n         match r0 with\n         | 0 => Zneg py\n         | Zpos y' => Z.pos_sub y' py\n         | Zneg y' => Zneg (Pos.add py y')\n         end\n   end)"
                ]
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c17_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c29_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c29_EQq : Logic.eq (NN.to_Z q) 0",
                    "c29_EQr : Logic.eq (NN.to_Z r) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c29_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c29_EQr : Logic.eq (NN.to_Z r) 0",
                    "c29_EQq : Logic.eq (NN.to_Z q) 0"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c30_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c31_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c32_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c32_EQq : Logic.eq (NN.to_Z q) 0",
                    "c32_EQr : Logic.eq (NN.to_Z r) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c32_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c32_EQr : Logic.eq (NN.to_Z r) 0",
                    "c32_EQq : Logic.eq (NN.to_Z q) 0"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c33_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c34_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c34_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c25_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 (Zpos px)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zpos px))"
                ],
                "tactic_res": [
                    "c35_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zpos px))",
                    "c35_EQq : Logic.eq (NN.to_Z q) 0",
                    "c35_EQr : Logic.eq (NN.to_Z r) (Zpos px)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?NN.spec_eqb , ?EQy , ?NN.spec_0 , <- ?EQx .",
                "tactic_sig_no_out_arg": "rewrite _i , ?NN.spec_eqb , ?EQy , ?NN.spec_0 , <- ?EQx .",
                "tactic_args": [
                    "c35_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zpos px))",
                    "c35_EQr : Logic.eq (NN.to_Z r) (Zpos px)"
                ],
                "tactic_res": [
                    "c36_goal : let (q, r) :=\n  if Z.eqb 0 0\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c36_goal : let (q, r) :=\n  if Z.eqb 0 0\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq (pair (NN.to_Z NN.zero) (NN.to_Z x)) (pair 0 (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "now rewrite ?EQq , NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite ?EQq , NN.spec_0 .",
                "tactic_args": [
                    "c37_goal : Logic.eq (pair (NN.to_Z NN.zero) (NN.to_Z x)) (pair 0 (NN.to_Z x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "pose proof ( B := Z.pos_div_eucl_bound _i ( Zpos _i ) ) .",
                "tactic_sig_no_out_arg": "pose proof ( B := Z.pos_div_eucl_bound _i ( Zpos _i ) ) .",
                "tactic_args": [
                    "c12_px : positive",
                    "c22_py : positive"
                ],
                "tactic_res": [
                    "c28_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (Z.pos_div_eucl px (Zpos py))))\n  (Z.lt (snd (Z.pos_div_eucl px (Zpos py))) (Zpos py))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.pos_div_eucl _i ( Zpos _i ) ) as ( q' , r' ) .",
                "tactic_sig_no_out_arg": "destruct ( Z.pos_div_eucl _i ( Zpos _i ) ) as ( q' , r' ) .",
                "tactic_args": [
                    "c28_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (let (q0, r0) := Z.pos_div_eucl px (Zpos py) in\n   match r0 with\n   | 0 => pair (Z.opp q0) 0\n   | _ =>\n       pair (Z.opp (Z.add q0 1))\n         match r0 with\n         | 0 => Zneg py\n         | Zpos y' => Z.pos_sub y' py\n         | Zneg y' => Zneg (Pos.add py y')\n         end\n   end)",
                    "c12_px : positive",
                    "c22_py : positive",
                    "c28_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (Z.pos_div_eucl px (Zpos py))))\n  (Z.lt (snd (Z.pos_div_eucl px (Zpos py))) (Zpos py))",
                    "c22_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c12_EQx : Logic.eq (NN.to_Z x) (Zpos px)",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c10_q : NN.t",
                    "c10_r : NN.t"
                ],
                "tactic_res": [
                    "c38_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair q' r'),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end",
                    "c38_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (pair q' r'))) (Z.lt (snd (pair q' r')) (Zpos py))",
                    "c38_r' : Z",
                    "c38_q' : Z"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c38_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (pair q' r'))) (Z.lt (snd (pair q' r')) (Zpos py))"
                ],
                "tactic_res": [
                    "c38_B : forall _ : Z.lt 0 (Zpos py), and (Z.le 0 r') (Z.lt r' (Zpos py))"
                ]
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c38_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair q' r'),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end"
                ],
                "tactic_res": [
                    "c39_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end",
                    "c39_EQq : Logic.eq (NN.to_Z q) q'",
                    "c39_EQr : Logic.eq (NN.to_Z r) r'"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i pr' EQr' .",
                "tactic_sig_no_out_arg": "break_nonneg _i pr' EQr' .",
                "tactic_args": [
                    "c39_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Pos x)\n   else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end",
                    "c10_r : NN.t"
                ],
                "tactic_res": [
                    "c40_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end",
                    "c40_EQr : Logic.eq 0 r'",
                    "c40_EQr' : Logic.eq (NN.to_Z r) 0",
                    "c41_goal : let (q, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end",
                    "c41_EQr : Logic.eq (Zpos pr') r'",
                    "c41_EQr' : Logic.eq (NN.to_Z r) (Zpos pr')",
                    "c41_pr' : positive"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c40_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end"
                ],
                "tactic_res": [
                    "c42_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (NN.to_Z q)) 0)",
                    "c42_B : forall _ : Z.lt 0 (Zpos py), and (Z.le 0 0) (Z.lt 0 (Zpos py))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c42_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (NN.to_Z q)) 0)"
                ],
                "tactic_res": [
                    "c43_goal : Logic.eq (pair (Z.opp (NN.to_Z q)) (NN.to_Z NN.zero))\n  (pair (Z.opp (NN.to_Z q)) 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c43_goal : Logic.eq (pair (Z.opp (NN.to_Z q)) (NN.to_Z NN.zero))\n  (pair (Z.opp (NN.to_Z q)) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c41_goal : let (q, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match r' with\n        | 0 => Zneg py\n        | Zpos y' => Z.pos_sub y' py\n        | Zneg y' => Zneg (Pos.add py y')\n        end\n  end"
                ],
                "tactic_res": [
                    "c44_goal : let (q0, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))",
                    "c44_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (Zpos pr')) (Z.lt (Zpos pr') (Zpos py))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c44_goal : let (q0, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "c22_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c45_goal : let (q0, r) :=\n  if Z.eqb 0 (Zpos py)\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c45_goal : let (q0, r) :=\n  if Z.eqb 0 (Zpos py)\n  then pair zero (Pos x)\n  else pair (Neg (NN.succ q)) (Neg (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z (NN.succ q))) (Z.opp (NN.to_Z (NN.sub y r))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i , _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i , _i , <- _i .",
                "tactic_args": [
                    "c46_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z (NN.succ q))) (Z.opp (NN.to_Z (NN.sub y r))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub pr' py))",
                    "_global_NN.spec_succ : forall n : NN.t, Logic.eq (NN.to_Z (NN.succ n)) (Z.add (NN.to_Z n) 1)",
                    "_global_NN.spec_sub : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.sub x y))\n         (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))",
                    "c22_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c41_EQr' : Logic.eq (NN.to_Z r) (Zpos pr')",
                    "_global_Z.pos_sub_opp : forall p q : positive,\n       Logic.eq (Z.opp (Z.pos_sub p q)) (Z.pos_sub q p)"
                ],
                "tactic_res": [
                    "c47_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.opp (Z.max 0 (Z.sub (Zpos py) (Zpos pr')))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.opp (Z.pos_sub py pr')))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c47_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.opp (Z.max 0 (Z.sub (Zpos py) (Zpos pr')))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.opp (Z.pos_sub py pr')))"
                ],
                "tactic_res": [
                    "c48_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.opp (Z.max 0 (Z.pos_sub py pr'))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.opp (Z.pos_sub py pr')))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c48_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.opp (Z.max 0 (Z.pos_sub py pr'))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.opp (Z.pos_sub py pr')))"
                ],
                "tactic_res": [
                    "c49_goal : Logic.eq (Z.opp (Z.max 0 (Z.pos_sub py pr')))\n  (Z.opp (Z.pos_sub py pr'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : Logic.eq (Z.opp (Z.max 0 (Z.pos_sub py pr')))\n  (Z.opp (Z.pos_sub py pr'))",
                    "_global_Z.pos_sub_gt : forall (p q : positive) (_ : Pos.lt q p),\n       Logic.eq (Z.pos_sub p q) (Zpos (Pos.sub p q))"
                ],
                "tactic_res": [
                    "c50_goal : Logic.eq (Z.opp (Z.max 0 (Zpos (Pos.sub py pr'))))\n  (Z.opp (Zpos (Pos.sub py pr')))",
                    "c51_goal : Pos.lt pr' py"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c50_goal : Logic.eq (Z.opp (Z.max 0 (Zpos (Pos.sub py pr'))))\n  (Z.opp (Zpos (Pos.sub py pr')))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c51_goal : Pos.lt pr' py"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c5_goal : let (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c52_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_sig_no_out_arg": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_args": [
                    "c52_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  let (q, r) := NN.div_eucl x y in\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c53_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c53_r : NN.t",
                    "c53_q : NN.t"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i px EQx .",
                "tactic_sig_no_out_arg": "break_nonneg _i px EQx .",
                "tactic_args": [
                    "c53_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c5_x : NN.t"
                ],
                "tactic_res": [
                    "c54_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (NN.to_Z y))",
                    "c54_EQx : Logic.eq (NN.to_Z x) 0",
                    "c55_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (NN.to_Z y))",
                    "c55_EQx : Logic.eq (NN.to_Z x) (Zpos px)",
                    "c55_px : positive"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c54_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (NN.to_Z y))",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c56_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) 0)",
                    "c56_EQy : Logic.eq (NN.to_Z y) 0",
                    "c57_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (Zpos py))",
                    "c57_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c57_py : positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c56_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) 0)",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c58_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c58_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) 0)"
                ],
                "tactic_res": [
                    "c59_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c57_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (Zpos py))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c60_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (Zpos py))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c60_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp 0) (Zpos py))"
                ],
                "tactic_res": [
                    "c61_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c55_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (NN.to_Z y))",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c62_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) 0)",
                    "c62_EQy : Logic.eq (NN.to_Z y) 0",
                    "c63_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (Zpos py))",
                    "c63_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c63_py : positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c62_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) 0)",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c64_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c64_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) 0)"
                ],
                "tactic_res": [
                    "c65_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 (Zpos px)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c63_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if NN.eqb NN.zero r\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (Zpos py))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c66_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (Zpos py))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c66_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nlet (q, r) :=\n  if Z.eqb 0 (NN.to_Z r)\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (Zpos px)) (Zpos py))"
                ],
                "tactic_res": [
                    "c67_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (let (q0, r0) := Z.pos_div_eucl px (Zpos py) in\n   match r0 with\n   | 0 => pair (Z.opp q0) 0\n   | _ =>\n       pair (Z.opp (Z.add q0 1))\n         match Z.opp r0 with\n         | 0 => Zpos py\n         | Zpos y' => Zpos (Pos.add py y')\n         | Zneg y' => Z.pos_sub py y'\n         end\n   end)"
                ]
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c59_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c68_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c68_EQq : Logic.eq (NN.to_Z q) 0",
                    "c68_EQr : Logic.eq (NN.to_Z r) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c68_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c68_EQr : Logic.eq (NN.to_Z r) 0",
                    "c68_EQq : Logic.eq (NN.to_Z q) 0"
                ],
                "tactic_res": [
                    "c69_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c69_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c70_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c70_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c61_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 0),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c71_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c71_EQq : Logic.eq (NN.to_Z q) 0",
                    "c71_EQr : Logic.eq (NN.to_Z r) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c71_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)",
                    "c71_EQr : Logic.eq (NN.to_Z r) 0",
                    "c71_EQq : Logic.eq (NN.to_Z q) 0"
                ],
                "tactic_res": [
                    "c72_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c72_goal : Logic.eq\n  (pair (Z.opp 0)\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 0)"
                ],
                "tactic_res": [
                    "c73_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c73_goal : Logic.eq (pair 0 (NN.to_Z NN.zero)) (pair 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c65_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair 0 (Zpos px)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))"
                ],
                "tactic_res": [
                    "c74_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))",
                    "c74_EQq : Logic.eq (NN.to_Z q) 0",
                    "c74_EQr : Logic.eq (NN.to_Z r) (Zpos px)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?NN.spec_eqb , ?EQy , ?NN.spec_0 .",
                "tactic_sig_no_out_arg": "rewrite _i , ?NN.spec_eqb , ?EQy , ?NN.spec_0 .",
                "tactic_args": [
                    "c74_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))",
                    "c74_EQr : Logic.eq (NN.to_Z r) (Zpos px)"
                ],
                "tactic_res": [
                    "c75_goal : let (q, r) :=\n  if Z.eqb 0 0\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c75_goal : let (q, r) :=\n  if Z.eqb 0 0\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair 0 (Zneg px))"
                ],
                "tactic_res": [
                    "c76_goal : Logic.eq (pair (NN.to_Z NN.zero) (Z.opp (NN.to_Z x)))\n  (pair 0 (Zneg px))"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 , <- ?Pos2Z.opp_pos , ?EQx , ?EQq .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 , <- ?Pos2Z.opp_pos , ?EQx , ?EQq .",
                "tactic_args": [
                    "c76_goal : Logic.eq (pair (NN.to_Z NN.zero) (Z.opp (NN.to_Z x)))\n  (pair 0 (Zneg px))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "pose proof ( B := Z.pos_div_eucl_bound _i ( Zpos _i ) ) .",
                "tactic_sig_no_out_arg": "pose proof ( B := Z.pos_div_eucl_bound _i ( Zpos _i ) ) .",
                "tactic_args": [
                    "c55_px : positive",
                    "c63_py : positive"
                ],
                "tactic_res": [
                    "c67_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (Z.pos_div_eucl px (Zpos py))))\n  (Z.lt (snd (Z.pos_div_eucl px (Zpos py))) (Zpos py))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.pos_div_eucl _i ( Zpos _i ) ) as ( q' , r' ) .",
                "tactic_sig_no_out_arg": "destruct ( Z.pos_div_eucl _i ( Zpos _i ) ) as ( q' , r' ) .",
                "tactic_args": [
                    "c67_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (let (q0, r0) := Z.pos_div_eucl px (Zpos py) in\n   match r0 with\n   | 0 => pair (Z.opp q0) 0\n   | _ =>\n       pair (Z.opp (Z.add q0 1))\n         match Z.opp r0 with\n         | 0 => Zpos py\n         | Zpos y' => Zpos (Pos.add py y')\n         | Zneg y' => Z.pos_sub py y'\n         end\n   end)",
                    "c55_px : positive",
                    "c63_py : positive",
                    "c67_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (Z.pos_div_eucl px (Zpos py))))\n  (Z.lt (snd (Z.pos_div_eucl px (Zpos py))) (Zpos py))",
                    "c63_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c55_EQx : Logic.eq (NN.to_Z x) (Zpos px)",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c53_q : NN.t",
                    "c53_r : NN.t"
                ],
                "tactic_res": [
                    "c77_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair q' r'),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end",
                    "c77_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (pair q' r'))) (Z.lt (snd (pair q' r')) (Zpos py))",
                    "c77_r' : Z",
                    "c77_q' : Z"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c77_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (snd (pair q' r'))) (Z.lt (snd (pair q' r')) (Zpos py))"
                ],
                "tactic_res": [
                    "c77_B : forall _ : Z.lt 0 (Zpos py), and (Z.le 0 r') (Z.lt r' (Zpos py))"
                ]
            },
            {
                "tactic_sig": "intros [ = _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ = EQq EQr ] .",
                "tactic_args": [
                    "c77_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (pair q' r'),\nlet (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end"
                ],
                "tactic_res": [
                    "c78_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end",
                    "c78_EQq : Logic.eq (NN.to_Z q) q'",
                    "c78_EQr : Logic.eq (NN.to_Z r) r'"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i pr' EQr' .",
                "tactic_sig_no_out_arg": "break_nonneg _i pr' EQr' .",
                "tactic_args": [
                    "c78_goal : let (q, r) :=\n  if match NN.to_Z r with\n     | 0 => true\n     | _ => false\n     end\n  then pair (Neg q) zero\n  else\n   if NN.eqb NN.zero y\n   then pair zero (Neg x)\n   else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end",
                    "c53_r : NN.t"
                ],
                "tactic_res": [
                    "c79_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end",
                    "c79_EQr : Logic.eq 0 r'",
                    "c79_EQr' : Logic.eq (NN.to_Z r) 0",
                    "c80_goal : let (q, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end",
                    "c80_EQr : Logic.eq (Zpos pr') r'",
                    "c80_EQr' : Logic.eq (NN.to_Z r) (Zpos pr')",
                    "c80_pr' : positive"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c79_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end"
                ],
                "tactic_res": [
                    "c81_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (NN.to_Z q)) 0)",
                    "c81_B : forall _ : Z.lt 0 (Zpos py), and (Z.le 0 0) (Z.lt 0 (Zpos py))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c81_goal : Logic.eq\n  (pair (Z.opp (NN.to_Z q))\n     match zero with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (pair (Z.opp (NN.to_Z q)) 0)"
                ],
                "tactic_res": [
                    "c82_goal : Logic.eq (pair (Z.opp (NN.to_Z q)) (NN.to_Z NN.zero))\n  (pair (Z.opp (NN.to_Z q)) 0)"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_0 .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_0 .",
                "tactic_args": [
                    "c82_goal : Logic.eq (pair (Z.opp (NN.to_Z q)) (NN.to_Z NN.zero))\n  (pair (Z.opp (NN.to_Z q)) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c80_goal : let (q, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  match r' with\n  | 0 => pair (Z.opp q') 0\n  | _ =>\n      pair (Z.opp (Z.add q' 1))\n        match Z.opp r' with\n        | 0 => Zpos py\n        | Zpos y' => Zpos (Pos.add py y')\n        | Zneg y' => Z.pos_sub py y'\n        end\n  end"
                ],
                "tactic_res": [
                    "c83_goal : let (q0, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     match Z.opp (Zpos pr') with\n     | 0 => Zpos py\n     | Zpos y' => Zpos (Pos.add py y')\n     | Zneg y' => Z.pos_sub py y'\n     end)",
                    "c83_B : forall _ : Z.lt 0 (Zpos py),\nand (Z.le 0 (Zpos pr')) (Z.lt (Zpos pr') (Zpos py))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c83_goal : let (q0, r) :=\n  if NN.eqb NN.zero y\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     match Z.opp (Zpos pr') with\n     | 0 => Zpos py\n     | Zpos y' => Zpos (Pos.add py y')\n     | Zneg y' => Z.pos_sub py y'\n     end)",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "c63_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c84_goal : let (q0, r) :=\n  if Z.eqb 0 (Zpos py)\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     match Z.opp (Zpos pr') with\n     | 0 => Zpos py\n     | Zpos y' => Zpos (Pos.add py y')\n     | Zneg y' => Z.pos_sub py y'\n     end)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c84_goal : let (q0, r) :=\n  if Z.eqb 0 (Zpos py)\n  then pair zero (Neg x)\n  else pair (Neg (NN.succ q)) (Pos (NN.sub y r)) in\nLogic.eq\n  (pair\n     match q0 with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end)\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     match Z.opp (Zpos pr') with\n     | 0 => Zpos py\n     | Zpos y' => Zpos (Pos.add py y')\n     | Zneg y' => Z.pos_sub py y'\n     end)"
                ],
                "tactic_res": [
                    "c85_goal : Logic.eq (pair (Z.opp (NN.to_Z (NN.succ q))) (NN.to_Z (NN.sub y r)))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i , _i .",
                "tactic_args": [
                    "c85_goal : Logic.eq (pair (Z.opp (NN.to_Z (NN.succ q))) (NN.to_Z (NN.sub y r)))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))",
                    "_global_NN.spec_succ : forall n : NN.t, Logic.eq (NN.to_Z (NN.succ n)) (Z.add (NN.to_Z n) 1)",
                    "_global_NN.spec_sub : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.sub x y))\n         (Z.max 0 (Z.sub (NN.to_Z x) (NN.to_Z y)))",
                    "c63_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c80_EQr' : Logic.eq (NN.to_Z r) (Zpos pr')"
                ],
                "tactic_res": [
                    "c86_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.max 0 (Z.sub (Zpos py) (Zpos pr'))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c86_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1))\n     (Z.max 0 (Z.sub (Zpos py) (Zpos pr'))))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))"
                ],
                "tactic_res": [
                    "c87_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.max 0 (Z.pos_sub py pr')))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c87_goal : Logic.eq\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.max 0 (Z.pos_sub py pr')))\n  (pair (Z.opp (Z.add (NN.to_Z q) 1)) (Z.pos_sub py pr'))"
                ],
                "tactic_res": [
                    "c88_goal : Logic.eq (Z.max 0 (Z.pos_sub py pr')) (Z.pos_sub py pr')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c88_goal : Logic.eq (Z.max 0 (Z.pos_sub py pr')) (Z.pos_sub py pr')",
                    "_global_Z.pos_sub_gt : forall (p q : positive) (_ : Pos.lt q p),\n       Logic.eq (Z.pos_sub p q) (Zpos (Pos.sub p q))"
                ],
                "tactic_res": [
                    "c89_goal : Logic.eq (Z.max 0 (Zpos (Pos.sub py pr'))) (Zpos (Pos.sub py pr'))",
                    "c90_goal : Pos.lt pr' py"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c89_goal : Logic.eq (Z.max 0 (Zpos (Pos.sub py pr'))) (Zpos (Pos.sub py pr'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c90_goal : Pos.lt pr' py"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c6_goal : let (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Neg r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c6_x : NN.t",
                    "c6_y : NN.t"
                ],
                "tactic_res": [
                    "c91_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Neg r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_sig_no_out_arg": "destruct ( NN.div_eucl _i _i ) as ( q , r ) .",
                "tactic_args": [
                    "c91_goal : forall\n  _ : let (q, r) := NN.div_eucl x y in\n      Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nlet (q, r) := let (q, r) := NN.div_eucl x y in pair (Pos q) (Neg r) in\nLogic.eq\n  (pair\n     match q with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end\n     match r with\n     | Pos nx => NN.to_Z nx\n     | Neg nx => Z.opp (NN.to_Z nx)\n     end) (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c6_x : NN.t",
                    "c6_y : NN.t"
                ],
                "tactic_res": [
                    "c92_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c92_r : NN.t",
                    "c92_q : NN.t"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i px EQx .",
                "tactic_sig_no_out_arg": "break_nonneg _i px EQx .",
                "tactic_args": [
                    "c92_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (NN.to_Z x) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c6_x : NN.t"
                ],
                "tactic_res": [
                    "c93_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp (NN.to_Z y)))",
                    "c93_EQx : Logic.eq (NN.to_Z x) 0",
                    "c94_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp (NN.to_Z y)))",
                    "c94_EQx : Logic.eq (NN.to_Z x) (Zpos px)",
                    "c94_px : positive"
                ]
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c93_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl 0 (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp (NN.to_Z y)))",
                    "c6_y : NN.t"
                ],
                "tactic_res": [
                    "c95_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp 0))",
                    "c95_EQy : Logic.eq (NN.to_Z y) 0",
                    "c96_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp (Zpos py)))",
                    "c96_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c96_py : positive"
                ]
            },
            {
                "tactic_sig": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_sig_no_out_arg": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_args": [
                    "c95_goal : forall _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 0),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp 0))",
                    "c92_q : NN.t",
                    "c92_r : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_sig_no_out_arg": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_args": [
                    "c96_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl 0 (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp 0) (Z.opp (Zpos py)))",
                    "c96_py : positive",
                    "c92_q : NN.t",
                    "c92_r : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_nonneg _i py EQy .",
                "tactic_sig_no_out_arg": "break_nonneg _i py EQy .",
                "tactic_args": [
                    "c94_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (NN.to_Z y)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp (NN.to_Z y)))",
                    "c6_y : NN.t"
                ],
                "tactic_res": [
                    "c97_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp 0))",
                    "c97_EQy : Logic.eq (NN.to_Z y) 0",
                    "c98_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp (Zpos py)))",
                    "c98_EQy : Logic.eq (NN.to_Z y) (Zpos py)",
                    "c98_py : positive"
                ]
            },
            {
                "tactic_sig": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_sig_no_out_arg": "try ( injection 1 as -> -> ; auto ) .",
                "tactic_args": [
                    "c97_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r)) (Z.div_eucl (Zpos px) 0),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp 0))",
                    "c94_px : positive",
                    "c92_q : NN.t",
                    "c92_r : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c98_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.div_eucl (Zpos px) (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (Z.div_eucl (Z.opp (Zpos px)) (Z.opp (Zpos py)))"
                ],
                "tactic_res": [
                    "c99_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (let (q, r) := Z.pos_div_eucl px (Zpos py) in pair q (Z.opp r))"
                ]
            },
            {
                "tactic_sig": "intros <- .",
                "tactic_sig_no_out_arg": "intros <- .",
                "tactic_args": [
                    "c99_goal : forall\n  _ : Logic.eq (pair (NN.to_Z q) (NN.to_Z r))\n        (Z.pos_div_eucl px (Zpos py)),\nLogic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (let (q, r) := Z.pos_div_eucl px (Zpos py) in pair q (Z.opp r))"
                ],
                "tactic_res": [
                    "c100_goal : Logic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c100_goal : Logic.eq (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))\n  (pair (NN.to_Z q) (Z.opp (NN.to_Z r)))",
                    "c92_q : NN.t",
                    "c92_r : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div",
        "proof": [
            {
                "tactic_sig": "Definition spec_div : forall x y , to_Z ( div x y ) = to_Z x / to_Z y .",
                "tactic_sig_no_out_arg": "Definition spec_div : forall x y , to_Z ( div x y ) = to_Z x / to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))",
                    "_global_div : forall (_ : t_) (_ : t_), t_",
                    "_global_Z.div : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (fst (div_eucl x y)))\n  (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ]
            },
            {
                "tactic_sig": "case div_eucl .",
                "tactic_sig_no_out_arg": "case div_eucl .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (fst (div_eucl x y)))\n  (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ],
                "tactic_res": [
                    "c5_goal : forall (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (fst (pair t t0)))\n  (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c5_goal : forall (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (fst (pair t t0)))\n  (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ],
                "tactic_res": [
                    "c6_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z (fst (pair t t0))) z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z (fst (pair t t0))) z"
                ],
                "tactic_res": [
                    "c7_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z t) z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros q r q11 r1 H .",
                "tactic_args": [
                    "c7_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z t) z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z q11) q",
                    "c8_q : Z",
                    "c8_r : Z",
                    "c8_q11 : t_",
                    "c8_r1 : t_",
                    "c8_H : Logic.eq (pair (to_Z q11) (to_Z r1)) (pair q r)"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z q11) q",
                    "c8_H : Logic.eq (pair (to_Z q11) (to_Z r1)) (pair q r)"
                ],
                "tactic_res": [
                    "c9_goal : forall (_ : Logic.eq (to_Z r1) r) (_ : Logic.eq (to_Z q11) q),\nLogic.eq (to_Z q11) q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall (_ : Logic.eq (to_Z r1) r) (_ : Logic.eq (to_Z q11) q),\nLogic.eq (to_Z q11) q",
                    "c8_q11 : t_",
                    "c8_r1 : t_",
                    "c8_q : Z",
                    "c8_r : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_modulo",
        "proof": [
            {
                "tactic_sig": "Theorem spec_modulo : forall x y , to_Z ( modulo x y ) = to_Z x mod to_Z y .",
                "tactic_sig_no_out_arg": "Theorem spec_modulo : forall x y , to_Z ( modulo x y ) = to_Z x mod to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_,\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_,\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_modulo : forall (_ : t_) (_ : t_), t_",
                    "_global_Z.modulo : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (snd (div_eucl x y)))\n  (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)"
                ]
            },
            {
                "tactic_sig": "case div_eucl .",
                "tactic_sig_no_out_arg": "case div_eucl .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (snd (div_eucl x y)))\n  (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)"
                ],
                "tactic_res": [
                    "c5_goal : forall (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (snd (pair t t0)))\n  (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c5_goal : forall (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (snd (pair t t0)))\n  (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)"
                ],
                "tactic_res": [
                    "c6_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z (snd (pair t t0))) z0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z (snd (pair t t0))) z0"
                ],
                "tactic_res": [
                    "c7_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z t0) z0"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros q r q11 r1 H .",
                "tactic_args": [
                    "c7_goal : forall (z z0 : Z) (t t0 : t_)\n  (_ : Logic.eq (pair (to_Z t) (to_Z t0)) (pair z z0)),\nLogic.eq (to_Z t0) z0"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z r1) r",
                    "c8_q : Z",
                    "c8_r : Z",
                    "c8_q11 : t_",
                    "c8_r1 : t_",
                    "c8_H : Logic.eq (pair (to_Z q11) (to_Z r1)) (pair q r)"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z r1) r",
                    "c8_H : Logic.eq (pair (to_Z q11) (to_Z r1)) (pair q r)"
                ],
                "tactic_res": [
                    "c9_goal : forall (_ : Logic.eq (to_Z r1) r) (_ : Logic.eq (to_Z q11) q),\nLogic.eq (to_Z r1) r"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall (_ : Logic.eq (to_Z r1) r) (_ : Logic.eq (to_Z q11) q),\nLogic.eq (to_Z r1) r",
                    "c8_q11 : t_",
                    "c8_r1 : t_",
                    "c8_q : Z",
                    "c8_r : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_quot",
        "proof": [
            {
                "tactic_sig": "Lemma spec_quot : forall x y , to_Z ( quot x y ) = ( to_Z x ) \u00f7 ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_quot : forall x y , to_Z ( quot x y ) = ( to_Z x ) \u00f7 ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (quot x y)) (Z.quot (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros [ x|x ] [ y|y ] .",
                "tactic_sig_no_out_arg": "intros [ x|x ] [ y|y ] .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (quot x y)) (Z.quot (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (quot (Pos x) (Pos y)))\n  (Z.quot (to_Z (Pos x)) (to_Z (Pos y)))",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : Logic.eq (to_Z (quot (Neg x) (Neg y)))\n  (Z.quot (to_Z (Neg x)) (to_Z (Neg y)))",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : Logic.eq (to_Z (quot (Neg x) (Pos y)))\n  (Z.quot (to_Z (Neg x)) (to_Z (Pos y)))",
                    "c3_x : NN.t",
                    "c3_y : NN.t",
                    "c3_goal : Logic.eq (to_Z (quot (Pos x) (Neg y)))\n  (Z.quot (to_Z (Pos x)) (to_Z (Neg y)))",
                    "c2_x : NN.t",
                    "c2_y : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (quot (Pos x) (Pos y)))\n  (Z.quot (to_Z (Pos x)) (to_Z (Pos y)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (NN.to_Z (NN.div x y)) (Z.quot (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.to_Z (NN.div x y)) (Z.quot (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y)) (NN.to_Z (NN.div x y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y)) (NN.to_Z (NN.div x y))",
                    "_global_NN.spec_div : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.div x y)) (Z.div (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c2_y : NN.t",
                    "c2_x : NN.t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c9_EQ : Logic.eq (NN.to_Z y) 0",
                    "c10_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c10_NEQ : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c9_EQ : Logic.eq (NN.to_Z y) 0",
                    "c2_x : NN.t",
                    "c2_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c2_x : NN.t",
                    "c10_NEQ : not (Logic.eq (NN.to_Z y) 0)",
                    "c2_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.quot_div_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.quot a b) (Z.div a b)"
                ],
                "tactic_res": [
                    "c11_goal : Z.le 0 (NN.to_Z x)",
                    "c12_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c11_goal : Z.le 0 (NN.to_Z x)",
                    "c2_x : NN.t",
                    "c2_y : NN.t"
                ],
                "tactic_res": [
                    "c13_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c13_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c12_goal : Z.lt 0 (NN.to_Z y)",
                    "c2_x : NN.t",
                    "c2_y : NN.t"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c14_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (quot (Pos x) (Neg y)))\n  (Z.quot (to_Z (Pos x)) (to_Z (Neg y)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.div x y)))\n  (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.div x y)))\n  (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (NN.to_Z (NN.div x y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (NN.to_Z (NN.div x y)))",
                    "_global_NN.spec_div : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.div x y)) (Z.div (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_args": [
                    "c17_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c3_y : NN.t",
                    "c3_x : NN.t"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c18_EQ : Logic.eq (NN.to_Z y) 0",
                    "c19_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c19_NEQ : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c18_EQ : Logic.eq (NN.to_Z y) 0",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c3_x : NN.t",
                    "c19_NEQ : not (Logic.eq (NN.to_Z y) 0)",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.quot (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c21_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.quot_div_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.quot a b) (Z.div a b)"
                ],
                "tactic_res": [
                    "c22_goal : Z.le 0 (NN.to_Z x)",
                    "c23_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c22_goal : Z.le 0 (NN.to_Z x)",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": [
                    "c24_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c24_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c23_goal : Z.lt 0 (NN.to_Z y)",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": [
                    "c25_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c25_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c21_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (quot (Neg x) (Pos y)))\n  (Z.quot (to_Z (Neg x)) (to_Z (Pos y)))"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (Z.opp (NN.to_Z (NN.div x y)))\n  (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Z.opp (NN.to_Z (NN.div x y)))\n  (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (NN.to_Z (NN.div x y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (NN.to_Z (NN.div x y)))",
                    "_global_NN.spec_div : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.div x y)) (Z.div (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_args": [
                    "c28_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c4_y : NN.t",
                    "c4_x : NN.t"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c29_EQ : Logic.eq (NN.to_Z y) 0",
                    "c30_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c30_NEQ : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c29_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))",
                    "c29_EQ : Logic.eq (NN.to_Z y) 0",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c4_x : NN.t",
                    "c30_NEQ : not (Logic.eq (NN.to_Z y) 0)",
                    "c4_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c30_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (Z.div (NN.to_Z x) (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c32_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.quot_div_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.quot a b) (Z.div a b)"
                ],
                "tactic_res": [
                    "c33_goal : Z.le 0 (NN.to_Z x)",
                    "c34_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c33_goal : Z.le 0 (NN.to_Z x)",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c35_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c35_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c34_goal : Z.lt 0 (NN.to_Z y)",
                    "c4_x : NN.t",
                    "c4_y : NN.t"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c36_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c32_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (quot (Neg x) (Neg y)))\n  (Z.quot (to_Z (Neg x)) (to_Z (Neg y)))"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq (NN.to_Z (NN.div x y))\n  (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c37_goal : Logic.eq (NN.to_Z (NN.div x y))\n  (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c38_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (NN.to_Z (NN.div x y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c38_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (NN.to_Z (NN.div x y))",
                    "_global_NN.spec_div : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.div x y)) (Z.div (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c39_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec ( NN.to_Z _i ) 0 ) as [ EQ|NEQ ] .",
                "tactic_args": [
                    "c39_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c5_y : NN.t",
                    "c5_x : NN.t"
                ],
                "tactic_res": [
                    "c40_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c40_EQ : Logic.eq (NN.to_Z y) 0",
                    "c41_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c41_NEQ : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c40_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c40_EQ : Logic.eq (NN.to_Z y) 0",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "try ( rewrite EQ ; now destruct ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c5_x : NN.t",
                    "c41_NEQ : not (Logic.eq (NN.to_Z y) 0)",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite ?Z.quot_opp_r , ?Z.quot_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c41_goal : Logic.eq (Z.quot (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.div (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c42_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "c43_goal : not (Logic.eq (NN.to_Z y) 0)",
                    "c44_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c42_goal : Logic.eq (Z.quot (NN.to_Z x) (NN.to_Z y))\n  (Z.div (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.quot_div_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.quot a b) (Z.div a b)"
                ],
                "tactic_res": [
                    "c45_goal : Z.le 0 (NN.to_Z x)",
                    "c46_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c45_goal : Z.le 0 (NN.to_Z x)",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c47_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c47_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c46_goal : Z.lt 0 (NN.to_Z y)",
                    "c5_x : NN.t",
                    "c5_y : NN.t"
                ],
                "tactic_res": [
                    "c48_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c48_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c43_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c44_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_rem",
        "proof": [
            {
                "tactic_sig": "Lemma spec_rem : forall x y , to_Z ( rem x y ) = Z.rem ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_rem : forall x y , to_Z ( rem x y ) = Z.rem ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (rem x y)) (Z.rem (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (rem x y)) (Z.rem (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (rem x y)) (Z.rem (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (rem x y)) (Z.rem (to_Z x) (to_Z y))",
                    "_global_rem : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb y zero\n      then x\n      else\n       match x with\n       | Pos nx =>\n           match y with\n           | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n           end\n       | Neg nx =>\n           match y with\n           | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n           end\n       end)) (Z.rem (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb y zero\n      then x\n      else\n       match x with\n       | Pos nx =>\n           match y with\n           | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n           end\n       | Neg nx =>\n           match y with\n           | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n           end\n       end)) (Z.rem (to_Z x) (to_Z y))",
                    "_global_spec_eqb : forall x y : t_, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z y) 0\n      then x\n      else\n       match x with\n       | Pos nx =>\n           match y with\n           | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n           end\n       | Neg nx =>\n           match y with\n           | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n           end\n       end)) (Z.rem (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z y) 0\n      then x\n      else\n       match x with\n       | Pos nx =>\n           match y with\n           | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n           end\n       | Neg nx =>\n           match y with\n           | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n           end\n       end)) (Z.rem (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (to_Z x) (Z.rem (to_Z x) (to_Z y))",
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nLogic.eq\n  (to_Z\n     match x with\n     | Pos nx =>\n         match y with\n         | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n         end\n     | Neg nx =>\n         match y with\n         | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n         end\n     end) (Z.rem (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hy .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (to_Z x) (Z.rem (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (to_Z x) (Z.rem (to_Z x) (to_Z y))",
                    "c7_Hy : Logic.eq (to_Z y) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hy .",
                "tactic_args": [
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nLogic.eq\n  (to_Z\n     match x with\n     | Pos nx =>\n         match y with\n         | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n         end\n     | Neg nx =>\n         match y with\n         | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n         end\n     end) (Z.rem (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match x with\n     | Pos nx =>\n         match y with\n         | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n         end\n     | Neg nx =>\n         match y with\n         | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n         end\n     end) (Z.rem (to_Z x) (to_Z y))",
                    "c8_Hy : not (Logic.eq (to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z x) (Z.rem (to_Z x) (to_Z y))",
                    "c7_Hy : Logic.eq (to_Z y) 0"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Z x) (Z.rem (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "now destruct ( to_Z _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( to_Z _i ) .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z x) (Z.rem (to_Z x) 0)",
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ x|x ] , _i as [ y|y ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ x|x ] , _i as [ y|y ] .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match x with\n     | Pos nx =>\n         match y with\n         | Pos ny | Neg ny => Pos (NN.modulo nx ny)\n         end\n     | Neg nx =>\n         match y with\n         | Pos ny | Neg ny => Neg (NN.modulo nx ny)\n         end\n     end) (Z.rem (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_",
                    "c8_Hy : not (Logic.eq (to_Z y) 0)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (Pos (NN.modulo x y)))\n  (Z.rem (to_Z (Pos x)) (to_Z (Pos y)))",
                    "c10_Hy : not (Logic.eq (to_Z (Pos y)) 0)",
                    "c10_y : NN.t",
                    "c10_x : NN.t",
                    "c11_goal : Logic.eq (to_Z (Pos (NN.modulo x y)))\n  (Z.rem (to_Z (Pos x)) (to_Z (Neg y)))",
                    "c11_Hy : not (Logic.eq (to_Z (Neg y)) 0)",
                    "c11_y : NN.t",
                    "c11_x : NN.t",
                    "c12_goal : Logic.eq (to_Z (Neg (NN.modulo x y)))\n  (Z.rem (to_Z (Neg x)) (to_Z (Pos y)))",
                    "c12_Hy : not (Logic.eq (to_Z (Pos y)) 0)",
                    "c12_y : NN.t",
                    "c12_x : NN.t",
                    "c13_goal : Logic.eq (to_Z (Neg (NN.modulo x y)))\n  (Z.rem (to_Z (Neg x)) (to_Z (Neg y)))",
                    "c13_Hy : not (Logic.eq (to_Z (Neg y)) 0)",
                    "c13_y : NN.t",
                    "c13_x : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (Pos (NN.modulo x y)))\n  (Z.rem (to_Z (Pos x)) (to_Z (Pos y)))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (NN.to_Z (NN.modulo x y)) (Z.rem (NN.to_Z x) (NN.to_Z y))",
                    "c14_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c14_goal : Logic.eq (NN.to_Z (NN.modulo x y)) (Z.rem (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y)) (NN.to_Z (NN.modulo x y))"
                ]
            },
            {
                "tactic_sig": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_sig_no_out_arg": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_args": [
                    "c14_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y)) (NN.to_Z (NN.modulo x y))",
                    "_global_NN.spec_modulo : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.modulo x y)) (Z.modulo (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.rem_mod_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.rem a b) (Z.modulo a b)"
                ],
                "tactic_res": [
                    "c17_goal : Z.le 0 (NN.to_Z x)",
                    "c18_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c17_goal : Z.le 0 (NN.to_Z x)",
                    "c10_x : NN.t",
                    "c10_y : NN.t"
                ],
                "tactic_res": [
                    "c19_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c19_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c18_goal : Z.lt 0 (NN.to_Z y)",
                    "c10_x : NN.t",
                    "c10_y : NN.t"
                ],
                "tactic_res": [
                    "c20_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c20_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z (Pos (NN.modulo x y)))\n  (Z.rem (to_Z (Pos x)) (to_Z (Neg y)))"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (NN.to_Z (NN.modulo x y))\n  (Z.rem (NN.to_Z x) (Z.opp (NN.to_Z y)))",
                    "c21_Hy : not (Logic.eq (Z.opp (NN.to_Z y)) 0)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c21_goal : Logic.eq (NN.to_Z (NN.modulo x y))\n  (Z.rem (NN.to_Z x) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.rem (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (NN.to_Z (NN.modulo x y))"
                ]
            },
            {
                "tactic_sig": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_sig_no_out_arg": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_args": [
                    "c22_Hy : not (Logic.eq (Z.opp (NN.to_Z y)) 0)"
                ],
                "tactic_res": [
                    "c22_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.rem (NN.to_Z x) (Z.opp (NN.to_Z y)))\n  (NN.to_Z (NN.modulo x y))",
                    "_global_NN.spec_modulo : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.modulo x y)) (Z.modulo (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "c24_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.rem_mod_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.rem a b) (Z.modulo a b)"
                ],
                "tactic_res": [
                    "c25_goal : Z.le 0 (NN.to_Z x)",
                    "c26_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c25_goal : Z.le 0 (NN.to_Z x)",
                    "c11_x : NN.t",
                    "c11_y : NN.t"
                ],
                "tactic_res": [
                    "c27_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c27_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 (NN.to_Z y)",
                    "c11_x : NN.t",
                    "c11_y : NN.t"
                ],
                "tactic_res": [
                    "c28_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c28_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c24_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c12_goal : Logic.eq (to_Z (Neg (NN.modulo x y)))\n  (Z.rem (to_Z (Neg x)) (to_Z (Pos y)))"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq (Z.opp (NN.to_Z (NN.modulo x y)))\n  (Z.rem (Z.opp (NN.to_Z x)) (NN.to_Z y))",
                    "c29_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c29_goal : Logic.eq (Z.opp (NN.to_Z (NN.modulo x y)))\n  (Z.rem (Z.opp (NN.to_Z x)) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq (Z.rem (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (NN.to_Z (NN.modulo x y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_sig_no_out_arg": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_args": [
                    "c29_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c30_goal : Logic.eq (Z.rem (Z.opp (NN.to_Z x)) (NN.to_Z y))\n  (Z.opp (NN.to_Z (NN.modulo x y)))",
                    "_global_NN.spec_modulo : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.modulo x y)) (Z.modulo (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "c32_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.rem_mod_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.rem a b) (Z.modulo a b)"
                ],
                "tactic_res": [
                    "c33_goal : Z.le 0 (NN.to_Z x)",
                    "c34_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c33_goal : Z.le 0 (NN.to_Z x)",
                    "c12_x : NN.t",
                    "c12_y : NN.t"
                ],
                "tactic_res": [
                    "c35_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c35_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c34_goal : Z.lt 0 (NN.to_Z y)",
                    "c12_x : NN.t",
                    "c12_y : NN.t"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c36_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c32_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.modulo x y)))\n  (Z.rem (to_Z (Neg x)) (to_Z (Neg y)))"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq (Z.opp (NN.to_Z (NN.modulo x y)))\n  (Z.rem (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))",
                    "c37_Hy : not (Logic.eq (Z.opp (NN.to_Z y)) 0)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c37_goal : Logic.eq (Z.opp (NN.to_Z (NN.modulo x y)))\n  (Z.rem (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))"
                ],
                "tactic_res": [
                    "c38_goal : Logic.eq (Z.rem (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.opp (NN.to_Z (NN.modulo x y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_sig_no_out_arg": "rewrite ?Z.eq_opp_l , ?Z.opp_0 in _i .",
                "tactic_args": [
                    "c38_Hy : not (Logic.eq (Z.opp (NN.to_Z y)) 0)"
                ],
                "tactic_res": [
                    "c38_Hy : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.rem_opp_r , ?Z.rem_opp_l , ?Z.opp_involutive , ?Z.opp_inj_wd .",
                "tactic_args": [
                    "c38_goal : Logic.eq (Z.rem (Z.opp (NN.to_Z x)) (Z.opp (NN.to_Z y)))\n  (Z.opp (NN.to_Z (NN.modulo x y)))",
                    "_global_NN.spec_modulo : forall x y : NN.t,\n       Logic.eq (NN.to_Z (NN.modulo x y)) (Z.modulo (NN.to_Z x) (NN.to_Z y))"
                ],
                "tactic_res": [
                    "c39_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "c40_goal : not (Logic.eq (NN.to_Z y) 0)",
                    "c41_goal : not (Logic.eq (NN.to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : Logic.eq (Z.rem (NN.to_Z x) (NN.to_Z y))\n  (Z.modulo (NN.to_Z x) (NN.to_Z y))",
                    "_global_Z.rem_mod_nonneg : forall (a b : Z) (_ : Z.le 0 a) (_ : Z.lt 0 b),\n       Logic.eq (Z.rem a b) (Z.modulo a b)"
                ],
                "tactic_res": [
                    "c42_goal : Z.le 0 (NN.to_Z x)",
                    "c43_goal : Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c42_goal : Z.le 0 (NN.to_Z x)",
                    "c13_x : NN.t",
                    "c13_y : NN.t"
                ],
                "tactic_res": [
                    "c44_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c44_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c43_goal : Z.lt 0 (NN.to_Z y)",
                    "c13_x : NN.t",
                    "c13_y : NN.t"
                ],
                "tactic_res": [
                    "c45_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "Z.order .",
                "tactic_sig_no_out_arg": "Z.order .",
                "tactic_args": [
                    "c45_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : Z.le 0 (NN.to_Z y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c40_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c41_goal : not (Logic.eq (NN.to_Z y) 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_gcd",
        "proof": [
            {
                "tactic_sig": "Theorem spec_gcd : forall a b , to_Z ( gcd a b ) = Z.gcd ( to_Z a ) ( to_Z b ) .",
                "tactic_sig_no_out_arg": "Theorem spec_gcd : forall a b , to_Z ( gcd a b ) = Z.gcd ( to_Z a ) ( to_Z b ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall a b : t_, Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c1_goal : forall a b : t_, Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_gcd : forall (_ : t_) (_ : t_), t_",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z",
                    "_global_to_Z : forall _ : t_, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall a b : t_,\nLogic.eq\n  match\n    match a with\n    | Pos nx | Neg nx =>\n        match b with\n        | Pos ny | Neg ny => Pos (NN.gcd nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  match\n    match a with\n    | Pos nx => NN.to_Z nx\n    | Neg nx => Z.opp (NN.to_Z nx)\n    end\n  with\n  | 0 =>\n      Z.abs\n        match b with\n        | Pos nx => NN.to_Z nx\n        | Neg nx => Z.opp (NN.to_Z nx)\n        end\n  | Zpos a0 | Zneg a0 =>\n      match\n        match b with\n        | Pos nx => NN.to_Z nx\n        | Neg nx => Z.opp (NN.to_Z nx)\n        end\n      with\n      | 0 =>\n          Z.abs\n            match a with\n            | Pos nx => NN.to_Z nx\n            | Neg nx => Z.opp (NN.to_Z nx)\n            end\n      | Zpos b0 | Zneg b0 => Zpos (Pos.gcd a0 b0)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o ] [ _o | _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | x ] [ y | y ] .",
                "tactic_args": [
                    "c2_goal : forall a b : t_,\nLogic.eq\n  match\n    match a with\n    | Pos nx | Neg nx =>\n        match b with\n        | Pos ny | Neg ny => Pos (NN.gcd nx ny)\n        end\n    end\n  with\n  | Pos nx => NN.to_Z nx\n  | Neg nx => Z.opp (NN.to_Z nx)\n  end\n  match\n    match a with\n    | Pos nx => NN.to_Z nx\n    | Neg nx => Z.opp (NN.to_Z nx)\n    end\n  with\n  | 0 =>\n      Z.abs\n        match b with\n        | Pos nx => NN.to_Z nx\n        | Neg nx => Z.opp (NN.to_Z nx)\n        end\n  | Zpos a0 | Zneg a0 =>\n      match\n        match b with\n        | Pos nx => NN.to_Z nx\n        | Neg nx => Z.opp (NN.to_Z nx)\n        end\n      with\n      | 0 =>\n          Z.abs\n            match a with\n            | Pos nx => NN.to_Z nx\n            | Neg nx => Z.opp (NN.to_Z nx)\n            end\n      | Zpos b0 | Zneg b0 => Zpos (Pos.gcd a0 b0)\n      end\n  end"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c6_x : NN.t",
                    "c6_y : NN.t",
                    "c6_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c5_x : NN.t",
                    "c5_y : NN.t",
                    "c5_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c4_x : NN.t",
                    "c4_y : NN.t",
                    "c4_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_NN.spec_gcd : forall a b : NN.t,\n       Logic.eq (NN.to_Z (NN.gcd a b)) (Z.gcd (NN.to_Z a) (NN.to_Z b))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c3_x : NN.t",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_NN.spec_gcd : forall a b : NN.t,\n       Logic.eq (NN.to_Z (NN.gcd a b)) (Z.gcd (NN.to_Z a) (NN.to_Z b))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match NN.to_Z x with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (Z.opp (NN.to_Z y)))",
                    "c12_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c13_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (Z.opp (NN.to_Z y)))",
                    "c4_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c14_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c14_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c15_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c16_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end",
                    "c17_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c18_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c19_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c20_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c21_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c21_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c22_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c23_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end",
                    "c24_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c25_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c26_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c26_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c24_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c27_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c27_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_NN.spec_gcd : forall a b : NN.t,\n       Logic.eq (NN.to_Z (NN.gcd a b)) (Z.gcd (NN.to_Z a) (NN.to_Z b))"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c28_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c29_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq (Z.abs (NN.to_Z y))\n  match Z.opp 0 with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp 0)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c31_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zpos p) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (Zpos p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c32_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zneg p) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (Zneg p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : Logic.eq (Z.abs (NN.to_Z y))\n  match Z.opp 0 with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp 0)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (NN.to_Z y))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c33_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (NN.to_Z y))",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c31_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zpos p) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (Zpos p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c34_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c34_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c32_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zneg p) with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (Z.opp (Zneg p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c35_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c35_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c5_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.to_Z (NN.gcd x y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_NN.spec_gcd : forall a b : NN.t,\n       Logic.eq (NN.to_Z (NN.gcd a b)) (Z.gcd (NN.to_Z a) (NN.to_Z b))"
                ],
                "tactic_res": [
                    "c36_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c36_goal : Logic.eq (Z.gcd (NN.to_Z x) (NN.to_Z y))\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c37_goal : Logic.eq\n  match NN.to_Z x with\n  | 0 => Z.abs (NN.to_Z y)\n  | Zpos a | Zneg a =>\n      match NN.to_Z y with\n      | 0 => Z.abs (NN.to_Z x)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end\n  match Z.opp (NN.to_Z x) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (NN.to_Z x))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c38_goal : Logic.eq (Z.abs (NN.to_Z y))\n  match Z.opp 0 with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp 0)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c39_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zpos p) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (Zpos p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end",
                    "c40_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zneg p) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (Zneg p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c38_goal : Logic.eq (Z.abs (NN.to_Z y))\n  match Z.opp 0 with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp 0)\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c41_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (Z.opp (NN.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c41_goal : Logic.eq (Z.abs (NN.to_Z y)) (Z.abs (Z.opp (NN.to_Z y)))",
                    "c6_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c39_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zpos p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zpos p) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (Zpos p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c42_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c42_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c43_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c44_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end",
                    "c45_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c43_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c46_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c46_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c44_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c47_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c47_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c45_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c48_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c48_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c40_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Z.abs (Zneg p)\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (Zneg p) with\n  | 0 => Z.abs (Z.opp (NN.to_Z y))\n  | Zpos a | Zneg a =>\n      match Z.opp (NN.to_Z y) with\n      | 0 => Z.abs (Z.opp (Zneg p))\n      | Zpos b | Zneg b => Zpos (Pos.gcd a b)\n      end\n  end"
                ],
                "tactic_res": [
                    "c49_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ]
            },
            {
                "tactic_sig": "case NN.to_Z .",
                "tactic_sig_no_out_arg": "case NN.to_Z .",
                "tactic_args": [
                    "c49_goal : forall p : positive,\nLogic.eq\n  match NN.to_Z y with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end\n  match Z.opp (NN.to_Z y) with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c50_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end",
                    "c51_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end",
                    "c52_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c50_goal : forall p : positive,\nLogic.eq (Zpos p)\n  match Z.opp 0 with\n  | 0 => Zpos p\n  | Zpos b | Zneg b => Zpos (Pos.gcd p b)\n  end"
                ],
                "tactic_res": [
                    "c53_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c53_goal : forall p : positive, Logic.eq (Zpos p) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c51_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zpos p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c54_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c54_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c52_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p))\n  match Z.opp (Zneg p) with\n  | 0 => Zpos p0\n  | Zpos b | Zneg b => Zpos (Pos.gcd p0 b)\n  end"
                ],
                "tactic_res": [
                    "c55_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c55_goal : forall p p0 : positive,\nLogic.eq (Zpos (Pos.gcd p0 p)) (Zpos (Pos.gcd p0 p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sgn",
        "proof": [
            {
                "tactic_sig": "Lemma spec_sgn : forall x , to_Z ( sgn x ) = Z.sgn ( to_Z x ) .",
                "tactic_sig_no_out_arg": "Lemma spec_sgn : forall x , to_Z ( sgn x ) = Z.sgn ( to_Z x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (sgn x)) (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (sgn x)) (Z.sgn (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (sgn x)) (Z.sgn (to_Z x))",
                    "c2_x : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (sgn x)) (Z.sgn (to_Z x))",
                    "_global_sgn : forall _ : t_, t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare zero x with\n     | Eq => zero\n     | Lt => one\n     | Gt => minus_one\n     end) (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare zero x with\n     | Eq => zero\n     | Lt => one\n     | Gt => minus_one\n     end) (Z.sgn (to_Z x))",
                    "_global_spec_compare : forall x y : t_, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z zero) (to_Z x) with\n     | Eq => zero\n     | Lt => one\n     | Gt => minus_one\n     end) (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z zero) (to_Z x) with\n     | Eq => zero\n     | Lt => one\n     | Gt => minus_one\n     end) (Z.sgn (to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z zero) (to_Z x),\nLogic.eq (to_Z zero) (Z.sgn (to_Z x))",
                    "c6_goal : forall _ : Z.lt (to_Z zero) (to_Z x),\nLogic.eq (to_Z one) (Z.sgn (to_Z x))",
                    "c7_goal : forall _ : Z.lt (to_Z x) (to_Z zero),\nLogic.eq (to_Z minus_one) (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z zero) (to_Z x),\nLogic.eq (to_Z zero) (Z.sgn (to_Z x))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Logic.eq 0 (to_Z x), Logic.eq 0 (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros <- .",
                "tactic_sig_no_out_arg": "intros <- .",
                "tactic_args": [
                    "c8_goal : forall _ : Logic.eq 0 (to_Z x), Logic.eq 0 (Z.sgn (to_Z x))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq 0 (Z.sgn 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Logic.eq 0 (Z.sgn 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.lt (to_Z zero) (to_Z x),\nLogic.eq (to_Z one) (Z.sgn (to_Z x))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0",
                    "_global_spec_1 : Logic.eq (to_Z one) 1"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x), Logic.eq 1 (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x), Logic.eq 1 (Z.sgn (to_Z x))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.sgn (to_Z x)) 1",
                    "c11_H : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.sgn (to_Z x)) 1",
                    "_global_Z.sgn_pos_iff : forall n : Z, iff (Logic.eq (Z.sgn n) 1) (Z.lt 0 n)"
                ],
                "tactic_res": [
                    "c12_goal : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Z.lt 0 (to_Z x)",
                    "c11_H : Z.lt 0 (to_Z x)",
                    "c2_x : t_"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c7_goal : forall _ : Z.lt (to_Z x) (to_Z zero),\nLogic.eq (to_Z minus_one) (Z.sgn (to_Z x))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0",
                    "_global_spec_m1 : Logic.eq (to_Z minus_one) (-1)"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Z.lt (to_Z x) 0, Logic.eq (-1) (Z.sgn (to_Z x))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt (to_Z x) 0, Logic.eq (-1) (Z.sgn (to_Z x))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.sgn (to_Z x)) (-1)",
                    "c14_H : Z.lt (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.sgn (to_Z x)) (-1)",
                    "_global_Z.sgn_neg_iff : forall n : Z, iff (Logic.eq (Z.sgn n) (Z.opp 1)) (Z.lt n 0)"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.lt (to_Z x) 0",
                    "c14_H : Z.lt (to_Z x) 0",
                    "c2_x : t_"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_even",
        "proof": [
            {
                "tactic_sig": "Lemma spec_even : forall z , even z = Z.even ( to_Z z ) .",
                "tactic_sig_no_out_arg": "Lemma spec_even : forall z , even z = Z.even ( to_Z z ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall z : t_, Logic.eq (even z) (Z.even (to_Z z))"
                ]
            },
            {
                "tactic_sig": "intros [ n|n ] .",
                "tactic_sig_no_out_arg": "intros [ n|n ] .",
                "tactic_args": [
                    "c1_goal : forall z : t_, Logic.eq (even z) (Z.even (to_Z z))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (even (Pos n)) (Z.even (to_Z (Pos n)))",
                    "c3_n : NN.t",
                    "c3_goal : Logic.eq (even (Neg n)) (Z.even (to_Z (Neg n)))",
                    "c2_n : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (even (Pos n)) (Z.even (to_Z (Pos n)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (NN.even n) (Z.even (NN.to_Z n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.even n) (Z.even (NN.to_Z n))",
                    "_global_NN.spec_even : forall x : NN.t, Logic.eq (NN.even x) (Z.even (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.even (NN.to_Z n)) (Z.even (NN.to_Z n))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.even (NN.to_Z n)) (Z.even (NN.to_Z n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (even (Neg n)) (Z.even (to_Z (Neg n)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (NN.even n) (Z.even (Z.opp (NN.to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.even n) (Z.even (Z.opp (NN.to_Z n)))",
                    "_global_NN.spec_even : forall x : NN.t, Logic.eq (NN.even x) (Z.even (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.even (NN.to_Z n)) (Z.even (Z.opp (NN.to_Z n)))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.to_Z _i ) as [ |p|p ] .",
                "tactic_sig_no_out_arg": "destruct ( NN.to_Z _i ) as [ |p|p ] .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.even (NN.to_Z n)) (Z.even (Z.opp (NN.to_Z n)))",
                    "c3_n : NN.t"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.even 0) (Z.even (Z.opp 0))",
                    "c9_goal : Logic.eq (Z.even (Zpos p)) (Z.even (Z.opp (Zpos p)))",
                    "c9_p : positive",
                    "c10_goal : Logic.eq (Z.even (Zneg p)) (Z.even (Z.opp (Zneg p)))",
                    "c10_p : positive"
                ]
            },
            {
                "tactic_sig": "now try destruct p .",
                "tactic_sig_no_out_arg": "now try destruct p .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.even 0) (Z.even (Z.opp 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now try destruct _i .",
                "tactic_sig_no_out_arg": "now try destruct _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.even (Zpos p)) (Z.even (Z.opp (Zpos p)))",
                    "c9_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now try destruct _i .",
                "tactic_sig_no_out_arg": "now try destruct _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.even (Zneg p)) (Z.even (Z.opp (Zneg p)))",
                    "c10_p : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_odd",
        "proof": [
            {
                "tactic_sig": "Lemma spec_odd : forall z , odd z = Z.odd ( to_Z z ) .",
                "tactic_sig_no_out_arg": "Lemma spec_odd : forall z , odd z = Z.odd ( to_Z z ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall z : t_, Logic.eq (odd z) (Z.odd (to_Z z))"
                ]
            },
            {
                "tactic_sig": "intros [ n|n ] .",
                "tactic_sig_no_out_arg": "intros [ n|n ] .",
                "tactic_args": [
                    "c1_goal : forall z : t_, Logic.eq (odd z) (Z.odd (to_Z z))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (odd (Pos n)) (Z.odd (to_Z (Pos n)))",
                    "c3_n : NN.t",
                    "c3_goal : Logic.eq (odd (Neg n)) (Z.odd (to_Z (Neg n)))",
                    "c2_n : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (odd (Pos n)) (Z.odd (to_Z (Pos n)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (NN.odd n) (Z.odd (NN.to_Z n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.odd n) (Z.odd (NN.to_Z n))",
                    "_global_NN.spec_odd : forall x : NN.t, Logic.eq (NN.odd x) (Z.odd (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.odd (NN.to_Z n)) (Z.odd (NN.to_Z n))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.odd (NN.to_Z n)) (Z.odd (NN.to_Z n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (odd (Neg n)) (Z.odd (to_Z (Neg n)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (NN.odd n) (Z.odd (Z.opp (NN.to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (NN.odd n) (Z.odd (Z.opp (NN.to_Z n)))",
                    "_global_NN.spec_odd : forall x : NN.t, Logic.eq (NN.odd x) (Z.odd (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.odd (NN.to_Z n)) (Z.odd (Z.opp (NN.to_Z n)))"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.to_Z _i ) as [ |p|p ] .",
                "tactic_sig_no_out_arg": "destruct ( NN.to_Z _i ) as [ |p|p ] .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.odd (NN.to_Z n)) (Z.odd (Z.opp (NN.to_Z n)))",
                    "c3_n : NN.t"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.odd 0) (Z.odd (Z.opp 0))",
                    "c9_goal : Logic.eq (Z.odd (Zpos p)) (Z.odd (Z.opp (Zpos p)))",
                    "c9_p : positive",
                    "c10_goal : Logic.eq (Z.odd (Zneg p)) (Z.odd (Z.opp (Zneg p)))",
                    "c10_p : positive"
                ]
            },
            {
                "tactic_sig": "now try destruct p .",
                "tactic_sig_no_out_arg": "now try destruct p .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.odd 0) (Z.odd (Z.opp 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now try destruct _i .",
                "tactic_sig_no_out_arg": "now try destruct _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.odd (Zpos p)) (Z.odd (Z.opp (Zpos p)))",
                    "c9_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now try destruct _i .",
                "tactic_sig_no_out_arg": "now try destruct _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.odd (Zneg p)) (Z.odd (Z.opp (Zneg p)))",
                    "c10_p : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zlnot_alt1",
        "proof": [
            {
                "tactic_sig": "Lemma Zlnot_alt1 : forall x , - ( x + 1 ) = Z.lnot x .",
                "tactic_sig_no_out_arg": "Lemma Zlnot_alt1 : forall x , - ( x + 1 ) = Z.lnot x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : Z, Logic.eq (Z.opp (Z.add x 1)) (Z.lnot x)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : Z, Logic.eq (Z.opp (Z.add x 1)) (Z.lnot x)",
                    "_global_Z.lnot : forall _ : Z, Z",
                    "_global_Z.pred : forall _ : Z, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x : Z, Logic.eq (Z.opp (Z.add x 1)) (Z.add (Z.opp x) (-1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c2_goal : forall x : Z, Logic.eq (Z.opp (Z.add x 1)) (Z.add (Z.opp x) (-1))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zlnot_alt2",
        "proof": [
            {
                "tactic_sig": "Lemma Zlnot_alt2 : forall x , Z.lnot ( x - 1 ) = - x .",
                "tactic_sig_no_out_arg": "Lemma Zlnot_alt2 : forall x , Z.lnot ( x - 1 ) = - x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : Z, Logic.eq (Z.lnot (Z.sub x 1)) (Z.opp x)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : Z, Logic.eq (Z.lnot (Z.sub x 1)) (Z.opp x)",
                    "_global_Z.lnot : forall _ : Z, Z",
                    "_global_Z.pred : forall _ : Z, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x : Z, Logic.eq (Z.add (Z.opp (Z.sub x 1)) (-1)) (Z.opp x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c2_goal : forall x : Z, Logic.eq (Z.add (Z.opp (Z.sub x 1)) (-1)) (Z.opp x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zlnot_alt3",
        "proof": [
            {
                "tactic_sig": "Lemma Zlnot_alt3 : forall x , Z.lnot ( - x ) = x - 1 .",
                "tactic_sig_no_out_arg": "Lemma Zlnot_alt3 : forall x , Z.lnot ( - x ) = x - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : Z, Logic.eq (Z.lnot (Z.opp x)) (Z.sub x 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : Z, Logic.eq (Z.lnot (Z.opp x)) (Z.sub x 1)",
                    "_global_Z.lnot : forall _ : Z, Z",
                    "_global_Z.pred : forall _ : Z, Z"
                ],
                "tactic_res": [
                    "c2_goal : forall x : Z, Logic.eq (Z.add (Z.opp (Z.opp x)) (-1)) (Z.sub x 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c2_goal : forall x : Z, Logic.eq (Z.add (Z.opp (Z.opp x)) (-1)) (Z.sub x 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_norm_pos",
        "proof": [
            {
                "tactic_sig": "Lemma spec_norm_pos : forall x , to_Z ( norm_pos x ) = to_Z x .",
                "tactic_sig_no_out_arg": "Lemma spec_norm_pos : forall x , to_Z ( norm_pos x ) = to_Z x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (norm_pos x)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "intros [ x|x ] .",
                "tactic_sig_no_out_arg": "intros [ x|x ] .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (norm_pos x)) (to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (norm_pos (Pos x))) (to_Z (Pos x))",
                    "c3_x : NN.t",
                    "c3_goal : Logic.eq (to_Z (norm_pos (Neg x))) (to_Z (Neg x))",
                    "c2_x : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (norm_pos (Pos x))) (to_Z (Pos x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (NN.to_Z x) (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : Logic.eq (NN.to_Z x) (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (norm_pos (Neg x))) (to_Z (Neg x))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (if Z.eqb (NN.to_Z x) 0 then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (if Z.eqb (NN.to_Z x) 0 then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                    "c8_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
            },
            {
                "tactic_sig": "custom10 .",
                "tactic_sig_no_out_arg": "custom10 .",
                "tactic_args": [
                    "c7_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom10 .",
                "tactic_sig_no_out_arg": "custom10 .",
                "tactic_args": [
                    "c8_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_norm_pos_pos",
        "proof": [
            {
                "tactic_sig": "Lemma spec_norm_pos_pos : forall x y , norm_pos x = Neg y -> 0 < NN.to_Z y .",
                "tactic_sig_no_out_arg": "Lemma spec_norm_pos_pos : forall x y , norm_pos x = Neg y -> 0 < NN.to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t_) (y : NN.t) (_ : Logic.eq (norm_pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "intros [ x|x ] _o .",
                "tactic_sig_no_out_arg": "intros [ x|x ] y .",
                "tactic_args": [
                    "c1_goal : forall (x : t_) (y : NN.t) (_ : Logic.eq (norm_pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Logic.eq (norm_pos (Pos x)) (Neg y), Z.lt 0 (NN.to_Z y)",
                    "c3_x : NN.t",
                    "c3_y : NN.t",
                    "c3_goal : forall _ : Logic.eq (norm_pos (Neg x)) (Neg y), Z.lt 0 (NN.to_Z y)",
                    "c2_x : NN.t",
                    "c2_y : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : Logic.eq (norm_pos (Pos x)) (Neg y), Z.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Logic.eq (Pos x) (Neg y), Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "try easy .",
                "tactic_sig_no_out_arg": "try easy .",
                "tactic_args": [
                    "c4_goal : forall _ : Logic.eq (Pos x) (Neg y), Z.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : Logic.eq (norm_pos (Neg x)) (Neg y), Z.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)",
                    "_global_NN.spec_eqb : forall x y : NN.t,\n       Logic.eq (NN.eqb x y) (Z.eqb (NN.to_Z x) (NN.to_Z y))",
                    "_global_NN.spec_0 : Logic.eq (NN.to_Z NN.zero) 0"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : Logic.eq (if Z.eqb (NN.to_Z x) 0 then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : Logic.eq (if Z.eqb (NN.to_Z x) 0 then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                    "c8_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "try easy .",
                "tactic_sig_no_out_arg": "try easy .",
                "tactic_args": [
                    "c7_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inversion 2 .",
                "tactic_sig_no_out_arg": "inversion 2 .",
                "tactic_args": [
                    "c8_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                    "c9_goal : Z.lt 0 (NN.to_Z y)",
                    "c9_H1 : Logic.eq x y",
                    "c9_H : Logic.eq (Neg x) (Neg y)",
                    "c9_n : not (Logic.eq (NN.to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c9_goal : Z.lt 0 (NN.to_Z y)",
                    "c3_y : NN.t"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Z.le 0 (NN.to_Z y), Z.lt 0 (NN.to_Z y)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.le 0 (NN.to_Z y), Z.lt 0 (NN.to_Z y)",
                    "c9_n : not (Logic.eq (NN.to_Z y) 0)",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_testbit",
        "proof": [
            {
                "tactic_sig": "Lemma spec_testbit : forall x p , testbit x p = Z.testbit ( to_Z x ) ( to_Z p ) .",
                "tactic_sig_no_out_arg": "Lemma spec_testbit : forall x p , testbit x p = Z.testbit ( to_Z x ) ( to_Z p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t_, Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x p .",
                "tactic_args": [
                    "c1_goal : forall x p : t_, Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))",
                    "c2_x : t_",
                    "c2_p : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))",
                    "_global_testbit : forall (_ : t_) (_ : t_), bool"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  match norm_pos p with\n  | Pos p =>\n      match norm_pos x with\n      | Pos a => NN.testbit a p\n      | Neg a => negb (NN.testbit (NN.pred a) p)\n      end\n  | Neg _ => false\n  end (Z.testbit (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  match norm_pos p with\n  | Pos p =>\n      match norm_pos x with\n      | Pos a => NN.testbit a p\n      | Neg a => negb (NN.testbit (NN.pred a) p)\n      end\n  | Neg _ => false\n  end (Z.testbit (to_Z x) (to_Z p))",
                    "c2_p : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  match norm_pos x with\n  | Pos a => NN.testbit a p0\n  | Neg a => negb (NN.testbit (NN.pred a) p0)\n  end (Z.testbit (to_Z x) (to_Z (Pos p0)))",
                    "c4_p0 : NN.t",
                    "c5_goal : Logic.eq false (Z.testbit (to_Z x) (to_Z (Neg p0)))",
                    "c5_H : Z.lt 0 (NN.to_Z p0)",
                    "c5_p0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  match norm_pos x with\n  | Pos a => NN.testbit a p0\n  | Neg a => negb (NN.testbit (NN.pred a) p0)\n  end (Z.testbit (to_Z x) (to_Z (Pos p0)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  match norm_pos x with\n  | Pos a => NN.testbit a p0\n  | Neg a => negb (NN.testbit (NN.pred a) p0)\n  end (Z.testbit (to_Z x) (NN.to_Z p0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq false (Z.testbit (to_Z x) (to_Z (Neg p0)))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq false (Z.testbit (to_Z x) (Z.opp (NN.to_Z p0)))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  match norm_pos x with\n  | Pos a => NN.testbit a p0\n  | Neg a => negb (NN.testbit (NN.pred a) p0)\n  end (Z.testbit (to_Z x) (NN.to_Z p0))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.testbit x0 p0) (Z.testbit (to_Z (Pos x0)) (NN.to_Z p0))",
                    "c8_x0 : NN.t",
                    "c9_goal : Logic.eq (negb (NN.testbit (NN.pred x0) p0))\n  (Z.testbit (to_Z (Neg x0)) (NN.to_Z p0))",
                    "c9_H : Z.lt 0 (NN.to_Z x0)",
                    "c9_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.testbit x0 p0) (Z.testbit (to_Z (Pos x0)) (NN.to_Z p0))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (NN.testbit x0 p0) (Z.testbit (NN.to_Z x0) (NN.to_Z p0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq (negb (NN.testbit (NN.pred x0) p0))\n  (Z.testbit (to_Z (Neg x0)) (NN.to_Z p0))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (negb (NN.testbit (NN.pred x0) p0))\n  (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (NN.testbit x0 p0) (Z.testbit (NN.to_Z x0) (NN.to_Z p0))",
                    "_global_NN.spec_testbit : forall x p : NN.t,\n       Logic.eq (NN.testbit x p) (Z.testbit (NN.to_Z x) (NN.to_Z p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i , _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i by auto with zarith .",
                "tactic_args": [
                    "c11_goal : Logic.eq (negb (NN.testbit (NN.pred x0) p0))\n  (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))",
                    "_global_NN.spec_testbit : forall x p : NN.t,\n       Logic.eq (NN.testbit x p) (Z.testbit (NN.to_Z x) (NN.to_Z p))",
                    "_global_NN.spec_pred : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.pred x)) (Z.max 0 (Z.sub (NN.to_Z x) 1))",
                    "_global_Z.max_r : forall (n m : Z) (_ : Z.le n m), Logic.eq (Z.max n m) m",
                    "c9_H : Z.lt 0 (NN.to_Z x0)",
                    "c4_p0 : NN.t",
                    "c9_x0 : NN.t",
                    "c2_x : t_",
                    "c2_p : t_"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (negb (Z.testbit (Z.sub (NN.to_Z x0) 1) (NN.to_Z p0)))\n  (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c12_goal : Logic.eq (negb (Z.testbit (Z.sub (NN.to_Z x0) 1) (NN.to_Z p0)))\n  (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))\n  (negb (Z.testbit (Z.sub (NN.to_Z x0) 1) (NN.to_Z p0)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.testbit (Z.opp (NN.to_Z x0)) (NN.to_Z p0))\n  (negb (Z.testbit (Z.sub (NN.to_Z x0) 1) (NN.to_Z p0)))",
                    "_global_Z.bits_opp : forall (a n : Z) (_ : Z.le 0 n),\n       Logic.eq (Z.testbit (Z.opp a) n) (negb (Z.testbit (Z.pred a) n))"
                ],
                "tactic_res": [
                    "c14_goal : Z.le 0 (NN.to_Z p0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.le 0 (NN.to_Z p0)",
                    "_global_NN.spec_pos : forall x : NN.t, Z.le 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c7_goal : Logic.eq false (Z.testbit (to_Z x) (Z.opp (NN.to_Z p0)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.testbit (to_Z x) (Z.opp (NN.to_Z p0))) false"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.testbit (to_Z x) (Z.opp (NN.to_Z p0))) false",
                    "_global_Z.testbit_neg_r : forall (a n : Z) (_ : Z.lt n 0), Logic.eq (Z.testbit a n) false"
                ],
                "tactic_res": [
                    "c16_goal : Z.lt (Z.opp (NN.to_Z p0)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.lt (Z.opp (NN.to_Z p0)) 0",
                    "c5_H : Z.lt 0 (NN.to_Z p0)",
                    "c5_p0 : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftl",
        "proof": [
            {
                "tactic_sig": "Lemma spec_shiftl : forall x p , to_Z ( shiftl x p ) = Z.shiftl ( to_Z x ) ( to_Z p ) .",
                "tactic_sig_no_out_arg": "Lemma spec_shiftl : forall x p , to_Z ( shiftl x p ) = Z.shiftl ( to_Z x ) ( to_Z p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t_,\nLogic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x p .",
                "tactic_args": [
                    "c1_goal : forall x p : t_,\nLogic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))",
                    "c2_x : t_",
                    "c2_p : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))",
                    "_global_shiftl : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match p with\n         | Pos n => Pos (NN.shiftl a n)\n         | Neg n => Pos (NN.shiftr a n)\n         end\n     | Neg a =>\n         match p with\n         | Pos n => Neg (NN.shiftl a n)\n         | Neg n => Neg (NN.succ (NN.shiftr (NN.pred a) n))\n         end\n     end) (Z.shiftl (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match p with\n         | Pos n => Pos (NN.shiftl a n)\n         | Neg n => Pos (NN.shiftr a n)\n         end\n     | Neg a =>\n         match p with\n         | Pos n => Neg (NN.shiftl a n)\n         | Neg n => Neg (NN.succ (NN.shiftr (NN.pred a) n))\n         end\n     end) (Z.shiftl (to_Z x) (to_Z p))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match p with\n     | Pos n => Pos (NN.shiftl x0 n)\n     | Neg n => Pos (NN.shiftr x0 n)\n     end) (Z.shiftl (to_Z (Pos x0)) (to_Z p))",
                    "c4_x0 : NN.t",
                    "c5_goal : Logic.eq\n  (to_Z\n     match p with\n     | Pos n => Neg (NN.shiftl x0 n)\n     | Neg n => Neg (NN.succ (NN.shiftr (NN.pred x0) n))\n     end) (Z.shiftl (to_Z (Neg x0)) (to_Z p))",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ p|p ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ p|p ] .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match p with\n     | Pos n => Pos (NN.shiftl x0 n)\n     | Neg n => Pos (NN.shiftr x0 n)\n     end) (Z.shiftl (to_Z (Pos x0)) (to_Z p))",
                    "c2_p : t_",
                    "c4_x0 : NN.t",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.shiftl x0 p)))\n  (Z.shiftl (to_Z (Pos x0)) (to_Z (Pos p)))",
                    "c6_p : NN.t",
                    "c7_goal : Logic.eq (to_Z (Pos (NN.shiftr x0 p)))\n  (Z.shiftl (to_Z (Pos x0)) (to_Z (Neg p)))",
                    "c7_p : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.shiftl x0 p)))\n  (Z.shiftl (to_Z (Pos x0)) (to_Z (Pos p)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.shiftl x0 p)) (Z.shiftl (NN.to_Z x0) (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c6_p : NN.t"
                ],
                "tactic_res": [
                    "c8_Hp : Z.le 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z (Pos (NN.shiftr x0 p)))\n  (Z.shiftl (to_Z (Pos x0)) (to_Z (Neg p)))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (NN.to_Z (NN.shiftr x0 p))\n  (Z.shiftl (NN.to_Z x0) (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c7_p : NN.t"
                ],
                "tactic_res": [
                    "c9_Hp : Z.le 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ p|p ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ p|p ] .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     match p with\n     | Pos n => Neg (NN.shiftl x0 n)\n     | Neg n => Neg (NN.succ (NN.shiftr (NN.pred x0) n))\n     end) (Z.shiftl (to_Z (Neg x0)) (to_Z p))",
                    "c2_p : t_",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (Neg (NN.shiftl x0 p)))\n  (Z.shiftl (to_Z (Neg x0)) (to_Z (Pos p)))",
                    "c10_p : NN.t",
                    "c11_goal : Logic.eq (to_Z (Neg (NN.succ (NN.shiftr (NN.pred x0) p))))\n  (Z.shiftl (to_Z (Neg x0)) (to_Z (Neg p)))",
                    "c11_p : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (Neg (NN.shiftl x0 p)))\n  (Z.shiftl (to_Z (Neg x0)) (to_Z (Pos p)))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.opp (NN.to_Z (NN.shiftl x0 p)))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c10_p : NN.t"
                ],
                "tactic_res": [
                    "c12_Hp : Z.le 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z (Neg (NN.succ (NN.shiftr (NN.pred x0) p))))\n  (Z.shiftl (to_Z (Neg x0)) (to_Z (Neg p)))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.shiftr (NN.pred x0) p))))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c11_p : NN.t"
                ],
                "tactic_res": [
                    "c13_Hp : Z.le 0 (NN.to_Z p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.shiftl x0 p)) (Z.shiftl (NN.to_Z x0) (NN.to_Z p))",
                    "_global_NN.spec_shiftl : forall x p : NN.t,\n       Logic.eq (NN.to_Z (NN.shiftl x p)) (Z.shiftl (NN.to_Z x) (NN.to_Z p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (NN.to_Z (NN.shiftr x0 p))\n  (Z.shiftl (NN.to_Z x0) (Z.opp (NN.to_Z p)))",
                    "_global_Z.shiftl_opp_r : forall a n : Z, Logic.eq (Z.shiftl a (Z.opp n)) (Z.shiftr a n)"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (NN.to_Z (NN.shiftr x0 p)) (Z.shiftr (NN.to_Z x0) (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq (NN.to_Z (NN.shiftr x0 p)) (Z.shiftr (NN.to_Z x0) (NN.to_Z p))",
                    "_global_NN.spec_shiftr : forall x p : NN.t,\n       Logic.eq (NN.to_Z (NN.shiftr x p)) (Z.shiftr (NN.to_Z x) (NN.to_Z p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite !NN.spec_shiftl .",
                "tactic_sig_no_out_arg": "rewrite !NN.spec_shiftl .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.opp (NN.to_Z (NN.shiftl x0 p)))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (NN.to_Z p))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.opp (Z.shiftl (NN.to_Z x0) (NN.to_Z p)))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "rewrite !Z.shiftl_mul_pow2 by apply _i .",
                "tactic_sig_no_out_arg": "rewrite !Z.shiftl_mul_pow2 by apply _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.opp (Z.shiftl (NN.to_Z x0) (NN.to_Z p)))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (NN.to_Z p))",
                    "_global_NN.spec_pos : forall x : NN.t, Z.le 0 (NN.to_Z x)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x0) (Z.pow 2 (NN.to_Z p))))\n  (Z.mul (Z.opp (NN.to_Z x0)) (Z.pow 2 (NN.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.opp (Z.mul (NN.to_Z x0) (Z.pow 2 (NN.to_Z p))))\n  (Z.mul (Z.opp (NN.to_Z x0)) (Z.pow 2 (NN.to_Z p)))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z x0)) (Z.pow 2 (NN.to_Z p)))\n  (Z.opp (Z.mul (NN.to_Z x0) (Z.pow 2 (NN.to_Z p))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z x0)) (Z.pow 2 (NN.to_Z p)))\n  (Z.opp (Z.mul (NN.to_Z x0) (Z.pow 2 (NN.to_Z p))))",
                    "_global_Z.mul_opp_l : forall n m : Z, Logic.eq (Z.mul (Z.opp n) m) (Z.opp (Z.mul n m))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i , _i , _i , _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i , _i , _i by auto with zarith .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.shiftr (NN.pred x0) p))))\n  (Z.shiftl (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z p)))",
                    "_global_Z.shiftl_opp_r : forall a n : Z, Logic.eq (Z.shiftl a (Z.opp n)) (Z.shiftr a n)",
                    "_global_NN.spec_succ : forall n : NN.t, Logic.eq (NN.to_Z (NN.succ n)) (Z.add (NN.to_Z n) 1)",
                    "_global_NN.spec_shiftr : forall x p : NN.t,\n       Logic.eq (NN.to_Z (NN.shiftr x p)) (Z.shiftr (NN.to_Z x) (NN.to_Z p))",
                    "_global_NN.spec_pred : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.pred x)) (Z.max 0 (Z.sub (NN.to_Z x) 1))",
                    "_global_Z.max_r : forall (n m : Z) (_ : Z.le n m), Logic.eq (Z.max n m) m",
                    "c13_Hp : Z.le 0 (NN.to_Z p)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c11_p : NN.t",
                    "c5_x0 : NN.t",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.opp (Z.add (Z.shiftr (Z.sub (NN.to_Z x0) 1) (NN.to_Z p)) 1))\n  (Z.shiftr (Z.opp (NN.to_Z x0)) (NN.to_Z p))"
                ]
            },
            {
                "tactic_sig": "now rewrite Zlnot_alt1 , Z.lnot_shiftr , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Zlnot_alt1 , Z.lnot_shiftr , Zlnot_alt2 .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.opp (Z.add (Z.shiftr (Z.sub (NN.to_Z x0) 1) (NN.to_Z p)) 1))\n  (Z.shiftr (Z.opp (NN.to_Z x0)) (NN.to_Z p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftr",
        "proof": [
            {
                "tactic_sig": "Lemma spec_shiftr : forall x p , to_Z ( shiftr x p ) = Z.shiftr ( to_Z x ) ( to_Z p ) .",
                "tactic_sig_no_out_arg": "Lemma spec_shiftr : forall x p , to_Z ( shiftr x p ) = Z.shiftr ( to_Z x ) ( to_Z p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t_,\nLogic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x p : t_,\nLogic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))",
                    "c2_x : t_",
                    "c2_p : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))",
                    "_global_shiftr : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (shiftl x (opp p))) (Z.shiftr (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (shiftl x (opp p))) (Z.shiftr (to_Z x) (to_Z p))",
                    "_global_spec_shiftl : forall x p : t_,\n       Logic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))",
                    "_global_spec_opp : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.shiftl (to_Z x) (Z.opp (to_Z p)))\n  (Z.shiftr (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.shiftl (to_Z x) (Z.opp (to_Z p)))\n  (Z.shiftr (to_Z x) (to_Z p))",
                    "_global_Z.shiftl_opp_r : forall a n : Z, Logic.eq (Z.shiftl a (Z.opp n)) (Z.shiftr a n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_land",
        "proof": [
            {
                "tactic_sig": "Lemma spec_land : forall x y , to_Z ( land x y ) = Z.land ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_land : forall x y , to_Z ( land x y ) = Z.land ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))",
                    "_global_land : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.land a b)\n         | Neg b => Pos (NN.ldiff a (NN.pred b))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.ldiff b (NN.pred a))\n         | Neg b => Neg (NN.succ (NN.lor (NN.pred a) (NN.pred b)))\n         end\n     end) (Z.land (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.land a b)\n         | Neg b => Pos (NN.ldiff a (NN.pred b))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.ldiff b (NN.pred a))\n         | Neg b => Neg (NN.succ (NN.lor (NN.pred a) (NN.pred b)))\n         end\n     end) (Z.land (to_Z x) (to_Z y))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.land x0 b)\n     | Neg b => Pos (NN.ldiff x0 (NN.pred b))\n     end) (Z.land (to_Z (Pos x0)) (to_Z y))",
                    "c4_x0 : NN.t",
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.ldiff b (NN.pred x0))\n     | Neg b => Neg (NN.succ (NN.lor (NN.pred x0) (NN.pred b)))\n     end) (Z.land (to_Z (Neg x0)) (to_Z y))",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.land x0 b)\n     | Neg b => Pos (NN.ldiff x0 (NN.pred b))\n     end) (Z.land (to_Z (Pos x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.land x0 y0)))\n  (Z.land (to_Z (Pos x0)) (to_Z (Pos y0)))",
                    "c6_y0 : NN.t",
                    "c7_goal : Logic.eq (to_Z (Pos (NN.ldiff x0 (NN.pred y0))))\n  (Z.land (to_Z (Pos x0)) (to_Z (Neg y0)))",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.land x0 y0)))\n  (Z.land (to_Z (Pos x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.land x0 y0)) (Z.land (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.land x0 y0)) (Z.land (NN.to_Z x0) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.land (NN.to_Z x0) (NN.to_Z y0))\n  (Z.land (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.land (NN.to_Z x0) (NN.to_Z y0))\n  (Z.land (NN.to_Z x0) (NN.to_Z y0))",
                    "c4_x0 : NN.t",
                    "c6_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z (Pos (NN.ldiff x0 (NN.pred y0))))\n  (Z.land (to_Z (Pos x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (NN.to_Z (NN.ldiff x0 (NN.pred y0)))\n  (Z.land (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c10_goal : Logic.eq (NN.to_Z (NN.ldiff x0 (NN.pred y0)))\n  (Z.land (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.ldiff (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1))\n  (Z.land (NN.to_Z x0) (Z.opp (NN.to_Z y0)))",
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.ldiff b (NN.pred x0))\n     | Neg b => Neg (NN.succ (NN.lor (NN.pred x0) (NN.pred b)))\n     end) (Z.land (to_Z (Neg x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z (Pos (NN.ldiff y0 (NN.pred x0))))\n  (Z.land (to_Z (Neg x0)) (to_Z (Pos y0)))",
                    "c13_y0 : NN.t",
                    "c14_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lor (NN.pred x0) (NN.pred y0)))))\n  (Z.land (to_Z (Neg x0)) (to_Z (Neg y0)))",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (Pos (NN.ldiff y0 (NN.pred x0))))\n  (Z.land (to_Z (Neg x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (NN.to_Z (NN.ldiff y0 (NN.pred x0)))\n  (Z.land (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c15_goal : Logic.eq (NN.to_Z (NN.ldiff y0 (NN.pred x0)))\n  (Z.land (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.ldiff (NN.to_Z y0) (Z.sub (NN.to_Z x0) 1))\n  (Z.land (Z.opp (NN.to_Z x0)) (NN.to_Z y0))",
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lor (NN.pred x0) (NN.pred y0)))))\n  (Z.land (to_Z (Neg x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lor (NN.pred x0) (NN.pred y0)))))\n  (Z.land (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lor (NN.pred x0) (NN.pred y0)))))\n  (Z.land (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.lnot (Z.lor (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1)))\n  (Z.land (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))",
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.ldiff_land , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.ldiff_land , Zlnot_alt2 .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.ldiff (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1))\n  (Z.land (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.ldiff_land , Z.land_comm , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.ldiff_land , Z.land_comm , Zlnot_alt2 .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.ldiff (NN.to_Z y0) (Z.sub (NN.to_Z x0) 1))\n  (Z.land (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.lnot_lor , !Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.lnot_lor , !Zlnot_alt2 .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.lnot (Z.lor (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1)))\n  (Z.land (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_lor",
        "proof": [
            {
                "tactic_sig": "Lemma spec_lor : forall x y , to_Z ( lor x y ) = Z.lor ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_lor : forall x y , to_Z ( lor x y ) = Z.lor ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))",
                    "_global_lor : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.lor a b)\n         | Neg b => Neg (NN.succ (NN.ldiff (NN.pred b) a))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.ldiff (NN.pred a) b))\n         | Neg b => Neg (NN.succ (NN.land (NN.pred a) (NN.pred b)))\n         end\n     end) (Z.lor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.lor a b)\n         | Neg b => Neg (NN.succ (NN.ldiff (NN.pred b) a))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.ldiff (NN.pred a) b))\n         | Neg b => Neg (NN.succ (NN.land (NN.pred a) (NN.pred b)))\n         end\n     end) (Z.lor (to_Z x) (to_Z y))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.lor x0 b)\n     | Neg b => Neg (NN.succ (NN.ldiff (NN.pred b) x0))\n     end) (Z.lor (to_Z (Pos x0)) (to_Z y))",
                    "c4_x0 : NN.t",
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.ldiff (NN.pred x0) b))\n     | Neg b => Neg (NN.succ (NN.land (NN.pred x0) (NN.pred b)))\n     end) (Z.lor (to_Z (Neg x0)) (to_Z y))",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.lor x0 b)\n     | Neg b => Neg (NN.succ (NN.ldiff (NN.pred b) x0))\n     end) (Z.lor (to_Z (Pos x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.lor x0 y0)))\n  (Z.lor (to_Z (Pos x0)) (to_Z (Pos y0)))",
                    "c6_y0 : NN.t",
                    "c7_goal : Logic.eq (to_Z (Neg (NN.succ (NN.ldiff (NN.pred y0) x0))))\n  (Z.lor (to_Z (Pos x0)) (to_Z (Neg y0)))",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.lor x0 y0)))\n  (Z.lor (to_Z (Pos x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.lor x0 y0)) (Z.lor (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.lor x0 y0)) (Z.lor (NN.to_Z x0) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.lor (NN.to_Z x0) (NN.to_Z y0))\n  (Z.lor (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.lor (NN.to_Z x0) (NN.to_Z y0))\n  (Z.lor (NN.to_Z x0) (NN.to_Z y0))",
                    "c4_x0 : NN.t",
                    "c6_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z (Neg (NN.succ (NN.ldiff (NN.pred y0) x0))))\n  (Z.lor (to_Z (Pos x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.ldiff (NN.pred y0) x0))))\n  (Z.lor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.ldiff (NN.pred y0) x0))))\n  (Z.lor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.lnot (Z.ldiff (Z.sub (NN.to_Z y0) 1) (NN.to_Z x0)))\n  (Z.lor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))",
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.ldiff (NN.pred x0) b))\n     | Neg b => Neg (NN.succ (NN.land (NN.pred x0) (NN.pred b)))\n     end) (Z.lor (to_Z (Neg x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.ldiff (NN.pred x0) y0))))\n  (Z.lor (to_Z (Neg x0)) (to_Z (Pos y0)))",
                    "c13_y0 : NN.t",
                    "c14_goal : Logic.eq (to_Z (Neg (NN.succ (NN.land (NN.pred x0) (NN.pred y0)))))\n  (Z.lor (to_Z (Neg x0)) (to_Z (Neg y0)))",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.ldiff (NN.pred x0) y0))))\n  (Z.lor (to_Z (Neg x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.ldiff (NN.pred x0) y0))))\n  (Z.lor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.ldiff (NN.pred x0) y0))))\n  (Z.lor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.lnot (Z.ldiff (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.lor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))",
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq (to_Z (Neg (NN.succ (NN.land (NN.pred x0) (NN.pred y0)))))\n  (Z.lor (to_Z (Neg x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.opp (NN.to_Z (NN.succ (NN.land (NN.pred x0) (NN.pred y0)))))\n  (Z.lor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.opp (NN.to_Z (NN.succ (NN.land (NN.pred x0) (NN.pred y0)))))\n  (Z.lor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq\n  (Z.lnot (Z.land (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1)))\n  (Z.lor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))",
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.lnot_ldiff , Z.lor_comm , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.lnot_ldiff , Z.lor_comm , Zlnot_alt2 .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.lnot (Z.ldiff (Z.sub (NN.to_Z y0) 1) (NN.to_Z x0)))\n  (Z.lor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.lnot_ldiff , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.lnot_ldiff , Zlnot_alt2 .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.lnot (Z.ldiff (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.lor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.lnot_land , !Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.lnot_land , !Zlnot_alt2 .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.lnot (Z.land (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1)))\n  (Z.lor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ldiff",
        "proof": [
            {
                "tactic_sig": "Lemma spec_ldiff : forall x y , to_Z ( ldiff x y ) = Z.ldiff ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_ldiff : forall x y , to_Z ( ldiff x y ) = Z.ldiff ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_,\nLogic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_,\nLogic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))",
                    "_global_ldiff : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.ldiff a b)\n         | Neg b => Pos (NN.land a (NN.pred b))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.lor (NN.pred a) b))\n         | Neg b => Pos (NN.ldiff (NN.pred b) (NN.pred a))\n         end\n     end) (Z.ldiff (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.ldiff a b)\n         | Neg b => Pos (NN.land a (NN.pred b))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.lor (NN.pred a) b))\n         | Neg b => Pos (NN.ldiff (NN.pred b) (NN.pred a))\n         end\n     end) (Z.ldiff (to_Z x) (to_Z y))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.ldiff x0 b)\n     | Neg b => Pos (NN.land x0 (NN.pred b))\n     end) (Z.ldiff (to_Z (Pos x0)) (to_Z y))",
                    "c4_x0 : NN.t",
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.lor (NN.pred x0) b))\n     | Neg b => Pos (NN.ldiff (NN.pred b) (NN.pred x0))\n     end) (Z.ldiff (to_Z (Neg x0)) (to_Z y))",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.ldiff x0 b)\n     | Neg b => Pos (NN.land x0 (NN.pred b))\n     end) (Z.ldiff (to_Z (Pos x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.ldiff x0 y0)))\n  (Z.ldiff (to_Z (Pos x0)) (to_Z (Pos y0)))",
                    "c6_y0 : NN.t",
                    "c7_goal : Logic.eq (to_Z (Pos (NN.land x0 (NN.pred y0))))\n  (Z.ldiff (to_Z (Pos x0)) (to_Z (Neg y0)))",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.ldiff x0 y0)))\n  (Z.ldiff (to_Z (Pos x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.ldiff x0 y0)) (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.ldiff x0 y0)) (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))\n  (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))\n  (Z.ldiff (NN.to_Z x0) (NN.to_Z y0))",
                    "c4_x0 : NN.t",
                    "c6_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z (Pos (NN.land x0 (NN.pred y0))))\n  (Z.ldiff (to_Z (Pos x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (NN.to_Z (NN.land x0 (NN.pred y0)))\n  (Z.ldiff (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c10_goal : Logic.eq (NN.to_Z (NN.land x0 (NN.pred y0)))\n  (Z.ldiff (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.land (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1))\n  (Z.ldiff (NN.to_Z x0) (Z.opp (NN.to_Z y0)))",
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.lor (NN.pred x0) b))\n     | Neg b => Pos (NN.ldiff (NN.pred b) (NN.pred x0))\n     end) (Z.ldiff (to_Z (Neg x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lor (NN.pred x0) y0))))\n  (Z.ldiff (to_Z (Neg x0)) (to_Z (Pos y0)))",
                    "c13_y0 : NN.t",
                    "c14_goal : Logic.eq (to_Z (Pos (NN.ldiff (NN.pred y0) (NN.pred x0))))\n  (Z.ldiff (to_Z (Neg x0)) (to_Z (Neg y0)))",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lor (NN.pred x0) y0))))\n  (Z.ldiff (to_Z (Neg x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lor (NN.pred x0) y0))))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lor (NN.pred x0) y0))))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.lnot (Z.lor (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (NN.to_Z y0))",
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq (to_Z (Pos (NN.ldiff (NN.pred y0) (NN.pred x0))))\n  (Z.ldiff (to_Z (Neg x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (NN.to_Z (NN.ldiff (NN.pred y0) (NN.pred x0)))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_land , ?NN.spec_ldiff , ?NN.spec_lor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c18_goal : Logic.eq (NN.to_Z (NN.ldiff (NN.pred y0) (NN.pred x0)))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.ldiff (Z.sub (NN.to_Z y0) 1) (Z.sub (NN.to_Z x0) 1))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))",
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.ldiff_land , Zlnot_alt3 .",
                "tactic_sig_no_out_arg": "now rewrite Z.ldiff_land , Zlnot_alt3 .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.land (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1))\n  (Z.ldiff (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite Z.lnot_lor , Z.ldiff_land , <- Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite Z.lnot_lor , Z.ldiff_land , <- Zlnot_alt2 .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.lnot (Z.lor (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite 2 Z.ldiff_land , Zlnot_alt2 , Z.land_comm , Zlnot_alt3 .",
                "tactic_sig_no_out_arg": "now rewrite 2 Z.ldiff_land , Zlnot_alt2 , Z.land_comm , Zlnot_alt3 .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.ldiff (Z.sub (NN.to_Z y0) 1) (Z.sub (NN.to_Z x0) 1))\n  (Z.ldiff (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_lxor",
        "proof": [
            {
                "tactic_sig": "Lemma spec_lxor : forall x y , to_Z ( lxor x y ) = Z.lxor ( to_Z x ) ( to_Z y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_lxor : forall x y , to_Z ( lxor x y ) = Z.lxor ( to_Z x ) ( to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t_, Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))",
                    "c2_x : t_",
                    "c2_y : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))",
                    "_global_lxor : forall (_ : t_) (_ : t_), t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.lxor a b)\n         | Neg b => Neg (NN.succ (NN.lxor a (NN.pred b)))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.lxor (NN.pred a) b))\n         | Neg b => Pos (NN.lxor (NN.pred a) (NN.pred b))\n         end\n     end) (Z.lxor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match norm_pos x with\n     | Pos a =>\n         match norm_pos y with\n         | Pos b => Pos (NN.lxor a b)\n         | Neg b => Neg (NN.succ (NN.lxor a (NN.pred b)))\n         end\n     | Neg a =>\n         match norm_pos y with\n         | Pos b => Neg (NN.succ (NN.lxor (NN.pred a) b))\n         | Neg b => Pos (NN.lxor (NN.pred a) (NN.pred b))\n         end\n     end) (Z.lxor (to_Z x) (to_Z y))",
                    "c2_x : t_"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.lxor x0 b)\n     | Neg b => Neg (NN.succ (NN.lxor x0 (NN.pred b)))\n     end) (Z.lxor (to_Z (Pos x0)) (to_Z y))",
                    "c4_x0 : NN.t",
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.lxor (NN.pred x0) b))\n     | Neg b => Pos (NN.lxor (NN.pred x0) (NN.pred b))\n     end) (Z.lxor (to_Z (Neg x0)) (to_Z y))",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ]
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Pos (NN.lxor x0 b)\n     | Neg b => Neg (NN.succ (NN.lxor x0 (NN.pred b)))\n     end) (Z.lxor (to_Z (Pos x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.lxor x0 y0)))\n  (Z.lxor (to_Z (Pos x0)) (to_Z (Pos y0)))",
                    "c6_y0 : NN.t",
                    "c7_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lxor x0 (NN.pred y0)))))\n  (Z.lxor (to_Z (Pos x0)) (to_Z (Neg y0)))",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (Pos (NN.lxor x0 y0)))\n  (Z.lxor (to_Z (Pos x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.lxor x0 y0)) (Z.lxor (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (NN.lxor x0 y0)) (Z.lxor (NN.to_Z x0) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.lxor (NN.to_Z x0) (NN.to_Z y0))\n  (Z.lxor (NN.to_Z x0) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.lxor (NN.to_Z x0) (NN.to_Z y0))\n  (Z.lxor (NN.to_Z x0) (NN.to_Z y0))",
                    "c4_x0 : NN.t",
                    "c6_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lxor x0 (NN.pred y0)))))\n  (Z.lxor (to_Z (Pos x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lxor x0 (NN.pred y0)))))\n  (Z.lxor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lxor x0 (NN.pred y0)))))\n  (Z.lxor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.lnot (Z.lxor (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1)))\n  (Z.lxor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))",
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c7_H : Z.lt 0 (NN.to_Z y0)",
                    "c7_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_norm_pos _i .",
                "tactic_sig_no_out_arg": "destr_norm_pos _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     match norm_pos y with\n     | Pos b => Neg (NN.succ (NN.lxor (NN.pred x0) b))\n     | Neg b => Pos (NN.lxor (NN.pred x0) (NN.pred b))\n     end) (Z.lxor (to_Z (Neg x0)) (to_Z y))",
                    "c2_y : t_"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lxor (NN.pred x0) y0))))\n  (Z.lxor (to_Z (Neg x0)) (to_Z (Pos y0)))",
                    "c13_y0 : NN.t",
                    "c14_goal : Logic.eq (to_Z (Pos (NN.lxor (NN.pred x0) (NN.pred y0))))\n  (Z.lxor (to_Z (Neg x0)) (to_Z (Neg y0)))",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (Neg (NN.succ (NN.lxor (NN.pred x0) y0))))\n  (Z.lxor (to_Z (Neg x0)) (to_Z (Pos y0)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lxor (NN.pred x0) y0))))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.opp (NN.to_Z (NN.succ (NN.lxor (NN.pred x0) y0))))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (Z.lnot (Z.lxor (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))",
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq (to_Z (Pos (NN.lxor (NN.pred x0) (NN.pred y0))))\n  (Z.lxor (to_Z (Neg x0)) (to_Z (Neg y0)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (NN.to_Z (NN.lxor (NN.pred x0) (NN.pred y0)))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ]
            },
            {
                "tactic_sig": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_sig_no_out_arg": "rewrite ?NN.spec_succ , ?NN.spec_lxor , ?NN.spec_pred , ?Z.max_r , ?Zlnot_alt1 .",
                "tactic_args": [
                    "c18_goal : Logic.eq (NN.to_Z (NN.lxor (NN.pred x0) (NN.pred y0)))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.lxor (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))",
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.sub (NN.to_Z y0) 1)",
                    "c14_H0 : Z.lt 0 (NN.to_Z y0)",
                    "c14_y0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.sub (NN.to_Z x0) 1)",
                    "c5_H : Z.lt 0 (NN.to_Z x0)",
                    "c5_x0 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite !Z.lnot_lxor_r , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite !Z.lnot_lxor_r , Zlnot_alt2 .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.lnot (Z.lxor (NN.to_Z x0) (Z.sub (NN.to_Z y0) 1)))\n  (Z.lxor (NN.to_Z x0) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite !Z.lnot_lxor_l , Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite !Z.lnot_lxor_l , Zlnot_alt2 .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.lnot (Z.lxor (Z.sub (NN.to_Z x0) 1) (NN.to_Z y0)))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (NN.to_Z y0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite <- Z.lxor_lnot_lnot , !Zlnot_alt2 .",
                "tactic_sig_no_out_arg": "now rewrite <- Z.lxor_lnot_lnot , !Zlnot_alt2 .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.lxor (Z.sub (NN.to_Z x0) 1) (Z.sub (NN.to_Z y0) 1))\n  (Z.lxor (Z.opp (NN.to_Z x0)) (Z.opp (NN.to_Z y0)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div2",
        "proof": [
            {
                "tactic_sig": "Lemma spec_div2 : forall x , to_Z ( div2 x ) = Z.div2 ( to_Z x ) .",
                "tactic_sig_no_out_arg": "Lemma spec_div2 : forall x , to_Z ( div2 x ) = Z.div2 ( to_Z x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t_, Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))",
                    "c2_x : t_"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))",
                    "_global_div2 : forall _ : t_, t_"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (shiftr x one)) (Z.div2 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "now rewrite spec_shiftr , Z.div2_spec , spec_1 .",
                "tactic_sig_no_out_arg": "now rewrite spec_shiftr , Z.div2_spec , spec_1 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (shiftr x one)) (Z.div2 (to_Z x))"
                ],
                "tactic_res": []
            }
        ]
    }
]