[
    {
        "lemma_name": "N_to_Z_pos",
        "proof": [
            {
                "tactic_sig": "Lemma N_to_Z_pos : forall x , ( NN.to_Z x <> NN.to_Z NN.zero ) % Z -> ( 0 < NN.to_Z x ) % Z .",
                "tactic_sig_no_out_arg": "Lemma N_to_Z_pos : forall x , ( NN.to_Z x <> NN.to_Z NN.zero ) % Z -> ( 0 < NN.to_Z x ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : NN.t) (_ : not (eq (NN.to_Z x) (NN.to_Z NN.zero))),\nZ.lt 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : NN.t) (_ : not (eq (NN.to_Z x) (NN.to_Z NN.zero))),\nZ.lt 0 (NN.to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : not (eq (NN.to_Z x) (NN.to_Z NN.zero)), Z.lt 0 (NN.to_Z x)",
                    "c2_x : NN.t"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall _ : not (eq (NN.to_Z x) (NN.to_Z NN.zero)), Z.lt 0 (NN.to_Z x)",
                    "_global_NN.spec_0 : eq (NN.to_Z NN.zero) 0%Z"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : not (eq (NN.to_Z x) 0%Z), Z.lt 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : not (eq (NN.to_Z x) 0%Z), Z.lt 0 (NN.to_Z x)",
                    "c2_x : NN.t"
                ],
                "tactic_res": [
                    "c4_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : not (eq (NN.to_Z x) 0%Z)),\nZ.lt 0 (NN.to_Z x)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c4_goal : forall (_ : Z.le 0 (NN.to_Z x)) (_ : not (eq (NN.to_Z x) 0%Z)),\nZ.lt 0 (NN.to_Z x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_of_Q",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_of_Q : forall q : Q , [ of_Q q ] = q .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_of_Q : forall q : Q , [ of_Q q ] = q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : Q, eq (to_Q (of_Q q)) q"
                ]
            },
            {
                "tactic_sig": "intros ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros ( x , y ) .",
                "tactic_args": [
                    "c1_goal : forall q : Q, eq (to_Q (of_Q q)) q"
                ],
                "tactic_res": [
                    "c2_goal : eq (to_Q (of_Q {| Qnum := x; Qden := y |})) {| Qnum := x; Qden := y |}",
                    "c2_x : Z",
                    "c2_y : positive"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ | | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | | ] .",
                "tactic_args": [
                    "c2_goal : eq (to_Q (of_Q {| Qnum := x; Qden := y |})) {| Qnum := x; Qden := y |}",
                    "c2_y : positive",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}",
                    "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}",
                    "c5_goal : eq (to_Q (of_Q {| Qnum := x; Qden := 1 |})) {| Qnum := x; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "custom28 .",
                "tactic_sig_no_out_arg": "custom28 .",
                "tactic_args": [
                    "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom28 .",
                "tactic_sig_no_out_arg": "custom28 .",
                "tactic_args": [
                    "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : eq (to_Q (of_Q {| Qnum := x; Qden := 1 |})) {| Qnum := x; Qden := 1 |}"
                ],
                "tactic_res": [
                    "c6_goal : eq {| Qnum := ZZ.to_Z (ZZ.of_Z x); Qden := 1 |}\n  {| Qnum := x; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "rewrite ?ZZ.spec_of_Z .",
                "tactic_sig_no_out_arg": "rewrite ?ZZ.spec_of_Z .",
                "tactic_args": [
                    "c6_goal : eq {| Qnum := ZZ.to_Z (ZZ.of_Z x); Qden := 1 |}\n  {| Qnum := x; Qden := 1 |}"
                ],
                "tactic_res": [
                    "c7_goal : eq {| Qnum := x; Qden := 1 |} {| Qnum := x; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq {| Qnum := x; Qden := 1 |} {| Qnum := x; Qden := 1 |}",
                    "c2_x : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_of_Q",
        "proof": [
            {
                "tactic_sig": "Theorem spec_of_Q : forall q : Q , [ of_Q q ] = = q .",
                "tactic_sig_no_out_arg": "Theorem spec_of_Q : forall q : Q , [ of_Q q ] = = q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : Q, Qeq (to_Q (of_Q q)) q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall q : Q, Qeq (to_Q (of_Q q)) q"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (of_Q q)) q",
                    "c2_q : Q"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (of_Q q)) q",
                    "_global_strong_spec_of_Q : forall q : Q, eq (to_Q (of_Q q)) q"
                ],
                "tactic_res": [
                    "c3_goal : Qeq q q"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : Qeq q q"
                ],
                "tactic_res": [
                    "c4_goal : eq (Z.mul (Qnum q) (Zpos (Qden q))) (Z.mul (Qnum q) (Zpos (Qden q)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (Z.mul (Qnum q) (Zpos (Qden q))) (Z.mul (Qnum q) (Zpos (Qden q)))",
                    "c2_q : Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_0",
        "proof": [
            {
                "tactic_sig": "Lemma spec_0 : [ zero ] = = 0 .",
                "tactic_sig_no_out_arg": "Lemma spec_0 : [ zero ] = = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Qeq (to_Q zero) 0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : Qeq (to_Q zero) 0"
                ],
                "tactic_res": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c3_goal : Qeq 0 0"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : Qeq 0 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_1",
        "proof": [
            {
                "tactic_sig": "Lemma spec_1 : [ one ] = = 1 .",
                "tactic_sig_no_out_arg": "Lemma spec_1 : [ one ] = = 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Qeq (to_Q one) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : Qeq (to_Q one) 1"
                ],
                "tactic_res": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |} 1"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |} 1"
                ],
                "tactic_res": [
                    "c3_goal : Qeq 1 1"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : Qeq 1 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_m1",
        "proof": [
            {
                "tactic_sig": "Lemma spec_m1 : [ minus_one ] = = - ( 1 ) .",
                "tactic_sig_no_out_arg": "Lemma spec_m1 : [ minus_one ] = = - ( 1 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Qeq (to_Q minus_one) (Qopp 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : Qeq (to_Q minus_one) (Qopp 1)"
                ],
                "tactic_res": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.minus_one; Qden := 1 |} (Qopp 1)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c2_goal : Qeq {| Qnum := ZZ.to_Z ZZ.minus_one; Qden := 1 |} (Qopp 1)"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (-1) (Qopp 1)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : Qeq (-1) (Qopp 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_compare",
        "proof": [
            {
                "tactic_sig": "Theorem spec_compare : forall q1 q2 , ( compare q1 q2 ) = ( [ q1 ] ? = [ q2 ] ) .",
                "tactic_sig_no_out_arg": "Theorem spec_compare : forall q1 q2 , ( compare q1 q2 ) = ( [ q1 ] ? = [ q2 ] ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o _o ] [ _o | _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ z1 | x1 y1 ] [ z2 | x2 y2 ] .",
                "tactic_args": [
                    "c1_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (compare (Qz z1) (Qz z2))\n  (Qcompare (to_Q (Qz z1)) (to_Q (Qz z2)))",
                    "c5_x1 : ZZ.t",
                    "c5_y1 : NN.t",
                    "c5_x2 : ZZ.t",
                    "c5_y2 : NN.t",
                    "c5_goal : Logic.eq (compare (Qq x1 y1) (Qq x2 y2))\n  (Qcompare (to_Q (Qq x1 y1)) (to_Q (Qq x2 y2)))",
                    "c4_x1 : ZZ.t",
                    "c4_y1 : NN.t",
                    "c4_z2 : ZZ.t",
                    "c4_goal : Logic.eq (compare (Qq x1 y1) (Qz z2))\n  (Qcompare (to_Q (Qq x1 y1)) (to_Q (Qz z2)))",
                    "c3_z1 : ZZ.t",
                    "c3_x2 : ZZ.t",
                    "c3_y2 : NN.t",
                    "c3_goal : Logic.eq (compare (Qz z1) (Qq x2 y2))\n  (Qcompare (to_Q (Qz z1)) (to_Q (Qq x2 y2)))",
                    "c2_z1 : ZZ.t",
                    "c2_z2 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (compare (Qz z1) (Qz z2))\n  (Qcompare (to_Q (Qz z1)) (to_Q (Qz z2)))",
                    "_global_Qcompare : forall (_ : Q) (_ : Q), comparison",
                    "_global_compare : forall (_ : t) (_ : t), comparison"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZZ.compare z1 z2)\n  (Z.compare (Z.mul (Qnum (to_Q (Qz z1))) (Zpos (Qden (to_Q (Qz z2)))))\n     (Z.mul (Qnum (to_Q (Qz z2))) (Zpos (Qden (to_Q (Qz z1))))))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZZ.compare z1 z2)\n  (Z.compare (Z.mul (Qnum (to_Q (Qz z1))) (Zpos (Qden (to_Q (Qz z2)))))\n     (Z.mul (Qnum (to_Q (Qz z2))) (Zpos (Qden (to_Q (Qz z1))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (compare (Qz z1) (Qq x2 y2))\n  (Qcompare (to_Q (Qz z1)) (to_Q (Qq x2 y2)))",
                    "_global_Qcompare : forall (_ : Q) (_ : Q), comparison",
                    "_global_compare : forall (_ : t) (_ : t), comparison"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (if NN.eqb y2 NN.zero\n   then ZZ.compare z1 ZZ.zero\n   else ZZ.compare (ZZ.mul z1 (Z_of_N y2)) x2)\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qz z1))) (Zpos (Qden (to_Q (Qq x2 y2)))))\n     (Z.mul (Qnum (to_Q (Qq x2 y2))) (Zpos (Qden (to_Q (Qz z1))))))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (if NN.eqb y2 NN.zero\n   then ZZ.compare z1 ZZ.zero\n   else ZZ.compare (ZZ.mul z1 (Z_of_N y2)) x2)\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qz z1))) (Zpos (Qden (to_Q (Qq x2 y2)))))\n     (Z.mul (Qnum (to_Q (Qq x2 y2))) (Zpos (Qden (to_Q (Qz z1))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (compare (Qq x1 y1) (Qz z2))\n  (Qcompare (to_Q (Qq x1 y1)) (to_Q (Qz z2)))",
                    "_global_Qcompare : forall (_ : Q) (_ : Q), comparison",
                    "_global_compare : forall (_ : t) (_ : t), comparison"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (if NN.eqb y1 NN.zero\n   then ZZ.compare ZZ.zero z2\n   else ZZ.compare x1 (ZZ.mul z2 (Z_of_N y1)))\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qq x1 y1))) (Zpos (Qden (to_Q (Qz z2)))))\n     (Z.mul (Qnum (to_Q (Qz z2))) (Zpos (Qden (to_Q (Qq x1 y1))))))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (if NN.eqb y1 NN.zero\n   then ZZ.compare ZZ.zero z2\n   else ZZ.compare x1 (ZZ.mul z2 (Z_of_N y1)))\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qq x1 y1))) (Zpos (Qden (to_Q (Qz z2)))))\n     (Z.mul (Qnum (to_Q (Qz z2))) (Zpos (Qden (to_Q (Qq x1 y1))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (compare (Qq x1 y1) (Qq x2 y2))\n  (Qcompare (to_Q (Qq x1 y1)) (to_Q (Qq x2 y2)))",
                    "_global_Qcompare : forall (_ : Q) (_ : Q), comparison",
                    "_global_compare : forall (_ : t) (_ : t), comparison"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq\n  (if NN.eqb y1 NN.zero\n   then if NN.eqb y2 NN.zero then Eq else ZZ.compare ZZ.zero x2\n   else\n    if NN.eqb y2 NN.zero\n    then ZZ.compare x1 ZZ.zero\n    else ZZ.compare (ZZ.mul x1 (Z_of_N y2)) (ZZ.mul x2 (Z_of_N y1)))\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qq x1 y1))) (Zpos (Qden (to_Q (Qq x2 y2)))))\n     (Z.mul (Qnum (to_Q (Qq x2 y2))) (Zpos (Qden (to_Q (Qq x1 y1))))))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  (if NN.eqb y1 NN.zero\n   then if NN.eqb y2 NN.zero then Eq else ZZ.compare ZZ.zero x2\n   else\n    if NN.eqb y2 NN.zero\n    then ZZ.compare x1 ZZ.zero\n    else ZZ.compare (ZZ.mul x1 (Z_of_N y2)) (ZZ.mul x2 (Z_of_N y1)))\n  (Z.compare\n     (Z.mul (Qnum (to_Q (Qq x1 y1))) (Zpos (Qden (to_Q (Qq x2 y2)))))\n     (Z.mul (Qnum (to_Q (Qq x2 y2))) (Zpos (Qden (to_Q (Qq x1 y1))))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_min",
        "proof": [
            {
                "tactic_sig": "Lemma spec_min : forall n m , [ min n m ] = = Qmin [ n ] [ m ] .",
                "tactic_sig_no_out_arg": "Lemma spec_min : forall n m , [ min n m ] = = Qmin [ n ] [ m ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t, Qeq (to_Q (min n m)) (Qmin (to_Q n) (to_Q m))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c1_goal : forall n m : t, Qeq (to_Q (min n m)) (Qmin (to_Q n) (to_Q m))",
                    "_global_min : forall (_ : t) (_ : t), t",
                    "_global_Qmin : forall (_ : Q) (_ : Q), Q",
                    "_global_GenericMinMax.gmin : forall (_ : forall (_ : ?A) (_ : ?A), comparison) (_ : ?A) (_ : ?A),\n       ?A\nwhere\n?A : [ |- Type]"
                ],
                "tactic_res": [
                    "c2_goal : forall n m : t,\nQeq (to_Q match compare n m with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall n m : t,\nQeq (to_Q match compare n m with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q match compare n m with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end",
                    "c3_n : True",
                    "c3_m : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q match compare n m with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end",
                    "_global_spec_compare : forall q1 q2 : t,\n       Logic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q match Qcompare (to_Q n) (to_Q m) with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct Qcompare as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct Qcompare .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q match Qcompare (to_Q n) (to_Q m) with\n          | Gt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Gt => to_Q m\n  | _ => to_Q n\n  end",
                    "c3_n : True",
                    "c3_m : True"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q n) (to_Q n)",
                    "c6_goal : Qeq (to_Q n) (to_Q n)",
                    "c7_goal : Qeq (to_Q m) (to_Q m)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q n) (to_Q n)",
                    "c3_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q n) (to_Q n)",
                    "c3_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q m) (to_Q m)",
                    "c3_m : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_max",
        "proof": [
            {
                "tactic_sig": "Lemma spec_max : forall n m , [ max n m ] = = Qmax [ n ] [ m ] .",
                "tactic_sig_no_out_arg": "Lemma spec_max : forall n m , [ max n m ] = = Qmax [ n ] [ m ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t, Qeq (to_Q (max n m)) (Qmax (to_Q n) (to_Q m))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c1_goal : forall n m : t, Qeq (to_Q (max n m)) (Qmax (to_Q n) (to_Q m))",
                    "_global_max : forall (_ : t) (_ : t), t",
                    "_global_Qmax : forall (_ : Q) (_ : Q), Q",
                    "_global_GenericMinMax.gmax : forall (_ : forall (_ : ?A) (_ : ?A), comparison) (_ : ?A) (_ : ?A),\n       ?A\nwhere\n?A : [ |- Type]"
                ],
                "tactic_res": [
                    "c2_goal : forall n m : t,\nQeq (to_Q match compare n m with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall n m : t,\nQeq (to_Q match compare n m with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q match compare n m with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end",
                    "c3_n : True",
                    "c3_m : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q match compare n m with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end",
                    "_global_spec_compare : forall q1 q2 : t,\n       Logic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q match Qcompare (to_Q n) (to_Q m) with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct Qcompare as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct Qcompare .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q match Qcompare (to_Q n) (to_Q m) with\n          | Lt => m\n          | _ => n\n          end)\n  match Qcompare (to_Q n) (to_Q m) with\n  | Lt => to_Q m\n  | _ => to_Q n\n  end",
                    "c3_n : True",
                    "c3_m : True"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q n) (to_Q n)",
                    "c6_goal : Qeq (to_Q m) (to_Q m)",
                    "c7_goal : Qeq (to_Q n) (to_Q n)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q n) (to_Q n)",
                    "c3_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q m) (to_Q m)",
                    "c3_m : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q n) (to_Q n)",
                    "c3_n : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_eq_bool",
        "proof": [
            {
                "tactic_sig": "Theorem spec_eq_bool : forall x y , eq_bool x y = Qeq_bool [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_eq_bool : forall x y , eq_bool x y = Qeq_bool [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (eq_bool x y) (Qeq_bool (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (eq_bool x y) (Qeq_bool (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (eq_bool x y) (Qeq_bool (to_Q x) (to_Q y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (eq_bool x y) (Qeq_bool (to_Q x) (to_Q y))",
                    "_global_eq_bool : forall (_ : t) (_ : t), bool"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq match compare x y with\n         | Eq => true\n         | _ => false\n         end (Qeq_bool (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq match compare x y with\n         | Eq => true\n         | _ => false\n         end (Qeq_bool (to_Q x) (to_Q y))",
                    "_global_spec_compare : forall q1 q2 : t,\n       Logic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  match Qcompare (to_Q x) (to_Q y) with\n  | Eq => true\n  | _ => false\n  end (Qeq_bool (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  match Qcompare (to_Q x) (to_Q y) with\n  | Eq => true\n  | _ => false\n  end (Qeq_bool (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_check_int",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_check_int : forall n d , [ check_int n d ] = [ Qq n d ] .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_check_int : forall n d , [ check_int n d ] = [ Qq n d ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ]
            },
            {
                "tactic_sig": "custom25 n d check_int .",
                "tactic_sig_no_out_arg": "custom25 n d check_int .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                    "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t",
                    "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                    "c3_H : Z.lt 1 (NN.to_Z d)",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t",
                    "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                    "c4_H : Z.lt (NN.to_Z d) 1",
                    "c4_d : NN.t",
                    "c4_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c2_H : Logic.eq 1%Z (NN.to_Z d)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ]
            },
            {
                "tactic_sig": "custom81 .",
                "tactic_sig_no_out_arg": "custom81 .",
                "tactic_args": [
                    "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq 0 {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}",
                    "c7_H0 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : Logic.eq 0 {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_norm : forall n q , [ norm n q ] = = [ Qq n q ] .",
                "tactic_sig_no_out_arg": "Theorem spec_norm : forall n q , [ norm n q ] = = [ Qq n q ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (q : NN.t), Qeq (to_Q (norm n q)) (to_Q (Qq n q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p q .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (q : NN.t), Qeq (to_Q (norm n q)) (to_Q (Qq n q))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (norm p q)) (to_Q (Qq p q))",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (norm p q)) (to_Q (Qq p q))",
                    "_global_norm : forall (_ : ZZ.t) (_ : NN.t), t"
                ],
                "tactic_res": [
                    "c3_goal : Qeq\n  (to_Q\n     match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n     | Eq => check_int p q\n     | Lt =>\n         check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n           (NN.div q (NN.gcd (Zabs_N p) q))\n     | Gt => zero\n     end) (to_Q (Qq p q))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos ( Zabs_N _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos ( Zabs_N _i ) ) .",
                "tactic_args": [
                    "c2_p : ZZ.t"
                ],
                "tactic_res": [
                    "c3_Hp : Z.le 0 (NN.to_Z (Zabs_N p))"
                ]
            },
            {
                "tactic_sig": "assert ( Hq := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hq := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c3_Hq : Z.le 0 (NN.to_Z q)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c3_goal : Qeq\n  (to_Q\n     match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n     | Eq => check_int p q\n     | Lt =>\n         check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n           (NN.div q (NN.gcd (Zabs_N p) q))\n     | Gt => zero\n     end) (to_Q (Qq p q))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq\n  (to_Q\n     match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n     | Eq => check_int p q\n     | Lt =>\n         check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n           (NN.div q (NN.gcd (Zabs_N p) q))\n     | Gt => zero\n     end) (to_Q (Qq p q))",
                    "c4_Hp : Z.le 0 (Z.abs (ZZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c4_goal : Qeq\n  (to_Q\n     match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n     | Eq => check_int p q\n     | Lt =>\n         check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n           (NN.div q (NN.gcd (Zabs_N p) q))\n     | Gt => zero\n     end) (to_Q (Qq p q))"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q (check_int p q)) (to_Q (Qq p q))",
                    "c5_H : Logic.eq 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c6_goal : Qeq\n  (to_Q\n     (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n        (NN.div q (NN.gcd (Zabs_N p) q)))) (to_Q (Qq p q))",
                    "c6_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c7_goal : Qeq (to_Q zero) (to_Q (Qq p q))",
                    "c7_H : Z.lt (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (check_int p q)) (to_Q (Qq p q))",
                    "_global_strong_spec_check_int : forall (n : ZZ.t) (d : NN.t),\n       Logic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c8_goal : Qeq (to_Q (Qq p q)) (to_Q (Qq p q))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q (Qq p q)) (to_Q (Qq p q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Qeq\n  (to_Q\n     (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n        (NN.div q (NN.gcd (Zabs_N p) q)))) (to_Q (Qq p q))",
                    "_global_strong_spec_check_int : forall (n : ZZ.t) (d : NN.t),\n       Logic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c9_goal : Qeq\n  (to_Q\n     (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n        (NN.div q (NN.gcd (Zabs_N p) q)))) (to_Q (Qq p q))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c9_goal : Qeq\n  (to_Q\n     (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n        (NN.div q (NN.gcd (Zabs_N p) q)))) (to_Q (Qq p q))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq 0%Z (ZZ.to_Z p)",
                    "c10_e : Logic.eq (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))) 0%Z",
                    "c10_H0 : Z.lt 0 (NN.to_Z q)",
                    "c11_goal : Logic.eq (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))) 0%Z",
                    "c11_H0 : Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c11_e : Logic.eq (NN.to_Z q) 0%Z",
                    "c12_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n     (NN.to_Z q))\n  (Z.mul (ZZ.to_Z p)\n     (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))))",
                    "c12_H1 : Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c12_H0 : Z.lt 0 (NN.to_Z q)"
                ]
            },
            {
                "tactic_sig": "generalize ( Zgcd_div_pos ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Zgcd_div_pos ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c10_goal : Logic.eq 0%Z (ZZ.to_Z p)",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  _ : forall (_ : Z.lt 0 (NN.to_Z q))\n        (_ : Z.lt 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))),\n      Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))),\nLogic.eq 0%Z (ZZ.to_Z p)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : forall (_ : Z.lt 0 (NN.to_Z q))\n        (_ : Z.lt 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))),\n      Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))),\nLogic.eq 0%Z (ZZ.to_Z p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( NN.to_Z _i ) with 0 % Z in * by assumption .",
                "tactic_sig_no_out_arg": "replace ( NN.to_Z _i ) with 0 % Z in * by assumption .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))) 0%Z",
                    "c2_q : NN.t",
                    "c11_H0 : Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c11_e : Logic.eq (NN.to_Z q) 0%Z",
                    "c6_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c3_Hq : Z.le 0 (NN.to_Z q)",
                    "c4_Hp : Z.le 0 (Z.abs (ZZ.to_Z p))",
                    "c2_p : ZZ.t"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z)) 0%Z",
                    "c14_H0 : Z.lt 0 (Z.div 0%Z (Z.gcd (ZZ.to_Z p) 0%Z))",
                    "c14_e : Logic.eq 0%Z 0%Z",
                    "c14_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) 0%Z)",
                    "c14_Hq : Z.le 0 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c14_H0 : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z)) 0%Z",
                    "c14_H0 : Z.lt 0 0",
                    "c2_p : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n     (NN.to_Z q))\n  (Z.mul (ZZ.to_Z p)\n     (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))))",
                    "_global_Zgcd_div_swap0 : forall (a b : Z) (_ : Z.lt 0 (Z.gcd a b)) (_ : Z.lt 0 b),\n       Logic.eq (Z.mul (Z.div a (Z.gcd a b)) b)\n         (Z.mul a (Z.div b (Z.gcd a b)))"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c16_goal : Z.lt 0 (NN.to_Z q)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c15_goal : Z.lt 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c16_goal : Z.lt 0 (NN.to_Z q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q zero) (to_Q (Qq p q))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq 0%Z (ZZ.to_Z p)",
                    "c17_H0 : Z.lt 0 (NN.to_Z q)"
                ]
            },
            {
                "tactic_sig": "assert ( H' : Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) = 0 % Z ) .",
                "tactic_sig_no_out_arg": "assert ( H' : Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) = 0 % Z ) .",
                "tactic_args": [
                    "c17_goal : Logic.eq 0%Z (ZZ.to_Z p)",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z",
                    "c19_goal : Logic.eq 0%Z (ZZ.to_Z p)",
                    "c19_H' : Logic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z"
                ]
            },
            {
                "tactic_sig": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q)),\nLogic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z p) (NN.to_Z q)),\nLogic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c19_goal : Logic.eq 0%Z (ZZ.to_Z p)"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (ZZ.to_Z p) 0%Z"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i _i _i ) .",
                "tactic_args": [
                    "c21_goal : Logic.eq (ZZ.to_Z p) 0%Z",
                    "_global_Z.gcd_eq_0_l : forall (n m : Z) (_ : Logic.eq (Z.gcd n m) 0%Z), Logic.eq n 0%Z",
                    "_global__ : ?T\nwhere\n?T : [ |- Type]\n?y : [ |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [ |- Type]\n?y : [ |- ?T]",
                    "c19_H' : Logic.eq (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0%Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_norm",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_norm : forall p q , [ norm p q ] = Qred [ Qq p q ] .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_norm : forall p q , [ norm p q ] = Qred [ Qq p q ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p : ZZ.t) (q : NN.t),\nLogic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (p : ZZ.t) (q : NN.t),\nLogic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ]
            },
            {
                "tactic_sig": "replace ( Qred [ Qq _i _i ] ) with ( Qred [ norm _i _i ] ) by ( apply Qred_complete ; apply spec_norm ) .",
                "tactic_sig_no_out_arg": "replace ( Qred [ Qq _i _i ] ) with ( Qred [ norm _i _i ] ) by ( apply Qred_complete ; apply spec_norm ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t",
                    "c2_p : ZZ.t",
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (norm p q)) (Qred (to_Q (norm p q)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (norm p q)) (Qred (to_Q (norm p q)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (norm p q))) (to_Q (norm p q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (norm p q))) (to_Q (norm p q))",
                    "_global_Qred_identity : forall (q : Q) (_ : Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z),\n       Logic.eq (Qred q) q"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (norm p q))) (Zpos (Qden (to_Q (norm p q))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (norm p q))) (Zpos (Qden (to_Q (norm p q))))) 1%Z",
                    "_global_norm : forall (_ : ZZ.t) (_ : NN.t), t"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n           | Eq => check_int p q\n           | Lt =>\n               check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))\n           | Gt => zero\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n              | Eq => check_int p q\n              | Lt =>\n                  check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                    (NN.div q (NN.gcd (Zabs_N p) q))\n              | Gt => zero\n              end)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "assert ( Hp := NN.spec_pos ( Zabs_N _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( Hp := NN.spec_pos ( Zabs_N _i ) ) .",
                "tactic_args": [
                    "c2_p : ZZ.t"
                ],
                "tactic_res": [
                    "c6_Hp : Z.le 0 (NN.to_Z (Zabs_N p))"
                ]
            },
            {
                "tactic_sig": "assert ( Hq := NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hq := NN.spec_pos _i ) .",
                "tactic_args": [
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c6_Hq : Z.le 0 (NN.to_Z q)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n           | Eq => check_int p q\n           | Lt =>\n               check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))\n           | Gt => zero\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match NN.compare NN.one (NN.gcd (Zabs_N p) q) with\n              | Eq => check_int p q\n              | Lt =>\n                  check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                    (NN.div q (NN.gcd (Zabs_N p) q))\n              | Gt => zero\n              end)))) 1%Z"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n           | Eq => check_int p q\n           | Lt =>\n               check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))\n           | Gt => zero\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n              | Eq => check_int p q\n              | Lt =>\n                  check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                    (NN.div q (NN.gcd (Zabs_N p) q))\n              | Gt => zero\n              end)))) 1%Z",
                    "c7_Hp : Z.le 0 (Z.abs (ZZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n           | Eq => check_int p q\n           | Lt =>\n               check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))\n           | Gt => zero\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match Z.compare 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) with\n              | Eq => check_int p q\n              | Lt =>\n                  check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                    (NN.div q (NN.gcd (Zabs_N p) q))\n              | Gt => zero\n              end)))) 1%Z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (check_int p q)))\n     (Zpos (Qden (to_Q (check_int p q))))) 1%Z",
                    "c8_H : Logic.eq 1%Z (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c9_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n              (NN.div q (NN.gcd (Zabs_N p) q)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))))))) 1%Z",
                    "c9_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c10_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c10_H : Z.lt (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite ?strong_spec_check_int .",
                "tactic_sig_no_out_arg": "rewrite ?strong_spec_check_int .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (check_int p q)))\n     (Zpos (Qden (to_Q (check_int p q))))) 1%Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qq p q))) (Zpos (Qden (to_Q (Qq p q)))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite ?strong_spec_check_int .",
                "tactic_sig_no_out_arg": "rewrite ?strong_spec_check_int .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n              (NN.div q (NN.gcd (Zabs_N p) q)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (check_int (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))))))) 1%Z"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n              (NN.div q (NN.gcd (Zabs_N p) q)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qq p q))) (Zpos (Qden (to_Q (Qq p q)))))\n  1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n              (NN.div q (NN.gcd (Zabs_N p) q)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.div p (Z_of_N (NN.gcd (Zabs_N p) q)))\n                 (NN.div q (NN.gcd (Zabs_N p) q))))))) 1%Z"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n     (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))) 1%Z",
                    "c13_H0 : Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n     (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c14_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z_lt_le_dec 0 ( NN.to_Z _i ) ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z_lt_le_dec 0 ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c14_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c2_q : NN.t",
                    "c13_H0 : Z.lt 0 (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c9_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c6_Hq : Z.le 0 (NN.to_Z q)",
                    "c7_Hp : Z.le 0 (Z.abs (ZZ.to_Z p))",
                    "c2_p : ZZ.t"
                ],
                "tactic_res": [
                    "c15_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c15_l : Z.lt 0 (NN.to_Z q)",
                    "c16_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c16_l : Z.le (NN.to_Z q) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "_global_Zis_gcd_rel_prime : forall (a b g : Z) (_ : Z.gt b 0) (_ : Z.ge g 0) (_ : Zis_gcd a b g),\n       rel_prime (Z.div a g) (Z.div b g)"
                ],
                "tactic_res": [
                    "c17_goal : Z.gt (NN.to_Z q) 0",
                    "c18_goal : Z.ge (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0",
                    "c19_goal : Zis_gcd (ZZ.to_Z p) (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.gt (NN.to_Z q) 0",
                    "c15_l : Z.lt 0 (NN.to_Z q)",
                    "c2_q : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : Z.ge (Z.gcd (ZZ.to_Z p) (NN.to_Z q)) 0",
                    "c9_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "c2_q : NN.t",
                    "c2_p : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Zis_gcd (ZZ.to_Z p) (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q))",
                    "_global_Zgcd_is_gcd : forall a b : Z, Zis_gcd a b (Z.gcd a b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( NN.to_Z _i ) with 0 % Z in * by lia .",
                "tactic_sig_no_out_arg": "replace ( NN.to_Z _i ) with 0 % Z in * by lia .",
                "tactic_args": [
                    "c16_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))\n  (Z.div (NN.to_Z q) (Z.gcd (ZZ.to_Z p) (NN.to_Z q)))",
                    "c2_q : NN.t"
                ],
                "tactic_res": [
                    "c20_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z))\n  (Z.div 0%Z (Z.gcd (ZZ.to_Z p) 0%Z))",
                    "c20_l : Z.le 0 0",
                    "c20_H0 : Z.lt 0 (Z.div 0%Z (Z.gcd (ZZ.to_Z p) 0%Z))",
                    "c20_H : Z.lt 1 (Z.gcd (ZZ.to_Z p) 0%Z)",
                    "c20_Hq : Z.le 0 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c20_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z))\n  (Z.div 0%Z (Z.gcd (ZZ.to_Z p) 0%Z))",
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c21_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z)) 0",
                    "c21_H0 : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c21_goal : rel_prime (Z.div (ZZ.to_Z p) (Z.gcd (ZZ.to_Z p) 0%Z)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_red",
        "proof": [
            {
                "tactic_sig": "Theorem spec_red : forall x , [ red x ] = = [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_red : forall x , [ red x ] = = [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_sig_no_out_arg": "custom86 n d z red spec_norm .",
                "tactic_args": [
                    "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                    "c2_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_red",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_red : forall x , [ red x ] = Qred [ x ] .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_red : forall x , [ red x ] = Qred [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ]
            },
            {
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_sig_no_out_arg": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                    "c2_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                    "_global_red : forall _ : t, t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ]
            },
            {
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_sig_no_out_arg": "custom70 Qred_identity .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "custom71 .",
                "tactic_sig_no_out_arg": "custom71 .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add : forall x y , [ add x y ] = = [ x ] + [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_add : forall x y , [ add x y ] = = [ x ] + [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o _o ] [ _o | _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | nx dx ] [ y | ny dy ] .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (add (Qz x) (Qz y))) (Qplus (to_Q (Qz x)) (to_Q (Qz y)))",
                    "c5_nx : ZZ.t",
                    "c5_dx : NN.t",
                    "c5_ny : ZZ.t",
                    "c5_dy : NN.t",
                    "c5_goal : Qeq (to_Q (add (Qq nx dx) (Qq ny dy)))\n  (Qplus (to_Q (Qq nx dx)) (to_Q (Qq ny dy)))",
                    "c4_nx : ZZ.t",
                    "c4_dx : NN.t",
                    "c4_y : ZZ.t",
                    "c4_goal : Qeq (to_Q (add (Qq nx dx) (Qz y)))\n  (Qplus (to_Q (Qq nx dx)) (to_Q (Qz y)))",
                    "c3_x : ZZ.t",
                    "c3_ny : ZZ.t",
                    "c3_dy : NN.t",
                    "c3_goal : Qeq (to_Q (add (Qz x) (Qq ny dy)))\n  (Qplus (to_Q (Qz x)) (to_Q (Qq ny dy)))",
                    "c2_x : ZZ.t",
                    "c2_y : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (add (Qz x) (Qz y))) (Qplus (to_Q (Qz x)) (to_Q (Qz y)))",
                    "_global_Qplus : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (to_Q (add (Qz x) (Qz y)))\n  {|\n    Qnum :=\n      Z.add (Z.mul (Qnum (to_Q (Qz x))) (Zpos (Qden (to_Q (Qz y)))))\n        (Z.mul (Qnum (to_Q (Qz y))) (Zpos (Qden (to_Q (Qz x)))));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qz y)))\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q (add (Qz x) (Qz y)))\n  {|\n    Qnum :=\n      Z.add (Z.mul (Qnum (to_Q (Qz x))) (Zpos (Qden (to_Q (Qz y)))))\n        (Z.mul (Qnum (to_Q (Qz y))) (Zpos (Qden (to_Q (Qz x)))));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qz y)))\n  |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (add (Qz x) (Qq ny dy)))\n  (Qplus (to_Q (Qz x)) (to_Q (Qq ny dy)))",
                    "_global_Qplus : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (add (Qz x) (Qq ny dy)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qz x))) (Zpos (Qden (to_Q (Qq ny dy)))))\n        (Z.mul (Qnum (to_Q (Qq ny dy))) (Zpos (Qden (to_Q (Qz x)))));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (add (Qz x) (Qq ny dy)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qz x))) (Zpos (Qden (to_Q (Qq ny dy)))))\n        (Z.mul (Qnum (to_Q (Qq ny dy))) (Zpos (Qden (to_Q (Qz x)))));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq 0%Z (Z.add (Z.mul (ZZ.to_Z x) (NN.to_Z dy)) (ZZ.to_Z ny))",
                    "c8_H : Z.lt 0 (NN.to_Z dy)",
                    "c8_e : Logic.eq (NN.to_Z dy) 0%Z"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c8_goal : Logic.eq 0%Z (Z.add (Z.mul (ZZ.to_Z x) (NN.to_Z dy)) (ZZ.to_Z ny))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (add (Qq nx dx) (Qz y)))\n  (Qplus (to_Q (Qq nx dx)) (to_Q (Qz y)))",
                    "_global_Qplus : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c9_goal : Qeq (to_Q (add (Qq nx dx) (Qz y)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qq nx dx))) (Zpos (Qden (to_Q (Qz y)))))\n        (Z.mul (Qnum (to_Q (Qz y))) (Zpos (Qden (to_Q (Qq nx dx)))));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qz y)))\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c9_goal : Qeq (to_Q (add (Qq nx dx) (Qz y)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qq nx dx))) (Zpos (Qden (to_Q (Qz y)))))\n        (Z.mul (Qnum (to_Q (Qz y))) (Zpos (Qden (to_Q (Qq nx dx)))));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qz y)))\n  |}"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq 0%Z (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))",
                    "c10_H : Z.lt 0 (NN.to_Z dx)",
                    "c10_e : Logic.eq (NN.to_Z dx) 0%Z",
                    "c11_goal : Logic.eq\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))",
                    "c11_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c11_H : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c10_goal : Logic.eq 0%Z (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (add (Qq nx dx) (Qq ny dy)))\n  (Qplus (to_Q (Qq nx dx)) (to_Q (Qq ny dy)))",
                    "_global_Qplus : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c12_goal : Qeq (to_Q (add (Qq nx dx) (Qq ny dy)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qq nx dx))) (Zpos (Qden (to_Q (Qq ny dy)))))\n        (Z.mul (Qnum (to_Q (Qq ny dy))) (Zpos (Qden (to_Q (Qq nx dx)))));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q (add (Qq nx dx) (Qq ny dy)))\n  {|\n    Qnum :=\n      Z.add\n        (Z.mul (Qnum (to_Q (Qq nx dx))) (Zpos (Qden (to_Q (Qq ny dy)))))\n        (Z.mul (Qnum (to_Q (Qq ny dy))) (Zpos (Qden (to_Q (Qq nx dx)))));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq 0%Z (ZZ.to_Z nx)",
                    "c13_H : Z.lt 0 (NN.to_Z dx)",
                    "c13_e0 : Logic.eq (NN.to_Z dy) 0%Z",
                    "c13_e : Logic.eq (NN.to_Z dx) 0%Z",
                    "c14_goal : Logic.eq\n  (Z.mul (ZZ.to_Z nx)\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))",
                    "c14_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c14_e : Logic.eq (NN.to_Z dy) 0%Z",
                    "c14_H : Z.lt 0 (NN.to_Z dx)",
                    "c15_goal : Logic.eq 0%Z\n  (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n     (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))",
                    "c15_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c15_H : Z.lt 0 (NN.to_Z dy)",
                    "c15_e : Logic.eq (Z.mul (NN.to_Z dx) (NN.to_Z dy)) 0%Z",
                    "c16_goal : Logic.eq\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) (Z.to_pos (NN.to_Z dy)))))\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c16_H1 : Z.lt 0 (NN.to_Z dx)",
                    "c16_H0 : Z.lt 0 (NN.to_Z dy)",
                    "c16_H : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c13_goal : Logic.eq 0%Z (ZZ.to_Z nx)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c15_goal : Logic.eq 0%Z\n  (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n     (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))",
                    "_global_Pos.mul_1_r : forall p : positive, Logic.eq (Pos.mul p 1) p",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))",
                    "c18_goal : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.eq\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))\n  (Z.mul (Z.add (ZZ.to_Z nx) (Z.mul (ZZ.to_Z y) (NN.to_Z dx)))\n     (NN.to_Z dx))",
                    "c4_y : ZZ.t",
                    "c4_dx : NN.t",
                    "c4_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Z.lt 0 (NN.to_Z dx)",
                    "c4_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (Z.mul (ZZ.to_Z nx)\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))",
                    "_global_Pos.mul_1_r : forall p : positive, Logic.eq (Pos.mul p 1) p",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))\n  (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))",
                    "c20_goal : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))\n  (Z.mul (ZZ.to_Z nx) (NN.to_Z dx))",
                    "c5_dx : NN.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Z.lt 0 (NN.to_Z dx)",
                    "c5_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) (Z.to_pos (NN.to_Z dy)))))\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "_global_Pos2Z.inj_mul : forall p q : positive,\n       Logic.eq (Zpos (Pos.mul p q)) (Z.mul (Zpos p) (Zpos q))",
                    "_global_2 : Q",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c22_goal : Z.lt 0 (NN.to_Z dy)",
                    "c23_goal : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Logic.eq\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul\n     (Z.add (Z.mul (ZZ.to_Z nx) (NN.to_Z dy))\n        (Z.mul (ZZ.to_Z ny) (NN.to_Z dx)))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c5_dy : NN.t",
                    "c5_ny : ZZ.t",
                    "c5_dx : NN.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Z.lt 0 (NN.to_Z dy)",
                    "c16_H0 : Z.lt 0 (NN.to_Z dy)",
                    "c5_dy : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Z.lt 0 (NN.to_Z dx)",
                    "c16_H1 : Z.lt 0 (NN.to_Z dx)",
                    "c5_dx : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add_norm : forall x y , [ add_norm x y ] = = [ x ] + [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_add_norm : forall x y , [ add_norm x y ] = = [ x ] + [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_spec_add : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (add_norm x y)) (to_Q (add x y))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (add_norm x y)) (to_Q (add x y))",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q (add_norm (Qz t0) y)) (to_Q (add (Qz t0) y))",
                    "c4_t0 : ZZ.t",
                    "c5_goal : Qeq (to_Q (add_norm (Qq t0 t1) y)) (to_Q (add (Qq t0 t1) y))",
                    "c5_t1 : NN.t",
                    "c5_t0 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (add_norm (Qz t0) y)) (to_Q (add (Qz t0) y))",
                    "c2_y : True",
                    "c4_t0 : ZZ.t"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (to_Q (add_norm (Qz t0) (Qz t1))) (to_Q (add (Qz t0) (Qz t1)))",
                    "c6_t1 : ZZ.t",
                    "c7_goal : Qeq (to_Q (add_norm (Qz t0) (Qq t1 t2)))\n  (to_Q (add (Qz t0) (Qq t1 t2)))",
                    "c7_t2 : NN.t",
                    "c7_t1 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q (add_norm (Qz t0) (Qz t1))) (to_Q (add (Qz t0) (Qz t1)))",
                    "_global_add_norm : forall (_ : t) (_ : t), t",
                    "_global_add : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c8_goal : Qeq (to_Q (Qz (ZZ.add t0 t1))) (to_Q (Qz (ZZ.add t0 t1)))"
                ]
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q (Qz (ZZ.add t0 t1))) (to_Q (Qz (ZZ.add t0 t1)))",
                    "c4_t0 : ZZ.t",
                    "c6_t1 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (add_norm (Qz t0) (Qq t1 t2)))\n  (to_Q (add (Qz t0) (Qq t1 t2)))",
                    "_global_add_norm : forall (_ : t) (_ : t), t",
                    "_global_add : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c9_goal : Qeq\n  (to_Q\n     (if NN.eqb t2 NN.zero\n      then Qz t0\n      else norm (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))\n  (to_Q\n     (if NN.eqb t2 NN.zero\n      then Qz t0\n      else Qq (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c9_goal : Qeq\n  (to_Q\n     (if NN.eqb t2 NN.zero\n      then Qz t0\n      else norm (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))\n  (to_Q\n     (if NN.eqb t2 NN.zero\n      then Qz t0\n      else Qq (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Logic.eq (NN.to_Z t2) (NN.to_Z NN.zero),\nQeq (to_Q (Qz t0)) (to_Q (Qz t0))",
                    "c11_goal : forall _ : Z.lt 0 (NN.to_Z t2),\nQeq (to_Q (norm (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))\n  (to_Q (Qq (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))"
                ]
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c10_goal : forall _ : Logic.eq (NN.to_Z t2) (NN.to_Z NN.zero),\nQeq (to_Q (Qz t0)) (to_Q (Qz t0))",
                    "c7_t2 : NN.t",
                    "c4_t0 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt 0 (NN.to_Z t2),\nQeq (to_Q (norm (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))\n  (to_Q (Qq (ZZ.add (ZZ.mul t0 (Z_of_N t2)) t1) t2))",
                    "c7_t2 : NN.t",
                    "c4_t0 : ZZ.t",
                    "c7_t1 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (add_norm (Qq t0 t1) y)) (to_Q (add (Qq t0 t1) y))",
                    "c2_y : True",
                    "c5_t1 : NN.t",
                    "c5_t0 : ZZ.t"
                ],
                "tactic_res": [
                    "c12_goal : Qeq (to_Q (add_norm (Qq t0 t1) (Qz t2)))\n  (to_Q (add (Qq t0 t1) (Qz t2)))",
                    "c12_t2 : ZZ.t",
                    "c13_goal : Qeq (to_Q (add_norm (Qq t0 t1) (Qq t2 t3)))\n  (to_Q (add (Qq t0 t1) (Qq t2 t3)))",
                    "c13_t3 : NN.t",
                    "c13_t2 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q (add_norm (Qq t0 t1) (Qz t2)))\n  (to_Q (add (Qq t0 t1) (Qz t2)))",
                    "_global_add_norm : forall (_ : t) (_ : t), t",
                    "_global_add : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c14_goal : Qeq\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qz t2\n      else norm (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qz t2\n      else Qq (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c14_goal : Qeq\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qz t2\n      else norm (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qz t2\n      else Qq (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z t1) (NN.to_Z NN.zero),\nQeq (to_Q (Qz t2)) (to_Q (Qz t2))",
                    "c16_goal : forall _ : Z.lt 0 (NN.to_Z t1),\nQeq (to_Q (norm (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))\n  (to_Q (Qq (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))"
                ]
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z t1) (NN.to_Z NN.zero),\nQeq (to_Q (Qz t2)) (to_Q (Qz t2))",
                    "c12_t2 : ZZ.t",
                    "c5_t1 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c16_goal : forall _ : Z.lt 0 (NN.to_Z t1),\nQeq (to_Q (norm (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))\n  (to_Q (Qq (ZZ.add t0 (ZZ.mul t2 (Z_of_N t1))) t1))",
                    "c12_t2 : ZZ.t",
                    "c5_t1 : NN.t",
                    "c5_t0 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c13_goal : Qeq (to_Q (add_norm (Qq t0 t1) (Qq t2 t3)))\n  (to_Q (add (Qq t0 t1) (Qq t2 t3)))",
                    "_global_add_norm : forall (_ : t) (_ : t), t",
                    "_global_add : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c17_goal : Qeq\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qq t2 t3\n      else\n       if NN.eqb t3 NN.zero\n       then Qq t0 t1\n       else\n        norm (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n          (NN.mul t1 t3)))\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qq t2 t3\n      else\n       if NN.eqb t3 NN.zero\n       then Qq t0 t1\n       else\n        Qq (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n          (NN.mul t1 t3)))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c17_goal : Qeq\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qq t2 t3\n      else\n       if NN.eqb t3 NN.zero\n       then Qq t0 t1\n       else\n        norm (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n          (NN.mul t1 t3)))\n  (to_Q\n     (if NN.eqb t1 NN.zero\n      then Qq t2 t3\n      else\n       if NN.eqb t3 NN.zero\n       then Qq t0 t1\n       else\n        Qq (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n          (NN.mul t1 t3)))"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z t1) (NN.to_Z NN.zero),\nQeq (to_Q (Qq t2 t3)) (to_Q (Qq t2 t3))",
                    "c19_goal : forall (_ : Logic.eq (NN.to_Z t3) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z t1)), Qeq (to_Q (Qq t0 t1)) (to_Q (Qq t0 t1))",
                    "c20_goal : forall (_ : Z.lt 0 (NN.to_Z t3)) (_ : Z.lt 0 (NN.to_Z t1)),\nQeq\n  (to_Q\n     (norm (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n        (NN.mul t1 t3)))\n  (to_Q\n     (Qq (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n        (NN.mul t1 t3)))"
                ]
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z t1) (NN.to_Z NN.zero),\nQeq (to_Q (Qq t2 t3)) (to_Q (Qq t2 t3))",
                    "c13_t3 : NN.t",
                    "c13_t2 : ZZ.t",
                    "c5_t1 : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c19_goal : forall (_ : Logic.eq (NN.to_Z t3) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z t1)), Qeq (to_Q (Qq t0 t1)) (to_Q (Qq t0 t1))",
                    "c13_t3 : NN.t",
                    "c5_t1 : NN.t",
                    "c5_t0 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using Qeq_refl , spec_norm .",
                "tactic_sig_no_out_arg": "auto using Qeq_refl , spec_norm .",
                "tactic_args": [
                    "c20_goal : forall (_ : Z.lt 0 (NN.to_Z t3)) (_ : Z.lt 0 (NN.to_Z t1)),\nQeq\n  (to_Q\n     (norm (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n        (NN.mul t1 t3)))\n  (to_Q\n     (Qq (ZZ.add (ZZ.mul t0 (Z_of_N t3)) (ZZ.mul t2 (Z_of_N t1)))\n        (NN.mul t1 t3)))",
                    "c13_t3 : NN.t",
                    "c13_t2 : ZZ.t",
                    "c5_t1 : NN.t",
                    "c5_t0 : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_add_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_add_norm x y ` ( Reduced x , Reduced y ) : Reduced ( add_norm x y ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_add_norm x y ` ( Reduced x , Reduced y ) : Reduced ( add_norm x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (add_norm x y)",
                    "c1_H0 : Reduced y",
                    "c1_H : Reduced x",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Reduced (add_norm x y)",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (red (add_norm x y))) (to_Q (add_norm x y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (red (add_norm x y))) (to_Q (add_norm x y))",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qred (to_Q (add_norm x y))) (to_Q (add_norm x y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i [ _i _i _i ] ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i [ _i _i _i ] ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qred (to_Q (add_norm x y))) (to_Q (add_norm x y))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "_global_add : forall (_ : t) (_ : t), t",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (add x y))) (to_Q (add_norm x y))",
                    "c5_goal : Qeq (to_Q (add x y)) (to_Q (add_norm x y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (add x y))) (to_Q (add_norm x y))",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Q (red (add x y))) (to_Q (add_norm x y))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ zx|nx dx ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zx|nx dx ] .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Q (red (add x y))) (to_Q (add_norm x y))",
                    "c1_x : True",
                    "c1_H0 : Reduced y",
                    "c1_H : Reduced x",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (to_Q (red (add (Qz zx) y))) (to_Q (add_norm (Qz zx) y))",
                    "c7_H : Reduced (Qz zx)",
                    "c7_zx : ZZ.t",
                    "c8_goal : Logic.eq (to_Q (red (add (Qq nx dx) y))) (to_Q (add_norm (Qq nx dx) y))",
                    "c8_H : Reduced (Qq nx dx)",
                    "c8_dx : NN.t",
                    "c8_nx : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ zy|ny dy ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zy|ny dy ] .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Q (red (add (Qz zx) y))) (to_Q (add_norm (Qz zx) y))",
                    "c1_y : True",
                    "c1_H0 : Reduced y",
                    "c7_H : Reduced (Qz zx)",
                    "c7_zx : ZZ.t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Q (red (add (Qz zx) (Qz zy))))\n  (to_Q (add_norm (Qz zx) (Qz zy)))",
                    "c9_H0 : Reduced (Qz zy)",
                    "c9_zy : ZZ.t",
                    "c10_goal : Logic.eq (to_Q (red (add (Qz zx) (Qq ny dy))))\n  (to_Q (add_norm (Qz zx) (Qq ny dy)))",
                    "c10_H0 : Reduced (Qq ny dy)",
                    "c10_dy : NN.t",
                    "c10_ny : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Q (red (add (Qz zx) (Qz zy))))\n  (to_Q (add_norm (Qz zx) (Qz zy)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.add zx zy); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.add zx zy); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.add zx zy); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.add zx zy); Qden := 1 |}"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq {| Qnum := Z.add (ZZ.to_Z zx) (ZZ.to_Z zy); Qden := 1 |}\n  {| Qnum := Z.add (ZZ.to_Z zx) (ZZ.to_Z zy); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Logic.eq {| Qnum := Z.add (ZZ.to_Z zx) (ZZ.to_Z zy); Qden := 1 |}\n  {| Qnum := Z.add (ZZ.to_Z zx) (ZZ.to_Z zy); Qden := 1 |}",
                    "c7_zx : ZZ.t",
                    "c9_zy : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Q (red (add (Qz zx) (Qq ny dy))))\n  (to_Q (add_norm (Qz zx) (Qq ny dy)))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dy NN.zero\n         then Qz zx\n         else Qq (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy)))\n  (to_Q\n     (if NN.eqb dy NN.zero\n      then Qz zx\n      else norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dy NN.zero\n         then Qz zx\n         else Qq (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy)))\n  (to_Q\n     (if NN.eqb dy NN.zero\n      then Qz zx\n      else norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))",
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z dy),\nLogic.eq (to_Q (red (Qq (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy)))\n  (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z dy) 0%Z,\nLogic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z dy) 0%Z,\nLogic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : Logic.eq (NN.to_Z dy) 0%Z,\nLogic.eq {| Qnum := ZZ.to_Z zx; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zx; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : forall _ : Logic.eq (NN.to_Z dy) 0%Z,\nLogic.eq {| Qnum := ZZ.to_Z zx; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zx; Qden := 1 |}",
                    "c10_dy : NN.t",
                    "c7_zx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z dy),\nLogic.eq (to_Q (red (Qq (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy)))\n  (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Z.lt 0 (NN.to_Z dy),\nLogic.eq (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))\n  (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : forall _ : Z.lt 0 (NN.to_Z dy),\nLogic.eq (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))\n  (to_Q (norm (ZZ.add (ZZ.mul zx (Z_of_N dy)) ny) dy))",
                    "c10_dy : NN.t",
                    "c7_zx : ZZ.t",
                    "c10_ny : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ zy|ny dy ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zy|ny dy ] .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Q (red (add (Qq nx dx) y))) (to_Q (add_norm (Qq nx dx) y))",
                    "c1_y : True",
                    "c1_H0 : Reduced y",
                    "c8_H : Reduced (Qq nx dx)",
                    "c8_dx : NN.t",
                    "c8_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (to_Q (red (add (Qq nx dx) (Qz zy))))\n  (to_Q (add_norm (Qq nx dx) (Qz zy)))",
                    "c19_H0 : Reduced (Qz zy)",
                    "c19_zy : ZZ.t",
                    "c20_goal : Logic.eq (to_Q (red (add (Qq nx dx) (Qq ny dy))))\n  (to_Q (add_norm (Qq nx dx) (Qq ny dy)))",
                    "c20_H0 : Reduced (Qq ny dy)",
                    "c20_dy : NN.t",
                    "c20_ny : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c19_goal : Logic.eq (to_Q (red (add (Qq nx dx) (Qz zy))))\n  (to_Q (add_norm (Qq nx dx) (Qz zy)))"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dx NN.zero\n         then Qz zy\n         else Qq (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx)))\n  (to_Q\n     (if NN.eqb dx NN.zero\n      then Qz zy\n      else norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c21_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dx NN.zero\n         then Qz zy\n         else Qq (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx)))\n  (to_Q\n     (if NN.eqb dx NN.zero\n      then Qz zy\n      else norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))",
                    "c23_goal : forall _ : Z.lt 0 (NN.to_Z dx),\nLogic.eq (to_Q (red (Qq (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx)))\n  (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c22_goal : forall _ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c24_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq {| Qnum := ZZ.to_Z zy; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zy; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq {| Qnum := ZZ.to_Z zy; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zy; Qden := 1 |}",
                    "c19_zy : ZZ.t",
                    "c8_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : forall _ : Z.lt 0 (NN.to_Z dx),\nLogic.eq (to_Q (red (Qq (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx)))\n  (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))"
                ],
                "tactic_res": [
                    "c26_goal : forall _ : Z.lt 0 (NN.to_Z dx),\nLogic.eq (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))\n  (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : forall _ : Z.lt 0 (NN.to_Z dx),\nLogic.eq (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))\n  (to_Q (norm (ZZ.add nx (ZZ.mul zy (Z_of_N dx))) dx))",
                    "c19_zy : ZZ.t",
                    "c8_dx : NN.t",
                    "c8_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c20_goal : Logic.eq (to_Q (red (add (Qq nx dx) (Qq ny dy))))\n  (to_Q (add_norm (Qq nx dx) (Qq ny dy)))"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dx NN.zero\n         then Qq ny dy\n         else\n          if NN.eqb dy NN.zero\n          then Qq nx dx\n          else\n           Qq (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n             (NN.mul dx dy))))\n  (to_Q\n     (if NN.eqb dx NN.zero\n      then Qq ny dy\n      else\n       if NN.eqb dy NN.zero\n       then Qq nx dx\n       else\n        norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n          (NN.mul dx dy)))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c27_goal : Logic.eq\n  (to_Q\n     (red\n        (if NN.eqb dx NN.zero\n         then Qq ny dy\n         else\n          if NN.eqb dy NN.zero\n          then Qq nx dx\n          else\n           Qq (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n             (NN.mul dx dy))))\n  (to_Q\n     (if NN.eqb dx NN.zero\n      then Qq ny dy\n      else\n       if NN.eqb dy NN.zero\n       then Qq nx dx\n       else\n        norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n          (NN.mul dx dy)))"
                ],
                "tactic_res": [
                    "c28_goal : forall _ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c29_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c30_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq\n  (to_Q\n     (red\n        (Qq (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n           (NN.mul dx dy))))\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c28_goal : forall _ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero),\nLogic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c31_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))"
                ],
                "tactic_res": [
                    "c32_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (norm ny dy))\n  (if NN.eqb dy NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : forall _ : Logic.eq (NN.to_Z dx) 0%Z,\nLogic.eq (to_Q (norm ny dy))\n  (if NN.eqb dy NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})",
                    "c20_H0 : Reduced (Qq ny dy)",
                    "c20_dy : NN.t",
                    "c20_ny : ZZ.t",
                    "c8_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c29_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))"
                ],
                "tactic_res": [
                    "c33_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c33_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))"
                ],
                "tactic_res": [
                    "c34_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (norm nx dx))\n  (if NN.eqb dx NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq (to_Q (norm nx dx))\n  (if NN.eqb dx NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})",
                    "c8_H : Reduced (Qq nx dx)",
                    "c20_dy : NN.t",
                    "c8_dx : NN.t",
                    "c8_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq\n  (to_Q\n     (red\n        (Qq (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n           (NN.mul dx dy))))\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))"
                ],
                "tactic_res": [
                    "c35_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx)),\nLogic.eq\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))\n  (to_Q\n     (norm (ZZ.add (ZZ.mul nx (Z_of_N dy)) (ZZ.mul ny (Z_of_N dx)))\n        (NN.mul dx dy)))",
                    "c20_dy : NN.t",
                    "c20_ny : ZZ.t",
                    "c8_dx : NN.t",
                    "c8_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (add x y)) (to_Q (add_norm x y))",
                    "_global_spec_add : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_spec_add_norm : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c36_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_opp",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_opp : forall q , [ opp q ] = - [ q ] .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_opp : forall q , [ opp q ] = - [ q ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : t, Logic.eq (to_Q (opp q)) (Qopp (to_Q q))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ z | x y ] .",
                "tactic_args": [
                    "c1_goal : forall q : t, Logic.eq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (opp (Qz z))) (Qopp (to_Q (Qz z)))",
                    "c3_x : ZZ.t",
                    "c3_y : NN.t",
                    "c3_goal : Logic.eq (to_Q (opp (Qq x y))) (Qopp (to_Q (Qq x y)))",
                    "c2_z : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (opp (Qz z))) (Qopp (to_Q (Qz z)))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp z); Qden := 1 |}\n  (Qopp {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (opp (Qq x y))) (Qopp (to_Q (Qq x y)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp z); Qden := 1 |}\n  (Qopp {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "_global_ZZ.spec_opp : forall x : ZZ.t, Logic.eq (ZZ.to_Z (ZZ.opp x)) (Z.opp (ZZ.to_Z x))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq {| Qnum := Z.opp (ZZ.to_Z z); Qden := 1 |}\n  (Qopp {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.eq {| Qnum := Z.opp (ZZ.to_Z z); Qden := 1 |}\n  (Qopp {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_sig_no_out_arg": "strong_spec_opp_tac .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                    "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                    "c3_y : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})",
                    "_global_ZZ.spec_opp : forall x : ZZ.t, Logic.eq (ZZ.to_Z (ZZ.opp x)) (Z.opp (ZZ.to_Z x))"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := Z.opp (ZZ.to_Z x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := Z.opp (ZZ.to_Z x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})",
                    "c3_y : NN.t",
                    "c3_x : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_opp",
        "proof": [
            {
                "tactic_sig": "Theorem spec_opp : forall q , [ opp q ] = = - [ q ] .",
                "tactic_sig_no_out_arg": "Theorem spec_opp : forall q , [ opp q ] = = - [ q ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (opp q)) (Qopp (to_Q q))",
                    "c2_q : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (opp q)) (Qopp (to_Q q))",
                    "_global_strong_spec_opp : forall q : t, Logic.eq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (Qopp (to_Q q)) (Qopp (to_Q q))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : Qeq (Qopp (to_Q q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.mul (Qnum (Qopp (to_Q q))) (Zpos (Qden (Qopp (to_Q q)))))\n  (Z.mul (Qnum (Qopp (to_Q q))) (Zpos (Qden (Qopp (to_Q q)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.mul (Qnum (Qopp (to_Q q))) (Zpos (Qden (Qopp (to_Q q)))))\n  (Z.mul (Qnum (Qopp (to_Q q))) (Zpos (Qden (Qopp (to_Q q)))))",
                    "c2_q : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_opp_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_opp_norm q ` ( Reduced q ) : Reduced ( opp q ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_opp_norm q ` ( Reduced q ) : Reduced ( opp q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (opp q)",
                    "c1_H : Reduced q",
                    "c1_q : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Reduced (opp q)",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (red (opp q))) (to_Q (opp q))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i , !strong_spec_red , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i , !strong_spec_red , <- _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (red (opp q))) (to_Q (opp q))",
                    "_global_strong_spec_opp : forall q : t, Logic.eq (to_Q (opp q)) (Qopp (to_Q q))",
                    "c1_H : Reduced q",
                    "_global_Qred_opp : forall q : Q, Logic.eq (Qred (Qopp q)) (Qopp (Qred q))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qred (to_Q (opp q))) (Qred (Qopp (to_Q q)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qred (to_Q (opp q))) (Qred (Qopp (to_Q q)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (opp q)) (Qopp (to_Q q))",
                    "_global_spec_opp : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub : forall x y , [ sub x y ] = = [ x ] - [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_sub : forall x y , [ sub x y ] = = [ x ] - [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (sub x y)) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (sub x y)) (Qminus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (sub x y)) (Qminus (to_Q x) (to_Q y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (sub x y)) (Qminus (to_Q x) (to_Q y))",
                    "_global_sub : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (add x (opp y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (add x (opp y))) (Qminus (to_Q x) (to_Q y))",
                    "_global_spec_add : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (Qplus (to_Q x) (to_Q (opp y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Qeq (Qplus (to_Q x) (to_Q (opp y))) (Qminus (to_Q x) (to_Q y))",
                    "_global_spec_opp : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (Qplus (to_Q x) (Qopp (to_Q y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c5_goal : Qeq (Qplus (to_Q x) (Qopp (to_Q y))) (Qminus (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub_norm : forall x y , [ sub_norm x y ] = = [ x ] - [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_sub_norm : forall x y , [ sub_norm x y ] = = [ x ] - [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (sub_norm x y)) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (sub_norm x y)) (Qminus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (sub_norm x y)) (Qminus (to_Q x) (to_Q y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (sub_norm x y)) (Qminus (to_Q x) (to_Q y))",
                    "_global_sub_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (add_norm x (opp y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (add_norm x (opp y))) (Qminus (to_Q x) (to_Q y))",
                    "_global_spec_add_norm : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (Qplus (to_Q x) (to_Q (opp y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Qeq (Qplus (to_Q x) (to_Q (opp y))) (Qminus (to_Q x) (to_Q y))",
                    "_global_spec_opp : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (Qplus (to_Q x) (Qopp (to_Q y))) (Qminus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c5_goal : Qeq (Qplus (to_Q x) (Qopp (to_Q y))) (Qminus (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_sub_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_sub_norm x y ` ( Reduced x , Reduced y ) : Reduced ( sub_norm x y ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_sub_norm x y ` ( Reduced x , Reduced y ) : Reduced ( sub_norm x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (sub_norm x y)",
                    "c1_H0 : Reduced y",
                    "c1_H : Reduced x",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Reduced (sub_norm x y)",
                    "_global_sub_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Reduced (add_norm x (opp y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Reduced (add_norm x (opp y))",
                    "_global_strong_spec_add_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (add_norm x y)"
                ],
                "tactic_res": [
                    "c3_goal : Reduced x",
                    "c4_goal : Reduced (opp y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Reduced x",
                    "c1_H : Reduced x",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Reduced (opp y)",
                    "_global_strong_spec_opp_norm : forall (q : t) (_ : Reduced q), Reduced (opp q)"
                ],
                "tactic_res": [
                    "c5_goal : Reduced y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Reduced y",
                    "c1_H0 : Reduced y",
                    "c1_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul : forall x y , [ mul x y ] = = [ x ] * [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mul : forall x y , [ mul x y ] = = [ x ] * [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o _o ] [ _o | _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ x | nx dx ] [ y | ny dy ] .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (mul (Qz x) (Qz y))) (Qmult (to_Q (Qz x)) (to_Q (Qz y)))",
                    "c5_nx : ZZ.t",
                    "c5_dx : NN.t",
                    "c5_ny : ZZ.t",
                    "c5_dy : NN.t",
                    "c5_goal : Qeq (to_Q (mul (Qq nx dx) (Qq ny dy)))\n  (Qmult (to_Q (Qq nx dx)) (to_Q (Qq ny dy)))",
                    "c4_nx : ZZ.t",
                    "c4_dx : NN.t",
                    "c4_y : ZZ.t",
                    "c4_goal : Qeq (to_Q (mul (Qq nx dx) (Qz y)))\n  (Qmult (to_Q (Qq nx dx)) (to_Q (Qz y)))",
                    "c3_x : ZZ.t",
                    "c3_ny : ZZ.t",
                    "c3_dy : NN.t",
                    "c3_goal : Qeq (to_Q (mul (Qz x) (Qq ny dy)))\n  (Qmult (to_Q (Qz x)) (to_Q (Qq ny dy)))",
                    "c2_x : ZZ.t",
                    "c2_y : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (mul (Qz x) (Qz y))) (Qmult (to_Q (Qz x)) (to_Q (Qz y)))",
                    "_global_Qmult : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (to_Q (mul (Qz x) (Qz y)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qz x))) (Qnum (to_Q (Qz y)));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qz y)))\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q (mul (Qz x) (Qz y)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qz x))) (Qnum (to_Q (Qz y)));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qz y)))\n  |}"
                ],
                "tactic_res": [
                    "c7_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.mul x y); Qden := 1 |}\n  {| Qnum := Z.mul (ZZ.to_Z x) (ZZ.to_Z y); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c7_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.mul x y); Qden := 1 |}\n  {| Qnum := Z.mul (ZZ.to_Z x) (ZZ.to_Z y); Qden := 1 |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (mul (Qz x) (Qq ny dy)))\n  (Qmult (to_Q (Qz x)) (to_Q (Qq ny dy)))",
                    "_global_Qmult : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c8_goal : Qeq (to_Q (mul (Qz x) (Qq ny dy)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qz x))) (Qnum (to_Q (Qq ny dy)));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q (mul (Qz x) (Qq ny dy)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qz x))) (Qnum (to_Q (Qq ny dy)));\n    Qden := Pos.mul (Qden (to_Q (Qz x))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ],
                "tactic_res": [
                    "c9_goal : Qeq\n  (if NN.eqb dy NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z (ZZ.mul x ny); Qden := Z.to_pos (NN.to_Z dy) |})\n  {|\n    Qnum :=\n      Z.mul (ZZ.to_Z x)\n        (Qnum\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}));\n    Qden :=\n      Qden\n        (if NN.eqb dy NN.zero\n         then 0\n         else {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c9_goal : Qeq\n  (if NN.eqb dy NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z (ZZ.mul x ny); Qden := Z.to_pos (NN.to_Z dy) |})\n  {|\n    Qnum :=\n      Z.mul (ZZ.to_Z x)\n        (Qnum\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}));\n    Qden :=\n      Qden\n        (if NN.eqb dy NN.zero\n         then 0\n         else {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n  |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (mul (Qq nx dx) (Qz y)))\n  (Qmult (to_Q (Qq nx dx)) (to_Q (Qz y)))",
                    "_global_Qmult : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (to_Q (mul (Qq nx dx) (Qz y)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qq nx dx))) (Qnum (to_Q (Qz y)));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qz y)))\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Qeq (to_Q (mul (Qq nx dx) (Qz y)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qq nx dx))) (Qnum (to_Q (Qz y)));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qz y)))\n  |}"
                ],
                "tactic_res": [
                    "c11_goal : Qeq\n  (if NN.eqb dx NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z (ZZ.mul nx y); Qden := Z.to_pos (NN.to_Z dx) |})\n  {|\n    Qnum :=\n      Z.mul\n        (Qnum\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (ZZ.to_Z y);\n    Qden :=\n      Pos.mul\n        (Qden\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        1%positive\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c11_goal : Qeq\n  (if NN.eqb dx NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z (ZZ.mul nx y); Qden := Z.to_pos (NN.to_Z dx) |})\n  {|\n    Qnum :=\n      Z.mul\n        (Qnum\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (ZZ.to_Z y);\n    Qden :=\n      Pos.mul\n        (Qden\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        1%positive\n  |}"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))",
                    "c12_H : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (mul (Qq nx dx) (Qq ny dy)))\n  (Qmult (to_Q (Qq nx dx)) (to_Q (Qq ny dy)))",
                    "_global_Qmult : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c13_goal : Qeq (to_Q (mul (Qq nx dx) (Qq ny dy)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qq nx dx))) (Qnum (to_Q (Qq ny dy)));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Qeq (to_Q (mul (Qq nx dx) (Qq ny dy)))\n  {|\n    Qnum := Z.mul (Qnum (to_Q (Qq nx dx))) (Qnum (to_Q (Qq ny dy)));\n    Qden := Pos.mul (Qden (to_Q (Qq nx dx))) (Qden (to_Q (Qq ny dy)))\n  |}"
                ],
                "tactic_res": [
                    "c14_goal : Qeq\n  (if NN.eqb (NN.mul dx dy) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.mul nx ny);\n      Qden := Z.to_pos (NN.to_Z (NN.mul dx dy))\n    |})\n  {|\n    Qnum :=\n      Z.mul\n        (Qnum\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (Qnum\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}));\n    Qden :=\n      Pos.mul\n        (Qden\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (Qden\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}))\n  |}"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c14_goal : Qeq\n  (if NN.eqb (NN.mul dx dy) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.mul nx ny);\n      Qden := Z.to_pos (NN.to_Z (NN.mul dx dy))\n    |})\n  {|\n    Qnum :=\n      Z.mul\n        (Qnum\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (Qnum\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}));\n    Qden :=\n      Pos.mul\n        (Qden\n           (if NN.eqb dx NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |}))\n        (Qden\n           (if NN.eqb dy NN.zero\n            then 0\n            else\n             {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |}))\n  |}"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c15_e : Logic.eq (Z.mul (NN.to_Z dx) (NN.to_Z dy)) 0%Z",
                    "c15_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c15_H : Z.lt 0 (NN.to_Z dy)",
                    "c16_goal : Logic.eq (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny)) 0%Z",
                    "c16_H : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))",
                    "c16_e0 : Logic.eq (NN.to_Z dx) 0%Z",
                    "c16_e : Logic.eq (NN.to_Z dy) 0%Z",
                    "c17_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny)) (NN.to_Z dy)) 0%Z",
                    "c17_H0 : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))",
                    "c17_e : Logic.eq (NN.to_Z dx) 0%Z",
                    "c17_H : Z.lt 0 (NN.to_Z dy)",
                    "c18_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive))) 0%Z",
                    "c18_H0 : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))",
                    "c18_H : Z.lt 0 (NN.to_Z dx)",
                    "c18_e : Logic.eq (NN.to_Z dy) 0%Z",
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) (Z.to_pos (NN.to_Z dy)))))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c19_H1 : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))",
                    "c19_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c19_H : Z.lt 0 (NN.to_Z dy)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))",
                    "_global_Pos.mul_1_r : forall p : positive, Logic.eq (Pos.mul p 1) p",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))",
                    "c21_goal : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z y)) (NN.to_Z dx))",
                    "c4_y : ZZ.t",
                    "c4_dx : NN.t",
                    "c4_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Z.lt 0 (NN.to_Z dx)",
                    "c12_H : Z.lt 0 (NN.to_Z dx)",
                    "c4_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_Z.mul_eq_0 : forall n m : Z,\n       iff (Logic.eq (Z.mul n m) 0%Z) (or (Logic.eq n 0%Z) (Logic.eq m 0%Z))"
                ],
                "tactic_res": [
                    "c15_e : or (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z dy) 0%Z)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c15_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c15_e : or (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z dy) 0%Z)",
                    "c15_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c15_H : Z.lt 0 (NN.to_Z dy)",
                    "c5_ny : ZZ.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny)) 0%Z",
                    "c16_H : Z.lt 0 (Z.mul 0%Z (NN.to_Z dy))",
                    "c5_ny : ZZ.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny)) (NN.to_Z dy)) 0%Z",
                    "c17_H0 : Z.lt 0 (Z.mul 0%Z (NN.to_Z dy))",
                    "c5_dy : NN.t",
                    "c5_ny : ZZ.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) 1%positive))) 0%Z",
                    "c18_H0 : Z.lt 0 0",
                    "c5_ny : ZZ.t",
                    "c5_dx : NN.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z dx)) (Z.to_pos (NN.to_Z dy)))))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "_global_Pos2Z.inj_mul : forall p q : positive,\n       Logic.eq (Zpos (Pos.mul p q)) (Z.mul (Zpos p) (Zpos q))",
                    "_global_2 : Q",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c23_goal : Z.lt 0 (NN.to_Z dy)",
                    "c24_goal : Z.lt 0 (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))",
                    "c5_dy : NN.t",
                    "c5_ny : ZZ.t",
                    "c5_dx : NN.t",
                    "c5_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Z.lt 0 (NN.to_Z dy)",
                    "c19_H : Z.lt 0 (NN.to_Z dy)",
                    "c5_dy : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Z.lt 0 (NN.to_Z dx)",
                    "c19_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c5_dx : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_norm_denum",
        "proof": [
            {
                "tactic_sig": "Lemma spec_norm_denum : forall n d , [ norm_denum n d ] = = [ Qq n d ] .",
                "tactic_sig_no_out_arg": "Lemma spec_norm_denum : forall n d , [ norm_denum n d ] = = [ Qq n d ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ]
            },
            {
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_sig_no_out_arg": "custom82 norm_denum n d .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "custom81 .",
                "tactic_sig_no_out_arg": "custom81 .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                    "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                    "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "nsubst .",
                "tactic_sig_no_out_arg": "nsubst .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.mul (ZZ.to_Z n) 1%Z) (ZZ.to_Z n)",
                    "c5_H : Z.lt 0 1"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.mul (ZZ.to_Z n) 1%Z) (ZZ.to_Z n)",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_irred",
        "proof": [
            {
                "tactic_sig": "Lemma spec_irred : forall n d , exists g , let ( n' , d' ) := irred n d in ( ZZ.to_Z n' * g = ZZ.to_Z n ) % Z /\\ ( NN.to_Z d' * g = NN.to_Z d ) % Z .",
                "tactic_sig_no_out_arg": "Lemma spec_irred : forall n d , exists g , let ( n' , d' ) := irred n d in ( ZZ.to_Z n' * g = ZZ.to_Z n ) % Z /\\ ( NN.to_Z d' * g = NN.to_Z d ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nex\n  (fun g : Z =>\n   let (n', d') := irred n d in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\nex\n  (fun g : Z =>\n   let (n', d') := irred n d in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun g : Z =>\n   let (n', d') := irred n d in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun g : Z =>\n   let (n', d') := irred n d in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))",
                    "_global_irred : forall (_ : ZZ.t) (_ : NN.t), prod ZZ.t NN.t"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun g : Z =>\n   let (n', d') :=\n     match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n     | Gt =>\n         pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))\n     | _ => pair n d\n     end in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun g : Z =>\n   let (n', d') :=\n     match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n     | Gt =>\n         pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))\n     | _ => pair n d\n     end in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c4_goal : ex\n  (fun g : Z =>\n   let (n', d') :=\n     match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n     | Gt =>\n         pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))\n     | _ => pair n d\n     end in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun g : Z =>\n   let (n', d') :=\n     match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n     | Gt =>\n         pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))\n     | _ => pair n d\n     end in\n   and (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c5_goal : ex\n  (fun g : Z =>\n   and (Logic.eq (Z.mul (ZZ.to_Z n) g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d) g) (NN.to_Z d)))",
                    "c5_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c6_goal : ex\n  (fun g : Z =>\n   and (Logic.eq (Z.mul (ZZ.to_Z n) g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d) g) (NN.to_Z d)))",
                    "c6_H : Z.lt (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1",
                    "c7_goal : ex\n  (fun g : Z =>\n   and\n     (Logic.eq\n        (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))) g)\n        (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) g)\n        (NN.to_Z d)))",
                    "c7_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "exists 1 % Z .",
                "tactic_sig_no_out_arg": "exists 1 % Z .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun g : Z =>\n   and (Logic.eq (Z.mul (ZZ.to_Z n) g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d) g) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c8_goal : and (Logic.eq (Z.mul (ZZ.to_Z n) 1%Z) (ZZ.to_Z n))\n  (Logic.eq (Z.mul (NN.to_Z d) 1%Z) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c8_goal : and (Logic.eq (Z.mul (ZZ.to_Z n) 1%Z) (ZZ.to_Z n))\n  (Logic.eq (Z.mul (NN.to_Z d) 1%Z) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c9_goal : and (Logic.eq (ZZ.to_Z n) (ZZ.to_Z n))\n  (Logic.eq (NN.to_Z d) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : and (Logic.eq (ZZ.to_Z n) (ZZ.to_Z n))\n  (Logic.eq (NN.to_Z d) (NN.to_Z d))",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists 0 % Z .",
                "tactic_sig_no_out_arg": "exists 0 % Z .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun g : Z =>\n   and (Logic.eq (Z.mul (ZZ.to_Z n) g) (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z d) g) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c10_goal : and (Logic.eq (Z.mul (ZZ.to_Z n) 0%Z) (ZZ.to_Z n))\n  (Logic.eq (Z.mul (NN.to_Z d) 0%Z) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c10_goal : and (Logic.eq (Z.mul (ZZ.to_Z n) 0%Z) (ZZ.to_Z n))\n  (Logic.eq (Z.mul (NN.to_Z d) 0%Z) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c11_goal : and (Logic.eq 0%Z (ZZ.to_Z n)) (Logic.eq 0%Z (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "assert ( Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) = 0 % Z ) .",
                "tactic_sig_no_out_arg": "assert ( Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) = 0 % Z ) .",
                "tactic_args": [
                    "c11_goal : and (Logic.eq 0%Z (ZZ.to_Z n)) (Logic.eq 0%Z (NN.to_Z d))",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z",
                    "c13_goal : and (Logic.eq 0%Z (ZZ.to_Z n)) (Logic.eq 0%Z (NN.to_Z d))",
                    "c13_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nLogic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nLogic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c6_H : Z.lt (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : and (Logic.eq 0%Z (ZZ.to_Z n)) (Logic.eq 0%Z (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq 0%Z (ZZ.to_Z n)",
                    "c16_goal : Logic.eq 0%Z (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c15_goal : Logic.eq 0%Z (ZZ.to_Z n)"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (ZZ.to_Z n) 0%Z"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i _i _i ) .",
                "tactic_args": [
                    "c17_goal : Logic.eq (ZZ.to_Z n) 0%Z",
                    "_global_Z.gcd_eq_0_l : forall (n m : Z) (_ : Logic.eq (Z.gcd n m) 0%Z), Logic.eq n 0%Z",
                    "_global__ : ?T\nwhere\n?T : [n : ZZ.t  d : NN.t  H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z\n     |- Type]\n?y : [n : ZZ.t  d : NN.t  H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z\n     |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [n : ZZ.t  d : NN.t  H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z\n     |- Type]\n?y : [n : ZZ.t  d : NN.t  H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z\n     |- ?T]",
                    "c13_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c16_goal : Logic.eq 0%Z (NN.to_Z d)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i _i _i ) .",
                "tactic_args": [
                    "c18_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "_global_Z.gcd_eq_0_r : forall (n m : Z) (_ : Logic.eq (Z.gcd n m) 0%Z), Logic.eq m 0%Z",
                    "_global__ : ?T\nwhere\n?T : [n : ZZ.t  d : NN.t  H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) |- Type]\n?y : [n : ZZ.t  d : NN.t  H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [n : ZZ.t  d : NN.t  H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) |- Type]\n?y : [n : ZZ.t  d : NN.t  H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) |- ?T]",
                    "c13_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "exists ( Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun g : Z =>\n   and\n     (Logic.eq\n        (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))) g)\n        (ZZ.to_Z n))\n     (Logic.eq (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) g)\n        (NN.to_Z d)))",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ],
                "tactic_res": [
                    "c19_goal : and\n  (Logic.eq\n     (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n        (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n))\n  (Logic.eq\n     (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))\n        (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c19_goal : and\n  (Logic.eq\n     (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n        (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n))\n  (Logic.eq\n     (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))\n        (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq\n  (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n)",
                    "c21_goal : Logic.eq\n  (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c20_goal : Logic.eq\n  (Z.mul (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n)"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [  _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c2_n : ZZ.t",
                    "c2_d : NN.t",
                    "c7_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c22_H2 : forall (x : Z) (_ : Z.divide x (ZZ.to_Z n))\n  (_ : Z.divide x (NN.to_Z d)),\nZ.divide x (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c22_H1 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (NN.to_Z d)",
                    "c22_H0 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (ZZ.to_Z n)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) \n  (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) \n  (ZZ.to_Z n)"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (ZZ.to_Z n)\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : Logic.eq (ZZ.to_Z n)\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))))",
                    "_global_Zdivide_Zdiv_eq : forall (a b : Z) (_ : Z.lt 0 a) (_ : Z.divide a b),\n       Logic.eq b (Z.mul a (Z.div b a))"
                ],
                "tactic_res": [
                    "c25_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c26_goal : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c7_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c26_goal : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                    "c22_H0 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c21_goal : Logic.eq\n  (Z.mul (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d)"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq\n  (Z.mul (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [  _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c2_n : ZZ.t",
                    "c2_d : NN.t",
                    "c7_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c27_H2 : forall (x : Z) (_ : Z.divide x (ZZ.to_Z n))\n  (_ : Z.divide x (NN.to_Z d)),\nZ.divide x (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c27_H1 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (NN.to_Z d)",
                    "c27_H0 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : Logic.eq\n  (Z.mul (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) (NN.to_Z d)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) \n  (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c28_goal : Logic.eq\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) \n  (NN.to_Z d)"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq (NN.to_Z d)\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : Logic.eq (NN.to_Z d)\n  (Z.mul (Z.gcd (ZZ.to_Z n) (NN.to_Z d))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))))",
                    "_global_Zdivide_Zdiv_eq : forall (a b : Z) (_ : Z.lt 0 a) (_ : Z.divide a b),\n       Logic.eq b (Z.mul a (Z.div b a))"
                ],
                "tactic_res": [
                    "c30_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c31_goal : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c30_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c7_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (NN.to_Z d)",
                    "c27_H1 : Z.divide (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) (NN.to_Z d)",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_irred_zero",
        "proof": [
            {
                "tactic_sig": "Lemma spec_irred_zero : forall n d , ( NN.to_Z d = 0 ) % Z <- > ( NN.to_Z ( snd ( irred n d ) ) = 0 ) % Z .",
                "tactic_sig_no_out_arg": "Lemma spec_irred_zero : forall n d , ( NN.to_Z d = 0 ) % Z <- > ( NN.to_Z ( snd ( irred n d ) ) = 0 ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\niff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred n d))) 0%Z)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t),\niff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred n d))) 0%Z)"
                ],
                "tactic_res": [
                    "c2_goal : iff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred n d))) 0%Z)",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : iff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred n d))) 0%Z)",
                    "_global_irred : forall (_ : ZZ.t) (_ : NN.t), prod ZZ.t NN.t"
                ],
                "tactic_res": [
                    "c3_goal : iff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq\n     (NN.to_Z\n        (snd\n           match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n           | Gt =>\n               pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                 (NN.div d (NN.gcd (Zabs_N n) d))\n           | _ => pair n d\n           end)) 0%Z)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : iff (Logic.eq (NN.to_Z d) 0%Z)\n  (Logic.eq\n     (NN.to_Z\n        (snd\n           match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n           | Gt =>\n               pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                 (NN.div d (NN.gcd (Zabs_N n) d))\n           | _ => pair n d\n           end)) 0%Z)"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z,\nLogic.eq\n  (NN.to_Z\n     (snd\n        match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z",
                    "c5_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n              | Gt =>\n                  pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                    (NN.div d (NN.gcd (Zabs_N n) d))\n              | _ => pair n d\n              end)) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c4_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z,\nLogic.eq\n  (NN.to_Z\n     (snd\n        match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z,\nLogic.eq\n  (NN.to_Z\n     (snd\n        match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z,\nLogic.eq\n  (NN.to_Z\n     (snd\n        match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (NN.to_Z\n     (snd\n        match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z",
                    "c7_H : Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (NN.to_Z\n     (snd\n        match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n        | Gt =>\n            pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n              (NN.div d (NN.gcd (Zabs_N n) d))\n        | _ => pair n d\n        end)) 0%Z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z",
                    "c8_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c9_goal : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z",
                    "c9_H0 : Z.lt (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1",
                    "c10_goal : Logic.eq\n  (NN.to_Z\n     (snd\n        (pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))))) 0%Z",
                    "c10_H0 : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z",
                    "c7_H : Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z",
                    "c7_H : Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (NN.to_Z\n     (snd\n        (pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n           (NN.div d (NN.gcd (Zabs_N n) d))))) 0%Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) 0%Z"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z",
                    "c7_H : Logic.eq (NN.to_Z d) 0%Z",
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n              | Gt =>\n                  pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                    (NN.div d (NN.gcd (Zabs_N n) d))\n              | _ => pair n d\n              end)) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n              | Gt =>\n                  pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                    (NN.div d (NN.gcd (Zabs_N n) d))\n              | _ => pair n d\n              end)) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n              | Gt =>\n                  pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                    (NN.div d (NN.gcd (Zabs_N n) d))\n              | _ => pair n d\n              end)) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z",
                    "c15_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c16_goal : forall _ : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z",
                    "c16_H : Z.lt (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1",
                    "c17_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              (pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                 (NN.div d (NN.gcd (Zabs_N n) d))))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z",
                    "c17_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z (snd (pair n d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : Logic.eq\n        (NN.to_Z\n           (snd\n              (pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n                 (NN.div d (NN.gcd (Zabs_N n) d))))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z,\nLogic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "c22_H0 : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c22_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : Z.le 0 (NN.to_Z d), Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall _ : Z.le 0 (NN.to_Z d), Logic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "c24_H1 : Z.le 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "destruct ( NN.to_Z _i ) as [  _o _o _o | _o _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( NN.to_Z _i ) .",
                "tactic_args": [
                    "c24_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "c2_d : NN.t",
                    "c24_H1 : Z.le 0 (NN.to_Z d)",
                    "c22_H0 : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))) 0%Z",
                    "c17_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq 0%Z 0%Z",
                    "c25_H1 : Z.le 0 0",
                    "c25_H0 : Logic.eq (Z.div 0%Z (Z.gcd (ZZ.to_Z n) 0%Z)) 0%Z",
                    "c25_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) 0%Z)",
                    "c26_goal : Logic.eq (Zpos p) 0%Z",
                    "c26_H1 : Z.le 0 (Zpos p)",
                    "c26_H0 : Logic.eq (Z.div (Zpos p) (Z.gcd (ZZ.to_Z n) (Zpos p))) 0%Z",
                    "c26_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (Zpos p))",
                    "c26_p : positive",
                    "c27_goal : Logic.eq (Zneg p) 0%Z",
                    "c27_H1 : Z.le 0 (Zneg p)",
                    "c27_H0 : Logic.eq (Z.div (Zneg p) (Z.gcd (ZZ.to_Z n) (Zneg p))) 0%Z",
                    "c27_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (Zneg p))",
                    "c27_p : positive"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( 0 < 0 ) % Z .",
                "tactic_sig_no_out_arg": "assert ( 0 < 0 ) % Z .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Zpos p) 0%Z"
                ],
                "tactic_res": [
                    "c28_goal : Z.lt 0 0",
                    "c29_goal : Logic.eq (Zpos p) 0%Z",
                    "c29_H2 : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i at _i .",
                "tactic_args": [
                    "c28_goal : Z.lt 0 0",
                    "c26_H0 : Logic.eq (Z.div (Zpos p) (Z.gcd (ZZ.to_Z n) (Zpos p))) 0%Z",
                    "_global_2 : Q"
                ],
                "tactic_res": [
                    "c30_goal : Z.lt 0 (Z.div (Zpos p) (Z.gcd (ZZ.to_Z n) (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : Z.lt 0 (Z.div (Zpos p) (Z.gcd (ZZ.to_Z n) (Zpos p)))",
                    "_global_Zgcd_div_pos : forall (a b : Z) (_ : Z.lt 0 b) (_ : Z.lt 0 (Z.gcd a b)),\n       Z.lt 0 (Z.div b (Z.gcd a b))"
                ],
                "tactic_res": [
                    "c31_goal : Z.lt 0 (Zpos p)",
                    "c32_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : Z.lt 0 (Zpos p)",
                    "c26_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c32_goal : Z.lt 0 (Z.gcd (ZZ.to_Z n) (Zpos p))",
                    "c26_H : Z.lt 1 (Z.gcd (ZZ.to_Z n) (Zpos p))",
                    "c26_p : positive",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c29_goal : Logic.eq (Zpos p) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "compute in _i .",
                "tactic_sig_no_out_arg": "compute in _i .",
                "tactic_args": [
                    "c27_H1 : Z.le 0 (Zneg p)"
                ],
                "tactic_res": [
                    "c27_H1 : forall _ : Logic.eq Gt Gt, False"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c27_goal : Logic.eq (Zneg p) 0%Z",
                    "c27_H1 : forall _ : Logic.eq Gt Gt, False"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq Gt Gt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : Logic.eq Gt Gt"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_irred",
        "proof": [
            {
                "tactic_sig": "Lemma strong_spec_irred : forall n d , ( NN.to_Z d <> 0 % Z ) -> let ( n' , d' ) := irred n d in Z.gcd ( ZZ.to_Z n' ) ( NN.to_Z d' ) = 1 % Z .",
                "tactic_sig_no_out_arg": "Lemma strong_spec_irred : forall n d , ( NN.to_Z d <> 0 % Z ) -> let ( n' , d' ) := irred n d in Z.gcd ( ZZ.to_Z n' ) ( NN.to_Z d' ) = 1 % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t) (_ : not (Logic.eq (NN.to_Z d) 0%Z)),\nlet (n', d') := irred n d in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (n : ZZ.t) (d : NN.t) (_ : not (Logic.eq (NN.to_Z d) 0%Z)),\nlet (n', d') := irred n d in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z",
                    "_global_irred : forall (_ : ZZ.t) (_ : NN.t), prod ZZ.t NN.t"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : ZZ.t) (d : NN.t) (_ : not (Logic.eq (NN.to_Z d) 0%Z)),\nlet (n', d') :=\n  match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (n : ZZ.t) (d : NN.t) (_ : not (Logic.eq (NN.to_Z d) 0%Z)),\nlet (n', d') :=\n  match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ],
                "tactic_res": [
                    "c3_goal : let (n', d') :=\n  match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z",
                    "c3_n : ZZ.t",
                    "c3_d : NN.t",
                    "c3_H : not (Logic.eq (NN.to_Z d) 0%Z)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c3_goal : let (n', d') :=\n  match NN.compare (NN.gcd (Zabs_N n) d) NN.one with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ],
                "tactic_res": [
                    "c4_goal : let (n', d') :=\n  match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c4_goal : let (n', d') :=\n  match Z.compare (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z with\n  | Gt =>\n      pair (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d)))\n        (NN.div d (NN.gcd (Zabs_N n) d))\n  | _ => pair n d\n  end in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c5_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c6_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c6_H0 : Z.lt (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1",
                    "c7_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n     (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))) 1%Z",
                    "c7_H0 : Z.lt 1 (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c5_H0 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c3_H : not (Logic.eq (NN.to_Z d) 0%Z)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NN.to_Z d) 0%Z",
                    "_global_Z.gcd_eq_0_r : forall (n m : Z) (_ : Logic.eq (Z.gcd n m) 0%Z), Logic.eq m 0%Z",
                    "_global_ZZ.to_Z : forall _ : ZZ.t, Z",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z",
                    "c3_n : ZZ.t",
                    "c3_d : NN.t"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nLogic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nLogic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.div n (Z_of_N (NN.gcd (Zabs_N n) d))))\n     (NN.to_Z (NN.div d (NN.gcd (Zabs_N n) d)))) 1%Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c12_goal : rel_prime (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n  (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : rel_prime (Z.div (ZZ.to_Z n) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))\n  (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d)))",
                    "_global_Zis_gcd_rel_prime : forall (a b g : Z) (_ : Z.gt b 0) (_ : Z.ge g 0) (_ : Zis_gcd a b g),\n       rel_prime (Z.div a g) (Z.div b g)"
                ],
                "tactic_res": [
                    "c13_goal : Z.gt (NN.to_Z d) 0",
                    "c14_goal : Z.ge (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0",
                    "c15_goal : Zis_gcd (ZZ.to_Z n) (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c13_goal : Z.gt (NN.to_Z d) 0",
                    "c3_d : NN.t"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Z.le 0 (NN.to_Z d), Z.gt (NN.to_Z d) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c16_goal : forall _ : Z.le 0 (NN.to_Z d), Z.gt (NN.to_Z d) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c14_goal : Z.ge (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0",
                    "c3_n : ZZ.t",
                    "c3_d : NN.t"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nZ.ge (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z n) (NN.to_Z d)),\nZ.ge (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Zis_gcd (ZZ.to_Z n) (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "_global_Zgcd_is_gcd : forall a b : Z, Zis_gcd a b (Z.gcd a b)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul_norm_Qz_Qq",
        "proof": [
            {
                "tactic_sig": "Lemma spec_mul_norm_Qz_Qq : forall z n d , [ mul_norm_Qz_Qq z n d ] = = [ Qq ( ZZ.mul z n ) d ] .",
                "tactic_sig_no_out_arg": "Lemma spec_mul_norm_Qz_Qq : forall z n d , [ mul_norm_Qz_Qq z n d ] = = [ Qq ( ZZ.mul z n ) d ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (z n : ZZ.t) (d : NN.t),\nQeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros z n d .",
                "tactic_args": [
                    "c1_goal : forall (z n : ZZ.t) (d : NN.t),\nQeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))",
                    "c2_z : ZZ.t",
                    "c2_n : ZZ.t",
                    "c2_d : NN.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))",
                    "_global_mul_norm_Qz_Qq : forall (_ : ZZ.t) (_ : ZZ.t) (_ : NN.t), t"
                ],
                "tactic_res": [
                    "c3_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n       | Gt =>\n           norm_denum\n             (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n             (NN.div d (NN.gcd (Zabs_N z) d))\n       | _ => Qq (ZZ.mul z n) d\n       end)) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c3_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n       | Gt =>\n           norm_denum\n             (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n             (NN.div d (NN.gcd (Zabs_N z) d))\n       | _ => Qq (ZZ.mul z n) d\n       end)) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n       | Gt =>\n           norm_denum\n             (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n             (NN.div d (NN.gcd (Zabs_N z) d))\n       | _ => Qq (ZZ.mul z n) d\n       end)) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n       | Gt =>\n           norm_denum\n             (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n             (NN.div d (NN.gcd (Zabs_N z) d))\n       | _ => Qq (ZZ.mul z n) d\n       end)) (to_Q (Qq (ZZ.mul z n) d))",
                    "_global_Zcompare_gt : forall (A : Type) (a a' : A) (p q : Z),\n       Logic.eq match Z.compare p q with\n                | Gt => a\n                | _ => a'\n                end (if Z_le_gt_dec p q then a' else a)"
                ],
                "tactic_res": [
                    "c5_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n       then Qq (ZZ.mul z n) d\n       else\n        norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n          (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c5_goal : Qeq\n  (to_Q\n     (if ZZ.eqb z ZZ.zero\n      then zero\n      else\n       if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n       then Qq (ZZ.mul z n) d\n       else\n        norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n          (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nQeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))",
                    "c7_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nQeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nQeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Logic.eq (ZZ.to_Z z) 0%Z,\nQeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c8_goal : forall _ : Logic.eq (ZZ.to_Z z) 0%Z,\nQeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c9_goal : Qeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))",
                    "c9_Hz : Logic.eq (ZZ.to_Z z) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c7_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nQeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : not (Logic.eq (ZZ.to_Z z) 0%Z),\nQeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c10_goal : forall _ : not (Logic.eq (ZZ.to_Z z) 0%Z),\nQeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c11_goal : Qeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))",
                    "c11_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c9_goal : Qeq (to_Q zero) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "c12_H : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "c9_Hz : Logic.eq (ZZ.to_Z z) 0%Z"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq 0%Z (Z.mul 0%Z (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq 0%Z (Z.mul 0%Z (ZZ.to_Z n))",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Z_le_gt_dec as [ LE|GT ] .",
                "tactic_sig_no_out_arg": "destruct Z_le_gt_dec as [ LE|GT ] .",
                "tactic_args": [
                    "c11_goal : Qeq\n  (to_Q\n     (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n      then Qq (ZZ.mul z n) d\n      else\n       norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n         (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))",
                    "c11_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)",
                    "c2_d : NN.t",
                    "c2_z : ZZ.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (to_Q (Qq (ZZ.mul z n) d)) (to_Q (Qq (ZZ.mul z n) d))",
                    "c14_LE : Z.le (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1",
                    "c15_goal : Qeq\n  (to_Q\n     (norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n        (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))",
                    "c15_GT : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c14_goal : Qeq (to_Q (Qq (ZZ.mul z n) d)) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : Qeq\n  (to_Q\n     (norm_denum (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n        (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))",
                    "_global_spec_norm_denum : forall (n : ZZ.t) (d : NN.t),\n       Qeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c16_goal : Qeq\n  (to_Q\n     (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n        (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c16_goal : Qeq\n  (to_Q\n     (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n        (NN.div d (NN.gcd (Zabs_N z) d)))) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "c17_e : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z",
                    "c17_H : Z.lt 0 (NN.to_Z d)",
                    "c18_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (ZZ.to_Z n)) 0%Z",
                    "c18_H : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c18_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c19_goal : Logic.eq\n  (Z.mul\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n)) (NN.to_Z d))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))",
                    "c19_H0 : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c19_H : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "_global_Zdiv_gcd_zero : forall (a b : Z) (_ : Logic.eq (Z.div b (Z.gcd a b)) 0%Z)\n         (_ : not (Logic.eq b 0%Z)), Logic.eq (Z.gcd a b) 0%Z",
                    "c15_GT : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "c20_GT : Z.gt 0 1",
                    "c21_goal : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z",
                    "c22_goal : not (Logic.eq (NN.to_Z d) 0%Z)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))",
                    "c20_GT : Z.gt 0 1",
                    "c2_z : ZZ.t",
                    "c2_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z",
                    "c17_e : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z",
                    "c2_d : NN.t",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : not (Logic.eq (NN.to_Z d) 0%Z)",
                    "c17_H : Z.lt 0 (NN.to_Z d)",
                    "c2_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nsubst .",
                "tactic_sig_no_out_arg": "nsubst .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (ZZ.to_Z n)) 0%Z"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) 0%Z)) (ZZ.to_Z n)) 0%Z",
                    "c23_H : Z.lt 0 (Z.div 0%Z (Z.gcd (ZZ.to_Z z) 0%Z))",
                    "c23_GT : Z.gt (Z.gcd (ZZ.to_Z z) 0%Z) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c23_H : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) 0%Z)) (ZZ.to_Z n)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i , ( _i ( _i _i ) ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , ( _i ( _i _i ) ) , _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.mul\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n)) (NN.to_Z d))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))",
                    "_global_Z.mul_assoc : forall n m p : Z, Logic.eq (Z.mul n (Z.mul m p)) (Z.mul (Z.mul n m) p)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)",
                    "_global_ZZ.to_Z : forall _ : ZZ.t, Z",
                    "c2_n : ZZ.t",
                    "_global_Z.mul_assoc : forall n m p : Z, Logic.eq (Z.mul n (Z.mul m p)) (Z.mul (Z.mul n m) p)"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq\n  (Z.mul\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (NN.to_Z d)) (ZZ.to_Z n))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : Logic.eq\n  (Z.mul\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (NN.to_Z d)) (ZZ.to_Z n))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))",
                    "_global_Zgcd_div_swap0 : forall (a b : Z) (_ : Z.lt 0 (Z.gcd a b)) (_ : Z.lt 0 b),\n       Logic.eq (Z.mul (Z.div a (Z.gcd a b)) b)\n         (Z.mul a (Z.div b (Z.gcd a b)))"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq\n  (Z.mul\n     (Z.mul (ZZ.to_Z z)\n        (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))\n     (ZZ.to_Z n))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))",
                    "c26_goal : Z.lt 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d))",
                    "c27_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c25_goal : Logic.eq\n  (Z.mul\n     (Z.mul (ZZ.to_Z z)\n        (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))\n     (ZZ.to_Z n))\n  (Z.mul (Z.mul (ZZ.to_Z z) (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c27_goal : Z.lt 0 (NN.to_Z d)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_mul_norm_Qz_Qq",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_mul_norm_Qz_Qq z n d : forall ` ( Reduced ( Qq n d ) ) , Reduced ( mul_norm_Qz_Qq z n d ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_mul_norm_Qz_Qq z n d : forall ` ( Reduced ( Qq n d ) ) , Reduced ( mul_norm_Qz_Qq z n d ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall _ : Reduced (Qq n d), Reduced (mul_norm_Qz_Qq z n d)",
                    "c1_d : NN.t",
                    "c1_n : ZZ.t",
                    "c1_z : ZZ.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall _ : Reduced (Qq n d), Reduced (mul_norm_Qz_Qq z n d)",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d)),\nLogic.eq (to_Q (red (mul_norm_Qz_Qq z n d)))\n  (to_Q (mul_norm_Qz_Qq z n d))"
                ]
            },
            {
                "tactic_sig": "rewrite _i _i , _i _i .",
                "tactic_sig_no_out_arg": "rewrite _i _i , _i _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d)),\nLogic.eq (to_Q (red (mul_norm_Qz_Qq z n d)))\n  (to_Q (mul_norm_Qz_Qq z n d))",
                    "_global_2 : Q",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_2 : Q",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "c6_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hd H .",
                "tactic_args": [
                    "c5_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "c7_Hd : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)",
                    "c7_H : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hd H .",
                "tactic_args": [
                    "c6_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "c8_Hd : Z.lt 0 (NN.to_Z d)",
                    "c8_H : Logic.eq\n  (Z.gcd (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n     (Zpos (Qden {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "_global_mul_norm_Qz_Qq : forall (_ : ZZ.t) (_ : ZZ.t) (_ : NN.t), t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match\n                  Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z\n                with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match\n                  Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z\n                with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z",
                    "_global_Zcompare_gt : forall (A : Type) (a a' : A) (p q : Z),\n       Logic.eq match Z.compare p q with\n                | Gt => a\n                | _ => a'\n                end (if Z_le_gt_dec p q then a' else a)"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n             then Qq (ZZ.mul z n) d\n             else\n              norm_denum\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n                then Qq (ZZ.mul z n) d\n                else\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n             then Qq (ZZ.mul z n) d\n             else\n              norm_denum\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n                then Qq (ZZ.mul z n) d\n                else\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nLogic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c13_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nLogic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c14_Hz : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq 1%Z 1%Z",
                    "c16_Hz : Logic.eq (ZZ.to_Z z) 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c13_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c17_Hz : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero))"
                ]
            },
            {
                "tactic_sig": "destruct Z_le_gt_dec as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct Z_le_gt_dec .",
                "tactic_args": [
                    "c17_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c17_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)",
                    "c7_H : Logic.eq 1%Z 1%Z",
                    "c7_Hd : Logic.eq (NN.to_Z d) 0%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq (ZZ.mul z n) d)))\n     (Zpos (Qden (to_Q (Qq (ZZ.mul z n) d))))) 1%Z",
                    "c18_l : Z.le (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1",
                    "c19_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (norm_denum\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (norm_denum\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c19_g : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq (ZZ.mul z n) d)))\n     (Zpos (Qden (to_Q (Qq (ZZ.mul z n) d))))) 1%Z"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z (ZZ.mul z n); Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z (ZZ.mul z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c20_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z (ZZ.mul z n); Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z (ZZ.mul z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n            Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c21_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n            Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c23_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n          Qden := Z.to_pos (NN.to_Z d)\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n             Qden := Z.to_pos (NN.to_Z d)\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c24_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq 1%Z 1%Z",
                    "c1_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n          Qden := Z.to_pos (NN.to_Z d)\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n             Qden := Z.to_pos (NN.to_Z d)\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c26_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c26_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z",
                    "c7_Hd : Logic.eq (NN.to_Z d) 0%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (norm_denum\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (norm_denum\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "_global_norm_denum : forall (_ : ZZ.t) (_ : NN.t), t_"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n            then\n             Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n            else\n             Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n               then\n                Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               else\n                Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c27_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n            then\n             Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n            else\n             Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n               then\n                Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               else\n                Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))))\n  1%Z",
                    "c29_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))))\n  1%Z"
                ],
                "tactic_res": [
                    "c30_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     1%Z) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c30_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     1%Z) 1%Z"
                ],
                "tactic_res": [
                    "c31_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z,\nLogic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c32_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              ZZ.to_Z\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n            Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 ZZ.to_Z\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n               Qden :=\n                 Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              ZZ.to_Z\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n            Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 ZZ.to_Z\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n               Qden :=\n                 Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c33_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                (ZZ.to_Z n);\n            Qden :=\n              Z.to_pos\n                (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 Z.mul\n                   (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                   (ZZ.to_Z n);\n               Qden :=\n                 Z.to_pos\n                   (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c31_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z,\nLogic.eq 1%Z 1%Z",
                    "c7_Hd : Logic.eq (NN.to_Z d) 0%Z",
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : Logic.eq 0%Z 1%Z, Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c34_goal : forall _ : Logic.eq 0%Z 1%Z, Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c33_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                (ZZ.to_Z n);\n            Qden :=\n              Z.to_pos\n                (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 Z.mul\n                   (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                   (ZZ.to_Z n);\n               Qden :=\n                 Z.to_pos\n                   (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c35_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                (ZZ.to_Z n);\n            Qden :=\n              Z.to_pos\n                (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 Z.mul\n                   (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                   (ZZ.to_Z n);\n               Qden :=\n                 Z.to_pos\n                   (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c35_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                (ZZ.to_Z n);\n            Qden :=\n              Z.to_pos\n                (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 Z.mul\n                   (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                   (ZZ.to_Z n);\n               Qden :=\n                 Z.to_pos\n                   (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c36_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum :=\n            Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n              (ZZ.to_Z n);\n          Qden :=\n            Z.to_pos\n              (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum :=\n               Z.mul\n                 (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                 (ZZ.to_Z n);\n             Qden :=\n               Z.to_pos\n                 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c36_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c38_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c38_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": [
                    "c39_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z,\nLogic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 0%Z,\nLogic.eq 1%Z 1%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum :=\n            Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n              (ZZ.to_Z n);\n          Qden :=\n            Z.to_pos\n              (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum :=\n               Z.mul\n                 (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n                 (ZZ.to_Z n);\n             Qden :=\n               Z.to_pos\n                 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c40_goal : forall _ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))),\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c40_goal : forall _ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))),\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z"
                ],
                "tactic_res": [
                    "c41_goal : forall _ : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))),\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c41_goal : forall _ : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))),\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z",
                    "c7_Hd : Logic.eq (NN.to_Z d) 0%Z",
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c42_goal : forall _ : Z.lt 0 0,\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) 0%Z)) (ZZ.to_Z n))\n     (Zpos (Z.to_pos 0%Z))) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c42_goal : forall _ : Z.lt 0 0,\nLogic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) 0%Z)) (ZZ.to_Z n))\n     (Zpos (Z.to_pos 0%Z))) 1%Z",
                    "c1_z : ZZ.t",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x",
                    "c8_H : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z"
                ],
                "tactic_res": [
                    "c43_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "c43_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c44_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c44_goal : Z.lt 0 (NN.to_Z d)",
                    "c8_Hd : Z.lt 0 (NN.to_Z d)",
                    "c1_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c43_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq z n d)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq z n d))))) 1%Z",
                    "_global_mul_norm_Qz_Qq : forall (_ : ZZ.t) (_ : ZZ.t) (_ : NN.t), t"
                ],
                "tactic_res": [
                    "c45_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c45_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match NN.compare (NN.gcd (Zabs_N z) d) NN.one with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match\n                  Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z\n                with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c46_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             match Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z with\n             | Gt =>\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))\n             | _ => Qq (ZZ.mul z n) d\n             end)))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                match\n                  Z.compare (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z\n                with\n                | Gt =>\n                    norm_denum\n                      (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d)))\n                         n) (NN.div d (NN.gcd (Zabs_N z) d))\n                | _ => Qq (ZZ.mul z n) d\n                end))))) 1%Z",
                    "_global_Zcompare_gt : forall (A : Type) (a a' : A) (p q : Z),\n       Logic.eq match Z.compare p q with\n                | Gt => a\n                | _ => a'\n                end (if Z_le_gt_dec p q then a' else a)"
                ],
                "tactic_res": [
                    "c47_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n             then Qq (ZZ.mul z n) d\n             else\n              norm_denum\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n                then Qq (ZZ.mul z n) d\n                else\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c47_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if ZZ.eqb z ZZ.zero\n            then zero\n            else\n             if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n             then Qq (ZZ.mul z n) d\n             else\n              norm_denum\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if ZZ.eqb z ZZ.zero\n               then zero\n               else\n                if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n                then Qq (ZZ.mul z n) d\n                else\n                 norm_denum\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                   (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c48_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nLogic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c49_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c48_goal : forall _ : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero),\nLogic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c50_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c50_Hz : Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c50_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c51_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c51_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ],
                "tactic_res": [
                    "c52_goal : Logic.eq 1%Z 1%Z",
                    "c52_Hz : Logic.eq (ZZ.to_Z z) 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c52_goal : Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hz .",
                "tactic_args": [
                    "c49_goal : forall _ : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c53_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c53_Hz : not (Logic.eq (ZZ.to_Z z) (ZZ.to_Z ZZ.zero))"
                ]
            },
            {
                "tactic_sig": "destruct Z_le_gt_dec as [ H'|H' ] .",
                "tactic_sig_no_out_arg": "destruct Z_le_gt_dec as [ H'|H' ] .",
                "tactic_args": [
                    "c53_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n            then Qq (ZZ.mul z n) d\n            else\n             norm_denum\n               (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if Z_le_gt_dec (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1\n               then Qq (ZZ.mul z n) d\n               else\n                norm_denum\n                  (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c53_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)",
                    "c43_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c8_Hd : Z.lt 0 (NN.to_Z d)",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": [
                    "c54_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq (ZZ.mul z n) d)))\n     (Zpos (Qden (to_Q (Qq (ZZ.mul z n) d))))) 1%Z",
                    "c54_H' : Z.le (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1",
                    "c55_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (norm_denum\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (norm_denum\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "c55_H' : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c54_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq (ZZ.mul z n) d)))\n     (Zpos (Qden (to_Q (Qq (ZZ.mul z n) d))))) 1%Z"
                ],
                "tactic_res": [
                    "c56_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z (ZZ.mul z n); Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z (ZZ.mul z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c56_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z (ZZ.mul z n); Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z (ZZ.mul z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c57_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n            Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c57_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb d NN.zero\n         then 0\n         else\n          {|\n            Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n            Qden := Z.to_pos (NN.to_Z d)\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb d NN.zero\n            then 0\n            else\n             {|\n               Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n               Qden := Z.to_pos (NN.to_Z d)\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c58_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c59_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n          Qden := Z.to_pos (NN.to_Z d)\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n             Qden := Z.to_pos (NN.to_Z d)\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c58_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c60_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c60_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": [
                    "c61_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c61_goal : forall _ : Logic.eq (NN.to_Z d) 0%Z, Logic.eq 1%Z 1%Z",
                    "c1_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c59_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n          Qden := Z.to_pos (NN.to_Z d)\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z n);\n             Qden := Z.to_pos (NN.to_Z d)\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c62_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c62_goal : forall _ : Z.lt 0 (NN.to_Z d),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z"
                ],
                "tactic_res": [
                    "c63_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z",
                    "c63_H0 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c63_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (Zpos (Z.to_pos (NN.to_Z d))))\n  1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c64_goal : Logic.eq (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (NN.to_Z d)) 1%Z",
                    "c65_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c65_goal : Z.lt 0 (NN.to_Z d)",
                    "c1_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c64_goal : Logic.eq (Z.gcd (Z.mul (ZZ.to_Z z) (ZZ.to_Z n)) (NN.to_Z d)) 1%Z",
                    "_global_Zgcd_mult_rel_prime : forall (a b c : Z) (_ : Logic.eq (Z.gcd a c) 1%Z)\n         (_ : Logic.eq (Z.gcd b c) 1%Z), Logic.eq (Z.gcd (Z.mul a b) c) 1%Z"
                ],
                "tactic_res": [
                    "c66_goal : Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z",
                    "c67_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c67_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c43_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c1_d : NN.t",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Z.gcd_eq_0_l ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_eq_0_l ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c66_goal : Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z",
                    "c1_z : ZZ.t",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t",
                    "c1_d : NN.t"
                ],
                "tactic_res": [
                    "c68_goal : forall\n  (_ : forall _ : Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0%Z,\n       Logic.eq (ZZ.to_Z z) 0%Z)\n  (_ : Z.le 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d))),\nLogic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c68_goal : forall\n  (_ : forall _ : Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0%Z,\n       Logic.eq (ZZ.to_Z z) 0%Z)\n  (_ : Z.le 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d))),\nLogic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c55_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (norm_denum\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (norm_denum\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z",
                    "_global_norm_denum : forall (_ : ZZ.t) (_ : NN.t), t_"
                ],
                "tactic_res": [
                    "c69_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n            then\n             Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n            else\n             Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n               then\n                Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               else\n                Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c69_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n            then\n             Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n            else\n             Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.one\n               then\n                Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n               else\n                Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                  (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c70_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))))\n  1%Z",
                    "c71_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c70_goal : forall\n  _ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        (NN.to_Z NN.one),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qz (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))))))\n  1%Z"
                ],
                "tactic_res": [
                    "c72_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z,\nLogic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c72_goal : forall\n  _ : Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z,\nLogic.eq 1%Z 1%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c71_goal : forall\n  _ : not\n        (Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           (NN.to_Z NN.one)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c73_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c73_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n              (NN.div d (NN.gcd (Zabs_N z) d)))))\n     (Zpos\n        (Qden\n           (to_Q\n              (Qq (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n)\n                 (NN.div d (NN.gcd (Zabs_N z) d))))))) 1%Z"
                ],
                "tactic_res": [
                    "c74_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              ZZ.to_Z\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n            Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 ZZ.to_Z\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n               Qden :=\n                 Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c74_goal : forall\n  _ : not\n        (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n           1%Z),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n         then 0\n         else\n          {|\n            Qnum :=\n              ZZ.to_Z\n                (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n            Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (NN.div d (NN.gcd (Zabs_N z) d)) NN.zero\n            then 0\n            else\n             {|\n               Qnum :=\n                 ZZ.to_Z\n                   (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n               Qden :=\n                 Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c75_goal : forall\n  (_ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n         (NN.to_Z NN.zero))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)), Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c76_goal : forall (_ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum :=\n            ZZ.to_Z\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n          Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum :=\n               ZZ.to_Z\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n             Qden :=\n               Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c75_goal : forall\n  (_ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n         (NN.to_Z NN.zero))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)), Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c77_goal : forall\n  (_ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n         (NN.to_Z NN.zero))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)), Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c77_goal : forall\n  (_ : Logic.eq (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n         (NN.to_Z NN.zero))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)), Logic.eq 1%Z 1%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c76_goal : forall (_ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum :=\n            ZZ.to_Z\n              (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n          Qden := Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum :=\n               ZZ.to_Z\n                 (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n);\n             Qden :=\n               Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c78_goal : forall (_ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     (Zpos (Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c78_goal : forall (_ : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d))))\n  (_ : not\n         (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n            1%Z)),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     (Zpos (Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))))) 1%Z"
                ],
                "tactic_res": [
                    "c79_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     (Zpos (Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))))) 1%Z",
                    "c79_H0 : Z.lt 0 (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))",
                    "c79_n0 : not (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c79_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.mul (ZZ.div z (Z_of_N (NN.gcd (Zabs_N z) d))) n))\n     (Zpos (Z.to_pos (NN.to_Z (NN.div d (NN.gcd (Zabs_N z) d)))))) 1%Z"
                ],
                "tactic_res": [
                    "c80_goal : Logic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z",
                    "c80_H0 : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c80_goal : Logic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Zpos\n        (Z.to_pos (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))))))\n  1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c81_goal : Logic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z",
                    "c82_goal : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c82_goal : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c80_H0 : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c81_goal : Logic.eq\n  (Z.gcd\n     (Z.mul (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n        (ZZ.to_Z n))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z",
                    "_global_Zgcd_mult_rel_prime : forall (a b c : Z) (_ : Logic.eq (Z.gcd a c) 1%Z)\n         (_ : Logic.eq (Z.gcd b c) 1%Z), Logic.eq (Z.gcd (Z.mul a b) c) 1%Z"
                ],
                "tactic_res": [
                    "c83_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z",
                    "c84_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z n)\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c83_goal : Logic.eq\n  (Z.gcd (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c85_goal : rel_prime (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n  (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c85_goal : rel_prime (Z.div (ZZ.to_Z z) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n  (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "_global_Zis_gcd_rel_prime : forall (a b g : Z) (_ : Z.gt b 0) (_ : Z.ge g 0) (_ : Zis_gcd a b g),\n       rel_prime (Z.div a g) (Z.div b g)"
                ],
                "tactic_res": [
                    "c86_goal : Z.gt (NN.to_Z d) 0",
                    "c87_goal : Z.ge (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0",
                    "c88_goal : Zis_gcd (ZZ.to_Z z) (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "generalize ( NN.spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( NN.spec_pos _i ) .",
                "tactic_args": [
                    "c86_goal : Z.gt (NN.to_Z d) 0",
                    "c1_d : NN.t"
                ],
                "tactic_res": [
                    "c89_goal : forall _ : Z.le 0 (NN.to_Z d), Z.gt (NN.to_Z d) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c89_goal : forall _ : Z.le 0 (NN.to_Z d), Z.gt (NN.to_Z d) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.gcd_nonneg ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) .",
                "tactic_args": [
                    "c87_goal : Z.ge (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0",
                    "c1_z : ZZ.t",
                    "c1_d : NN.t"
                ],
                "tactic_res": [
                    "c90_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)),\nZ.ge (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c90_goal : forall _ : Z.le 0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)),\nZ.ge (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c88_goal : Zis_gcd (ZZ.to_Z z) (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))",
                    "_global_Zgcd_is_gcd : forall a b : Z, Zis_gcd a b (Z.gcd a b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ ( z0 , Hz0 ) ( d0 , Hd0 ) Hzd ] .",
                "tactic_sig_no_out_arg": "destruct ( Zgcd_is_gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ ( z0 , Hz0 ) ( d0 , Hd0 ) Hzd ] .",
                "tactic_args": [
                    "c1_z : ZZ.t",
                    "c1_d : NN.t",
                    "c79_n0 : not (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z)",
                    "c80_H0 : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c55_H' : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1",
                    "c53_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)",
                    "c43_H : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c8_Hd : Z.lt 0 (NN.to_Z d)",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": [
                    "c84_Hzd : forall (x : Z) (_ : Z.divide x (ZZ.to_Z z))\n  (_ : Z.divide x (NN.to_Z d)),\nZ.divide x (Z.gcd (ZZ.to_Z z) (NN.to_Z d))",
                    "c84_Hd0 : Logic.eq (NN.to_Z d) (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c84_d0 : Z",
                    "c84_Hz0 : Logic.eq (ZZ.to_Z z) (Z.mul z0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c84_z0 : Z"
                ]
            },
            {
                "tactic_sig": "replace ( NN.to_Z _i / Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) % Z with _i .",
                "tactic_sig_no_out_arg": "replace ( NN.to_Z _i / Z.gcd ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) % Z with _i .",
                "tactic_args": [
                    "c84_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z n)\n     (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))) 1%Z",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t",
                    "c1_d : NN.t",
                    "c84_d0 : Z"
                ],
                "tactic_res": [
                    "c91_goal : Logic.eq (Z.gcd (ZZ.to_Z n) d0) 1%Z",
                    "c92_goal : Logic.eq d0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c91_goal : Logic.eq (Z.gcd (ZZ.to_Z n) d0) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c93_goal : rel_prime (ZZ.to_Z n) d0",
                    "c93_H : rel_prime (ZZ.to_Z n) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c93_goal : rel_prime (ZZ.to_Z n) d0",
                    "_global_bezout_rel_prime : forall (a b : Z) (_ : Bezout a b 1), rel_prime a b"
                ],
                "tactic_res": [
                    "c94_goal : Bezout (ZZ.to_Z n) d0 1"
                ]
            },
            {
                "tactic_sig": "destruct ( rel_prime_bezout _ _ _i ) as [ u v Huv ] .",
                "tactic_sig_no_out_arg": "destruct ( rel_prime_bezout _ _ _i ) as [ u v Huv ] .",
                "tactic_args": [
                    "c93_H : rel_prime (ZZ.to_Z n) (NN.to_Z d)",
                    "c84_Hzd : forall (x : Z) (_ : Z.divide x (ZZ.to_Z z))\n  (_ : Z.divide x (NN.to_Z d)),\nZ.divide x (Z.gcd (ZZ.to_Z z) (NN.to_Z d))",
                    "c84_Hd0 : Logic.eq (NN.to_Z d) (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c84_d0 : Z",
                    "c84_Hz0 : Logic.eq (ZZ.to_Z z) (Z.mul z0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c79_n0 : not (Logic.eq (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) 1%Z)",
                    "c80_H0 : Z.lt 0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c55_H' : Z.gt (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 1",
                    "c53_Hz : not (Logic.eq (ZZ.to_Z z) 0%Z)",
                    "c8_Hd : Z.lt 0 (NN.to_Z d)",
                    "c1_n : ZZ.t"
                ],
                "tactic_res": [
                    "c94_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z n)) (Z.mul v (NN.to_Z d))) 1%Z",
                    "c94_v : Z",
                    "c94_u : Z"
                ]
            },
            {
                "tactic_sig": "apply _i with _i ( _i * ( _i ( _i _i ) ( _i _i ) ) ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with _i ( _i * ( _i ( _i _i ) ( _i _i ) ) ) % _i .",
                "tactic_args": [
                    "c94_goal : Bezout (ZZ.to_Z n) d0 1",
                    "_global_Bezout_intro : forall (a b d u v : Z)\n         (_ : Logic.eq (Z.add (Z.mul u a) (Z.mul v b)) d), \n       Bezout a b d",
                    "c94_u : Z",
                    "c94_v : Z",
                    "_global_Z.gcd : forall (_ : Z) (_ : Z), Z",
                    "_global_ZZ.to_Z : forall _ : ZZ.t, Z",
                    "c1_z : ZZ.t",
                    "_global_NN.to_Z : forall _ : NN.t, Z",
                    "c1_d : NN.t",
                    "_global_Z : Set"
                ],
                "tactic_res": [
                    "c95_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0)) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c95_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0)) 1%Z",
                    "c94_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z n)) (Z.mul v (NN.to_Z d))) 1%Z"
                ],
                "tactic_res": [
                    "c96_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0))\n  (Z.add (Z.mul u (ZZ.to_Z n)) (Z.mul v (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i at _i .",
                "tactic_sig_no_out_arg": "rewrite _i at _i .",
                "tactic_args": [
                    "c96_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0))\n  (Z.add (Z.mul u (ZZ.to_Z n)) (Z.mul v (NN.to_Z d)))",
                    "c84_Hd0 : Logic.eq (NN.to_Z d) (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "_global_2 : Q"
                ],
                "tactic_res": [
                    "c97_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0))\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul v (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c97_goal : Logic.eq\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul (Z.mul v (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0))\n  (Z.add (Z.mul u (ZZ.to_Z n))\n     (Z.mul v (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i at _i .",
                "tactic_sig_no_out_arg": "rewrite _i at _i .",
                "tactic_args": [
                    "c92_goal : Logic.eq d0 (Z.div (NN.to_Z d) (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "c84_Hd0 : Logic.eq (NN.to_Z d) (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))",
                    "_global_1 : Q"
                ],
                "tactic_res": [
                    "c98_goal : Logic.eq d0\n  (Z.div (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c98_goal : Logic.eq d0\n  (Z.div (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))"
                ],
                "tactic_res": [
                    "c99_goal : Logic.eq\n  (Z.div (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c99_goal : Logic.eq\n  (Z.div (Z.mul d0 (Z.gcd (ZZ.to_Z z) (NN.to_Z d)))\n     (Z.gcd (ZZ.to_Z z) (NN.to_Z d))) d0",
                    "_global_Z_div_mult_full : forall (a b : Z) (_ : not (Logic.eq b 0%Z)),\n       Logic.eq (Z.div (Z.mul a b) b) a"
                ],
                "tactic_res": [
                    "c100_goal : not (Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0%Z)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c100_goal : not (Logic.eq (Z.gcd (ZZ.to_Z z) (NN.to_Z d)) 0%Z)",
                    "c1_d : NN.t",
                    "c1_z : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul_norm : forall x y , [ mul_norm x y ] = = [ x ] * [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mul_norm : forall x y , [ mul_norm x y ] = = [ x ] * [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))",
                    "_global_spec_mul : forall x y : t, Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (mul_norm x y)) (to_Q (mul x y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (mul_norm x y)) (to_Q (mul x y))",
                    "_global_mul_norm : forall (_ : t) (_ : t), t",
                    "_global_mul : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c4_goal : Qeq\n  (to_Q\n     match x with\n     | Qz zx =>\n         match y with\n         | Qz zy => Qz (ZZ.mul zx zy)\n         | Qq ny dy => mul_norm_Qz_Qq zx ny dy\n         end\n     | Qq nx dx =>\n         match y with\n         | Qz zy => mul_norm_Qz_Qq zy nx dx\n         | Qq ny dy =>\n             let (nx0, dy0) := irred nx dy in\n             let (ny0, dx0) := irred ny dx in\n             norm_denum (ZZ.mul ny0 nx0) (NN.mul dx0 dy0)\n         end\n     end)\n  (to_Q\n     match x with\n     | Qz zx =>\n         match y with\n         | Qz zy => Qz (ZZ.mul zx zy)\n         | Qq ny dy => Qq (ZZ.mul zx ny) dy\n         end\n     | Qq nx dx =>\n         match y with\n         | Qz zy => Qq (ZZ.mul nx zy) dx\n         | Qq ny dy => Qq (ZZ.mul nx ny) (NN.mul dx dy)\n         end\n     end)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : Qeq\n  (to_Q\n     match x with\n     | Qz zx =>\n         match y with\n         | Qz zy => Qz (ZZ.mul zx zy)\n         | Qq ny dy => mul_norm_Qz_Qq zx ny dy\n         end\n     | Qq nx dx =>\n         match y with\n         | Qz zy => mul_norm_Qz_Qq zy nx dx\n         | Qq ny dy =>\n             let (nx0, dy0) := irred nx dy in\n             let (ny0, dx0) := irred ny dx in\n             norm_denum (ZZ.mul ny0 nx0) (NN.mul dx0 dy0)\n         end\n     end)\n  (to_Q\n     match x with\n     | Qz zx =>\n         match y with\n         | Qz zy => Qz (ZZ.mul zx zy)\n         | Qq ny dy => Qq (ZZ.mul zx ny) dy\n         end\n     | Qq nx dx =>\n         match y with\n         | Qz zy => Qq (ZZ.mul nx zy) dx\n         | Qq ny dy => Qq (ZZ.mul nx ny) (NN.mul dx dy)\n         end\n     end)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": [
                    "c5_goal : Qeq\n  (to_Q\n     match y with\n     | Qz zy => Qz (ZZ.mul t0 zy)\n     | Qq ny dy => mul_norm_Qz_Qq t0 ny dy\n     end)\n  (to_Q\n     match y with\n     | Qz zy => Qz (ZZ.mul t0 zy)\n     | Qq ny dy => Qq (ZZ.mul t0 ny) dy\n     end)",
                    "c5_t0 : ZZ.t",
                    "c6_goal : Qeq\n  (to_Q\n     match y with\n     | Qz zy => mul_norm_Qz_Qq zy t0 t1\n     | Qq ny dy =>\n         let (nx, dy0) := irred t0 dy in\n         let (ny0, dx) := irred ny t1 in\n         norm_denum (ZZ.mul ny0 nx) (NN.mul dx dy0)\n     end)\n  (to_Q\n     match y with\n     | Qz zy => Qq (ZZ.mul t0 zy) t1\n     | Qq ny dy => Qq (ZZ.mul t0 ny) (NN.mul t1 dy)\n     end)",
                    "c6_t1 : NN.t",
                    "c6_t0 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : Qeq\n  (to_Q\n     match y with\n     | Qz zy => Qz (ZZ.mul t0 zy)\n     | Qq ny dy => mul_norm_Qz_Qq t0 ny dy\n     end)\n  (to_Q\n     match y with\n     | Qz zy => Qz (ZZ.mul t0 zy)\n     | Qq ny dy => Qq (ZZ.mul t0 ny) dy\n     end)",
                    "c2_y : True",
                    "c5_t0 : ZZ.t"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (Qz (ZZ.mul t0 t1))) (to_Q (Qz (ZZ.mul t0 t1)))",
                    "c7_t1 : ZZ.t",
                    "c8_goal : Qeq (to_Q (mul_norm_Qz_Qq t0 t1 t2)) (to_Q (Qq (ZZ.mul t0 t1) t2))",
                    "c8_t2 : NN.t",
                    "c8_t1 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : Qeq\n  (to_Q\n     match y with\n     | Qz zy => mul_norm_Qz_Qq zy t0 t1\n     | Qq ny dy =>\n         let (nx, dy0) := irred t0 dy in\n         let (ny0, dx) := irred ny t1 in\n         norm_denum (ZZ.mul ny0 nx) (NN.mul dx dy0)\n     end)\n  (to_Q\n     match y with\n     | Qz zy => Qq (ZZ.mul t0 zy) t1\n     | Qq ny dy => Qq (ZZ.mul t0 ny) (NN.mul t1 dy)\n     end)",
                    "c2_y : True",
                    "c6_t1 : NN.t",
                    "c6_t0 : ZZ.t"
                ],
                "tactic_res": [
                    "c9_goal : Qeq (to_Q (mul_norm_Qz_Qq t2 t0 t1)) (to_Q (Qq (ZZ.mul t0 t2) t1))",
                    "c9_t2 : ZZ.t",
                    "c10_goal : Qeq\n  (to_Q\n     (let (nx, dy) := irred t0 t3 in\n      let (ny, dx) := irred t2 t1 in\n      norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))\n  (to_Q (Qq (ZZ.mul t0 t2) (NN.mul t1 t3)))",
                    "c10_t3 : NN.t",
                    "c10_t2 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (Qz (ZZ.mul t0 t1))) (to_Q (Qz (ZZ.mul t0 t1)))",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q (mul_norm_Qz_Qq t0 t1 t2)) (to_Q (Qq (ZZ.mul t0 t1) t2))",
                    "_global_spec_mul_norm_Qz_Qq : forall (z n : ZZ.t) (d : NN.t),\n       Qeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Qeq (to_Q (mul_norm_Qz_Qq t2 t0 t1)) (to_Q (Qq (ZZ.mul t0 t2) t1))",
                    "_global_spec_mul_norm_Qz_Qq : forall (z n : ZZ.t) (d : NN.t),\n       Qeq (to_Q (mul_norm_Qz_Qq z n d)) (to_Q (Qq (ZZ.mul z n) d))"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q (Qq (ZZ.mul t2 t0) t1)) (to_Q (Qq (ZZ.mul t0 t2) t1))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q (Qq (ZZ.mul t2 t0) t1)) (to_Q (Qq (ZZ.mul t0 t2) t1))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z t2) (ZZ.to_Z t0)) (NN.to_Z t1))\n  (Z.mul (Z.mul (ZZ.to_Z t0) (ZZ.to_Z t2)) (NN.to_Z t1))",
                    "c12_H : Z.lt 0 (NN.to_Z t1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.mul (Z.mul (ZZ.to_Z t2) (ZZ.to_Z t0)) (NN.to_Z t1))\n  (Z.mul (Z.mul (ZZ.to_Z t0) (ZZ.to_Z t2)) (NN.to_Z t1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rename _i into nx , _i into dy , _i into ny , _i into dx .",
                "tactic_sig_no_out_arg": "rename _i into nx , _i into dy , _i into ny , _i into dx .",
                "tactic_args": [
                    "c10_goal : Qeq\n  (to_Q\n     (let (nx, dy) := irred t0 t3 in\n      let (ny, dx) := irred t2 t1 in\n      norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))\n  (to_Q (Qq (ZZ.mul t0 t2) (NN.mul t1 t3)))",
                    "c6_t0 : ZZ.t",
                    "c10_t3 : NN.t",
                    "c10_t2 : ZZ.t",
                    "c6_t1 : NN.t"
                ],
                "tactic_res": [
                    "c13_goal : Qeq\n  (to_Q\n     (let (nx, dy) := irred nx dy in\n      let (ny, dx) := irred ny dx in\n      norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_nx : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_irred _i _i ) as ( g & Hg ) .",
                "tactic_sig_no_out_arg": "destruct ( spec_irred _i _i ) as ( g & Hg ) .",
                "tactic_args": [
                    "c13_nx : ZZ.t",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t"
                ],
                "tactic_res": [
                    "c13_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c13_g : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_irred _i _i ) as ( g' & Hg' ) .",
                "tactic_sig_no_out_arg": "destruct ( spec_irred _i _i ) as ( g' & Hg' ) .",
                "tactic_args": [
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c13_dy : NN.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c13_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c13_g' : Z"
                ]
            },
            {
                "tactic_sig": "assert ( Hz := spec_irred_zero _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hz := spec_irred_zero _i _i ) .",
                "tactic_args": [
                    "c13_nx : ZZ.t",
                    "c13_dy : NN.t"
                ],
                "tactic_res": [
                    "c13_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred nx dy))) 0%Z)"
                ]
            },
            {
                "tactic_sig": "assert ( Hz' := spec_irred_zero _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hz' := spec_irred_zero _i _i ) .",
                "tactic_args": [
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t"
                ],
                "tactic_res": [
                    "c13_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)"
                ]
            },
            {
                "tactic_sig": "destruct irred as ( n1 , d1 ) .",
                "tactic_sig_no_out_arg": "destruct irred as ( n1 , d1 ) .",
                "tactic_args": [
                    "c13_goal : Qeq\n  (to_Q\n     (let (nx, dy) := irred nx dy in\n      let (ny, dx) := irred ny dx in\n      norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "c13_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)",
                    "c13_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred nx dy))) 0%Z)",
                    "c13_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c13_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c14_goal : Qeq\n  (to_Q\n     (let (ny, dx) := irred ny dx in\n      norm_denum (ZZ.mul ny n1) (NN.mul dx d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "c14_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n1 d1))) 0%Z)",
                    "c14_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c14_d1 : NN.t",
                    "c14_n1 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct irred as ( n2 , d2 ) .",
                "tactic_sig_no_out_arg": "destruct irred as ( n2 , d2 ) .",
                "tactic_args": [
                    "c14_goal : Qeq\n  (to_Q\n     (let (ny, dx) := irred ny dx in\n      norm_denum (ZZ.mul ny n1) (NN.mul dx d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "c13_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)",
                    "c14_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n1 d1))) 0%Z)",
                    "c13_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c14_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c14_d1 : NN.t",
                    "c14_n1 : ZZ.t",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c15_goal : Qeq (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "c15_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n2 d2))) 0%Z)",
                    "c15_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c15_d2 : NN.t",
                    "c15_n2 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hg1 Hg2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hg1 Hg2 ] .",
                "tactic_args": [
                    "c14_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c15_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c15_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c15_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c15_d2 : NN.t",
                    "c15_n2 : ZZ.t",
                    "c14_d1 : NN.t",
                    "c14_n1 : ZZ.t",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c15_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c15_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hg1' Hg2' ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hg1' Hg2' ] .",
                "tactic_args": [
                    "c15_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c15_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c15_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c15_d2 : NN.t",
                    "c15_n2 : ZZ.t",
                    "c15_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c15_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)",
                    "c14_d1 : NN.t",
                    "c14_n1 : ZZ.t",
                    "c13_dy : NN.t",
                    "c13_ny : ZZ.t",
                    "c13_dx : NN.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c15_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)",
                    "c15_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : Qeq (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))",
                    "_global_spec_norm_denum : forall (n : ZZ.t) (d : NN.t),\n       Qeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c16_goal : Qeq (to_Q (Qq (ZZ.mul n2 n1) (NN.mul d2 d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c16_goal : Qeq (to_Q (Qq (ZZ.mul n2 n1) (NN.mul d2 d1)))\n  (to_Q (Qq (ZZ.mul nx ny) (NN.mul dx dy)))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c17_e : Logic.eq (Z.mul (NN.to_Z d2) (NN.to_Z d1)) 0%Z",
                    "c17_H : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))",
                    "c18_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z",
                    "c18_H : Z.lt 0 (Z.mul (NN.to_Z d2) (NN.to_Z d1))",
                    "c18_e : Logic.eq (Z.mul (NN.to_Z dx) (NN.to_Z dy)) 0%Z",
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1)))",
                    "c19_H0 : Z.lt 0 (Z.mul (NN.to_Z d2) (NN.to_Z d1))",
                    "c19_H : Z.lt 0 (Z.mul (NN.to_Z dx) (NN.to_Z dy))"
                ]
            },
            {
                "tactic_sig": "spec_mul_norm_tac .",
                "tactic_sig_no_out_arg": "spec_mul_norm_tac .",
                "tactic_args": [
                    "c17_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c20_Eq : Logic.eq (NN.to_Z d2) 0%Z",
                    "c21_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c21_Eq : Logic.eq (NN.to_Z d1) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c20_Eq : Logic.eq (NN.to_Z d2) 0%Z"
                ],
                "tactic_res": [
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq 0%Z 0%Z)",
                    "c20_Hg2' : Logic.eq (Z.mul 0%Z g') (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in * .",
                "tactic_sig_no_out_arg": "rewrite <- _i in * .",
                "tactic_args": [
                    "c20_Hg2' : Logic.eq 0%Z (NN.to_Z dx)"
                ],
                "tactic_res": [
                    "c20_H : Z.lt 0 (Z.mul 0%Z (NN.to_Z dy))",
                    "c20_Hz' : iff (Logic.eq 0%Z 0%Z) (Logic.eq 0%Z 0%Z)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c20_H : Z.lt 0 (Z.mul 0%Z (NN.to_Z dy))",
                    "c13_ny : ZZ.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c21_Eq : Logic.eq (NN.to_Z d1) 0%Z"
                ],
                "tactic_res": [
                    "c21_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq 0%Z 0%Z)",
                    "c21_Hg2 : Logic.eq (Z.mul 0%Z g) (NN.to_Z dy)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in * .",
                "tactic_sig_no_out_arg": "rewrite <- _i in * .",
                "tactic_args": [
                    "c21_Hg2 : Logic.eq 0%Z (NN.to_Z dy)"
                ],
                "tactic_res": [
                    "c21_H : Z.lt 0 (Z.mul (NN.to_Z dx) 0%Z)",
                    "c21_Hz : iff (Logic.eq 0%Z 0%Z) (Logic.eq 0%Z 0%Z)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Logic.eq 0%Z (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))",
                    "c21_H : Z.lt 0 (Z.mul (NN.to_Z dx) 0%Z)",
                    "c13_ny : ZZ.t",
                    "c13_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "spec_mul_norm_tac .",
                "tactic_sig_no_out_arg": "spec_mul_norm_tac .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z",
                    "c22_Eq : Logic.eq (NN.to_Z dx) 0%Z",
                    "c23_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z",
                    "c23_Eq : Logic.eq (NN.to_Z dy) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c15_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c22_Eq : Logic.eq (NN.to_Z dx) 0%Z"
                ],
                "tactic_res": [
                    "c22_Eq : Logic.eq (NN.to_Z d2) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c22_Eq : Logic.eq (NN.to_Z d2) 0%Z"
                ],
                "tactic_res": [
                    "c22_H : Z.lt 0 (Z.mul 0%Z (NN.to_Z d1))",
                    "c22_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq 0%Z 0%Z)",
                    "c22_Hg2' : Logic.eq (Z.mul 0%Z g') (NN.to_Z dx)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z",
                    "c22_H : Z.lt 0 (Z.mul 0%Z (NN.to_Z d1))",
                    "c15_n2 : ZZ.t",
                    "c14_n1 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c15_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c23_Eq : Logic.eq (NN.to_Z dy) 0%Z"
                ],
                "tactic_res": [
                    "c23_Eq : Logic.eq (NN.to_Z d1) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c23_Eq : Logic.eq (NN.to_Z d1) 0%Z"
                ],
                "tactic_res": [
                    "c23_H : Z.lt 0 (Z.mul (NN.to_Z d2) 0%Z)",
                    "c23_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq 0%Z 0%Z)",
                    "c23_Hg2 : Logic.eq (Z.mul 0%Z g) (NN.to_Z dy)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : Logic.eq (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1)) 0%Z",
                    "c23_H : Z.lt 0 (Z.mul (NN.to_Z d2) 0%Z)",
                    "c15_n2 : ZZ.t",
                    "c14_n1 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i , <- _i , <- _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , <- _i , <- _i , <- _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z dx) (NN.to_Z dy)))\n  (Z.mul (Z.mul (ZZ.to_Z nx) (ZZ.to_Z ny))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1)))",
                    "c15_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)",
                    "c15_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c15_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)",
                    "c15_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (Z.mul (NN.to_Z d2) g') (Z.mul (NN.to_Z d1) g)))\n  (Z.mul (Z.mul (Z.mul (ZZ.to_Z n1) g) (Z.mul (ZZ.to_Z n2) g'))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1)))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c24_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (Z.mul (NN.to_Z d2) g') (Z.mul (NN.to_Z d1) g)))\n  (Z.mul (Z.mul (Z.mul (ZZ.to_Z n1) g) (Z.mul (ZZ.to_Z n2) g'))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_mul_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_mul_norm x y : forall ` ( Reduced x , Reduced y ) , Reduced ( mul_norm x y ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_mul_norm x y : forall ` ( Reduced x , Reduced y ) , Reduced ( mul_norm x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : Reduced x) (_ : Reduced y), Reduced (mul_norm x y)",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (_ : Reduced x) (_ : Reduced y), Reduced (mul_norm x y)",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : Logic.eq (to_Q (red x)) (to_Q x))\n  (_ : Logic.eq (to_Q (red y)) (to_Q y)),\nLogic.eq (to_Q (red (mul_norm x y))) (to_Q (mul_norm x y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (_ : Logic.eq (to_Q (red x)) (to_Q x))\n  (_ : Logic.eq (to_Q (red y)) (to_Q y)),\nLogic.eq (to_Q (red (mul_norm x y))) (to_Q (mul_norm x y))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (mul_norm x y))) (to_Q (mul_norm x y))",
                    "c3_H : Logic.eq (to_Q (red x)) (to_Q x)",
                    "c3_H0 : Logic.eq (to_Q (red y)) (to_Q y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (mul_norm x y))) (to_Q (mul_norm x y))",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm x y)))\n     (Zpos (Qden (to_Q (mul_norm x y))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ zx|nx dx ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zx|nx dx ] .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm x y)))\n     (Zpos (Qden (to_Q (mul_norm x y))))) 1%Z",
                    "c1_x : True",
                    "c3_H0 : Logic.eq (to_Q (red y)) (to_Q y)",
                    "c3_H : Logic.eq (to_Q (red x)) (to_Q x)",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) y)))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) y))))) 1%Z",
                    "c5_H : Logic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))",
                    "c5_zx : ZZ.t",
                    "c6_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) y)))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) y))))) 1%Z",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c6_dx : NN.t",
                    "c6_nx : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ zy|ny dy ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zy|ny dy ] .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) y)))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) y))))) 1%Z",
                    "c1_y : True",
                    "c3_H0 : Logic.eq (to_Q (red y)) (to_Q y)",
                    "c5_H : Logic.eq (to_Q (red (Qz zx))) (to_Q (Qz zx))",
                    "c5_zx : ZZ.t"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) (Qz zy))))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) (Qz zy)))))) 1%Z",
                    "c7_H0 : Logic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))",
                    "c7_zy : ZZ.t",
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) (Qq ny dy))))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) (Qq ny dy)))))) 1%Z",
                    "c8_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c8_dy : NN.t",
                    "c8_ny : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ zy|ny dy ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ zy|ny dy ] .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) y)))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) y))))) 1%Z",
                    "c1_y : True",
                    "c3_H0 : Logic.eq (to_Q (red y)) (to_Q y)",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c6_dx : NN.t",
                    "c6_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) (Qz zy))))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) (Qz zy)))))) 1%Z",
                    "c9_H0 : Logic.eq (to_Q (red (Qz zy))) (to_Q (Qz zy))",
                    "c9_zy : ZZ.t",
                    "c10_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) (Qq ny dy))))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) (Qq ny dy)))))) 1%Z",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c10_dy : NN.t",
                    "c10_ny : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) (Qz zy))))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) (Qz zy)))))) 1%Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.gcd (ZZ.to_Z (ZZ.mul zx zy)) 1%Z) 1%Z",
                    "c11_H0 : Logic.eq {| Qnum := ZZ.to_Z zy; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zy; Qden := 1 |}",
                    "c11_H : Logic.eq {| Qnum := ZZ.to_Z zx; Qden := 1 |}\n  {| Qnum := ZZ.to_Z zx; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.gcd (ZZ.to_Z (ZZ.mul zx zy)) 1%Z) 1%Z",
                    "c5_zx : ZZ.t",
                    "c7_zy : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qz zx) (Qq ny dy))))\n     (Zpos (Qden (to_Q (mul_norm (Qz zx) (Qq ny dy)))))) 1%Z"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq zx ny dy)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq zx ny dy))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , <- _i , _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq zx ny dy)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq zx ny dy))))) 1%Z",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_strong_spec_mul_norm_Qz_Qq : forall (z n : ZZ.t) (d : NN.t) (_ : Reduced (Qq n d)),\n       Reduced (mul_norm_Qz_Qq z n d)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Q (mul_norm_Qz_Qq zx ny dy))\n  (to_Q (mul_norm_Qz_Qq zx ny dy))",
                    "c14_goal : Reduced (Qq ny dy)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Q (mul_norm_Qz_Qq zx ny dy))\n  (to_Q (mul_norm_Qz_Qq zx ny dy))",
                    "c8_dy : NN.t",
                    "c5_zx : ZZ.t",
                    "c8_ny : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Reduced (Qq ny dy)",
                    "c8_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c8_dy : NN.t",
                    "c8_ny : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) (Qz zy))))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) (Qz zy)))))) 1%Z"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq zy nx dx)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq zy nx dx))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , <- _i , _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm_Qz_Qq zy nx dx)))\n     (Zpos (Qden (to_Q (mul_norm_Qz_Qq zy nx dx))))) 1%Z",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_strong_spec_mul_norm_Qz_Qq : forall (z n : ZZ.t) (d : NN.t) (_ : Reduced (Qq n d)),\n       Reduced (mul_norm_Qz_Qq z n d)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (to_Q (mul_norm_Qz_Qq zy nx dx))\n  (to_Q (mul_norm_Qz_Qq zy nx dx))",
                    "c17_goal : Reduced (Qq nx dx)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Logic.eq (to_Q (mul_norm_Qz_Qq zy nx dx))\n  (to_Q (mul_norm_Qz_Qq zy nx dx))",
                    "c9_zy : ZZ.t",
                    "c6_dx : NN.t",
                    "c6_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Reduced (Qq nx dx)",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c6_dx : NN.t",
                    "c6_nx : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (mul_norm (Qq nx dx) (Qq ny dy))))\n     (Zpos (Qden (to_Q (mul_norm (Qq nx dx) (Qq ny dy)))))) 1%Z"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (let (nx, dy) := irred nx dy in\n            let (ny, dx) := irred ny dx in\n            norm_denum (ZZ.mul ny nx) (NN.mul dx dy))))\n     (Zpos\n        (Qden\n           (to_Q\n              (let (nx, dy) := irred nx dy in\n               let (ny, dx) := irred ny dx in\n               norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_irred _i _i ) as [ g Hg ] .",
                "tactic_sig_no_out_arg": "destruct ( spec_irred _i _i ) as [ g Hg ] .",
                "tactic_args": [
                    "c6_nx : ZZ.t",
                    "c10_dy : NN.t",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t"
                ],
                "tactic_res": [
                    "c18_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c18_g : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_irred _i _i ) as [ g' Hg' ] .",
                "tactic_sig_no_out_arg": "destruct ( spec_irred _i _i ) as [ g' Hg' ] .",
                "tactic_args": [
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t",
                    "c18_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c10_dy : NN.t",
                    "c6_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c18_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c18_g' : Z"
                ]
            },
            {
                "tactic_sig": "assert ( Hz := spec_irred_zero _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hz := spec_irred_zero _i _i ) .",
                "tactic_args": [
                    "c6_nx : ZZ.t",
                    "c10_dy : NN.t"
                ],
                "tactic_res": [
                    "c18_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred nx dy))) 0%Z)"
                ]
            },
            {
                "tactic_sig": "assert ( Hz' := spec_irred_zero _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hz' := spec_irred_zero _i _i ) .",
                "tactic_args": [
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t"
                ],
                "tactic_res": [
                    "c18_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)"
                ]
            },
            {
                "tactic_sig": "assert ( Hgc := strong_spec_irred _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hgc := strong_spec_irred _i _i ) .",
                "tactic_args": [
                    "c6_nx : ZZ.t",
                    "c10_dy : NN.t"
                ],
                "tactic_res": [
                    "c18_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nlet (n', d') := irred nx dy in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ]
            },
            {
                "tactic_sig": "assert ( Hgc' := strong_spec_irred _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hgc' := strong_spec_irred _i _i ) .",
                "tactic_args": [
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t"
                ],
                "tactic_res": [
                    "c18_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nlet (n', d') := irred ny dx in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z"
                ]
            },
            {
                "tactic_sig": "destruct irred as ( n1 , d1 ) .",
                "tactic_sig_no_out_arg": "destruct irred as ( n1 , d1 ) .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (let (nx, dy) := irred nx dy in\n            let (ny, dx) := irred ny dx in\n            norm_denum (ZZ.mul ny nx) (NN.mul dx dy))))\n     (Zpos\n        (Qden\n           (to_Q\n              (let (nx, dy) := irred nx dy in\n               let (ny, dx) := irred ny dx in\n               norm_denum (ZZ.mul ny nx) (NN.mul dx dy)))))) 1%Z",
                    "c18_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nlet (n', d') := irred ny dx in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z",
                    "c18_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nlet (n', d') := irred nx dy in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z",
                    "c18_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)",
                    "c18_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred nx dy))) 0%Z)",
                    "c18_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c18_Hg : let (n', d') := irred nx dy in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d') g) (NN.to_Z dy))",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c10_dy : NN.t",
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t",
                    "c6_nx : ZZ.t"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (let (ny, dx) := irred ny dx in\n            norm_denum (ZZ.mul ny n1) (NN.mul dx d1))))\n     (Zpos\n        (Qden\n           (to_Q\n              (let (ny, dx) := irred ny dx in\n               norm_denum (ZZ.mul ny n1) (NN.mul dx d1)))))) 1%Z",
                    "c19_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c19_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n1 d1))) 0%Z)",
                    "c19_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c19_d1 : NN.t",
                    "c19_n1 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct irred as ( n2 , d2 ) .",
                "tactic_sig_no_out_arg": "destruct irred as ( n2 , d2 ) .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (let (ny, dx) := irred ny dx in\n            norm_denum (ZZ.mul ny n1) (NN.mul dx d1))))\n     (Zpos\n        (Qden\n           (to_Q\n              (let (ny, dx) := irred ny dx in\n               norm_denum (ZZ.mul ny n1) (NN.mul dx d1)))))) 1%Z",
                    "c18_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nlet (n', d') := irred ny dx in\nLogic.eq (Z.gcd (ZZ.to_Z n') (NN.to_Z d')) 1%Z",
                    "c19_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c18_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (irred ny dx))) 0%Z)",
                    "c19_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n1 d1))) 0%Z)",
                    "c18_Hg' : let (n', d') := irred ny dx in\nand (Logic.eq (Z.mul (ZZ.to_Z n') g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d') g') (NN.to_Z dx))",
                    "c19_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c19_d1 : NN.t",
                    "c19_n1 : ZZ.t",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c10_ny : ZZ.t",
                    "c6_dx : NN.t"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1))))\n     (Zpos (Qden (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1))))))\n  1%Z",
                    "c20_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z)\n  (Logic.eq (NN.to_Z (snd (pair n2 d2))) 0%Z)",
                    "c20_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c20_d2 : NN.t",
                    "c20_n2 : ZZ.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hg1 Hg2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hg1 Hg2 ] .",
                "tactic_args": [
                    "c19_Hg : and (Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx))\n  (Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy))",
                    "c20_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c19_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c20_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c20_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c20_d2 : NN.t",
                    "c20_n2 : ZZ.t",
                    "c19_d1 : NN.t",
                    "c19_n1 : ZZ.t",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))"
                ],
                "tactic_res": [
                    "c20_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c20_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hg1' Hg2' ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hg1' Hg2' ] .",
                "tactic_args": [
                    "c20_Hg' : and (Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny))\n  (Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx))",
                    "c20_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c19_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c20_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c20_d2 : NN.t",
                    "c20_n2 : ZZ.t",
                    "c20_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c20_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)",
                    "c19_d1 : NN.t",
                    "c19_n1 : ZZ.t",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))"
                ],
                "tactic_res": [
                    "c20_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)",
                    "c20_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c20_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1))))\n     (Zpos (Qden (to_Q (norm_denum (ZZ.mul n2 n1) (NN.mul d2 d1))))))\n  1%Z",
                    "_global_norm_denum : forall (_ : ZZ.t) (_ : NN.t), t_"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.mul d2 d1) NN.one\n            then Qz (ZZ.mul n2 n1)\n            else Qq (ZZ.mul n2 n1) (NN.mul d2 d1))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.mul d2 d1) NN.one\n               then Qz (ZZ.mul n2 n1)\n               else Qq (ZZ.mul n2 n1) (NN.mul d2 d1)))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "qsimpl .",
                "tactic_sig_no_out_arg": "qsimpl .",
                "tactic_args": [
                    "c21_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           (if NN.eqb (NN.mul d2 d1) NN.one\n            then Qz (ZZ.mul n2 n1)\n            else Qq (ZZ.mul n2 n1) (NN.mul d2 d1))))\n     (Zpos\n        (Qden\n           (to_Q\n              (if NN.eqb (NN.mul d2 d1) NN.one\n               then Qz (ZZ.mul n2 n1)\n               else Qq (ZZ.mul n2 n1) (NN.mul d2 d1)))))) 1%Z"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c22_n : not (Logic.eq (Z.mul (NN.to_Z d2) (NN.to_Z d1)) 1%Z)",
                    "c22_H1 : Z.lt 0 (Z.mul (NN.to_Z d2) (NN.to_Z d1))"
                ]
            },
            {
                "tactic_sig": "assert ( NEQ : NN.to_Z _i <> 0 % Z ) by ( rewrite _i ; intros EQ ; rewrite EQ in * ; lia ) .",
                "tactic_sig_no_out_arg": "assert ( NEQ : NN.to_Z _i <> 0 % Z ) by ( rewrite _i ; intros EQ ; rewrite EQ in * ; lia ) .",
                "tactic_args": [
                    "c10_dy : NN.t",
                    "c20_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)"
                ],
                "tactic_res": [
                    "c22_NEQ : not (Logic.eq (NN.to_Z dy) 0%Z)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c22_Hgc : forall _ : not (Logic.eq (NN.to_Z dy) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c22_NEQ : not (Logic.eq (NN.to_Z dy) 0%Z)"
                ],
                "tactic_res": [
                    "c22_Hgc : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z"
                ]
            },
            {
                "tactic_sig": "assert ( NEQ' : NN.to_Z _i <> 0 % Z ) by ( rewrite _i ; intro EQ ; rewrite EQ in * ; lia ) .",
                "tactic_sig_no_out_arg": "assert ( NEQ' : NN.to_Z _i <> 0 % Z ) by ( rewrite _i ; intro EQ ; rewrite EQ in * ; lia ) .",
                "tactic_args": [
                    "c6_dx : NN.t",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)"
                ],
                "tactic_res": [
                    "c22_NEQ' : not (Logic.eq (NN.to_Z dx) 0%Z)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c22_Hgc' : forall _ : not (Logic.eq (NN.to_Z dx) 0%Z),\nLogic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c22_NEQ' : not (Logic.eq (NN.to_Z dx) 0%Z)"
                ],
                "tactic_res": [
                    "c22_Hgc' : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z"
                ]
            },
            {
                "tactic_sig": "revert _i _i .",
                "tactic_sig_no_out_arg": "revert _i _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c6_H : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx))",
                    "c10_H0 : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))"
                ],
                "tactic_res": [
                    "c23_goal : forall (_ : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx)))\n  (_ : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i _i , _i _i .",
                "tactic_sig_no_out_arg": "rewrite _i _i , _i _i .",
                "tactic_args": [
                    "c23_goal : forall (_ : Logic.eq (to_Q (red (Qq nx dx))) (to_Q (Qq nx dx)))\n  (_ : Logic.eq (to_Q (red (Qq ny dy))) (to_Q (Qq ny dy))),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "_global_2 : Q",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_2 : Q",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  (_ : Logic.eq\n         (Z.gcd (Qnum (to_Q (Qq nx dx)))\n            (Zpos (Qden (to_Q (Qq nx dx))))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd (Qnum (to_Q (Qq ny dy)))\n            (Zpos (Qden (to_Q (Qq ny dy))))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c24_goal : forall\n  (_ : Logic.eq\n         (Z.gcd (Qnum (to_Q (Qq nx dx)))\n            (Zpos (Qden (to_Q (Qq nx dx))))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd (Qnum (to_Q (Qq ny dy)))\n            (Zpos (Qden (to_Q (Qq ny dy))))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c25_goal : forall\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               (if NN.eqb dx NN.zero\n                then 0\n                else\n                 {|\n                   Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                 |}))\n            (Zpos\n               (Qden\n                  (if NN.eqb dx NN.zero\n                   then 0\n                   else\n                    {|\n                      Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                    |})))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               (if NN.eqb dy NN.zero\n                then 0\n                else\n                 {|\n                   Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                 |}))\n            (Zpos\n               (Qden\n                  (if NN.eqb dy NN.zero\n                   then 0\n                   else\n                    {|\n                      Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                    |})))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c25_goal : forall\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               (if NN.eqb dx NN.zero\n                then 0\n                else\n                 {|\n                   Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                 |}))\n            (Zpos\n               (Qden\n                  (if NN.eqb dx NN.zero\n                   then 0\n                   else\n                    {|\n                      Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                    |})))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               (if NN.eqb dy NN.zero\n                then 0\n                else\n                 {|\n                   Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                 |}))\n            (Zpos\n               (Qden\n                  (if NN.eqb dy NN.zero\n                   then 0\n                   else\n                    {|\n                      Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                    |})))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c26_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z)\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c27_goal : forall (_ : Z.lt 0 (NN.to_Z dy))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                  |}))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c28_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                  |}))) 1%Z)\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c29_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                  |}))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                  |}))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c26_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z)\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c30_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero)) (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c30_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero)) (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c31_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Logic.eq (NN.to_Z dx) 0%Z)\n  (_ : Logic.eq 1%Z 1%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c31_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Logic.eq (NN.to_Z dx) 0%Z)\n  (_ : Logic.eq 1%Z 1%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c27_goal : forall (_ : Z.lt 0 (NN.to_Z dy))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                  |}))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c32_goal : forall (_ : Z.lt 0 (NN.to_Z dy))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero)) (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c32_goal : forall (_ : Z.lt 0 (NN.to_Z dy))\n  (_ : Logic.eq (NN.to_Z dx) (NN.to_Z NN.zero)) (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c33_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Logic.eq (NN.to_Z dx) 0%Z)\n  (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c33_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Logic.eq (NN.to_Z dx) 0%Z)\n  (_ : Logic.eq 1%Z 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                  |}))) 1%Z)\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c34_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c34_goal : forall (_ : Logic.eq (NN.to_Z dy) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c35_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c35_goal : forall (_ : Logic.eq (NN.to_Z dy) 0%Z) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z nx; Qden := Z.to_pos (NN.to_Z dx)\n                  |}))) 1%Z)\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum\n               {| Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy) |})\n            (Zpos\n               (Qden\n                  {|\n                    Qnum := ZZ.to_Z ny; Qden := Z.to_pos (NN.to_Z dy)\n                  |}))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c36_goal : forall (_ : Z.lt 0 (NN.to_Z dy)) (_ : Z.lt 0 (NN.to_Z dx))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z)\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z),\nLogic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c37_H : Z.lt 0 (NN.to_Z dy)",
                    "c37_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c37_H2 : Logic.eq (Z.gcd (ZZ.to_Z nx) (Zpos (Z.to_pos (NN.to_Z dx)))) 1%Z",
                    "c37_H3 : Logic.eq (Z.gcd (ZZ.to_Z ny) (Zpos (Z.to_pos (NN.to_Z dy)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c37_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c38_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c38_H3 : Logic.eq (Z.gcd (ZZ.to_Z ny) (NN.to_Z dy)) 1%Z",
                    "c38_H2 : Logic.eq (Z.gcd (ZZ.to_Z nx) (NN.to_Z dx)) 1%Z",
                    "c39_goal : Z.lt 0 (NN.to_Z dx)",
                    "c39_H3 : Logic.eq (Z.gcd (ZZ.to_Z ny) (NN.to_Z dy)) 1%Z",
                    "c40_goal : Z.lt 0 (NN.to_Z dy)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : Z.lt 0 (NN.to_Z dx)",
                    "c37_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c6_dx : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : Z.lt 0 (NN.to_Z dy)",
                    "c37_H : Z.lt 0 (NN.to_Z dy)",
                    "c10_dy : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : Logic.eq\n  (Z.gcd (Z.mul (ZZ.to_Z n2) (ZZ.to_Z n1))\n     (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "_global_Zgcd_mult_rel_prime : forall (a b c : Z) (_ : Logic.eq (Z.gcd a c) 1%Z)\n         (_ : Logic.eq (Z.gcd b c) 1%Z), Logic.eq (Z.gcd (Z.mul a b) c) 1%Z"
                ],
                "tactic_res": [
                    "c41_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "c42_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c41_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c43_goal : Logic.eq (Z.gcd (Z.mul (NN.to_Z d2) (NN.to_Z d1)) (ZZ.to_Z n2)) 1%Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c43_goal : Logic.eq (Z.gcd (Z.mul (NN.to_Z d2) (NN.to_Z d1)) (ZZ.to_Z n2)) 1%Z",
                    "_global_Zgcd_mult_rel_prime : forall (a b c : Z) (_ : Logic.eq (Z.gcd a c) 1%Z)\n         (_ : Logic.eq (Z.gcd b c) 1%Z), Logic.eq (Z.gcd (Z.mul a b) c) 1%Z"
                ],
                "tactic_res": [
                    "c44_goal : Logic.eq (Z.gcd (NN.to_Z d2) (ZZ.to_Z n2)) 1%Z",
                    "c45_goal : Logic.eq (Z.gcd (NN.to_Z d1) (ZZ.to_Z n2)) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c44_goal : Logic.eq (Z.gcd (NN.to_Z d2) (ZZ.to_Z n2)) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c22_Hgc' : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d2)) 1%Z",
                    "c20_d2 : NN.t",
                    "c20_n2 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c45_goal : Logic.eq (Z.gcd (NN.to_Z d1) (ZZ.to_Z n2)) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c47_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d1)) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c42_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (Z.mul (NN.to_Z d2) (NN.to_Z d1))) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c48_goal : Logic.eq (Z.gcd (Z.mul (NN.to_Z d2) (NN.to_Z d1)) (ZZ.to_Z n1)) 1%Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c48_goal : Logic.eq (Z.gcd (Z.mul (NN.to_Z d2) (NN.to_Z d1)) (ZZ.to_Z n1)) 1%Z",
                    "_global_Zgcd_mult_rel_prime : forall (a b c : Z) (_ : Logic.eq (Z.gcd a c) 1%Z)\n         (_ : Logic.eq (Z.gcd b c) 1%Z), Logic.eq (Z.gcd (Z.mul a b) c) 1%Z"
                ],
                "tactic_res": [
                    "c49_goal : Logic.eq (Z.gcd (NN.to_Z d2) (ZZ.to_Z n1)) 1%Z",
                    "c50_goal : Logic.eq (Z.gcd (NN.to_Z d1) (ZZ.to_Z n1)) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : Logic.eq (Z.gcd (NN.to_Z d2) (ZZ.to_Z n1)) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c51_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d2)) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c50_goal : Logic.eq (Z.gcd (NN.to_Z d1) (ZZ.to_Z n1)) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c52_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c52_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c22_Hgc : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d1)) 1%Z",
                    "c19_d1 : NN.t",
                    "c19_n1 : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c47_goal : Logic.eq (Z.gcd (ZZ.to_Z n2) (NN.to_Z d1)) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c53_goal : rel_prime (ZZ.to_Z n2) (NN.to_Z d1)",
                    "c53_H3 : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)",
                    "c53_H2 : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)",
                    "c53_Hgc' : rel_prime (ZZ.to_Z n2) (NN.to_Z d2)",
                    "c53_Hgc : rel_prime (ZZ.to_Z n1) (NN.to_Z d1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c53_goal : rel_prime (ZZ.to_Z n2) (NN.to_Z d1)",
                    "_global_bezout_rel_prime : forall (a b : Z) (_ : Bezout a b 1), rel_prime a b"
                ],
                "tactic_res": [
                    "c54_goal : Bezout (ZZ.to_Z n2) (NN.to_Z d1) 1"
                ]
            },
            {
                "tactic_sig": "destruct ( rel_prime_bezout ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ u v Huv ] .",
                "tactic_sig_no_out_arg": "destruct ( rel_prime_bezout ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ u v Huv ] .",
                "tactic_args": [
                    "c54_goal : Bezout (ZZ.to_Z n2) (NN.to_Z d1) 1",
                    "c10_ny : ZZ.t",
                    "c10_dy : NN.t",
                    "c53_H3 : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)",
                    "c53_H2 : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)",
                    "c37_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c37_H : Z.lt 0 (NN.to_Z dy)",
                    "c22_NEQ' : not (Logic.eq (NN.to_Z dx) 0%Z)",
                    "c22_NEQ : not (Logic.eq (NN.to_Z dy) 0%Z)",
                    "c22_n : not (Logic.eq (Z.mul (NN.to_Z d2) (NN.to_Z d1)) 1%Z)",
                    "c22_H1 : Z.lt 0 (Z.mul (NN.to_Z d2) (NN.to_Z d1))",
                    "c53_Hgc' : rel_prime (ZZ.to_Z n2) (NN.to_Z d2)",
                    "c53_Hgc : rel_prime (ZZ.to_Z n1) (NN.to_Z d1)",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c20_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c20_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)",
                    "c20_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)",
                    "c20_n2 : ZZ.t",
                    "c20_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c20_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)",
                    "c19_d1 : NN.t"
                ],
                "tactic_res": [
                    "c55_goal : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)",
                    "c56_goal : Bezout (ZZ.to_Z n2) (NN.to_Z d1) 1",
                    "c56_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z ny)) (Z.mul v (NN.to_Z dy))) 1%Z",
                    "c56_v : Z",
                    "c56_u : Z"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c55_goal : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i * _i ) % _i ( _i * _i ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with ( _i * _i ) % _i ( _i * _i ) % _i .",
                "tactic_args": [
                    "c56_goal : Bezout (ZZ.to_Z n2) (NN.to_Z d1) 1",
                    "_global_Bezout_intro : forall (a b d u v : Z)\n         (_ : Logic.eq (Z.add (Z.mul u a) (Z.mul v b)) d), \n       Bezout a b d",
                    "c56_u : Z",
                    "c18_g' : Z",
                    "_global_Z : Set",
                    "c56_v : Z",
                    "c18_g : Z",
                    "_global_Z : Set"
                ],
                "tactic_res": [
                    "c57_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g') (ZZ.to_Z n2))\n     (Z.mul (Z.mul v g) (NN.to_Z d1))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , <- _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , <- _i , <- _i .",
                "tactic_args": [
                    "c57_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g') (ZZ.to_Z n2))\n     (Z.mul (Z.mul v g) (NN.to_Z d1))) 1%Z",
                    "c56_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z ny)) (Z.mul v (NN.to_Z dy))) 1%Z",
                    "c20_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)",
                    "c20_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)"
                ],
                "tactic_res": [
                    "c58_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g') (ZZ.to_Z n2))\n     (Z.mul (Z.mul v g) (NN.to_Z d1)))\n  (Z.add (Z.mul u (Z.mul (ZZ.to_Z n2) g'))\n     (Z.mul v (Z.mul (NN.to_Z d1) g)))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c58_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g') (ZZ.to_Z n2))\n     (Z.mul (Z.mul v g) (NN.to_Z d1)))\n  (Z.add (Z.mul u (Z.mul (ZZ.to_Z n2) g'))\n     (Z.mul v (Z.mul (NN.to_Z d1) g)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c51_goal : Logic.eq (Z.gcd (ZZ.to_Z n1) (NN.to_Z d2)) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c59_goal : rel_prime (ZZ.to_Z n1) (NN.to_Z d2)",
                    "c59_H3 : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)",
                    "c59_H2 : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)",
                    "c59_Hgc' : rel_prime (ZZ.to_Z n2) (NN.to_Z d2)",
                    "c59_Hgc : rel_prime (ZZ.to_Z n1) (NN.to_Z d1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c59_goal : rel_prime (ZZ.to_Z n1) (NN.to_Z d2)",
                    "_global_bezout_rel_prime : forall (a b : Z) (_ : Bezout a b 1), rel_prime a b"
                ],
                "tactic_res": [
                    "c60_goal : Bezout (ZZ.to_Z n1) (NN.to_Z d2) 1"
                ]
            },
            {
                "tactic_sig": "destruct ( rel_prime_bezout ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ u v Huv ] .",
                "tactic_sig_no_out_arg": "destruct ( rel_prime_bezout ( ZZ.to_Z _i ) ( NN.to_Z _i ) ) as [ u v Huv ] .",
                "tactic_args": [
                    "c60_goal : Bezout (ZZ.to_Z n1) (NN.to_Z d2) 1",
                    "c6_nx : ZZ.t",
                    "c6_dx : NN.t",
                    "c59_H3 : rel_prime (ZZ.to_Z ny) (NN.to_Z dy)",
                    "c59_H2 : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)",
                    "c37_H0 : Z.lt 0 (NN.to_Z dx)",
                    "c37_H : Z.lt 0 (NN.to_Z dy)",
                    "c22_NEQ' : not (Logic.eq (NN.to_Z dx) 0%Z)",
                    "c22_NEQ : not (Logic.eq (NN.to_Z dy) 0%Z)",
                    "c22_n : not (Logic.eq (Z.mul (NN.to_Z d2) (NN.to_Z d1)) 1%Z)",
                    "c22_H1 : Z.lt 0 (Z.mul (NN.to_Z d2) (NN.to_Z d1))",
                    "c59_Hgc' : rel_prime (ZZ.to_Z n2) (NN.to_Z d2)",
                    "c59_Hgc : rel_prime (ZZ.to_Z n1) (NN.to_Z d1)",
                    "c20_Hz' : iff (Logic.eq (NN.to_Z dx) 0%Z) (Logic.eq (NN.to_Z d2) 0%Z)",
                    "c20_Hz : iff (Logic.eq (NN.to_Z dy) 0%Z) (Logic.eq (NN.to_Z d1) 0%Z)",
                    "c20_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)",
                    "c20_Hg1' : Logic.eq (Z.mul (ZZ.to_Z n2) g') (ZZ.to_Z ny)",
                    "c20_d2 : NN.t",
                    "c20_Hg2 : Logic.eq (Z.mul (NN.to_Z d1) g) (NN.to_Z dy)",
                    "c20_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)",
                    "c19_n1 : ZZ.t"
                ],
                "tactic_res": [
                    "c61_goal : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)",
                    "c62_goal : Bezout (ZZ.to_Z n1) (NN.to_Z d2) 1",
                    "c62_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z nx)) (Z.mul v (NN.to_Z dx))) 1%Z",
                    "c62_v : Z",
                    "c62_u : Z"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c61_goal : rel_prime (ZZ.to_Z nx) (NN.to_Z dx)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i * _i ) % _i ( _i * _i ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with ( _i * _i ) % _i ( _i * _i ) % _i .",
                "tactic_args": [
                    "c62_goal : Bezout (ZZ.to_Z n1) (NN.to_Z d2) 1",
                    "_global_Bezout_intro : forall (a b d u v : Z)\n         (_ : Logic.eq (Z.add (Z.mul u a) (Z.mul v b)) d), \n       Bezout a b d",
                    "c62_u : Z",
                    "c18_g : Z",
                    "_global_Z : Set",
                    "c62_v : Z",
                    "c18_g' : Z",
                    "_global_Z : Set"
                ],
                "tactic_res": [
                    "c63_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g) (ZZ.to_Z n1))\n     (Z.mul (Z.mul v g') (NN.to_Z d2))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , <- _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , <- _i , <- _i .",
                "tactic_args": [
                    "c63_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g) (ZZ.to_Z n1))\n     (Z.mul (Z.mul v g') (NN.to_Z d2))) 1%Z",
                    "c62_Huv : Logic.eq (Z.add (Z.mul u (ZZ.to_Z nx)) (Z.mul v (NN.to_Z dx))) 1%Z",
                    "c20_Hg2' : Logic.eq (Z.mul (NN.to_Z d2) g') (NN.to_Z dx)",
                    "c20_Hg1 : Logic.eq (Z.mul (ZZ.to_Z n1) g) (ZZ.to_Z nx)"
                ],
                "tactic_res": [
                    "c64_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g) (ZZ.to_Z n1))\n     (Z.mul (Z.mul v g') (NN.to_Z d2)))\n  (Z.add (Z.mul u (Z.mul (ZZ.to_Z n1) g))\n     (Z.mul v (Z.mul (NN.to_Z d2) g')))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c64_goal : Logic.eq\n  (Z.add (Z.mul (Z.mul u g) (ZZ.to_Z n1))\n     (Z.mul (Z.mul v g') (NN.to_Z d2)))\n  (Z.add (Z.mul u (Z.mul (ZZ.to_Z n1) g))\n     (Z.mul v (Z.mul (NN.to_Z d2) g')))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_inv",
        "proof": [
            {
                "tactic_sig": "Theorem spec_inv : forall x , [ inv x ] = = / [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_inv : forall x , [ inv x ] = = / [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ]
            },
            {
                "tactic_sig": "destruct x as [ z | n d ] .",
                "tactic_sig_no_out_arg": "destruct x as [ z | n d ] .",
                "tactic_args": [
                    "c1_goal : forall x : t, Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (inv (Qz z))) (Qinv (to_Q (Qz z)))",
                    "c2_z : ZZ.t",
                    "c3_goal : Qeq (to_Q (inv (Qq n d))) (Qinv (to_Q (Qq n d)))",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (inv (Qz z))) (Qinv (to_Q (Qz z)))"
                ],
                "tactic_res": [
                    "c4_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "_global_ZZ.spec_compare : forall x y : ZZ.t,\n       Logic.eq (ZZ.compare x y) (Z.compare (ZZ.to_Z x) (ZZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c5_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (to_Q zero) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c6_H : Logic.eq (ZZ.to_Z ZZ.zero) (ZZ.to_Z z)",
                    "c7_goal : Qeq (to_Q (Qq ZZ.one (Zabs_N z)))\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c7_H : Z.lt (ZZ.to_Z ZZ.zero) (ZZ.to_Z z)",
                    "c8_goal : Qeq (to_Q (Qq ZZ.minus_one (Zabs_N z)))\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c8_H : Z.lt (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q zero) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c6_H : Logic.eq (ZZ.to_Z ZZ.zero) (ZZ.to_Z z)"
                ],
                "tactic_res": [
                    "c9_goal : Qeq (to_Q zero) (Qinv {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Qeq (to_Q zero) (Qinv {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c10_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (Qinv {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c10_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (Qinv {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c11_goal : Qeq 0 (Qinv 0)",
                    "c11_H : Logic.eq 0%Z (ZZ.to_Z z)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c11_goal : Qeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (Qq ZZ.one (Zabs_N z)))\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c13_goal : Qeq\n  (if NN.eqb (Zabs_N z) NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z ZZ.one; Qden := Z.to_pos (NN.to_Z (Zabs_N z)) |})\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c13_goal : Qeq\n  (if NN.eqb (Zabs_N z) NN.zero\n   then 0\n   else\n    {| Qnum := ZZ.to_Z ZZ.one; Qden := Z.to_pos (NN.to_Z (Zabs_N z)) |})\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nQeq {| Qnum := ZZ.to_Z ZZ.one; Qden := Z.to_pos (NN.to_Z (Zabs_N z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z,\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c16_H : Z.lt 0 (ZZ.to_Z z)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c15_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nQeq {| Qnum := ZZ.to_Z ZZ.one; Qden := Z.to_pos (NN.to_Z (Zabs_N z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nQeq {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c17_H : Z.lt 0 (ZZ.to_Z z)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z,\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c18_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c18_e : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c18_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c19_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c19_e : Logic.eq (ZZ.to_Z z) 0%Z",
                    "c20_goal : Z.le 0 (ZZ.to_Z z)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c19_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (ZZ.to_Z z)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nQeq {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c21_goal : Qeq {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "set ( z' := ZZ.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( z' := ZZ.to_Z _i ) in * .",
                "tactic_args": [
                    "c21_goal : Qeq {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": [
                    "c22_goal : Qeq {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |}\n  (Qinv {| Qnum := z'; Qden := 1 |})",
                    "c22_H : Z.lt 0 z'",
                    "c22_z' : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c22_z' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c22_goal : Qeq {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |}\n  (Qinv {| Qnum := z'; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |})\n     (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |})\n     (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs z') |})))"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.abs z'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c24_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.abs z'))))",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) (Zpos (Z.to_pos z')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c25_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) (Zpos (Z.to_pos z')))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x",
                    "c22_H : Z.lt 0 z'",
                    "c22_z' : Z",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) z')"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) z')",
                    "_global_Qinv : forall _ : Q, Q"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq\n  (Zpos\n     (Qden\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end) z')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c27_goal : Logic.eq\n  (Zpos\n     (Qden\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end) z')"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq\n  (Zpos\n     (Qden\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end))\n  (Z.mul\n     (Qnum\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end) z')"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c28_goal : Logic.eq\n  (Zpos\n     (Qden\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end))\n  (Z.mul\n     (Qnum\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end) z')",
                    "c22_z' : Z",
                    "c22_H : Z.lt 0 z'",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq (Zpos (Qden 0)) (Z.mul (Qnum 0) 0%Z)",
                    "c29_H : Z.lt 0 0",
                    "c30_goal : Logic.eq (Zpos (Qden {| Qnum := 1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := 1; Qden := p |}) (Zpos p))",
                    "c30_H : Z.lt 0 (Zpos p)",
                    "c30_p : positive",
                    "c31_goal : Logic.eq (Zpos (Qden {| Qnum := -1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := -1; Qden := p |}) (Zneg p))",
                    "c31_H : Z.lt 0 (Zneg p)",
                    "c31_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : Logic.eq (Zpos (Qden 0)) (Z.mul (Qnum 0) 0%Z)"
                ],
                "tactic_res": [
                    "c32_goal : Logic.eq 1%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c32_goal : Logic.eq 1%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : Logic.eq (Zpos (Qden {| Qnum := 1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := 1; Qden := p |}) (Zpos p))"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : Logic.eq (Zpos p) (Zpos p)",
                    "c30_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c31_goal : Logic.eq (Zpos (Qden {| Qnum := -1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := -1; Qden := p |}) (Zneg p))"
                ],
                "tactic_res": [
                    "c34_goal : Logic.eq (Zpos p) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Logic.eq (Zpos p) (Zpos p)",
                    "c31_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q (Qq ZZ.minus_one (Zabs_N z)))\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c35_goal : Qeq\n  (if NN.eqb (Zabs_N z) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z ZZ.minus_one;\n      Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n    |}) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c35_goal : Qeq\n  (if NN.eqb (Zabs_N z) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z ZZ.minus_one;\n      Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n    |}) (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c36_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nQeq\n  {|\n    Qnum := ZZ.to_Z ZZ.minus_one; Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n  |} (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c36_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c38_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z,\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c38_H : Z.lt (ZZ.to_Z z) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c38_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z,\nQeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c39_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c39_e : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nQeq\n  {|\n    Qnum := ZZ.to_Z ZZ.minus_one; Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n  |} (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c40_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nQeq {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c40_H : Z.lt (ZZ.to_Z z) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c40_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nQeq {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c41_goal : Qeq {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c41_H0 : Z.lt 0 (Z.abs (ZZ.to_Z z))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c39_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c42_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c42_e : Logic.eq (Z.opp (ZZ.to_Z z)) 0%Z",
                    "c43_goal : Z.le (ZZ.to_Z z) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c42_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c43_goal : Z.le (ZZ.to_Z z) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( z' := ZZ.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( z' := ZZ.to_Z _i ) in * .",
                "tactic_args": [
                    "c41_goal : Qeq {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}\n  (Qinv {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": [
                    "c44_goal : Qeq {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |}\n  (Qinv {| Qnum := z'; Qden := 1 |})",
                    "c44_H0 : Z.lt 0 (Z.abs z')",
                    "c44_H : Z.lt z' 0",
                    "c44_z' : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c44_z' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c44_goal : Qeq {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |}\n  (Qinv {| Qnum := z'; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c45_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |})\n     (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c45_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |})\n     (Zpos (Qden (Qinv {| Qnum := z'; Qden := 1 |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs z') |})))"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.abs z'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c46_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.abs z'))))",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c47_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.opp z'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c47_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |}))\n     (Zpos (Z.to_pos (Z.opp z'))))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c48_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) (Z.opp z'))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c48_goal : Logic.eq (Zneg (Qden (Qinv {| Qnum := z'; Qden := 1 |})))\n  (Z.mul (Qnum (Qinv {| Qnum := z'; Qden := 1 |})) (Z.opp z'))",
                    "_global_Qinv : forall _ : Q, Q"
                ],
                "tactic_res": [
                    "c49_goal : Logic.eq\n  (Zneg\n     (Qden\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end) (Z.opp z'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c49_goal : Logic.eq\n  (Zneg\n     (Qden\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := z'; Qden := 1 |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum := Zpos (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum := Zneg (Qden {| Qnum := z'; Qden := 1 |});\n              Qden := p\n            |}\n        end) (Z.opp z'))"
                ],
                "tactic_res": [
                    "c50_goal : Logic.eq\n  (Zneg\n     (Qden\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end))\n  (Z.mul\n     (Qnum\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end) (Z.opp z'))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c50_goal : Logic.eq\n  (Zneg\n     (Qden\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end))\n  (Z.mul\n     (Qnum\n        match z' with\n        | 0%Z => 0\n        | Zpos p => {| Qnum := 1; Qden := p |}\n        | Zneg p => {| Qnum := -1; Qden := p |}\n        end) (Z.opp z'))",
                    "c44_z' : Z",
                    "c44_H0 : Z.lt 0 (Z.abs z')",
                    "c44_H : Z.lt z' 0",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": [
                    "c51_goal : Logic.eq (Zneg (Qden 0)) (Z.mul (Qnum 0) (Z.opp 0%Z))",
                    "c51_H0 : Z.lt 0 (Z.abs 0%Z)",
                    "c51_H : Z.lt 0 0",
                    "c52_goal : Logic.eq (Zneg (Qden {| Qnum := 1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := 1; Qden := p |}) (Z.opp (Zpos p)))",
                    "c52_H0 : Z.lt 0 (Z.abs (Zpos p))",
                    "c52_H : Z.lt (Zpos p) 0",
                    "c52_p : positive",
                    "c53_goal : Logic.eq (Zneg (Qden {| Qnum := -1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := -1; Qden := p |}) (Z.opp (Zneg p)))",
                    "c53_H0 : Z.lt 0 (Z.abs (Zneg p))",
                    "c53_H : Z.lt (Zneg p) 0",
                    "c53_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c51_goal : Logic.eq (Zneg (Qden 0)) (Z.mul (Qnum 0) (Z.opp 0%Z))"
                ],
                "tactic_res": [
                    "c54_goal : Logic.eq (-1)%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c54_goal : Logic.eq (-1)%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c52_goal : Logic.eq (Zneg (Qden {| Qnum := 1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := 1; Qden := p |}) (Z.opp (Zpos p)))"
                ],
                "tactic_res": [
                    "c55_goal : Logic.eq (Zneg p) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : Logic.eq (Zneg p) (Zneg p)",
                    "c52_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c53_goal : Logic.eq (Zneg (Qden {| Qnum := -1; Qden := p |}))\n  (Z.mul (Qnum {| Qnum := -1; Qden := p |}) (Z.opp (Zneg p)))"
                ],
                "tactic_res": [
                    "c56_goal : Logic.eq (Zneg p) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : Logic.eq (Zneg p) (Zneg p)",
                    "c53_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (inv (Qq n d))) (Qinv (to_Q (Qq n d)))"
                ],
                "tactic_res": [
                    "c57_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero n with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c57_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero n with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "_global_ZZ.spec_compare : forall x y : ZZ.t,\n       Logic.eq (ZZ.compare x y) (Z.compare (ZZ.to_Z x) (ZZ.to_Z y))"
                ],
                "tactic_res": [
                    "c58_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c58_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c59_goal : Qeq (to_Q zero)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "c59_H : Logic.eq (ZZ.to_Z ZZ.zero) (ZZ.to_Z n)",
                    "c60_goal : Qeq (to_Q (Qq (Z_of_N d) (Zabs_N n)))\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "c60_H : Z.lt (ZZ.to_Z ZZ.zero) (ZZ.to_Z n)",
                    "c61_goal : Qeq (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "c61_H : Z.lt (ZZ.to_Z n) (ZZ.to_Z ZZ.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c59_goal : Qeq (to_Q zero)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "c59_H : Logic.eq (ZZ.to_Z ZZ.zero) (ZZ.to_Z n)"
                ],
                "tactic_res": [
                    "c62_goal : Qeq (to_Q zero)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z ZZ.zero; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c62_goal : Qeq (to_Q zero)\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z ZZ.zero; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c63_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z ZZ.zero; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c63_goal : Qeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z ZZ.zero; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c64_goal : Qeq 0\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |}))",
                    "c64_H : Logic.eq 0%Z (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c64_goal : Qeq 0\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c65_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Qeq 0 (Qinv 0)",
                    "c66_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq 0 (Qinv {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c65_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero), Qeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c67_goal : Qeq 0 (Qinv 0)",
                    "c67_e : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c67_goal : Qeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c68_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c68_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c66_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq 0 (Qinv {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c69_goal : Qeq 0 (Qinv {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c69_H0 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c69_goal : Qeq 0 (Qinv {| Qnum := 0; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c70_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c70_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c60_goal : Qeq (to_Q (Qq (Z_of_N d) (Zabs_N n)))\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c71_goal : Qeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c71_goal : Qeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c72_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)), \nQeq 0 (Qinv 0)",
                    "c73_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c74_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv 0)",
                    "c75_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c72_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)), \nQeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c76_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z), Qeq 0 (Qinv 0)",
                    "c76_H : Z.lt 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c76_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z), Qeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c77_goal : Qeq 0 (Qinv 0)",
                    "c77_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c77_e0 : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c73_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c78_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c78_H : Z.lt 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c78_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c79_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c79_H0 : Z.lt 0 (NN.to_Z d)",
                    "c79_e : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c74_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv 0)"
                ],
                "tactic_res": [
                    "c80_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)",
                    "c80_H : Z.lt 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c80_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ],
                "tactic_res": [
                    "c81_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)",
                    "c81_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c81_H0 : Z.lt 0 (Z.abs (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c75_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c82_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c82_H : Z.lt 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c82_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c83_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c83_H0 : Z.lt 0 (NN.to_Z d)",
                    "c83_H1 : Z.lt 0 (Z.abs (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c77_goal : Qeq 0 (Qinv 0)",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c84_goal : Qeq 0 (Qinv 0)",
                    "c84_e0 : Logic.eq (ZZ.to_Z n) 0%Z",
                    "c85_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c84_goal : Qeq 0 (Qinv 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c85_goal : Z.le 0 (ZZ.to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c79_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c86_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c86_e : Logic.eq (ZZ.to_Z n) 0%Z",
                    "c87_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c86_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c87_goal : Z.le 0 (ZZ.to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nsubst .",
                "tactic_sig_no_out_arg": "nsubst .",
                "tactic_args": [
                    "c81_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ],
                "tactic_res": [
                    "c88_goal : Qeq {| Qnum := 0; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |} (Qinv 0)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c88_goal : Qeq {| Qnum := 0; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |} (Qinv 0)"
                ],
                "tactic_res": [
                    "c89_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c89_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( n' := ZZ.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( n' := ZZ.to_Z _i ) in * .",
                "tactic_args": [
                    "c83_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c90_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs n') |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c90_H1 : Z.lt 0 (Z.abs n')",
                    "c90_H : Z.lt 0 n'",
                    "c90_n' : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c90_n' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c90_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs n') |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c91_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c91_goal : Qeq {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c92_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |})\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Qden {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c92_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |})\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Qden {| Qnum := NN.to_Z d; Qden := Z.to_pos n' |})))"
                ],
                "tactic_res": [
                    "c93_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos n')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c93_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos n')))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x",
                    "c90_H1 : Z.lt 0 (Z.abs n')",
                    "c83_H0 : Z.lt 0 (NN.to_Z d)",
                    "c90_H : Z.lt 0 n'",
                    "c90_n' : Z",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c94_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     n')"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c94_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     n')",
                    "_global_Qinv : forall _ : Q, Q"
                ],
                "tactic_res": [
                    "c95_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos\n        (Qden\n           match\n             Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}\n           with\n           | 0%Z => 0\n           | Zpos p =>\n               {|\n                 Qnum :=\n                   Zpos\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           | Zneg p =>\n               {|\n                 Qnum :=\n                   Zneg\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           end)))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum :=\n                Zpos\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum :=\n                Zneg\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        end) n')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c95_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos\n        (Qden\n           match\n             Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}\n           with\n           | 0%Z => 0\n           | Zpos p =>\n               {|\n                 Qnum :=\n                   Zpos\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           | Zneg p =>\n               {|\n                 Qnum :=\n                   Zneg\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           end)))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum :=\n                Zpos\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum :=\n                Zneg\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        end) n')"
                ],
                "tactic_res": [
                    "c96_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos\n        (Qden\n           match n' with\n           | 0%Z => 0\n           | Zpos p =>\n               {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n           | Zneg p =>\n               {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n           end)))\n  (Z.mul\n     (Qnum\n        match n' with\n        | 0%Z => 0\n        | Zpos p =>\n            {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n        | Zneg p =>\n            {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n        end) n')"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c96_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos\n        (Qden\n           match n' with\n           | 0%Z => 0\n           | Zpos p =>\n               {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n           | Zneg p =>\n               {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n           end)))\n  (Z.mul\n     (Qnum\n        match n' with\n        | 0%Z => 0\n        | Zpos p =>\n            {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n        | Zneg p =>\n            {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n        end) n')",
                    "c90_n' : Z",
                    "c90_H1 : Z.lt 0 (Z.abs n')",
                    "c83_H0 : Z.lt 0 (NN.to_Z d)",
                    "c90_H : Z.lt 0 n'",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c97_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos (Qden 0))) (Z.mul (Qnum 0) 0%Z)",
                    "c97_H1 : Z.lt 0 (Z.abs 0%Z)",
                    "c97_H : Z.lt 0 0",
                    "c98_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Zpos p))",
                    "c98_H1 : Z.lt 0 (Z.abs (Zpos p))",
                    "c98_H : Z.lt 0 (Zpos p)",
                    "c98_p : positive",
                    "c99_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Zneg p))",
                    "c99_H1 : Z.lt 0 (Z.abs (Zneg p))",
                    "c99_H : Z.lt 0 (Zneg p)",
                    "c99_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c97_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos (Qden 0))) (Z.mul (Qnum 0) 0%Z)"
                ],
                "tactic_res": [
                    "c100_goal : Logic.eq (Z.mul (NN.to_Z d) 1%Z) 0%Z"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c100_goal : Logic.eq (Z.mul (NN.to_Z d) 1%Z) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c98_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Zpos p))"
                ],
                "tactic_res": [
                    "c101_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p))\n  (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c99_goal : Logic.eq\n  (Z.mul (NN.to_Z d)\n     (Zpos (Qden {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Zneg p))"
                ],
                "tactic_res": [
                    "c102_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p))\n  (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c102_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p))\n  (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c101_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p))\n  (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) p))",
                    "_global_Pos2Z.inj_mul : forall p q : positive,\n       Logic.eq (Zpos (Pos.mul p q)) (Z.mul (Zpos p) (Zpos q))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c103_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p)) (Z.mul (NN.to_Z d) (Zpos p))",
                    "c104_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c103_goal : Logic.eq (Z.mul (NN.to_Z d) (Zpos p)) (Z.mul (NN.to_Z d) (Zpos p))",
                    "c98_p : positive",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c104_goal : Z.lt 0 (NN.to_Z d)",
                    "c83_H0 : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c61_goal : Qeq (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c105_goal : Qeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c105_goal : Qeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (Qinv\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c106_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)), \nQeq 0 (Qinv 0)",
                    "c107_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c108_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv 0)",
                    "c109_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c106_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)), \nQeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c110_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z), Qeq 0 (Qinv 0)",
                    "c110_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c110_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z), Qeq 0 (Qinv 0)"
                ],
                "tactic_res": [
                    "c111_goal : Qeq 0 (Qinv 0)",
                    "c111_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c111_e0 : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c107_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero)),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c112_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c112_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c112_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z),\nQeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c113_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c113_H0 : Z.lt 0 (NN.to_Z d)",
                    "c113_e : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c108_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv 0)"
                ],
                "tactic_res": [
                    "c114_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)",
                    "c114_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c114_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ],
                "tactic_res": [
                    "c115_goal : Qeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)",
                    "c115_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c115_H0 : Z.lt 0 (Z.abs (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c109_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (Zabs_N n))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |} (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c116_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c116_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c116_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))),\nQeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c117_goal : Qeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c117_H0 : Z.lt 0 (NN.to_Z d)",
                    "c117_H1 : Z.lt 0 (Z.abs (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c111_goal : Qeq 0 (Qinv 0)",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c118_goal : Qeq 0 (Qinv 0)",
                    "c118_e0 : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z",
                    "c119_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c118_goal : Qeq 0 (Qinv 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c119_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c113_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c120_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c120_e : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z",
                    "c121_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c120_goal : Qeq 0 (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c121_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nsubst .",
                "tactic_sig_no_out_arg": "nsubst .",
                "tactic_args": [
                    "c115_goal : Qeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ],
                "tactic_res": [
                    "c122_goal : Qeq {| Qnum := Z.opp 0%Z; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c122_goal : Qeq {| Qnum := Z.opp 0%Z; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv 0)"
                ],
                "tactic_res": [
                    "c123_goal : Logic.eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c123_goal : Logic.eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( n' := ZZ.to_Z _i ) in * .",
                "tactic_sig_no_out_arg": "set ( n' := ZZ.to_Z _i ) in * .",
                "tactic_args": [
                    "c117_goal : Qeq\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}\n  (Qinv {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c124_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c124_H1 : Z.lt 0 (Z.abs n')",
                    "c124_H : Z.lt n' 0",
                    "c124_n' : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c124_n' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c124_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |}\n  (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c125_goal : Logic.eq\n  (Z.mul\n     (Qnum {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |})\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos\n        (Qden\n           {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c125_goal : Logic.eq\n  (Z.mul\n     (Qnum {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |})\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos\n        (Qden\n           {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs n') |})))"
                ],
                "tactic_res": [
                    "c126_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos (Z.abs n'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c126_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos (Z.abs n'))))",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c127_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos (Z.opp n'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c127_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos (Z.to_pos (Z.opp n'))))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c128_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Z.opp n'))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c128_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul (Qnum (Qinv {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Z.opp n'))",
                    "_global_Qinv : forall _ : Q, Q"
                ],
                "tactic_res": [
                    "c129_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos\n        (Qden\n           match\n             Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}\n           with\n           | 0%Z => 0\n           | Zpos p =>\n               {|\n                 Qnum :=\n                   Zpos\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           | Zneg p =>\n               {|\n                 Qnum :=\n                   Zneg\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           end)))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum :=\n                Zpos\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum :=\n                Zneg\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        end) (Z.opp n'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c129_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos\n        (Qden\n           match\n             Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |}\n           with\n           | 0%Z => 0\n           | Zpos p =>\n               {|\n                 Qnum :=\n                   Zpos\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           | Zneg p =>\n               {|\n                 Qnum :=\n                   Zneg\n                     (Qden\n                        {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n                 Qden := p\n               |}\n           end)))\n  (Z.mul\n     (Qnum\n        match Qnum {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |} with\n        | 0%Z => 0\n        | Zpos p =>\n            {|\n              Qnum :=\n                Zpos\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        | Zneg p =>\n            {|\n              Qnum :=\n                Zneg\n                  (Qden {| Qnum := n'; Qden := Z.to_pos (NN.to_Z d) |});\n              Qden := p\n            |}\n        end) (Z.opp n'))"
                ],
                "tactic_res": [
                    "c130_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos\n        (Qden\n           match n' with\n           | 0%Z => 0\n           | Zpos p =>\n               {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n           | Zneg p =>\n               {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n           end)))\n  (Z.mul\n     (Qnum\n        match n' with\n        | 0%Z => 0\n        | Zpos p =>\n            {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n        | Zneg p =>\n            {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n        end) (Z.opp n'))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c130_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos\n        (Qden\n           match n' with\n           | 0%Z => 0\n           | Zpos p =>\n               {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n           | Zneg p =>\n               {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n           end)))\n  (Z.mul\n     (Qnum\n        match n' with\n        | 0%Z => 0\n        | Zpos p =>\n            {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |}\n        | Zneg p =>\n            {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |}\n        end) (Z.opp n'))",
                    "c124_n' : Z",
                    "c124_H1 : Z.lt 0 (Z.abs n')",
                    "c117_H0 : Z.lt 0 (NN.to_Z d)",
                    "c124_H : Z.lt n' 0",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c131_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos (Qden 0)))\n  (Z.mul (Qnum 0) (Z.opp 0%Z))",
                    "c131_H1 : Z.lt 0 (Z.abs 0%Z)",
                    "c131_H : Z.lt 0 0",
                    "c132_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Z.opp (Zpos p)))",
                    "c132_H1 : Z.lt 0 (Z.abs (Zpos p))",
                    "c132_H : Z.lt (Zpos p) 0",
                    "c132_p : positive",
                    "c133_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Z.opp (Zneg p)))",
                    "c133_H1 : Z.lt 0 (Z.abs (Zneg p))",
                    "c133_H : Z.lt (Zneg p) 0",
                    "c133_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c131_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos (Qden 0)))\n  (Z.mul (Qnum 0) (Z.opp 0%Z))"
                ],
                "tactic_res": [
                    "c134_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) 1%Z) 0%Z"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c134_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) 1%Z) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c132_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zpos (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Z.opp (Zpos p)))"
                ],
                "tactic_res": [
                    "c135_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Zneg (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c135_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Zneg (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c133_goal : Logic.eq\n  (Z.mul (Z.opp (NN.to_Z d))\n     (Zpos (Qden {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})))\n  (Z.mul (Qnum {| Qnum := Zneg (Z.to_pos (NN.to_Z d)); Qden := p |})\n     (Z.opp (Zneg p)))"
                ],
                "tactic_res": [
                    "c136_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Zneg (Pos.mul (Z.to_pos (NN.to_Z d)) p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c136_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Zneg (Pos.mul (Z.to_pos (NN.to_Z d)) p))",
                    "c136_T : forall x : positive, Logic.eq (Zneg x) (Z.opp (Zpos x))",
                    "_global_Pos2Z.inj_mul : forall p q : positive,\n       Logic.eq (Zpos (Pos.mul p q)) (Z.mul (Zpos p) (Zpos q))",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c137_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Z.opp (Z.mul (NN.to_Z d) (Zpos p)))",
                    "c138_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c137_goal : Logic.eq (Z.mul (Z.opp (NN.to_Z d)) (Zpos p))\n  (Z.opp (Z.mul (NN.to_Z d) (Zpos p)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c138_goal : Z.lt 0 (NN.to_Z d)",
                    "c117_H0 : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_inv_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_inv_norm : forall x , [ inv_norm x ] = = / [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_inv_norm : forall x , [ inv_norm x ] = = / [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x : t, Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))",
                    "_global_spec_inv : forall x : t, Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (to_Q (inv_norm x)) (to_Q (inv x))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ z | n d ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ z | n d ] .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (inv_norm x)) (to_Q (inv x))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q (inv_norm (Qz z))) (to_Q (inv (Qz z)))",
                    "c4_z : ZZ.t",
                    "c5_goal : Qeq (to_Q (inv_norm (Qq n d))) (to_Q (inv (Qq n d)))",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (inv_norm (Qz z))) (to_Q (inv (Qz z)))"
                ],
                "tactic_res": [
                    "c6_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Qeq\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)",
                    "_global_ZZ.spec_compare : forall x y : ZZ.t,\n       Logic.eq (ZZ.compare x y) (Z.compare (ZZ.to_Z x) (ZZ.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c7_goal : Qeq\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)\n  (to_Q\n     match Z.compare (ZZ.to_Z ZZ.zero) (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ],
                "tactic_res": [
                    "c8_goal : Qeq (to_Q zero) (to_Q zero)",
                    "c8_H : Logic.eq (ZZ.to_Z ZZ.zero) (ZZ.to_Z z)",
                    "c9_goal : Qeq (to_Q (Qq ZZ.one (Zabs_N z))) (to_Q (Qq ZZ.one (Zabs_N z)))",
                    "c9_H : Z.lt (ZZ.to_Z ZZ.zero) (ZZ.to_Z z)",
                    "c10_goal : Qeq (to_Q (Qq ZZ.minus_one (Zabs_N z)))\n  (to_Q (Qq ZZ.minus_one (Zabs_N z)))",
                    "c10_H : Z.lt (ZZ.to_Z z) (ZZ.to_Z ZZ.zero)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c8_goal : Qeq (to_Q zero) (to_Q zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c9_goal : Qeq (to_Q (Qq ZZ.one (Zabs_N z))) (to_Q (Qq ZZ.one (Zabs_N z)))",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c10_goal : Qeq (to_Q (Qq ZZ.minus_one (Zabs_N z)))\n  (to_Q (Qq ZZ.minus_one (Zabs_N z)))",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (inv_norm (Qq n d))) (to_Q (inv (Qq n d)))"
                ],
                "tactic_res": [
                    "c11_goal : Qeq\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match ZZ.compare ZZ.zero n with\n       | Eq => zero\n       | Lt =>\n           match ZZ.compare n ZZ.one with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match ZZ.compare n ZZ.minus_one with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))\n  (to_Q\n     match ZZ.compare ZZ.zero n with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c11_goal : Qeq\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match ZZ.compare ZZ.zero n with\n       | Eq => zero\n       | Lt =>\n           match ZZ.compare n ZZ.one with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match ZZ.compare n ZZ.minus_one with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))\n  (to_Q\n     match ZZ.compare ZZ.zero n with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ],
                "tactic_res": [
                    "c12_goal : Qeq\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match Z.compare 0%Z (ZZ.to_Z n) with\n       | Eq => zero\n       | Lt =>\n           match Z.compare (ZZ.to_Z n) 1%Z with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match Z.compare (ZZ.to_Z n) (-1)%Z with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c12_goal : Qeq\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match Z.compare 0%Z (ZZ.to_Z n) with\n       | Eq => zero\n       | Lt =>\n           match Z.compare (ZZ.to_Z n) 1%Z with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match Z.compare (ZZ.to_Z n) (-1)%Z with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero)\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)",
                    "c14_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt =>\n         match Z.compare (ZZ.to_Z n) 1%Z with\n         | Gt => Qq (Z_of_N d) (Zabs_N n)\n         | _ => Qz (Z_of_N d)\n         end\n     | Gt =>\n         match Z.compare (ZZ.to_Z n) (-1)%Z with\n         | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n         | _ => Qz (ZZ.opp (Z_of_N d))\n         end\n     end)\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c13_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero)\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q zero)",
                    "c15_H : Logic.eq 0%Z (ZZ.to_Z n)",
                    "c16_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c16_H : Z.lt 0 (ZZ.to_Z n)",
                    "c17_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c17_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q zero)"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq (to_Q zero) (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c19_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c21_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0",
                    "c22_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n)))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c21_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c23_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z)\n  (_ : Logic.eq (NN.to_Z d) 0%Z), Qeq 0 0"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c23_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z)\n  (_ : Logic.eq (NN.to_Z d) 0%Z), Qeq 0 0",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c22_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n)))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ],
                "tactic_res": [
                    "c24_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Logic.eq (NN.to_Z d) 0%Z),\nQeq 0 {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ Hd .",
                "tactic_args": [
                    "c24_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Logic.eq (NN.to_Z d) 0%Z),\nQeq 0 {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c25_goal : Qeq 0 {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c25_Hd : Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c25_goal : Qeq 0 {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c25_Hd : Logic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c26_goal : Qeq 0 {| Qnum := 0; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c26_goal : Qeq 0 {| Qnum := 0; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c27_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0",
                    "c28_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n)))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c27_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c29_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z)\n  (_ : Logic.eq (NN.to_Z d) 0%Z), Qeq 0 0"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c29_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z)\n  (_ : Logic.eq (NN.to_Z d) 0%Z), Qeq 0 0",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c28_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n)))\n  (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero)),\nQeq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ],
                "tactic_res": [
                    "c30_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Logic.eq (NN.to_Z d) 0%Z),\nQeq 0\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ Hd .",
                "tactic_args": [
                    "c30_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Logic.eq (NN.to_Z d) 0%Z),\nQeq 0\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c31_goal : Qeq 0\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c31_Hd : Logic.eq (NN.to_Z d) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : Qeq 0\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c31_Hd : Logic.eq (NN.to_Z d) 0%Z"
                ],
                "tactic_res": [
                    "c32_goal : Qeq 0 {| Qnum := Z.opp 0%Z; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c32_goal : Qeq 0 {| Qnum := Z.opp 0%Z; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt =>\n         match Z.compare (ZZ.to_Z n) 1%Z with\n         | Gt => Qq (Z_of_N d) (Zabs_N n)\n         | _ => Qz (Z_of_N d)\n         end\n     | Gt =>\n         match Z.compare (ZZ.to_Z n) (-1)%Z with\n         | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n         | _ => Qz (ZZ.opp (Z_of_N d))\n         end\n     end)\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt => Qq (Z_of_N d) (Zabs_N n)\n     | Gt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     end)"
                ],
                "tactic_res": [
                    "c33_goal : forall _ : Z.lt 0 (NN.to_Z d), Qeq (to_Q zero) (to_Q zero)",
                    "c33_H : Logic.eq 0%Z (ZZ.to_Z n)",
                    "c34_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end) (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c34_H : Z.lt 0 (ZZ.to_Z n)",
                    "c35_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end) (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c35_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c33_goal : forall _ : Z.lt 0 (NN.to_Z d), Qeq (to_Q zero) (to_Q zero)",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c34_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end) (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c36_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (Z_of_N d))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c36_H0 : Logic.eq (ZZ.to_Z n) 1%Z",
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (Z_of_N d))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c37_H0 : Z.lt (ZZ.to_Z n) 1",
                    "c38_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qq (Z_of_N d) (Zabs_N n))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c38_H0 : Z.lt 1 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c36_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (Z_of_N d))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c39_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c39_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c40_goal : Qeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})",
                    "c40_H1 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c37_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (Z_of_N d))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c41_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c41_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c42_goal : Qeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})",
                    "c42_H1 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c38_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qq (Z_of_N d) (Zabs_N n))) (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c43_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c43_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c40_goal : Qeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c44_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |} 0",
                    "c45_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c44_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c46_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nQeq {| Qnum := NN.to_Z d; Qden := 1 |} 0"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c45_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nQeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ],
                "tactic_res": [
                    "c47_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nQeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c46_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nQeq {| Qnum := NN.to_Z d; Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c48_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |} 0",
                    "c48_e : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c48_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |} 0",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c49_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |} 0",
                    "c49_e : Logic.eq (ZZ.to_Z n) 0%Z",
                    "c50_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c49_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |} 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c50_goal : Z.le 0 (ZZ.to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c47_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nQeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c51_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c51_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c36_H0 : Logic.eq (ZZ.to_Z n) 1%Z"
                ],
                "tactic_res": [
                    "c52_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs 1%Z) |}"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c52_goal : Qeq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs 1%Z) |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c42_goal : Qeq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c35_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end) (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c53_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (ZZ.opp (Z_of_N d))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c53_H0 : Logic.eq (ZZ.to_Z n) (-1)%Z",
                    "c54_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c54_H0 : Z.lt (ZZ.to_Z n) (-1)",
                    "c55_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (ZZ.opp (Z_of_N d))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c55_H0 : Z.lt (-1) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c53_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (ZZ.opp (Z_of_N d))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c56_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c54_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c57_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c57_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c55_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq (to_Q (Qz (ZZ.opp (Z_of_N d))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c58_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c56_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c59_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |} 0",
                    "c60_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n))) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c59_goal : forall (_ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c61_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c61_goal : forall (_ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0"
                ],
                "tactic_res": [
                    "c62_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0",
                    "c62_e : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z",
                    "c62_H1 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c60_goal : forall (_ : Z.lt 0 (NN.to_Z (Zabs_N n))) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {|\n    Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n    Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n  |}"
                ],
                "tactic_res": [
                    "c63_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c63_goal : forall (_ : Z.lt 0 (Z.abs (ZZ.to_Z n))) (_ : Z.lt 0 (NN.to_Z d)),\nQeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c64_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c64_H1 : Z.lt 0 (Z.abs (ZZ.to_Z n))",
                    "c64_H2 : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c62_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c65_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0",
                    "c65_e : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z",
                    "c66_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c65_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |} 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c66_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c64_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c53_H0 : Logic.eq (ZZ.to_Z n) (-1)%Z"
                ],
                "tactic_res": [
                    "c67_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (-1)%Z) |}"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c67_goal : Qeq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (-1)%Z) |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c58_goal : forall _ : Z.lt 0 (NN.to_Z d),\nQeq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_inv_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_inv_norm x : Reduced x -> Reduced ( inv_norm x ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_inv_norm x : Reduced x -> Reduced ( inv_norm x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall _ : Reduced x, Reduced (inv_norm x)",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall _ : Reduced x, Reduced (inv_norm x)",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Logic.eq (to_Q (red x)) (to_Q x),\nLogic.eq (to_Q (red (inv_norm x))) (to_Q (inv_norm x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall _ : Logic.eq (to_Q (red x)) (to_Q x),\nLogic.eq (to_Q (red (inv_norm x))) (to_Q (inv_norm x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (inv_norm x))) (to_Q (inv_norm x))",
                    "c3_H : Logic.eq (to_Q (red x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ z | n d ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ z | n d ] .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (inv_norm x))) (to_Q (inv_norm x))",
                    "c1_x : True",
                    "c3_H : Logic.eq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Q (red (inv_norm (Qz z)))) (to_Q (inv_norm (Qz z)))",
                    "c4_H : Logic.eq (to_Q (red (Qz z))) (to_Q (Qz z))",
                    "c4_z : ZZ.t",
                    "c5_goal : Logic.eq (to_Q (red (inv_norm (Qq n d)))) (to_Q (inv_norm (Qq n d)))",
                    "c5_H : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d))",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Q (red (inv_norm (Qz z)))) (to_Q (inv_norm (Qz z)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (to_Q\n     (red\n        match ZZ.compare ZZ.zero z with\n        | Eq => zero\n        | Lt => Qq ZZ.one (Zabs_N z)\n        | Gt => Qq ZZ.minus_one (Zabs_N z)\n        end))\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (to_Q\n     (red\n        match ZZ.compare ZZ.zero z with\n        | Eq => zero\n        | Lt => Qq ZZ.one (Zabs_N z)\n        | Gt => Qq ZZ.minus_one (Zabs_N z)\n        end))\n  (to_Q\n     match ZZ.compare ZZ.zero z with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare 0%Z (ZZ.to_Z z) with\n        | Eq => zero\n        | Lt => Qq ZZ.one (Zabs_N z)\n        | Gt => Qq ZZ.minus_one (Zabs_N z)\n        end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare 0%Z (ZZ.to_Z z) with\n        | Eq => zero\n        | Lt => Qq ZZ.one (Zabs_N z)\n        | Gt => Qq ZZ.minus_one (Zabs_N z)\n        end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z z) with\n     | Eq => zero\n     | Lt => Qq ZZ.one (Zabs_N z)\n     | Gt => Qq ZZ.minus_one (Zabs_N z)\n     end)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match Z.compare 0%Z (ZZ.to_Z z) with\n           | Eq => zero\n           | Lt => Qq ZZ.one (Zabs_N z)\n           | Gt => Qq ZZ.minus_one (Zabs_N z)\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match Z.compare 0%Z (ZZ.to_Z z) with\n              | Eq => zero\n              | Lt => Qq ZZ.one (Zabs_N z)\n              | Gt => Qq ZZ.minus_one (Zabs_N z)\n              end)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (to_Q\n           match Z.compare 0%Z (ZZ.to_Z z) with\n           | Eq => zero\n           | Lt => Qq ZZ.one (Zabs_N z)\n           | Gt => Qq ZZ.minus_one (Zabs_N z)\n           end))\n     (Zpos\n        (Qden\n           (to_Q\n              match Z.compare 0%Z (ZZ.to_Z z) with\n              | Eq => zero\n              | Lt => Qq ZZ.one (Zabs_N z)\n              | Gt => Qq ZZ.minus_one (Zabs_N z)\n              end)))) 1%Z"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z",
                    "c9_H0 : Logic.eq 0%Z (ZZ.to_Z z)",
                    "c10_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq ZZ.one (Zabs_N z))))\n     (Zpos (Qden (to_Q (Qq ZZ.one (Zabs_N z)))))) 1%Z",
                    "c10_H0 : Z.lt 0 (ZZ.to_Z z)",
                    "c11_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq ZZ.minus_one (Zabs_N z))))\n     (Zpos (Qden (to_Q (Qq ZZ.minus_one (Zabs_N z)))))) 1%Z",
                    "c11_H0 : Z.lt (ZZ.to_Z z) 0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.gcd (Qnum (to_Q zero)) (Zpos (Qden (to_Q zero)))) 1%Z"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.gcd (ZZ.to_Z ZZ.zero) 1%Z) 1%Z"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq 1%Z 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq ZZ.one (Zabs_N z))))\n     (Zpos (Qden (to_Q (Qq ZZ.one (Zabs_N z)))))) 1%Z"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z ZZ.one;\n            Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z ZZ.one;\n               Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z ZZ.one;\n            Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z ZZ.one;\n               Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (Z.gcd (Qnum (to_Q (Qq ZZ.minus_one (Zabs_N z))))\n     (Zpos (Qden (to_Q (Qq ZZ.minus_one (Zabs_N z)))))) 1%Z"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z ZZ.minus_one;\n            Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z ZZ.minus_one;\n               Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n             |})))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else\n          {|\n            Qnum := ZZ.to_Z ZZ.minus_one;\n            Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n          |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else\n             {|\n               Qnum := ZZ.to_Z ZZ.minus_one;\n               Qden := Z.to_pos (NN.to_Z (Zabs_N z))\n             |})))) 1%Z"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))))\n  1%Z"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c19_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c18_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z, Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z, Logic.eq 1%Z 1%Z",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c19_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c21_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos (Qden {| Qnum := 1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq (Zpos (Pos.gcd 1%positive (Z.to_pos (Z.abs (ZZ.to_Z z))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq (Zpos (Pos.gcd 1%positive (Z.to_pos (Z.abs (ZZ.to_Z z))))) 1%Z",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c17_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        (if NN.eqb (Zabs_N z) NN.zero\n         then 0\n         else {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))\n     (Zpos\n        (Qden\n           (if NN.eqb (Zabs_N z) NN.zero\n            then 0\n            else {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |}))))\n  1%Z"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z",
                    "c24_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos\n        (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c23_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N z)) (NN.to_Z NN.zero),\nLogic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z, Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z z)) 0%Z, Logic.eq 1%Z 1%Z",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c24_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos\n        (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ],
                "tactic_res": [
                    "c26_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos\n        (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c26_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq\n  (Z.gcd (Qnum {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})\n     (Zpos\n        (Qden {| Qnum := -1; Qden := Z.to_pos (Z.abs (ZZ.to_Z z)) |})))\n  1%Z"
                ],
                "tactic_res": [
                    "c27_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq (Zpos (Pos.gcd 1%positive (Z.to_pos (Z.abs (ZZ.to_Z z))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z z)),\nLogic.eq (Zpos (Pos.gcd 1%positive (Z.to_pos (Z.abs (ZZ.to_Z z))))) 1%Z",
                    "c4_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i in _i .",
                "tactic_args": [
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)",
                    "c5_H : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                    "c5_H : Logic.eq (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n  1%Z"
                ]
            },
            {
                "tactic_sig": "revert _i .",
                "tactic_sig_no_out_arg": "revert _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Q (red (inv_norm (Qq n d)))) (to_Q (inv_norm (Qq n d)))",
                    "c5_H : Logic.eq (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n  1%Z"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq (to_Q (red (inv_norm (Qq n d)))) (to_Q (inv_norm (Qq n d)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq (to_Q (red (inv_norm (Qq n d)))) (to_Q (inv_norm (Qq n d)))"
                ],
                "tactic_res": [
                    "c29_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (to_Q\n     (red\n        (if NN.eqb d NN.zero\n         then zero\n         else\n          match ZZ.compare ZZ.zero n with\n          | Eq => zero\n          | Lt =>\n              match ZZ.compare n ZZ.one with\n              | Gt => Qq (Z_of_N d) (Zabs_N n)\n              | _ => Qz (Z_of_N d)\n              end\n          | Gt =>\n              match ZZ.compare n ZZ.minus_one with\n              | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n              | _ => Qz (ZZ.opp (Z_of_N d))\n              end\n          end)))\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match ZZ.compare ZZ.zero n with\n       | Eq => zero\n       | Lt =>\n           match ZZ.compare n ZZ.one with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match ZZ.compare n ZZ.minus_one with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c29_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (to_Q\n     (red\n        (if NN.eqb d NN.zero\n         then zero\n         else\n          match ZZ.compare ZZ.zero n with\n          | Eq => zero\n          | Lt =>\n              match ZZ.compare n ZZ.one with\n              | Gt => Qq (Z_of_N d) (Zabs_N n)\n              | _ => Qz (Z_of_N d)\n              end\n          | Gt =>\n              match ZZ.compare n ZZ.minus_one with\n              | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n              | _ => Qz (ZZ.opp (Z_of_N d))\n              end\n          end)))\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match ZZ.compare ZZ.zero n with\n       | Eq => zero\n       | Lt =>\n           match ZZ.compare n ZZ.one with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match ZZ.compare n ZZ.minus_one with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))"
                ],
                "tactic_res": [
                    "c30_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (to_Q\n     (red\n        (if NN.eqb d NN.zero\n         then zero\n         else\n          match Z.compare 0%Z (ZZ.to_Z n) with\n          | Eq => zero\n          | Lt =>\n              match Z.compare (ZZ.to_Z n) 1%Z with\n              | Gt => Qq (Z_of_N d) (Zabs_N n)\n              | _ => Qz (Z_of_N d)\n              end\n          | Gt =>\n              match Z.compare (ZZ.to_Z n) (-1)%Z with\n              | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n              | _ => Qz (ZZ.opp (Z_of_N d))\n              end\n          end)))\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match Z.compare 0%Z (ZZ.to_Z n) with\n       | Eq => zero\n       | Lt =>\n           match Z.compare (ZZ.to_Z n) 1%Z with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match Z.compare (ZZ.to_Z n) (-1)%Z with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c30_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (to_Q\n     (red\n        (if NN.eqb d NN.zero\n         then zero\n         else\n          match Z.compare 0%Z (ZZ.to_Z n) with\n          | Eq => zero\n          | Lt =>\n              match Z.compare (ZZ.to_Z n) 1%Z with\n              | Gt => Qq (Z_of_N d) (Zabs_N n)\n              | _ => Qz (Z_of_N d)\n              end\n          | Gt =>\n              match Z.compare (ZZ.to_Z n) (-1)%Z with\n              | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n              | _ => Qz (ZZ.opp (Z_of_N d))\n              end\n          end)))\n  (to_Q\n     (if NN.eqb d NN.zero\n      then zero\n      else\n       match Z.compare 0%Z (ZZ.to_Z n) with\n       | Eq => zero\n       | Lt =>\n           match Z.compare (ZZ.to_Z n) 1%Z with\n           | Gt => Qq (Z_of_N d) (Zabs_N n)\n           | _ => Qz (Z_of_N d)\n           end\n       | Gt =>\n           match Z.compare (ZZ.to_Z n) (-1)%Z with\n           | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n           | _ => Qz (ZZ.opp (Z_of_N d))\n           end\n       end))"
                ],
                "tactic_res": [
                    "c31_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq (to_Q (red zero)) (to_Q zero)",
                    "c32_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare 0%Z (ZZ.to_Z n) with\n        | Eq => zero\n        | Lt =>\n            match Z.compare (ZZ.to_Z n) 1%Z with\n            | Gt => Qq (Z_of_N d) (Zabs_N n)\n            | _ => Qz (Z_of_N d)\n            end\n        | Gt =>\n            match Z.compare (ZZ.to_Z n) (-1)%Z with\n            | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n            | _ => Qz (ZZ.opp (Z_of_N d))\n            end\n        end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt =>\n         match Z.compare (ZZ.to_Z n) 1%Z with\n         | Gt => Qq (Z_of_N d) (Zabs_N n)\n         | _ => Qz (Z_of_N d)\n         end\n     | Gt =>\n         match Z.compare (ZZ.to_Z n) (-1)%Z with\n         | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n         | _ => Qz (ZZ.opp (Z_of_N d))\n         end\n     end)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c31_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq (to_Q (red zero)) (to_Q zero)"
                ],
                "tactic_res": [
                    "c33_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq (to_Q (red zero)) (to_Q zero)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c33_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq (to_Q (red zero)) (to_Q zero)",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c32_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare 0%Z (ZZ.to_Z n) with\n        | Eq => zero\n        | Lt =>\n            match Z.compare (ZZ.to_Z n) 1%Z with\n            | Gt => Qq (Z_of_N d) (Zabs_N n)\n            | _ => Qz (Z_of_N d)\n            end\n        | Gt =>\n            match Z.compare (ZZ.to_Z n) (-1)%Z with\n            | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n            | _ => Qz (ZZ.opp (Z_of_N d))\n            end\n        end))\n  (to_Q\n     match Z.compare 0%Z (ZZ.to_Z n) with\n     | Eq => zero\n     | Lt =>\n         match Z.compare (ZZ.to_Z n) 1%Z with\n         | Gt => Qq (Z_of_N d) (Zabs_N n)\n         | _ => Qz (Z_of_N d)\n         end\n     | Gt =>\n         match Z.compare (ZZ.to_Z n) (-1)%Z with\n         | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n         | _ => Qz (ZZ.opp (Z_of_N d))\n         end\n     end)"
                ],
                "tactic_res": [
                    "c34_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z), Logic.eq (to_Q (red zero)) (to_Q zero)",
                    "c34_H : Logic.eq 0%Z (ZZ.to_Z n)",
                    "c35_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)",
                    "c35_H : Z.lt 0 (ZZ.to_Z n)",
                    "c36_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)",
                    "c36_H : Z.lt (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c34_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z), Logic.eq (to_Q (red zero)) (to_Q zero)"
                ],
                "tactic_res": [
                    "c37_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c37_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}\n  {| Qnum := ZZ.to_Z ZZ.zero; Qden := 1 |}"
                ],
                "tactic_res": [
                    "c38_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq 0 0",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c35_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)"
                ],
                "tactic_res": [
                    "c39_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c39_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)"
                ],
                "tactic_res": [
                    "c40_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)",
                    "c40_H0 : Z.lt 0 (NN.to_Z d)",
                    "c40_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c36_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)"
                ],
                "tactic_res": [
                    "c41_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c41_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)"
                ],
                "tactic_res": [
                    "c42_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)",
                    "c42_H0 : Z.lt 0 (NN.to_Z d)",
                    "c42_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c40_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) 1%Z with\n        | Gt => Qq (Z_of_N d) (Zabs_N n)\n        | _ => Qz (Z_of_N d)\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) 1%Z with\n     | Gt => Qq (Z_of_N d) (Zabs_N n)\n     | _ => Qz (Z_of_N d)\n     end)"
                ],
                "tactic_res": [
                    "c43_goal : Logic.eq (to_Q (red (Qz (Z_of_N d)))) (to_Q (Qz (Z_of_N d)))",
                    "c43_H2 : Logic.eq (ZZ.to_Z n) 1%Z",
                    "c44_goal : Logic.eq (to_Q (red (Qz (Z_of_N d)))) (to_Q (Qz (Z_of_N d)))",
                    "c44_H2 : Z.lt (ZZ.to_Z n) 1",
                    "c45_goal : Logic.eq (to_Q (red (Qq (Z_of_N d) (Zabs_N n))))\n  (to_Q (Qq (Z_of_N d) (Zabs_N n)))",
                    "c45_H2 : Z.lt 1 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c43_goal : Logic.eq (to_Q (red (Qz (Z_of_N d)))) (to_Q (Qz (Z_of_N d)))"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c46_goal : Logic.eq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}"
                ],
                "tactic_res": [
                    "c47_goal : Logic.eq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : Logic.eq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := 1 |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c44_goal : Logic.eq (to_Q (red (Qz (Z_of_N d)))) (to_Q (Qz (Z_of_N d)))"
                ],
                "tactic_res": [
                    "c48_goal : Logic.eq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c48_goal : Logic.eq {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (Z_of_N d); Qden := 1 |}"
                ],
                "tactic_res": [
                    "c49_goal : Logic.eq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c49_goal : Logic.eq {| Qnum := NN.to_Z d; Qden := 1 |}\n  {| Qnum := NN.to_Z d; Qden := 1 |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c45_goal : Logic.eq (to_Q (red (Qq (Z_of_N d) (Zabs_N n))))\n  (to_Q (Qq (Z_of_N d) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c50_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c50_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (Z_of_N d); Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c51_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c51_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})"
                ],
                "tactic_res": [
                    "c52_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0",
                    "c53_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c52_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0"
                ],
                "tactic_res": [
                    "c54_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c53_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c55_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c54_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c56_goal : forall _ : Logic.eq (ZZ.to_Z n) 0%Z,\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0",
                    "c57_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c56_goal : forall _ : Logic.eq (ZZ.to_Z n) 0%Z,\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n))) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c57_goal : Z.le 0 (ZZ.to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c55_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c58_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c58_goal : Logic.eq (to_Q (norm (Z_of_N d) (Zabs_N n)))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_strong_spec_norm : forall (p : ZZ.t) (q : NN.t),\n       Logic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))"
                ],
                "tactic_res": [
                    "c59_goal : Logic.eq (Qred (to_Q (Qq (Z_of_N d) (Zabs_N n))))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c59_goal : Logic.eq (Qred (to_Q (Qq (Z_of_N d) (Zabs_N n))))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c60_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (Z_of_N d);\n         Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n       |}))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c60_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (Z_of_N d);\n         Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n       |}))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c61_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c61_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}))\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c62_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0)\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c63_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c62_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0)\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c64_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c63_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c65_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c64_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c66_goal : forall _ : Logic.eq (ZZ.to_Z n) 0%Z,\nLogic.eq (Qred 0) {| Qnum := NN.to_Z d; Qden := Z.to_pos (ZZ.to_Z n) |}",
                    "c67_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c66_goal : forall _ : Logic.eq (ZZ.to_Z n) 0%Z,\nLogic.eq (Qred 0) {| Qnum := NN.to_Z d; Qden := Z.to_pos (ZZ.to_Z n) |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c67_goal : Z.le 0 (ZZ.to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c65_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c68_goal : Logic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c68_goal : Logic.eq\n  (Qred {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n  {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c69_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c69_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {| Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := NN.to_Z d; Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c70_goal : Logic.eq (Z.gcd (NN.to_Z d) (Zpos (Z.to_pos (Z.abs (ZZ.to_Z n))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c70_goal : Logic.eq (Z.gcd (NN.to_Z d) (Zpos (Z.to_pos (Z.abs (ZZ.to_Z n))))) 1%Z",
                    "_global_Z.abs_eq : forall (n : Z) (_ : Z.le 0 n), Logic.eq (Z.abs n) n"
                ],
                "tactic_res": [
                    "c71_goal : Logic.eq (Z.gcd (NN.to_Z d) (Zpos (Z.to_pos (ZZ.to_Z n)))) 1%Z",
                    "c72_goal : Z.le 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c72_goal : Z.le 0 (ZZ.to_Z n)",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c71_goal : Logic.eq (Z.gcd (NN.to_Z d) (Zpos (Z.to_pos (ZZ.to_Z n)))) 1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c73_goal : Logic.eq (Z.gcd (NN.to_Z d) (ZZ.to_Z n)) 1%Z",
                    "c73_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c74_goal : Z.lt 0 (NN.to_Z d)",
                    "c75_goal : Z.lt 0 (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : Z.lt 0 (NN.to_Z d)",
                    "c40_H0 : Z.lt 0 (NN.to_Z d)",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c75_goal : Z.lt 0 (ZZ.to_Z n)",
                    "c35_H : Z.lt 0 (ZZ.to_Z n)",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c73_goal : Logic.eq (Z.gcd (NN.to_Z d) (ZZ.to_Z n)) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c76_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c76_goal : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c73_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c5_d : NN.t",
                    "c5_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_zcompare .",
                "tactic_sig_no_out_arg": "destr_zcompare .",
                "tactic_args": [
                    "c42_goal : Logic.eq\n  (to_Q\n     (red\n        match Z.compare (ZZ.to_Z n) (-1)%Z with\n        | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n        | _ => Qz (ZZ.opp (Z_of_N d))\n        end))\n  (to_Q\n     match Z.compare (ZZ.to_Z n) (-1)%Z with\n     | Lt => Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)\n     | _ => Qz (ZZ.opp (Z_of_N d))\n     end)"
                ],
                "tactic_res": [
                    "c77_goal : Logic.eq (to_Q (red (Qz (ZZ.opp (Z_of_N d)))))\n  (to_Q (Qz (ZZ.opp (Z_of_N d))))",
                    "c77_H2 : Logic.eq (ZZ.to_Z n) (-1)%Z",
                    "c78_goal : Logic.eq (to_Q (red (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))",
                    "c78_H2 : Z.lt (ZZ.to_Z n) (-1)",
                    "c79_goal : Logic.eq (to_Q (red (Qz (ZZ.opp (Z_of_N d)))))\n  (to_Q (Qz (ZZ.opp (Z_of_N d))))",
                    "c79_H2 : Z.lt (-1) (ZZ.to_Z n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c77_goal : Logic.eq (to_Q (red (Qz (ZZ.opp (Z_of_N d)))))\n  (to_Q (Qz (ZZ.opp (Z_of_N d))))"
                ],
                "tactic_res": [
                    "c80_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c80_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}"
                ],
                "tactic_res": [
                    "c81_goal : Logic.eq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c81_goal : Logic.eq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c78_goal : Logic.eq (to_Q (red (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n))))\n  (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n)))"
                ],
                "tactic_res": [
                    "c82_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c82_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n      Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n    |})"
                ],
                "tactic_res": [
                    "c83_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n    |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c79_goal : Logic.eq (to_Q (red (Qz (ZZ.opp (Z_of_N d)))))\n  (to_Q (Qz (ZZ.opp (Z_of_N d))))"
                ],
                "tactic_res": [
                    "c84_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c84_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d)); Qden := 1 |}"
                ],
                "tactic_res": [
                    "c85_goal : Logic.eq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c85_goal : Logic.eq {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}\n  {| Qnum := Z.opp (NN.to_Z d); Qden := 1 |}",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c83_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  (if NN.eqb (Zabs_N n) NN.zero\n   then 0\n   else\n    {|\n      Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n    |})"
                ],
                "tactic_res": [
                    "c86_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0",
                    "c87_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c86_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0"
                ],
                "tactic_res": [
                    "c88_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c87_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c89_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c88_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c90_goal : forall _ : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0",
                    "c91_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c90_goal : forall _ : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z,\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n))) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c91_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c89_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c92_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c92_goal : Logic.eq (to_Q (norm (ZZ.opp (Z_of_N d)) (Zabs_N n)))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_strong_spec_norm : forall (p : ZZ.t) (q : NN.t),\n       Logic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))"
                ],
                "tactic_res": [
                    "c93_goal : Logic.eq (Qred (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n))))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c93_goal : Logic.eq (Qred (to_Q (Qq (ZZ.opp (Z_of_N d)) (Zabs_N n))))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c94_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n         Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n       |}))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c94_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (ZZ.opp (Z_of_N d));\n         Qden := Z.to_pos (NN.to_Z (Zabs_N n))\n       |}))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c95_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := Z.opp (NN.to_Z d);\n         Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n       |}))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c95_goal : Logic.eq\n  (Qred\n     (if NN.eqb (Zabs_N n) NN.zero\n      then 0\n      else\n       {|\n         Qnum := Z.opp (NN.to_Z d);\n         Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n       |}))\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c96_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "c97_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c96_goal : forall _ : Logic.eq (NN.to_Z (Zabs_N n)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c98_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c97_goal : forall _ : Z.lt 0 (NN.to_Z (Zabs_N n)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c99_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c98_goal : forall _ : Logic.eq (Z.abs (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c100_goal : forall _ : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.opp (ZZ.to_Z n)) |}",
                    "c101_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c100_goal : forall _ : Logic.eq (Z.opp (ZZ.to_Z n)) 0%Z,\nLogic.eq (Qred 0)\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.opp (ZZ.to_Z n)) |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c101_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c99_goal : forall _ : Z.lt 0 (Z.abs (ZZ.to_Z n)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ],
                "tactic_res": [
                    "c102_goal : Logic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c102_goal : Logic.eq\n  (Qred\n     {|\n       Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n     |})\n  {| Qnum := Z.opp (NN.to_Z d); Qden := Z.to_pos (Z.abs (ZZ.to_Z n)) |}",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c103_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.opp (NN.to_Z d);\n          Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.opp (NN.to_Z d);\n             Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c103_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := Z.opp (NN.to_Z d);\n          Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.opp (NN.to_Z d);\n             Qden := Z.to_pos (Z.abs (ZZ.to_Z n))\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c104_goal : Logic.eq\n  (Z.gcd (Z.opp (NN.to_Z d)) (Zpos (Z.to_pos (Z.abs (ZZ.to_Z n))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c104_goal : Logic.eq\n  (Z.gcd (Z.opp (NN.to_Z d)) (Zpos (Z.to_pos (Z.abs (ZZ.to_Z n))))) 1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c105_goal : Logic.eq (Z.gcd (Z.opp (NN.to_Z d)) (Z.abs (ZZ.to_Z n))) 1%Z",
                    "c105_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c106_goal : Z.lt 0 (NN.to_Z d)",
                    "c107_goal : Z.lt 0 (Z.abs (ZZ.to_Z n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c106_goal : Z.lt 0 (NN.to_Z d)",
                    "c42_H0 : Z.lt 0 (NN.to_Z d)",
                    "c5_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c105_goal : Logic.eq (Z.gcd (Z.opp (NN.to_Z d)) (Z.abs (ZZ.to_Z n))) 1%Z",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)",
                    "_global_Z.gcd_abs_l : forall n m : Z, Logic.eq (Z.gcd (Z.abs n) m) (Z.gcd n m)",
                    "_global_Z.gcd_comm : forall n m : Z, Logic.eq (Z.gcd n m) (Z.gcd m n)"
                ],
                "tactic_res": [
                    "c108_goal : Logic.eq (Z.gcd (Z.opp (NN.to_Z d)) (ZZ.to_Z n)) 1%Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c108_goal : Logic.eq (Z.gcd (Z.opp (NN.to_Z d)) (ZZ.to_Z n)) 1%Z",
                    "_global_Zis_gcd_gcd : forall (a b c : Z) (_ : Z.le 0 c) (_ : Zis_gcd a b c),\n       Logic.eq (Z.gcd a b) c"
                ],
                "tactic_res": [
                    "c109_goal : Z.le 0 1",
                    "c110_goal : Zis_gcd (Z.opp (NN.to_Z d)) (ZZ.to_Z n) 1"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c109_goal : Z.le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c110_goal : Zis_gcd (Z.opp (NN.to_Z d)) (ZZ.to_Z n) 1",
                    "_global_Zis_gcd_minus : forall (a b d : Z) (_ : Zis_gcd a (Z.opp b) d), Zis_gcd b a d"
                ],
                "tactic_res": [
                    "c111_goal : Zis_gcd (ZZ.to_Z n) (Z.opp (Z.opp (NN.to_Z d))) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i .",
                "tactic_args": [
                    "c111_goal : Zis_gcd (ZZ.to_Z n) (Z.opp (Z.opp (NN.to_Z d))) 1",
                    "_global_Z.opp_involutive : forall n : Z, Logic.eq (Z.opp (Z.opp n)) n",
                    "c105_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z"
                ],
                "tactic_res": [
                    "c112_goal : Zis_gcd (ZZ.to_Z n) (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c112_goal : Zis_gcd (ZZ.to_Z n) (NN.to_Z d) (Z.gcd (ZZ.to_Z n) (NN.to_Z d))",
                    "_global_Zgcd_is_gcd : forall a b : Z, Zis_gcd a b (Z.gcd a b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c107_goal : Z.lt 0 (Z.abs (ZZ.to_Z n))",
                    "_global_Z.abs_neq : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.abs n) (Z.opp n)"
                ],
                "tactic_res": [
                    "c113_goal : Z.lt 0 (Z.opp (ZZ.to_Z n))",
                    "c114_goal : Z.le (ZZ.to_Z n) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c113_goal : Z.lt 0 (Z.opp (ZZ.to_Z n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c114_goal : Z.le (ZZ.to_Z n) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div x y : [ div x y ] = = [ x ] / [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div x y : [ div x y ] = = [ x ] / [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Qeq (to_Q (div x y)) (Qdiv (to_Q x) (to_Q y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Qeq (to_Q (div x y)) (Qdiv (to_Q x) (to_Q y))",
                    "_global_div : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (mul x (inv y))) (Qdiv (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (mul x (inv y))) (Qdiv (to_Q x) (to_Q y))",
                    "_global_spec_mul : forall x y : t, Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (Qmult (to_Q x) (to_Q (inv y))) (Qdiv (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Qeq (Qmult (to_Q x) (to_Q (inv y))) (Qdiv (to_Q x) (to_Q y))",
                    "_global_Qdiv : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (Qmult (to_Q x) (to_Q (inv y))) (Qmult (to_Q x) (Qinv (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Qeq (Qmult (to_Q x) (to_Q (inv y))) (Qmult (to_Q x) (Qinv (to_Q y)))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q x) (to_Q x)",
                    "c6_goal : Qeq (to_Q (inv y)) (Qinv (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q x) (to_Q x)",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q (inv y)) (Qinv (to_Q y))",
                    "_global_spec_inv : forall x : t, Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_norm x y : [ div_norm x y ] = = [ x ] / [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div_norm x y : [ div_norm x y ] = = [ x ] / [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Qeq (to_Q (div_norm x y)) (Qdiv (to_Q x) (to_Q y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Qeq (to_Q (div_norm x y)) (Qdiv (to_Q x) (to_Q y))",
                    "_global_div_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (mul_norm x (inv_norm y))) (Qdiv (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (mul_norm x (inv_norm y))) (Qdiv (to_Q x) (to_Q y))",
                    "_global_spec_mul_norm : forall x y : t, Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": [
                    "c3_goal : Qeq (Qmult (to_Q x) (to_Q (inv_norm y))) (Qdiv (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Qeq (Qmult (to_Q x) (to_Q (inv_norm y))) (Qdiv (to_Q x) (to_Q y))",
                    "_global_Qdiv : forall (_ : Q) (_ : Q), Q"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (Qmult (to_Q x) (to_Q (inv_norm y)))\n  (Qmult (to_Q x) (Qinv (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Qeq (Qmult (to_Q x) (to_Q (inv_norm y)))\n  (Qmult (to_Q x) (Qinv (to_Q y)))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q x) (to_Q x)",
                    "c6_goal : Qeq (to_Q (inv_norm y)) (Qinv (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q x) (to_Q x)",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q (inv_norm y)) (Qinv (to_Q y))",
                    "_global_spec_inv_norm : forall x : t, Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_div_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_div_norm x y ` ( Reduced x , Reduced y ) : Reduced ( div_norm x y ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_div_norm x y ` ( Reduced x , Reduced y ) : Reduced ( div_norm x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (div_norm x y)",
                    "c1_H0 : Reduced y",
                    "c1_H : Reduced x",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Reduced (div_norm x y)",
                    "_global_div_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Reduced (mul_norm x (inv_norm y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Reduced (mul_norm x (inv_norm y))",
                    "_global_strong_spec_mul_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (mul_norm x y)"
                ],
                "tactic_res": [
                    "c3_goal : Reduced x",
                    "c4_goal : Reduced (inv_norm y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Reduced x",
                    "c1_H : Reduced x",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Reduced (inv_norm y)",
                    "_global_strong_spec_inv_norm : forall (x : t) (_ : Reduced x), Reduced (inv_norm x)"
                ],
                "tactic_res": [
                    "c5_goal : Reduced y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Reduced y",
                    "c1_H0 : Reduced y",
                    "c1_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_square",
        "proof": [
            {
                "tactic_sig": "Theorem spec_square : forall x , [ square x ] = = [ x ] ^ 2 .",
                "tactic_sig_no_out_arg": "Theorem spec_square : forall x , [ square x ] = = [ x ] ^ 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Qeq (to_Q (square x)) (Qpower (to_Q x) 2)"
                ]
            },
            {
                "tactic_sig": "destruct x as [ z | n d ] .",
                "tactic_sig_no_out_arg": "destruct x as [ z | n d ] .",
                "tactic_args": [
                    "c1_goal : forall x : t, Qeq (to_Q (square x)) (Qpower (to_Q x) 2)"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (square (Qz z))) (Qpower (to_Q (Qz z)) 2)",
                    "c2_z : ZZ.t",
                    "c3_goal : Qeq (to_Q (square (Qq n d))) (Qpower (to_Q (Qq n d)) 2)",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (square (Qz z))) (Qpower (to_Q (Qz z)) 2)"
                ],
                "tactic_res": [
                    "c4_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.square z); Qden := 1 |}\n  (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n     {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.square z); Qden := 1 |}\n  (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n     {| Qnum := ZZ.to_Z z; Qden := 1 |})",
                    "_global_ZZ.spec_square : forall x : ZZ.t,\n       Logic.eq (ZZ.to_Z (ZZ.square x)) (Z.mul (ZZ.to_Z x) (ZZ.to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : Qeq {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |}\n  (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n     {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c5_goal : Qeq {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |}\n  (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n     {| Qnum := ZZ.to_Z z; Qden := 1 |})"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |})\n     (Zpos\n        (Qden\n           (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n              {| Qnum := ZZ.to_Z z; Qden := 1 |}))))\n  (Z.mul\n     (Qnum\n        (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n           {| Qnum := ZZ.to_Z z; Qden := 1 |}))\n     (Zpos\n        (Qden {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |})))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |})\n     (Zpos\n        (Qden\n           (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n              {| Qnum := ZZ.to_Z z; Qden := 1 |}))))\n  (Z.mul\n     (Qnum\n        (Qmult {| Qnum := ZZ.to_Z z; Qden := 1 |}\n           {| Qnum := ZZ.to_Z z; Qden := 1 |}))\n     (Zpos\n        (Qden {| Qnum := Z.mul (ZZ.to_Z z) (ZZ.to_Z z); Qden := 1 |})))",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (square (Qq n d))) (Qpower (to_Q (Qq n d)) 2)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq\n  (if NN.eqb (NN.square d) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.square n);\n      Qden := Z.to_pos (NN.to_Z (NN.square d))\n    |})\n  (Qmult\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c7_goal : Qeq\n  (if NN.eqb (NN.square d) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.square n);\n      Qden := Z.to_pos (NN.to_Z (NN.square d))\n    |})\n  (Qmult\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))"
                ],
                "tactic_res": [
                    "c8_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) (NN.to_Z NN.zero)),\nQeq 0 (Qmult 0 0)",
                    "c9_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) (NN.to_Z NN.zero)),\nQeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c10_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)",
                    "c11_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c8_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) (NN.to_Z NN.zero)),\nQeq 0 (Qmult 0 0)"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (NN.to_Z (NN.square d)) 0%Z), Qeq 0 (Qmult 0 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (NN.to_Z (NN.square d)) 0%Z), Qeq 0 (Qmult 0 0)"
                ],
                "tactic_res": [
                    "c13_goal : Qeq 0 (Qmult 0 0)",
                    "c13_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c13_e0 : Logic.eq (NN.to_Z (NN.square d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c9_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) (NN.to_Z NN.zero)),\nQeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) 0%Z),\nQeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.square d)) 0%Z),\nQeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c15_goal : Qeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c15_H : Z.lt 0 (NN.to_Z d)",
                    "c15_e : Logic.eq (NN.to_Z (NN.square d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c10_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)"
                ],
                "tactic_res": [
                    "c16_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)"
                ],
                "tactic_res": [
                    "c17_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)",
                    "c17_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c17_H : Z.lt 0 (NN.to_Z (NN.square d))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (NN.square d))),\nQeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c18_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "c18_H : Z.lt 0 (NN.to_Z d)",
                    "c18_H0 : Z.lt 0 (NN.to_Z (NN.square d))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Qeq 0 (Qmult 0 0)",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_NN.spec_square : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c15_e : Logic.eq (Z.mul (NN.to_Z d) (NN.to_Z d)) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_Z.mul_eq_0 : forall n m : Z,\n       iff (Logic.eq (Z.mul n m) 0%Z) (or (Logic.eq n 0%Z) (Logic.eq m 0%Z))"
                ],
                "tactic_res": [
                    "c15_e : or (Logic.eq (NN.to_Z d) 0%Z) (Logic.eq (NN.to_Z d) 0%Z)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c15_goal : Qeq 0\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c17_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |} (Qmult 0 0)",
                    "_global_NN.spec_square : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c19_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n  |} (Qmult 0 0)",
                    "c19_H : Z.lt 0 (Z.mul (NN.to_Z d) (NN.to_Z d))"
                ]
            },
            {
                "tactic_sig": "nsubst .",
                "tactic_sig_no_out_arg": "nsubst .",
                "tactic_args": [
                    "c19_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n  |} (Qmult 0 0)"
                ],
                "tactic_res": [
                    "c20_goal : Qeq\n  {| Qnum := ZZ.to_Z (ZZ.square n); Qden := Z.to_pos (Z.mul 0%Z 0%Z) |}\n  (Qmult 0 0)",
                    "c20_H : Z.lt 0 (Z.mul 0%Z 0%Z)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : Qeq\n  {| Qnum := ZZ.to_Z (ZZ.square n); Qden := Z.to_pos (Z.mul 0%Z 0%Z) |}\n  (Qmult 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c18_goal : Qeq\n  {|\n    Qnum := ZZ.to_Z (ZZ.square n);\n    Qden := Z.to_pos (NN.to_Z (NN.square d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})",
                    "_global_ZZ.spec_square : forall x : ZZ.t,\n       Logic.eq (ZZ.to_Z (ZZ.square x)) (Z.mul (ZZ.to_Z x) (ZZ.to_Z x))",
                    "_global_NN.spec_square : forall x : NN.t,\n       Logic.eq (NN.to_Z (NN.square x)) (Z.mul (NN.to_Z x) (NN.to_Z x))"
                ],
                "tactic_res": [
                    "c21_goal : Qeq\n  {|\n    Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n    Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c21_goal : Qeq\n  {|\n    Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n    Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n  |}\n  (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n          Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n        |})\n     (Zpos\n        (Qden\n           (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n              {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul\n     (Qnum\n        (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n           {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n             Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n           |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : Logic.eq\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n          Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n        |})\n     (Zpos\n        (Qden\n           (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n              {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))))\n  (Z.mul\n     (Qnum\n        (Qmult {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}\n           {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.mul (ZZ.to_Z n) (ZZ.to_Z n);\n             Qden := Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d))\n           |})))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) (Z.to_pos (NN.to_Z d)))))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Pos.mul (Z.to_pos (NN.to_Z d)) (Z.to_pos (NN.to_Z d)))))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d)))))",
                    "_global_Pos2Z.inj_mul : forall p q : positive,\n       Logic.eq (Zpos (Pos.mul p q)) (Z.mul (Zpos p) (Zpos q))"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (Zpos (Z.to_pos (NN.to_Z d))) (Zpos (Z.to_pos (NN.to_Z d)))))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d)))))"
                ]
            },
            {
                "tactic_sig": "rewrite !Z2Pos.id .",
                "tactic_sig_no_out_arg": "rewrite !Z2Pos.id .",
                "tactic_args": [
                    "c24_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (Zpos (Z.to_pos (NN.to_Z d))) (Zpos (Z.to_pos (NN.to_Z d)))))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Zpos (Z.to_pos (Z.mul (NN.to_Z d) (NN.to_Z d)))))"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (NN.to_Z d) (NN.to_Z d)))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (NN.to_Z d) (NN.to_Z d)))",
                    "c26_goal : Z.lt 0 (Z.mul (NN.to_Z d) (NN.to_Z d))",
                    "c27_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Logic.eq\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (NN.to_Z d) (NN.to_Z d)))\n  (Z.mul (Z.mul (ZZ.to_Z n) (ZZ.to_Z n))\n     (Z.mul (NN.to_Z d) (NN.to_Z d)))",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : Z.lt 0 (NN.to_Z d)",
                    "c18_H : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 (Z.mul (NN.to_Z d) (NN.to_Z d))",
                    "_global_Z.mul_pos_pos : forall (n m : Z) (_ : Z.lt 0 n) (_ : Z.lt 0 m), Z.lt 0 (Z.mul n m)"
                ],
                "tactic_res": [
                    "c28_goal : Z.lt 0 (NN.to_Z d)",
                    "c29_goal : Z.lt 0 (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : Z.lt 0 (NN.to_Z d)",
                    "c18_H : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : Z.lt 0 (NN.to_Z d)",
                    "c18_H : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_power_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_power_pos : forall x p , [ power_pos x p ] = = [ x ] ^ Zpos p .",
                "tactic_sig_no_out_arg": "Theorem spec_power_pos : forall x p , [ power_pos x p ] = = [ x ] ^ Zpos p .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (p : positive),\nQeq (to_Q (power_pos x p)) (Qpower (to_Q x) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "intros [ _o | _o _o ] _o .",
                "tactic_sig_no_out_arg": "intros [ z | n d ] p .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (p : positive),\nQeq (to_Q (power_pos x p)) (Qpower (to_Q x) (Zpos p))"
                ],
                "tactic_res": [
                    "c2_goal : Qeq (to_Q (power_pos (Qz z) p)) (Qpower (to_Q (Qz z)) (Zpos p))",
                    "c3_n : ZZ.t",
                    "c3_d : NN.t",
                    "c3_p : positive",
                    "c3_goal : Qeq (to_Q (power_pos (Qq n d) p)) (Qpower (to_Q (Qq n d)) (Zpos p))",
                    "c2_z : ZZ.t",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Qeq (to_Q (power_pos (Qz z) p)) (Qpower (to_Q (Qz z)) (Zpos p))",
                    "_global_power_pos : forall (_ : t) (_ : positive), t"
                ],
                "tactic_res": [
                    "c4_goal : Qeq (to_Q (Qz (ZZ.pow_pos z p))) (Qpower (to_Q (Qz z)) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Qeq (to_Q (power_pos (Qq n d) p)) (Qpower (to_Q (Qq n d)) (Zpos p))",
                    "_global_power_pos : forall (_ : t) (_ : positive), t"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p)))\n  (Qpower (to_Q (Qq n d)) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Qeq (to_Q (Qz (ZZ.pow_pos z p))) (Qpower (to_Q (Qz z)) (Zpos p))"
                ],
                "tactic_res": [
                    "c6_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}\n  (Qpower_positive {| Qnum := ZZ.to_Z z; Qden := 1 |} p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c6_goal : Qeq {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}\n  (Qpower_positive {| Qnum := ZZ.to_Z z; Qden := 1 |} p)",
                    "_global_ZZ.spec_pow_pos : forall (x : ZZ.t) (n : positive),\n       Logic.eq (ZZ.to_Z (ZZ.pow_pos x n)) (Z.pow (ZZ.to_Z x) (Zpos n))",
                    "_global_Qpower_decomp : forall (p : positive) (x : Z) (y : positive),\n       Logic.eq (Qpower_positive {| Qnum := x; Qden := y |} p)\n         {| Qnum := Z.pow x (Zpos p); Qden := Pos.pow y p |}"
                ],
                "tactic_res": [
                    "c7_goal : Qeq {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |}\n  {|\n    Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := Pos.pow 1%positive p\n  |}"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : Qeq {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |}\n  {|\n    Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := Pos.pow 1%positive p\n  |}"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z z) (Zpos p);\n             Qden := Pos.pow 1%positive p\n           |})))\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z z) (Zpos p);\n          Qden := Pos.pow 1%positive p\n        |})\n     (Zpos (Qden {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.mul (Qnum {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z z) (Zpos p);\n             Qden := Pos.pow 1%positive p\n           |})))\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z z) (Zpos p);\n          Qden := Pos.pow 1%positive p\n        |})\n     (Zpos (Qden {| Qnum := Z.pow (ZZ.to_Z z) (Zpos p); Qden := 1 |})))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq\n  (Z.mul (Z.pow_pos (ZZ.to_Z z) p) (Zpos (Pos.pow 1%positive p)))\n  (Z.mul (Z.pow_pos (ZZ.to_Z z) p) 1%Z)"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c9_goal : Logic.eq\n  (Z.mul (Z.pow_pos (ZZ.to_Z z) p) (Zpos (Pos.pow 1%positive p)))\n  (Z.mul (Z.pow_pos (ZZ.to_Z z) p) 1%Z)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Zpos (Pos.pow 1%positive p)) 1%Z"
                ]
            },
            {
                "tactic_sig": "now rewrite Pos2Z.inj_pow , Z.pow_1_l .",
                "tactic_sig_no_out_arg": "now rewrite Pos2Z.inj_pow , Z.pow_1_l .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Zpos (Pos.pow 1%positive p)) 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p)))\n  (Qpower (to_Q (Qq n d)) (Zpos p))"
                ],
                "tactic_res": [
                    "c11_goal : Qeq\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})\n  (Qpower_positive\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}) p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Qeq\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})\n  (Qpower_positive\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}) p)",
                    "_global_ZZ.spec_pow_pos : forall (x : ZZ.t) (n : positive),\n       Logic.eq (ZZ.to_Z (ZZ.pow_pos x n)) (Z.pow (ZZ.to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c12_goal : Qeq\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})\n  (Qpower_positive\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}) p)"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c12_goal : Qeq\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})\n  (Qpower_positive\n     (if NN.eqb d NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}) p)"
                ],
                "tactic_res": [
                    "c13_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero)),\nQeq 0 (Qpower_positive 0 p)",
                    "c14_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero)),\nQeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)",
                    "c15_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)",
                    "c16_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c13_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero)),\nQeq 0 (Qpower_positive 0 p)"
                ],
                "tactic_res": [
                    "c17_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z),\nQeq 0 (Qpower_positive 0 p)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z),\nQeq 0 (Qpower_positive 0 p)"
                ],
                "tactic_res": [
                    "c18_goal : Qeq 0 (Qpower_positive 0 p)",
                    "c18_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c18_e0 : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c14_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero)),\nQeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ],
                "tactic_res": [
                    "c19_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z),\nQeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c19_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z),\nQeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ],
                "tactic_res": [
                    "c20_goal : Qeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)",
                    "c20_H : Z.lt 0 (NN.to_Z d)",
                    "c20_e : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c15_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)"
                ],
                "tactic_res": [
                    "c21_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z)\n  (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)"
                ],
                "tactic_res": [
                    "c22_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)",
                    "c22_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c22_H : Z.lt 0 (NN.to_Z (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (_ : Z.lt 0 (NN.to_Z d)) (_ : Z.lt 0 (NN.to_Z (NN.pow_pos d p))),\nQeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ],
                "tactic_res": [
                    "c23_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)",
                    "c23_H : Z.lt 0 (NN.to_Z d)",
                    "c23_H0 : Z.lt 0 (NN.to_Z (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Qeq 0 (Qpower_positive 0 p)",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c24_goal : Qeq (Qpower_positive 0 p) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : Qeq (Qpower_positive 0 p) 0",
                    "_global_Qpower_positive_0 : forall n : positive, Qeq (Qpower_positive 0 n) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_NN.spec_pow_pos : forall (x : NN.t) (n : positive),\n       Logic.eq (NN.to_Z (NN.pow_pos x n)) (Z.pow (NN.to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c20_e : Logic.eq (Z.pow (NN.to_Z d) (Zpos p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "assert ( 0 < NN.to_Z _i ^ Zpos _i ) % Z by ( apply Z.pow_pos_nonneg ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "assert ( 0 < NN.to_Z _i ^ Zpos _i ) % Z by ( apply Z.pow_pos_nonneg ; auto with zarith ) .",
                "tactic_args": [
                    "c3_d : NN.t",
                    "c3_p : positive",
                    "c20_e : Logic.eq (Z.pow (NN.to_Z d) (Zpos p)) 0%Z",
                    "c20_H : Z.lt 0 (NN.to_Z d)",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": [
                    "c20_H0 : Z.lt 0 (Z.pow (NN.to_Z d) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : Qeq 0\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c22_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |} (Qpower_positive 0 p)"
                ],
                "tactic_res": [
                    "c25_goal : False"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_NN.spec_pow_pos : forall (x : NN.t) (n : positive),\n       Logic.eq (NN.to_Z (NN.pow_pos x n)) (Z.pow (NN.to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c25_H : Z.lt 0 (Z.pow (NN.to_Z d) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c25_goal : False",
                    "_global_Z.pow_0_l' : forall (a : Z) (_ : not (Logic.eq a 0%Z)), Logic.eq (Z.pow 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c26_goal : False",
                    "c26_H : Z.lt 0 0",
                    "c27_goal : not (Logic.eq (Zpos p) 0%Z)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c27_goal : not (Logic.eq (Zpos p) 0%Z)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  (Qpower_positive\n     {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |} p)",
                    "_global_Qpower_decomp : forall (p : positive) (x : Z) (y : positive),\n       Logic.eq (Qpower_positive {| Qnum := x; Qden := y |} p)\n         {| Qnum := Z.pow x (Zpos p); Qden := Pos.pow y p |}"
                ],
                "tactic_res": [
                    "c28_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n  |}"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c28_goal : Qeq\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}\n  {|\n    Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n    Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n  |}"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n             Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n           |})))\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n          Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |})))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : Logic.eq\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n             Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n           |})))\n  (Z.mul\n     (Qnum\n        {|\n          Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n          Qden := Pos.pow (Z.to_pos (NN.to_Z d)) p\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := Z.pow (ZZ.to_Z n) (Zpos p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |})))"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq\n  (Z.mul (Z.pow_pos (ZZ.to_Z n) p)\n     (Zpos (Pos.pow (Z.to_pos (NN.to_Z d)) p)))\n  (Z.mul (Z.pow_pos (ZZ.to_Z n) p)\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p)))))"
                ]
            },
            {
                "tactic_sig": "do 3 f_equal .",
                "tactic_sig_no_out_arg": "do 3 f_equal .",
                "tactic_args": [
                    "c30_goal : Logic.eq\n  (Z.mul (Z.pow_pos (ZZ.to_Z n) p)\n     (Zpos (Pos.pow (Z.to_pos (NN.to_Z d)) p)))\n  (Z.mul (Z.pow_pos (ZZ.to_Z n) p)\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p)))))"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (Pos.pow (Z.to_pos (NN.to_Z d)) p)\n  (Z.to_pos (NN.to_Z (NN.pow_pos d p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : Logic.eq (Pos.pow (Z.to_pos (NN.to_Z d)) p)\n  (Z.to_pos (NN.to_Z (NN.pow_pos d p)))",
                    "_global_Pos2Z.inj : forall (p q : positive) (_ : Logic.eq (Zpos p) (Zpos q)), Logic.eq p q"
                ],
                "tactic_res": [
                    "c32_goal : Logic.eq (Zpos (Pos.pow (Z.to_pos (NN.to_Z d)) p))\n  (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c32_goal : Logic.eq (Zpos (Pos.pow (Z.to_pos (NN.to_Z d)) p))\n  (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))",
                    "_global_Pos2Z.inj_pow : forall p q : positive,\n       Logic.eq (Zpos (Pos.pow p q)) (Z.pow (Zpos p) (Zpos q))"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq (Z.pow (Zpos (Z.to_pos (NN.to_Z d))) (Zpos p))\n  (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i _i by ( generalize ( _i _i ) ; lia ) .",
                "tactic_sig_no_out_arg": "rewrite _i _i by ( generalize ( _i _i ) ; lia ) .",
                "tactic_args": [
                    "c33_goal : Logic.eq (Z.pow (Zpos (Z.to_pos (NN.to_Z d))) (Zpos p))\n  (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))",
                    "_global_2 : Q",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x",
                    "_global_NN.spec_pos : forall x : NN.t, Z.le 0 (NN.to_Z x)",
                    "c3_d : NN.t"
                ],
                "tactic_res": [
                    "c34_goal : Logic.eq (Z.pow (NN.to_Z d) (Zpos p)) (NN.to_Z (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "now rewrite NN.spec_pow_pos .",
                "tactic_sig_no_out_arg": "now rewrite NN.spec_pow_pos .",
                "tactic_args": [
                    "c34_goal : Logic.eq (Z.pow (NN.to_Z d) (Zpos p)) (NN.to_Z (NN.pow_pos d p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_power_pos",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_power_pos x p ` ( Reduced x ) : Reduced ( power_pos x p ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_power_pos x p ` ( Reduced x ) : Reduced ( power_pos x p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (power_pos x p)",
                    "c1_H : Reduced x",
                    "c1_p : positive",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ z | n d ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ z | n d ] .",
                "tactic_args": [
                    "c1_goal : Reduced (power_pos x p)",
                    "c1_x : True",
                    "c1_H : Reduced x",
                    "c1_p : positive"
                ],
                "tactic_res": [
                    "c2_goal : Reduced (power_pos (Qz z) p)",
                    "c2_H : Reduced (Qz z)",
                    "c2_z : ZZ.t",
                    "c3_goal : Reduced (power_pos (Qq n d) p)",
                    "c3_H : Reduced (Qq n d)",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Reduced (power_pos (Qz z) p)"
                ],
                "tactic_res": [
                    "c4_goal : Reduced (Qz (ZZ.pow_pos z p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Reduced (power_pos (Qq n d) p)"
                ],
                "tactic_res": [
                    "c5_goal : Reduced (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : Reduced (Qz (ZZ.pow_pos z p))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Q (red (Qz (ZZ.pow_pos z p))))\n  (to_Q (Qz (ZZ.pow_pos z p)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Q (red (Qz (ZZ.pow_pos z p))))\n  (to_Q (Qz (ZZ.pow_pos z p)))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.eq {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}\n  {| Qnum := ZZ.to_Z (ZZ.pow_pos z p); Qden := 1 |}",
                    "c1_p : positive",
                    "c2_z : ZZ.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c5_goal : Reduced (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Q (red (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))))\n  (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Q (red (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))))\n  (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p)))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Q (norm (ZZ.pow_pos n p) (NN.pow_pos d p)))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Q (norm (ZZ.pow_pos n p) (NN.pow_pos d p)))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})",
                    "_global_strong_spec_norm : forall (p : ZZ.t) (q : NN.t),\n       Logic.eq (to_Q (norm p q)) (Qred (to_Q (Qq p q)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Qred (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Qred (to_Q (Qq (ZZ.pow_pos n p) (NN.pow_pos d p))))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (Qred\n     (if NN.eqb (NN.pow_pos d p) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n         Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n       |}))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (Qred\n     (if NN.eqb (NN.pow_pos d p) NN.zero\n      then 0\n      else\n       {|\n         Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n         Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n       |}))\n  (if NN.eqb (NN.pow_pos d p) NN.zero\n   then 0\n   else\n    {|\n      Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n      Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n    |})"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0) 0",
                    "c13_goal : forall _ : Z.lt 0 (NN.to_Z (NN.pow_pos d p)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n       Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n     |})\n  {|\n    Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq (NN.to_Z (NN.pow_pos d p)) (NN.to_Z NN.zero),\nLogic.eq (Qred 0) 0"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z, Logic.eq (Qred 0) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall _ : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z, Logic.eq (Qred 0) 0"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Qred 0) 0",
                    "c15_e : Logic.eq (NN.to_Z (NN.pow_pos d p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt 0 (NN.to_Z (NN.pow_pos d p)),\nLogic.eq\n  (Qred\n     {|\n       Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n       Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n     |})\n  {|\n    Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq\n  (Qred\n     {|\n       Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n       Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n     |})\n  {|\n    Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}",
                    "c16_H0 : Z.lt 0 (NN.to_Z (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Qred 0) 0"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (Qred\n     {|\n       Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n       Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n     |})\n  {|\n    Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n    Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n  |}",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "revert _i .",
                "tactic_sig_no_out_arg": "revert _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z",
                    "c3_H : Reduced (Qq n d)"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : Reduced (Qq n d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : forall _ : Reduced (Qq n d),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c20_goal : forall _ : Logic.eq (to_Q (red (Qq n d))) (to_Q (Qq n d)),\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_Qred_iff : forall q : Q,\n       iff (Logic.eq (Qred q) q)\n         (Logic.eq (Z.gcd (Qnum q) (Zpos (Qden q))) 1%Z)"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : Logic.eq\n        (Z.gcd (Qnum (to_Q (Qq n d))) (Zpos (Qden (to_Q (Qq n d)))))\n        1%Z,\nLogic.eq\n  (Z.gcd\n     (Qnum\n        {|\n          Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n          Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n        |})\n     (Zpos\n        (Qden\n           {|\n             Qnum := ZZ.to_Z (ZZ.pow_pos n p);\n             Qden := Z.to_pos (NN.to_Z (NN.pow_pos d p))\n           |}))) 1%Z"
                ],
                "tactic_res": [
                    "c22_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "destr_eqb .",
                "tactic_sig_no_out_arg": "destr_eqb .",
                "tactic_args": [
                    "c22_goal : forall\n  _ : Logic.eq\n        (Z.gcd\n           (Qnum\n              (if NN.eqb d NN.zero\n               then 0\n               else\n                {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |}))\n           (Zpos\n              (Qden\n                 (if NN.eqb d NN.zero\n                  then 0\n                  else\n                   {|\n                     Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d)\n                   |})))) 1%Z,\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c23_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z",
                    "c24_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c23_goal : forall (_ : Logic.eq (NN.to_Z d) (NN.to_Z NN.zero))\n  (_ : Logic.eq (Z.gcd (Qnum 0) (Zpos (Qden 0))) 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c25_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c25_goal : forall (_ : Logic.eq (NN.to_Z d) 0%Z) (_ : Logic.eq 1%Z 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z",
                    "c26_e : Logic.eq (NN.to_Z d) 0%Z",
                    "c26_H : Logic.eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c24_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq\n         (Z.gcd\n            (Qnum {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})\n            (Zpos\n               (Qden\n                  {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})))\n         1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c27_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c27_goal : forall (_ : Z.lt 0 (NN.to_Z d))\n  (_ : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z),\nLogic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z",
                    "c28_H : Z.lt 0 (NN.to_Z d)",
                    "c28_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (Zpos (Z.to_pos (NN.to_Z d)))) 1%Z"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c26_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z"
                ],
                "tactic_res": [
                    "c29_goal : False"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "_global_NN.spec_pow_pos : forall (x : NN.t) (n : positive),\n       Logic.eq (NN.to_Z (NN.pow_pos x n)) (Z.pow (NN.to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c29_H0 : Z.lt 0 (Z.pow (NN.to_Z d) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c29_goal : False",
                    "_global_Z.pow_0_l' : forall (a : Z) (_ : not (Logic.eq a 0%Z)), Logic.eq (Z.pow 0 a) 0%Z"
                ],
                "tactic_res": [
                    "c30_goal : False",
                    "c30_H0 : Z.lt 0 0",
                    "c31_goal : not (Logic.eq (Zpos p) 0%Z)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c30_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c31_goal : not (Logic.eq (Zpos p) 0%Z)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c28_goal : Logic.eq\n  (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p))\n     (Zpos (Z.to_pos (NN.to_Z (NN.pow_pos d p))))) 1%Z",
                    "_global_Z2Pos.id : forall (x : Z) (_ : Z.lt 0 x), Logic.eq (Zpos (Z.to_pos x)) x"
                ],
                "tactic_res": [
                    "c32_goal : Logic.eq (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p)) (NN.to_Z (NN.pow_pos d p)))\n  1%Z",
                    "c32_H1 : Logic.eq (Z.gcd (ZZ.to_Z n) (NN.to_Z d)) 1%Z",
                    "c33_goal : Z.lt 0 (NN.to_Z d)",
                    "c34_goal : Z.lt 0 (NN.to_Z (NN.pow_pos d p))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : Z.lt 0 (NN.to_Z d)",
                    "c28_H : Z.lt 0 (NN.to_Z d)",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Z.lt 0 (NN.to_Z (NN.pow_pos d p))",
                    "c16_H0 : Z.lt 0 (NN.to_Z (NN.pow_pos d p))",
                    "c1_p : positive",
                    "c3_d : NN.t"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c32_goal : Logic.eq (Z.gcd (ZZ.to_Z (ZZ.pow_pos n p)) (NN.to_Z (NN.pow_pos d p)))\n  1%Z",
                    "_global_NN.spec_pow_pos : forall (x : NN.t) (n : positive),\n       Logic.eq (NN.to_Z (NN.pow_pos x n)) (Z.pow (NN.to_Z x) (Zpos n))",
                    "_global_ZZ.spec_pow_pos : forall (x : ZZ.t) (n : positive),\n       Logic.eq (ZZ.to_Z (ZZ.pow_pos x n)) (Z.pow (ZZ.to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c35_goal : Logic.eq\n  (Z.gcd (Z.pow (ZZ.to_Z n) (Zpos p)) (Z.pow (NN.to_Z d) (Zpos p))) 1%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c35_goal : Logic.eq\n  (Z.gcd (Z.pow (ZZ.to_Z n) (Zpos p)) (Z.pow (NN.to_Z d) (Zpos p))) 1%Z",
                    "_global_Zgcd_1_rel_prime : forall a b : Z, iff (Logic.eq (Z.gcd a b) 1%Z) (rel_prime a b)"
                ],
                "tactic_res": [
                    "c36_goal : rel_prime (Z.pow (ZZ.to_Z n) (Zpos p)) (Z.pow (NN.to_Z d) (Zpos p))",
                    "c36_H1 : rel_prime (ZZ.to_Z n) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : rel_prime (Z.pow (ZZ.to_Z n) (Zpos p)) (Z.pow (NN.to_Z d) (Zpos p))",
                    "_global_rel_prime_Zpower : forall (i j p q : Z) (_ : Z.le 0 i) (_ : Z.le 0 j) (_ : rel_prime p q),\n       rel_prime (Z.pow p i) (Z.pow q j)"
                ],
                "tactic_res": [
                    "c37_goal : Z.le 0 (Zpos p)",
                    "c38_goal : Z.le 0 (Zpos p)",
                    "c39_goal : rel_prime (ZZ.to_Z n) (NN.to_Z d)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c37_goal : Z.le 0 (Zpos p)",
                    "c1_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c38_goal : Z.le 0 (Zpos p)",
                    "c1_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c39_goal : rel_prime (ZZ.to_Z n) (NN.to_Z d)",
                    "c36_H1 : rel_prime (ZZ.to_Z n) (NN.to_Z d)",
                    "c3_d : NN.t",
                    "c3_n : ZZ.t"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_power",
        "proof": [
            {
                "tactic_sig": "Theorem spec_power : forall x z , [ power x z ] = = [ x ] ^ z .",
                "tactic_sig_no_out_arg": "Theorem spec_power : forall x z , [ power x z ] = = [ x ] ^ z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ]
            },
            {
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_sig_no_out_arg": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_power_norm",
        "proof": [
            {
                "tactic_sig": "Theorem spec_power_norm : forall x z , [ power_norm x z ] = = [ x ] ^ z .",
                "tactic_sig_no_out_arg": "Theorem spec_power_norm : forall x z , [ power_norm x z ] = = [ x ] ^ z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ]
            },
            {
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_sig_no_out_arg": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_power_norm",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_power_norm x z : Reduced x -> Reduced ( power_norm x z ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_power_norm x z : Reduced x -> Reduced ( power_norm x z ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall _ : Reduced x, Reduced (power_norm x z)",
                    "c1_z : Z",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c1_goal : forall _ : Reduced x, Reduced (power_norm x z)",
                    "c1_z : Z",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Reduced x, Reduced (power_norm x 0)",
                    "c3_goal : forall _ : Reduced x, Reduced (power_norm x (Zpos p))",
                    "c3_p : positive",
                    "c4_goal : forall _ : Reduced x, Reduced (power_norm x (Zneg p))",
                    "c4_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : Reduced x, Reduced (power_norm x 0)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Reduced x, Reduced one"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : Reduced x, Reduced (power_norm x (Zpos p))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Reduced x, Reduced (power_pos x p)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall _ : Reduced x, Reduced (power_norm x (Zneg p))"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : Reduced x, Reduced (inv_norm (power_pos x p))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c5_goal : forall _ : Reduced x, Reduced one"
                ],
                "tactic_res": [
                    "c8_goal : Reduced one"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Reduced one",
                    "_global_Reduced : forall _ : t, Prop"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Q (red one)) (to_Q one)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Q (red one)) (to_Q one)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Qred (to_Q one)) (to_Q one)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Qred (to_Q one)) (to_Q one)",
                    "_global_one : t"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Qred (to_Q (Qz ZZ.one))) (to_Q (Qz ZZ.one))"
                ]
            },
            {
                "tactic_sig": "simpl to_Q .",
                "tactic_sig_no_out_arg": "simpl to_Q .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Qred (to_Q (Qz ZZ.one))) (to_Q (Qz ZZ.one))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Qred {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |})\n  {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |}"
                ]
            },
            {
                "tactic_sig": "nzsimpl .",
                "tactic_sig_no_out_arg": "nzsimpl .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Qred {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |})\n  {| Qnum := ZZ.to_Z ZZ.one; Qden := 1 |}"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Qred 1) 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Qred 1) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall _ : Reduced x, Reduced (power_pos x p)"
                ],
                "tactic_res": [
                    "c14_goal : Reduced (power_pos x p)",
                    "c14_H : Reduced x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Reduced (power_pos x p)",
                    "_global_strong_spec_power_pos : forall (x : t) (p : positive) (_ : Reduced x), Reduced (power_pos x p)"
                ],
                "tactic_res": [
                    "c15_goal : Reduced x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Reduced x",
                    "c14_H : Reduced x",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall _ : Reduced x, Reduced (inv_norm (power_pos x p))"
                ],
                "tactic_res": [
                    "c16_goal : Reduced (inv_norm (power_pos x p))",
                    "c16_H : Reduced x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Reduced (inv_norm (power_pos x p))",
                    "_global_strong_spec_inv_norm : forall (x : t) (_ : Reduced x), Reduced (inv_norm x)"
                ],
                "tactic_res": [
                    "c17_goal : Reduced (power_pos x p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Reduced (power_pos x p)",
                    "_global_strong_spec_power_pos : forall (x : t) (p : positive) (_ : Reduced x), Reduced (power_pos x p)"
                ],
                "tactic_res": [
                    "c18_goal : Reduced x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Reduced x",
                    "c16_H : Reduced x",
                    "c1_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_of_Qc",
        "proof": [
            {
                "tactic_sig": "Theorem strong_spec_of_Qc : forall q , [ of_Qc q ] = q .",
                "tactic_sig_no_out_arg": "Theorem strong_spec_of_Qc : forall q , [ of_Qc q ] = q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ]
            },
            {
                "tactic_sig": "intros ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros ( q , Hq ) .",
                "tactic_args": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (of_Qc {| this := q; canon := Hq |}))\n  {| this := q; canon := Hq |}",
                    "c2_q : Q",
                    "c2_Hq : Logic.eq (Qred q) q"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (of_Qc {| this := q; canon := Hq |}))\n  {| this := q; canon := Hq |}",
                    "_global_of_Qc : forall _ : Qc, t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (of_Q {| this := q; canon := Hq |}))\n  {| this := q; canon := Hq |}"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (of_Q {| this := q; canon := Hq |}))\n  {| this := q; canon := Hq |}",
                    "_global_strong_spec_of_Q : forall q : Q, Logic.eq (to_Q (of_Q q)) q"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq {| this := q; canon := Hq |} {| this := q; canon := Hq |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : Logic.eq {| this := q; canon := Hq |} {| this := q; canon := Hq |}",
                    "c2_Hq : Logic.eq (Qred q) q",
                    "c2_q : Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "strong_spec_of_Qc_bis",
        "proof": [
            {
                "tactic_sig": "Instance strong_spec_of_Qc_bis q : Reduced ( of_Qc q ) .",
                "tactic_sig_no_out_arg": "Instance strong_spec_of_Qc_bis q : Reduced ( of_Qc q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Reduced (of_Qc q)",
                    "c1_q : Qc"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c1_goal : Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (red (of_Qc q))) (to_Q (of_Qc q))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (red (of_Qc q))) (to_Q (of_Qc q))",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qred q) q"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qred q) q",
                    "c1_q : Qc"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred {| this := this; canon := canon |})\n  {| this := this; canon := canon |}",
                    "c4_canon : Logic.eq (Qred this) this",
                    "c4_this : Q"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred {| this := this; canon := canon |})\n  {| this := this; canon := canon |}"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qred this) this"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qred this) this",
                    "c4_canon : Logic.eq (Qred this) this",
                    "c4_this : Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_of_Qc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_of_Qc : forall q , [ [ of_Qc q ] ] = q .",
                "tactic_sig_no_out_arg": "Theorem spec_of_Qc : forall q , [ [ of_Qc q ] ] = q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Qc (of_Qc q)) q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Qc (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (of_Qc q)) q",
                    "c2_q : Qc"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qred (to_Q (of_Qc q))) q"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qred (to_Q (of_Qc q))) q",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred q) q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred q) q",
                    "_global_canon : forall q : Qc, Logic.eq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_oppc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_oppc : forall q , [ [ opp q ] ] = - [ [ q ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_oppc : forall q , [ [ opp q ] ] = - [ [ q ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : t, Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros q .",
                "tactic_args": [
                    "c1_goal : forall q : t, Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))",
                    "c2_q : True"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))",
                    "_global_Qcopp : forall _ : Qc, Qc",
                    "_global_to_Qc : forall _ : t, Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  {|\n    this := Qred (to_Q (opp q));\n    canon := Qred_involutive (to_Q (opp q))\n  |}\n  {|\n    this :=\n      Qred\n        (Qopp\n           {|\n             this := Qred (to_Q q); canon := Qred_involutive (to_Q q)\n           |});\n    canon :=\n      Qred_involutive\n        (Qopp\n           {|\n             this := Qred (to_Q q); canon := Qred_involutive (to_Q q)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  {|\n    this := Qred (to_Q (opp q));\n    canon := Qred_involutive (to_Q (opp q))\n  |}\n  {|\n    this :=\n      Qred\n        (Qopp\n           {|\n             this := Qred (to_Q q); canon := Qred_involutive (to_Q q)\n           |});\n    canon :=\n      Qred_involutive\n        (Qopp\n           {|\n             this := Qred (to_Q q); canon := Qred_involutive (to_Q q)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (opp q))) (Qred (Qopp (Qred (to_Q q))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (opp q))) (Qred (Qopp (Qred (to_Q q))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c5_goal : Qeq (to_Q (opp q)) (Qopp (Qred (to_Q q)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i , _i .",
                "tactic_args": [
                    "c5_goal : Qeq (to_Q (opp q)) (Qopp (Qred (to_Q q)))",
                    "_global_spec_opp : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))",
                    "_global_Qred_opp : forall q : Q, Logic.eq (Qred (Qopp q)) (Qopp (Qred q))",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qopp (to_Q q)) (Qopp (to_Q q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qopp (to_Q q)) (Qopp (to_Q q))",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_oppc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_oppc_bis : forall q : Qc , [ opp ( of_Qc q ) ] = - q .",
                "tactic_sig_no_out_arg": "Theorem spec_oppc_bis : forall q : Qc , [ opp ( of_Qc q ) ] = - q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Q (opp (of_Qc q))) (Qcopp q)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall q : Qc, Logic.eq (to_Q (opp (of_Qc q))) (Qcopp q)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (opp (of_Qc q))) (Qcopp q)",
                    "c2_q : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (opp (of_Qc q))) (Qcopp q)",
                    "_global_strong_spec_opp_norm : forall (q : t) (_ : Reduced q), Reduced (opp q)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (opp (of_Qc q)))) (Qcopp q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (opp (of_Qc q)))) (Qcopp q)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (opp (of_Qc q)))) (Qcopp q)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (opp (of_Qc q)))) (Qcopp q)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcopp q) (Qred (to_Q (opp (of_Qc q))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( - _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( - _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcopp q) (Qred (to_Q (opp (of_Qc q))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_q : Qc",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qopp q) (to_Q (opp (of_Qc q)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qopp q) (to_Q (opp (of_Qc q)))",
                    "_global_spec_opp : forall q : t, Qeq (to_Q (opp q)) (Qopp (to_Q q))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qopp q) (Qopp q)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (Qopp q) (Qopp q)",
                    "c2_q : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_comparec",
        "proof": [
            {
                "tactic_sig": "Theorem spec_comparec : forall q1 q2 , compare q1 q2 = ( [ [ q1 ] ] ? = [ [ q2 ] ] ) .",
                "tactic_sig_no_out_arg": "Theorem spec_comparec : forall q1 q2 , compare q1 q2 = ( [ [ q1 ] ] ? = [ [ q2 ] ] ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qccompare (to_Qc q1) (to_Qc q2))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qccompare (to_Qc q1) (to_Qc q2))",
                    "_global_Qccompare : forall (_ : Qc) (_ : Qc), comparison",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros q1 q2 .",
                "tactic_args": [
                    "c2_goal : forall q1 q2 : t,\nLogic.eq (compare q1 q2) (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (compare q1 q2) (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))",
                    "c3_q1 : True",
                    "c3_q2 : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (compare q1 q2) (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))",
                    "_global_spec_compare : forall q1 q2 : t,\n       Logic.eq (compare q1 q2) (Qcompare (to_Q q1) (to_Q q2))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qcompare (to_Q q1) (to_Q q2))\n  (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qcompare (to_Q q1) (to_Q q2))\n  (Qcompare (Q2Qc (to_Q q1)) (Q2Qc (to_Q q2)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcompare (to_Q q1) (to_Q q2))\n  (Qcompare (Qred (to_Q q1)) (Qred (to_Q q2)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcompare (to_Q q1) (to_Q q2))\n  (Qcompare (Qred (to_Q q1)) (Qred (to_Q q2)))",
                    "_global_Qcompare_comp : Proper (respectful Qeq (respectful Qeq Logic.eq)) Qcompare"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (to_Q q1) (Qred (to_Q q1))",
                    "c7_goal : Qeq (to_Q q2) (Qred (to_Q q2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Qeq (to_Q q1) (Qred (to_Q q1))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c8_goal : Qeq (Qred (to_Q q1)) (to_Q q1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Qeq (Qred (to_Q q1)) (to_Q q1)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q q2) (Qred (to_Q q2))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c9_goal : Qeq (Qred (to_Q q2)) (to_Q q2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Qeq (Qred (to_Q q2)) (to_Q q2)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_addc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_addc x y : [ [ add x y ] ] = [ [ x ] ] + [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_addc x y : [ [ add x y ] ] = [ [ x ] ] + [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (add x y)) (Qcplus (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (add x y)) (Qcplus (to_Qc x) (to_Qc y))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (add x y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] + [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] + [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (add x y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (add x y))) (Q2Qc (Qplus (to_Q x) (to_Q y)))",
                    "c4_goal : Logic.eq (Q2Qc (Qplus (to_Q x) (to_Q y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (add x y))) (Q2Qc (Qplus (to_Q x) (to_Q y)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (add x y));\n    canon := Qred_involutive (to_Q (add x y))\n  |}\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (add x y));\n    canon := Qred_involutive (to_Q (add x y))\n  |}\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (add x y))) (Qred (Qplus (to_Q x) (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (add x y))) (Qred (Qplus (to_Q x) (to_Q y)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_spec_add : forall x y : t, Qeq (to_Q (add x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qplus (to_Q x) (to_Q y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "_global_Qcplus : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qplus (to_Q x) (to_Q y)))\n  (Qred (Qplus (Qred (to_Q x)) (Qred (to_Q y))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qplus (to_Q x) (to_Q y)))\n  (Qred (Qplus (Qred (to_Q x)) (Qred (to_Q y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (Qred (to_Q x)) (Qred (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (Qred (to_Q x)) (Qred (to_Q y)))",
                    "_global_Qplus_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qplus"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add_normc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add_normc x y : [ [ add_norm x y ] ] = [ [ x ] ] + [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_add_normc x y : [ [ add_norm x y ] ] = [ [ x ] ] + [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (add_norm x y)) (Qcplus (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (add_norm x y)) (Qcplus (to_Qc x) (to_Qc y))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (add_norm x y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] + [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] + [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (add_norm x y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (add_norm x y))) (Q2Qc (Qplus (to_Q x) (to_Q y)))",
                    "c4_goal : Logic.eq (Q2Qc (Qplus (to_Q x) (to_Q y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (add_norm x y))) (Q2Qc (Qplus (to_Q x) (to_Q y)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (add_norm x y));\n    canon := Qred_involutive (to_Q (add_norm x y))\n  |}\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (add_norm x y));\n    canon := Qred_involutive (to_Q (add_norm x y))\n  |}\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (add_norm x y))) (Qred (Qplus (to_Q x) (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (add_norm x y))) (Qred (Qplus (to_Q x) (to_Q y)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_spec_add_norm : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qplus (to_Q x) (to_Q y)))\n  (Qcplus (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "_global_Qcplus : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qplus (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qplus (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qplus\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qplus (to_Q x) (to_Q y)))\n  (Qred (Qplus (Qred (to_Q x)) (Qred (to_Q y))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qplus (to_Q x) (to_Q y)))\n  (Qred (Qplus (Qred (to_Q x)) (Qred (to_Q y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (Qred (to_Q x)) (Qred (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qplus (to_Q x) (to_Q y)) (Qplus (Qred (to_Q x)) (Qred (to_Q y)))",
                    "_global_Qplus_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qplus"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add_normc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add_normc_bis : forall x y : Qc , [ add_norm ( of_Qc x ) ( of_Qc y ) ] = x + y .",
                "tactic_sig_no_out_arg": "Theorem spec_add_normc_bis : forall x y : Qc , [ add_norm ( of_Qc x ) ( of_Qc y ) ] = x + y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (add_norm (of_Qc x) (of_Qc y))) (Qcplus x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (add_norm (of_Qc x) (of_Qc y))) (Qcplus x y)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (add_norm (of_Qc x) (of_Qc y))) (Qcplus x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (add_norm (of_Qc x) (of_Qc y))) (Qcplus x y)",
                    "_global_strong_spec_add_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (add_norm x y)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (add_norm (of_Qc x) (of_Qc y)))) (Qcplus x y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (add_norm (of_Qc x) (of_Qc y)))) (Qcplus x y)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (add_norm (of_Qc x) (of_Qc y)))) (Qcplus x y)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (add_norm (of_Qc x) (of_Qc y)))) (Qcplus x y)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcplus x y) (Qred (to_Q (add_norm (of_Qc x) (of_Qc y))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i + _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i + _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcplus x y) (Qred (to_Q (add_norm (of_Qc x) (of_Qc y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_x : Qc",
                    "c2_y : Qc",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qplus x y) (to_Q (add_norm (of_Qc x) (of_Qc y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qplus x y) (to_Q (add_norm (of_Qc x) (of_Qc y)))",
                    "_global_spec_add_norm : forall x y : t, Qeq (to_Q (add_norm x y)) (Qplus (to_Q x) (to_Q y))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qplus x y) (Qplus x y)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (Qplus x y) (Qplus x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_subc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_subc x y : [ [ sub x y ] ] = [ [ x ] ] - [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_subc x y : [ [ sub x y ] ] = [ [ x ] ] - [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (sub x y)) (Qcminus (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (sub x y)) (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_sub : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (add x (opp y))) (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (add x (opp y))) (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_spec_addc : forall x y : t,\n       Logic.eq (to_Qc (add x y)) (Qcplus (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qcplus (to_Qc x) (to_Qc (opp y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qcplus (to_Qc x) (to_Qc (opp y)))\n  (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_spec_oppc : forall q : t, Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qcplus (to_Qc x) (Qcopp (to_Qc y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qcplus (to_Qc x) (Qcopp (to_Qc y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub_normc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub_normc x y : [ [ sub_norm x y ] ] = [ [ x ] ] - [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_sub_normc x y : [ [ sub_norm x y ] ] = [ [ x ] ] - [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (sub_norm x y)) (Qcminus (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (sub_norm x y)) (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_sub_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (add_norm x (opp y))) (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (add_norm x (opp y))) (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_spec_add_normc : forall x y : t,\n       Logic.eq (to_Qc (add_norm x y)) (Qcplus (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qcplus (to_Qc x) (to_Qc (opp y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qcplus (to_Qc x) (to_Qc (opp y)))\n  (Qcminus (to_Qc x) (to_Qc y))",
                    "_global_spec_oppc : forall q : t, Logic.eq (to_Qc (opp q)) (Qcopp (to_Qc q))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qcplus (to_Qc x) (Qcopp (to_Qc y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qcplus (to_Qc x) (Qcopp (to_Qc y)))\n  (Qcminus (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub_normc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub_normc_bis : forall x y : Qc , [ sub_norm ( of_Qc x ) ( of_Qc y ) ] = x - y .",
                "tactic_sig_no_out_arg": "Theorem spec_sub_normc_bis : forall x y : Qc , [ sub_norm ( of_Qc x ) ( of_Qc y ) ] = x - y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (sub_norm (of_Qc x) (of_Qc y))) (Qcminus x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (sub_norm (of_Qc x) (of_Qc y))) (Qcminus x y)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (sub_norm (of_Qc x) (of_Qc y))) (Qcminus x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (sub_norm (of_Qc x) (of_Qc y))) (Qcminus x y)",
                    "_global_strong_spec_sub_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (sub_norm x y)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (sub_norm (of_Qc x) (of_Qc y)))) (Qcminus x y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (sub_norm (of_Qc x) (of_Qc y)))) (Qcminus x y)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (sub_norm (of_Qc x) (of_Qc y)))) (Qcminus x y)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (sub_norm (of_Qc x) (of_Qc y)))) (Qcminus x y)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcminus x y) (Qred (to_Q (sub_norm (of_Qc x) (of_Qc y))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i + ( - _i ) % _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i + ( - _i ) % _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcminus x y) (Qred (to_Q (sub_norm (of_Qc x) (of_Qc y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_x : Qc",
                    "c2_y : Qc",
                    "_global_Qc : Set",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qplus x (Qcopp y)) (to_Q (sub_norm (of_Qc x) (of_Qc y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qplus x (Qcopp y)) (to_Q (sub_norm (of_Qc x) (of_Qc y)))",
                    "_global_spec_sub_norm : forall x y : t, Qeq (to_Q (sub_norm x y)) (Qminus (to_Q x) (to_Q y))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qplus x (Qcopp y)) (Qminus x y)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c7_goal : Qeq (Qplus x (Qcopp y)) (Qminus x y)",
                    "_global_Qcopp : forall _ : Qc, Qc",
                    "_global_Q2Qc : forall _ : Q, Qc",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c8_goal : Qeq\n  (Qplus (let (this, _) := x in this)\n     (Qred (Qopp (let (this, _) := y in this))))\n  (Qminus (let (this, _) := x in this) (let (this, _) := y in this))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Qeq\n  (Qplus (let (this, _) := x in this)\n     (Qred (Qopp (let (this, _) := y in this))))\n  (Qminus (let (this, _) := x in this) (let (this, _) := y in this))",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": [
                    "c9_goal : Qeq\n  (Qplus (let (this, _) := x in this)\n     (Qopp (let (this, _) := y in this)))\n  (Qminus (let (this, _) := x in this) (let (this, _) := y in this))"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c9_goal : Qeq\n  (Qplus (let (this, _) := x in this)\n     (Qopp (let (this, _) := y in this)))\n  (Qminus (let (this, _) := x in this) (let (this, _) := y in this))",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mulc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mulc x y : [ [ mul x y ] ] = [ [ x ] ] * [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mulc x y : [ [ mul x y ] ] = [ [ x ] ] * [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (mul x y)) (Qcmult (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (mul x y)) (Qcmult (to_Qc x) (to_Qc y))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (mul x y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] * [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] * [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (mul x y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (mul x y))) (Q2Qc (Qmult (to_Q x) (to_Q y)))",
                    "c4_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (mul x y))) (Q2Qc (Qmult (to_Q x) (to_Q y)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (mul x y));\n    canon := Qred_involutive (to_Q (mul x y))\n  |}\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (mul x y));\n    canon := Qred_involutive (to_Q (mul x y))\n  |}\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (mul x y))) (Qred (Qmult (to_Q x) (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (mul x y))) (Qred (Qmult (to_Q x) (to_Q y)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))",
                    "_global_spec_mul : forall x y : t, Qeq (to_Q (mul x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q y)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q y))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q y)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qmult (to_Q x) (to_Q y)) (Qmult (Qred (to_Q x)) (Qred (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qmult (to_Q x) (to_Q y)) (Qmult (Qred (to_Q x)) (Qred (to_Q y)))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul_normc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul_normc x y : [ [ mul_norm x y ] ] = [ [ x ] ] * [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mul_normc x y : [ [ mul_norm x y ] ] = [ [ x ] ] * [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (mul_norm x y)) (Qcmult (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (mul_norm x y)) (Qcmult (to_Qc x) (to_Qc y))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (mul_norm x y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] * [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] * [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (mul_norm x y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (mul_norm x y))) (Q2Qc (Qmult (to_Q x) (to_Q y)))",
                    "c4_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (mul_norm x y))) (Q2Qc (Qmult (to_Q x) (to_Q y)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (mul_norm x y));\n    canon := Qred_involutive (to_Q (mul_norm x y))\n  |}\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (mul_norm x y));\n    canon := Qred_involutive (to_Q (mul_norm x y))\n  |}\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (mul_norm x y))) (Qred (Qmult (to_Q x) (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (mul_norm x y))) (Qred (Qmult (to_Q x) (to_Q y)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))",
                    "_global_spec_mul_norm : forall x y : t, Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q y)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q y)))",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q y));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q y))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q y); canon := Qred_involutive (to_Q y)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q y)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q y))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q y)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qmult (to_Q x) (to_Q y)) (Qmult (Qred (to_Q x)) (Qred (to_Q y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qmult (to_Q x) (to_Q y)) (Qmult (Qred (to_Q x)) (Qred (to_Q y)))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (to_Q y) (Qred (to_Q y))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Qeq (Qred (to_Q y)) (to_Q y)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul_normc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul_normc_bis : forall x y : Qc , [ mul_norm ( of_Qc x ) ( of_Qc y ) ] = x * y .",
                "tactic_sig_no_out_arg": "Theorem spec_mul_normc_bis : forall x y : Qc , [ mul_norm ( of_Qc x ) ( of_Qc y ) ] = x * y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (mul_norm (of_Qc x) (of_Qc y))) (Qcmult x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (mul_norm (of_Qc x) (of_Qc y))) (Qcmult x y)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (mul_norm (of_Qc x) (of_Qc y))) (Qcmult x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (mul_norm (of_Qc x) (of_Qc y))) (Qcmult x y)",
                    "_global_strong_spec_mul_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (mul_norm x y)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (mul_norm (of_Qc x) (of_Qc y)))) (Qcmult x y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (mul_norm (of_Qc x) (of_Qc y)))) (Qcmult x y)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (mul_norm (of_Qc x) (of_Qc y)))) (Qcmult x y)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (mul_norm (of_Qc x) (of_Qc y)))) (Qcmult x y)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcmult x y) (Qred (to_Q (mul_norm (of_Qc x) (of_Qc y))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i * _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i * _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcmult x y) (Qred (to_Q (mul_norm (of_Qc x) (of_Qc y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_x : Qc",
                    "c2_y : Qc",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qmult x y) (to_Q (mul_norm (of_Qc x) (of_Qc y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qmult x y) (to_Q (mul_norm (of_Qc x) (of_Qc y)))",
                    "_global_spec_mul_norm : forall x y : t, Qeq (to_Q (mul_norm x y)) (Qmult (to_Q x) (to_Q y))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qmult x y) (Qmult x y)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (Qmult x y) (Qmult x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_invc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_invc x : [ [ inv x ] ] = / [ [ x ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_invc x : [ [ inv x ] ] = / [ [ x ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (inv x)) (Qcinv (to_Qc x))",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (inv x)) (Qcinv (to_Qc x))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (inv x))) (Qcinv (Q2Qc (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( / [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( / [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (inv x))) (Qcinv (Q2Qc (to_Q x)))",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (inv x))) (Q2Qc (Qinv (to_Q x)))",
                    "c4_goal : Logic.eq (Q2Qc (Qinv (to_Q x))) (Qcinv (Q2Qc (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (inv x))) (Q2Qc (Qinv (to_Q x)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (inv x));\n    canon := Qred_involutive (to_Q (inv x))\n  |}\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (inv x));\n    canon := Qred_involutive (to_Q (inv x))\n  |}\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (inv x))) (Qred (Qinv (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (inv x))) (Qred (Qinv (to_Q x)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (inv x)) (Qinv (to_Q x))",
                    "_global_spec_inv : forall x : t, Qeq (to_Q (inv x)) (Qinv (to_Q x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qinv (to_Q x))) (Qcinv (Q2Qc (to_Q x)))",
                    "_global_Qcinv : forall _ : Qc, Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qinv (to_Q x))) (Qred (Qinv (Qred (to_Q x))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qinv (to_Q x))) (Qred (Qinv (Qred (to_Q x))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qinv (to_Q x)) (Qinv (Qred (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qinv (to_Q x)) (Qinv (Qred (to_Q x)))",
                    "_global_Qinv_comp : Proper (respectful Qeq Qeq) Qinv"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c12_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_inv_normc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_inv_normc x : [ [ inv_norm x ] ] = / [ [ x ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_inv_normc x : [ [ inv_norm x ] ] = / [ [ x ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (inv_norm x)) (Qcinv (to_Qc x))",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (inv_norm x)) (Qcinv (to_Qc x))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (inv_norm x))) (Qcinv (Q2Qc (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( / [ _i ] ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( / [ _i ] ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (inv_norm x))) (Qcinv (Q2Qc (to_Q x)))",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (inv_norm x))) (Q2Qc (Qinv (to_Q x)))",
                    "c4_goal : Logic.eq (Q2Qc (Qinv (to_Q x))) (Qcinv (Q2Qc (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (inv_norm x))) (Q2Qc (Qinv (to_Q x)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (inv_norm x));\n    canon := Qred_involutive (to_Q (inv_norm x))\n  |}\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (inv_norm x));\n    canon := Qred_involutive (to_Q (inv_norm x))\n  |}\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (inv_norm x))) (Qred (Qinv (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (inv_norm x))) (Qred (Qinv (to_Q x)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))",
                    "_global_spec_inv_norm : forall x : t, Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qinv (to_Q x))) (Qcinv (Q2Qc (to_Q x)))",
                    "_global_Qcinv : forall _ : Qc, Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  {|\n    this := Qred (Qinv (to_Q x));\n    canon := Qred_involutive (Qinv (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qinv\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Qred (Qinv (to_Q x))) (Qred (Qinv (Qred (to_Q x))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Qred (Qinv (to_Q x))) (Qred (Qinv (Qred (to_Q x))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c10_goal : Qeq (Qinv (to_Q x)) (Qinv (Qred (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Qeq (Qinv (to_Q x)) (Qinv (Qred (to_Q x)))",
                    "_global_Qinv_comp : Proper (respectful Qeq Qeq) Qinv"
                ],
                "tactic_res": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c12_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_inv_normc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_inv_normc_bis : forall x : Qc , [ inv_norm ( of_Qc x ) ] = / x .",
                "tactic_sig_no_out_arg": "Theorem spec_inv_normc_bis : forall x : Qc , [ inv_norm ( of_Qc x ) ] = / x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : Qc, Logic.eq (to_Q (inv_norm (of_Qc x))) (Qcinv x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x : Qc, Logic.eq (to_Q (inv_norm (of_Qc x))) (Qcinv x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (inv_norm (of_Qc x))) (Qcinv x)",
                    "c2_x : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (inv_norm (of_Qc x))) (Qcinv x)",
                    "_global_strong_spec_inv_norm : forall (x : t) (_ : Reduced x), Reduced (inv_norm x)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (inv_norm (of_Qc x)))) (Qcinv x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (inv_norm (of_Qc x)))) (Qcinv x)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (inv_norm (of_Qc x)))) (Qcinv x)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (inv_norm (of_Qc x)))) (Qcinv x)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcinv x) (Qred (to_Q (inv_norm (of_Qc x))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( / _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( / _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcinv x) (Qred (to_Q (inv_norm (of_Qc x))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_x : Qc",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qinv x) (to_Q (inv_norm (of_Qc x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qinv x) (to_Q (inv_norm (of_Qc x)))",
                    "_global_spec_inv_norm : forall x : t, Qeq (to_Q (inv_norm x)) (Qinv (to_Q x))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qinv x) (Qinv x)"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c7_goal : Qeq (Qinv x) (Qinv x)",
                    "c2_x : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_divc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_divc x y : [ [ div x y ] ] = [ [ x ] ] / [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_divc x y : [ [ div x y ] ] = [ [ x ] ] / [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (div x y)) (Qcdiv (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (div x y)) (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_div : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (mul x (inv y))) (Qcdiv (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (mul x (inv y))) (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_spec_mulc : forall x y : t,\n       Logic.eq (to_Qc (mul x y)) (Qcmult (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv y))) (Qcdiv (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv y))) (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_Qcdiv : forall (_ : Qc) (_ : Qc), Qc"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv y)))\n  (Qcmult (to_Qc x) (Qcinv (to_Qc y)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( f := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( f := _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv y)))\n  (Qcmult (to_Qc x) (Qcinv (to_Qc y)))",
                    "_global_f_equal2 : forall (A1 A2 B : Type) (f : forall (_ : A1) (_ : A2), B) \n         (x1 y1 : A1) (x2 y2 : A2) (_ : Logic.eq x1 y1) \n         (_ : Logic.eq x2 y2), Logic.eq (f x1 x2) (f y1 y2)",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Qc x) (to_Qc x)",
                    "c6_goal : Logic.eq (to_Qc (inv y)) (Qcinv (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Qc x) (to_Qc x)",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Qc (inv y)) (Qcinv (to_Qc y))",
                    "_global_spec_invc : forall x : t, Logic.eq (to_Qc (inv x)) (Qcinv (to_Qc x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_normc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_normc x y : [ [ div_norm x y ] ] = [ [ x ] ] / [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div_normc x y : [ [ div_norm x y ] ] = [ [ x ] ] / [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (div_norm x y)) (Qcdiv (to_Qc x) (to_Qc y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (div_norm x y)) (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_div_norm : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Qc (mul_norm x (inv_norm y))) (Qcdiv (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Qc (mul_norm x (inv_norm y))) (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_spec_mul_normc : forall x y : t,\n       Logic.eq (to_Qc (mul_norm x y)) (Qcmult (to_Qc x) (to_Qc y))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv_norm y)))\n  (Qcdiv (to_Qc x) (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv_norm y)))\n  (Qcdiv (to_Qc x) (to_Qc y))",
                    "_global_Qcdiv : forall (_ : Qc) (_ : Qc), Qc"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv_norm y)))\n  (Qcmult (to_Qc x) (Qcinv (to_Qc y)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( f := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( f := _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qcmult (to_Qc x) (to_Qc (inv_norm y)))\n  (Qcmult (to_Qc x) (Qcinv (to_Qc y)))",
                    "_global_f_equal2 : forall (A1 A2 B : Type) (f : forall (_ : A1) (_ : A2), B) \n         (x1 y1 : A1) (x2 y2 : A2) (_ : Logic.eq x1 y1) \n         (_ : Logic.eq x2 y2), Logic.eq (f x1 x2) (f y1 y2)",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Qc x) (to_Qc x)",
                    "c6_goal : Logic.eq (to_Qc (inv_norm y)) (Qcinv (to_Qc y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Qc x) (to_Qc x)",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Qc (inv_norm y)) (Qcinv (to_Qc y))",
                    "_global_spec_inv_normc : forall x : t, Logic.eq (to_Qc (inv_norm x)) (Qcinv (to_Qc x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_normc_bis",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_normc_bis : forall x y : Qc , [ div_norm ( of_Qc x ) ( of_Qc y ) ] = x / y .",
                "tactic_sig_no_out_arg": "Theorem spec_div_normc_bis : forall x y : Qc , [ div_norm ( of_Qc x ) ( of_Qc y ) ] = x / y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (div_norm (of_Qc x) (of_Qc y))) (Qcdiv x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : Qc,\nLogic.eq (to_Q (div_norm (of_Qc x) (of_Qc y))) (Qcdiv x y)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Q (div_norm (of_Qc x) (of_Qc y))) (Qcdiv x y)",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i by apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Q (div_norm (of_Qc x) (of_Qc y))) (Qcdiv x y)",
                    "_global_strong_spec_div_norm : forall (x y : t) (_ : Reduced x) (_ : Reduced y),\n       Reduced (div_norm x y)",
                    "_global_strong_spec_of_Qc_bis : forall q : Qc, Reduced (of_Qc q)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Q (red (div_norm (of_Qc x) (of_Qc y)))) (Qcdiv x y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Q (red (div_norm (of_Qc x) (of_Qc y)))) (Qcdiv x y)",
                    "_global_strong_spec_red : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Qred (to_Q (div_norm (of_Qc x) (of_Qc y)))) (Qcdiv x y)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Qred (to_Q (div_norm (of_Qc x) (of_Qc y)))) (Qcdiv x y)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Qcdiv x y) (Qred (to_Q (div_norm (of_Qc x) (of_Qc y))))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i * ( / _i ) % _i ) % _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i * ( / _i ) % _i ) % _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Qcdiv x y) (Qred (to_Q (div_norm (of_Qc x) (of_Qc y))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)",
                    "c2_x : Qc",
                    "c2_y : Qc",
                    "_global_Qc : Set",
                    "_global_Q : Set"
                ],
                "tactic_res": [
                    "c6_goal : Qeq (Qmult x (Qcinv y)) (to_Q (div_norm (of_Qc x) (of_Qc y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i .",
                "tactic_args": [
                    "c6_goal : Qeq (Qmult x (Qcinv y)) (to_Q (div_norm (of_Qc x) (of_Qc y)))",
                    "_global_spec_div_norm : forall x y : t, Qeq (to_Q (div_norm x y)) (Qdiv (to_Q x) (to_Q y))",
                    "_global_strong_spec_of_Qc : forall q : Qc, Logic.eq (to_Q (of_Qc q)) q"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (Qmult x (Qcinv y)) (Qdiv x y)"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i .",
                "tactic_args": [
                    "c7_goal : Qeq (Qmult x (Qcinv y)) (Qdiv x y)",
                    "_global_Qcinv : forall _ : Qc, Qc",
                    "_global_Q2Qc : forall _ : Q, Qc",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c8_goal : Qeq\n  (Qmult (let (this, _) := x in this)\n     (Qred (Qinv (let (this, _) := y in this))))\n  (Qdiv (let (this, _) := x in this) (let (this, _) := y in this))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Qeq\n  (Qmult (let (this, _) := x in this)\n     (Qred (Qinv (let (this, _) := y in this))))\n  (Qdiv (let (this, _) := x in this) (let (this, _) := y in this))",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": [
                    "c9_goal : Qeq\n  (Qmult (let (this, _) := x in this)\n     (Qinv (let (this, _) := y in this)))\n  (Qdiv (let (this, _) := x in this) (let (this, _) := y in this))"
                ]
            },
            {
                "tactic_sig": "auto with qarith .",
                "tactic_sig_no_out_arg": "auto with qarith .",
                "tactic_args": [
                    "c9_goal : Qeq\n  (Qmult (let (this, _) := x in this)\n     (Qinv (let (this, _) := y in this)))\n  (Qdiv (let (this, _) := x in this) (let (this, _) := y in this))",
                    "c2_x : Qc",
                    "c2_y : Qc"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_squarec",
        "proof": [
            {
                "tactic_sig": "Theorem spec_squarec x : [ [ square x ] ] = [ [ x ] ] ^ 2 .",
                "tactic_sig_no_out_arg": "Theorem spec_squarec x : [ [ square x ] ] = [ [ x ] ] ^ 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (square x)) (Qcpower (to_Qc x) 2)",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (square x)) (Qcpower (to_Qc x) 2)",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (square x))) (Qcpower (Q2Qc (to_Q x)) 2)"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] ^ 2 ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] ^ 2 ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (square x))) (Qcpower (Q2Qc (to_Q x)) 2)",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (square x))) (Q2Qc (Qpower (to_Q x) 2))",
                    "c4_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2)) (Qcpower (Q2Qc (to_Q x)) 2)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (square x))) (Q2Qc (Qpower (to_Q x) 2))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (square x));\n    canon := Qred_involutive (to_Q (square x))\n  |}\n  {|\n    this := Qred (Qpower (to_Q x) 2);\n    canon := Qred_involutive (Qpower (to_Q x) 2)\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (square x));\n    canon := Qred_involutive (to_Q (square x))\n  |}\n  {|\n    this := Qred (Qpower (to_Q x) 2);\n    canon := Qred_involutive (Qpower (to_Q x) 2)\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (square x))) (Qred (Qpower (to_Q x) 2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (square x))) (Qred (Qpower (to_Q x) 2))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (square x)) (Qpower (to_Q x) 2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (square x)) (Qpower (to_Q x) 2)",
                    "_global_spec_square : forall x : t, Qeq (to_Q (square x)) (Qpower (to_Q x) 2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl Qcpower .",
                "tactic_sig_no_out_arg": "simpl Qcpower .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2)) (Qcpower (Q2Qc (to_Q x)) 2)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2))\n  (Qcmult (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1)))"
                ]
            },
            {
                "tactic_sig": "replace ( Q2Qc [ _i ] * 1 ) with ( Q2Qc [ _i ] ) .",
                "tactic_sig_no_out_arg": "replace ( Q2Qc [ _i ] * 1 ) with ( Q2Qc [ _i ] ) .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2))\n  (Qcmult (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1)))",
                    "c1_x : True",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q x)))",
                    "c10_goal : Logic.eq (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1))"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 2))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q x)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q x)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Q2Qc (Qmult (to_Q x) (to_Q x)))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (to_Q x)))",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q x));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  {|\n    this := Qred (Qmult (to_Q x) (to_Q x));\n    canon := Qred_involutive (Qmult (to_Q x) (to_Q x))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q x)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q x))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Qred (Qmult (to_Q x) (to_Q x)))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (to_Q x))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c14_goal : Qeq (Qmult (to_Q x) (to_Q x)) (Qmult (Qred (to_Q x)) (Qred (to_Q x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Qeq (Qmult (to_Q x) (to_Q x)) (Qmult (Qred (to_Q x)) (Qred (to_Q x)))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c15_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c16_goal : Qeq (to_Q x) (Qred (to_Q x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c17_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c18_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_power_posc",
        "proof": [
            {
                "tactic_sig": "Theorem spec_power_posc x p : [ [ power_pos x p ] ] = [ [ x ] ] ^ Pos.to_nat p .",
                "tactic_sig_no_out_arg": "Theorem spec_power_posc x p : [ [ power_pos x p ] ] = [ [ x ] ] ^ Pos.to_nat p .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Qc (power_pos x p)) (Qcpower (to_Qc x) (Pos.to_nat p))",
                    "c1_p : positive",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Qc (power_pos x p)) (Qcpower (to_Qc x) (Pos.to_nat p))",
                    "_global_to_Qc : forall _ : t, Qc"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (power_pos x p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))"
                ]
            },
            {
                "tactic_sig": "transitivity ( Q2Qc ( [ _i ] ^ Zpos _i ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Q2Qc ( [ _i ] ^ Zpos _i ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Q2Qc (to_Q (power_pos x p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))",
                    "c1_x : True",
                    "c1_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (power_pos x p)))\n  (Q2Qc (Qpower (to_Q x) (Zpos p)))",
                    "c4_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Q2Qc (to_Q (power_pos x p)))\n  (Q2Qc (Qpower (to_Q x) (Zpos p)))",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (power_pos x p));\n    canon := Qred_involutive (to_Q (power_pos x p))\n  |}\n  {|\n    this := Qred (Qpower (to_Q x) (Zpos p));\n    canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  {|\n    this := Qred (to_Q (power_pos x p));\n    canon := Qred_involutive (to_Q (power_pos x p))\n  |}\n  {|\n    this := Qred (Qpower (to_Q x) (Zpos p));\n    canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Qred (to_Q (power_pos x p)))\n  (Qred (Qpower (to_Q x) (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Qred (to_Q (power_pos x p)))\n  (Qred (Qpower (to_Q x) (Zpos p)))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c7_goal : Qeq (to_Q (power_pos x p)) (Qpower (to_Q x) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Qeq (to_Q (power_pos x p)) (Qpower (to_Q x) (Zpos p))",
                    "_global_spec_power_pos : forall (x : t) (p : positive),\n       Qeq (to_Q (power_pos x p)) (Qpower (to_Q x) (Zpos p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction _i using Pos.peano_ind .",
                "tactic_sig_no_out_arg": "induction _i using Pos.peano_ind .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))",
                    "c1_p : positive"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 1))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat 1%positive))",
                    "c9_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat (Pos.succ p)))",
                    "c9_IHp : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Q2Qc (Qpower (to_Q x) 1))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat 1%positive))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Q2Qc (to_Q x)) (Qcmult (Q2Qc (to_Q x)) (Q2Qc 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat (Pos.succ p)))",
                    "_global_Pos2Nat.inj_succ : forall p : positive,\n       Logic.eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcpower (Q2Qc (to_Q x)) (S (Pos.to_nat p)))"
                ]
            },
            {
                "tactic_sig": "simpl Qcpower .",
                "tactic_sig_no_out_arg": "simpl Qcpower .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcpower (Q2Qc (to_Q x)) (S (Pos.to_nat p)))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcmult (Q2Qc (to_Q x)) (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcmult (Q2Qc (to_Q x)) (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p)))",
                    "c9_IHp : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (Qpower (to_Q x) (Zpos p))))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c9_IHp : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos p)))\n  (Qcpower (Q2Qc (to_Q x)) (Pos.to_nat p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Q2Qc (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qcmult (Q2Qc (to_Q x)) (Q2Qc (Qpower (to_Q x) (Zpos p))))",
                    "_global_Qcmult : forall (_ : Qc) (_ : Qc), Qc",
                    "_global_Q2Qc : forall _ : Q, Qc"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  {|\n    this := Qred (Qpower (to_Q x) (Zpos (Pos.succ p)));\n    canon := Qred_involutive (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (Qpower (to_Q x) (Zpos p));\n             canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (Qpower (to_Q x) (Zpos p));\n             canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n           |})\n  |}"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_global_Qc_decomp : forall (q q' : Qc) (_ : Logic.eq q q'), Logic.eq q q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  {|\n    this := Qred (Qpower (to_Q x) (Zpos (Pos.succ p)));\n    canon := Qred_involutive (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  |}\n  {|\n    this :=\n      Qred\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (Qpower (to_Q x) (Zpos p));\n             canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n           |});\n    canon :=\n      Qred_involutive\n        (Qmult\n           {|\n             this := Qred (to_Q x); canon := Qred_involutive (to_Q x)\n           |}\n           {|\n             this := Qred (Qpower (to_Q x) (Zpos p));\n             canon := Qred_involutive (Qpower (to_Q x) (Zpos p))\n           |})\n  |}",
                    "_global_this : forall _ : Qc, Q"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Qred (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Qred (Qpower (to_Q x) (Zpos (Pos.succ p))))\n  (Qred (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p)))))",
                    "_global_Qred_complete : forall (p q : Q) (_ : Qeq p q), Logic.eq (Qred p) (Qred q)"
                ],
                "tactic_res": [
                    "c16_goal : Qeq (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p))))"
                ]
            },
            {
                "tactic_sig": "setoid_replace ( [ _i ] ^ Zpos ( Pos.succ _i ) ) % Q with ( [ _i ] * [ _i ] ^ Zpos _i ) % Q .",
                "tactic_sig_no_out_arg": "setoid_replace ( [ _i ] ^ Zpos ( Pos.succ _i ) ) % Q with ( [ _i ] * [ _i ] ^ Zpos _i ) % Q .",
                "tactic_args": [
                    "c16_goal : Qeq (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p))))",
                    "c1_x : True",
                    "c1_p : positive",
                    "c1_x : True",
                    "c1_x : True",
                    "c1_p : positive"
                ],
                "tactic_res": [
                    "c17_goal : Qeq (Qmult (to_Q x) (Qpower (to_Q x) (Zpos p)))\n  (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p))))",
                    "c18_goal : Qeq (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  (Qmult (to_Q x) (Qpower (to_Q x) (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Qeq (Qmult (to_Q x) (Qpower (to_Q x) (Zpos p)))\n  (Qmult (Qred (to_Q x)) (Qred (Qpower (to_Q x) (Zpos p))))",
                    "_global_Qmult_comp : Proper (respectful Qeq (respectful Qeq Qeq)) Qmult"
                ],
                "tactic_res": [
                    "c19_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "c20_goal : Qeq (Qpower (to_Q x) (Zpos p)) (Qred (Qpower (to_Q x) (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Qeq (to_Q x) (Qred (to_Q x))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c21_goal : Qeq (Qred (to_Q x)) (to_Q x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Qeq (Qred (to_Q x)) (to_Q x)",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : Qeq (Qpower (to_Q x) (Zpos p)) (Qred (Qpower (to_Q x) (Zpos p)))",
                    "_global_Qeq_sym : forall (x y : Q) (_ : Qeq x y), Qeq y x"
                ],
                "tactic_res": [
                    "c22_goal : Qeq (Qred (Qpower (to_Q x) (Zpos p))) (Qpower (to_Q x) (Zpos p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Qeq (Qred (Qpower (to_Q x) (Zpos p))) (Qpower (to_Q x) (Zpos p))",
                    "_global_Qred_correct : forall q : Q, Qeq (Qred q) q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c18_goal : Qeq (Qpower (to_Q x) (Zpos (Pos.succ p)))\n  (Qmult (to_Q x) (Qpower (to_Q x) (Zpos p)))"
                ],
                "tactic_res": [
                    "c23_goal : Qeq (Qpower_positive (to_Q x) (Pos.succ p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c23_goal : Qeq (Qpower_positive (to_Q x) (Pos.succ p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))",
                    "_global_Pos.add_1_l : forall p : positive, Logic.eq (Pos.add 1 p) (Pos.succ p)"
                ],
                "tactic_res": [
                    "c24_goal : Qeq (Qpower_positive (to_Q x) (Pos.add 1%positive p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : Qeq (Qpower_positive (to_Q x) (Pos.add 1%positive p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))",
                    "_global_Qpower_plus_positive : forall (a : Q) (n m : positive),\n       Qeq (Qpower_positive a (Pos.add n m))\n         (Qmult (Qpower_positive a n) (Qpower_positive a m))"
                ],
                "tactic_res": [
                    "c25_goal : Qeq (Qmult (Qpower_positive (to_Q x) 1) (Qpower_positive (to_Q x) p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c25_goal : Qeq (Qmult (Qpower_positive (to_Q x) 1) (Qpower_positive (to_Q x) p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))"
                ],
                "tactic_res": [
                    "c26_goal : Qeq (Qmult (to_Q x) (Qpower_positive (to_Q x) p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Qeq (Qmult (to_Q x) (Qpower_positive (to_Q x) p))\n  (Qmult (to_Q x) (Qpower_positive (to_Q x) p))",
                    "_global_Qeq_refl : forall x : Q, Qeq x x"
                ],
                "tactic_res": []
            }
        ]
    }
]