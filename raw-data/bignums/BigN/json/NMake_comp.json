[
    {
        "lemma_name": "spec_same_level",
        "proof": [
            {
                "tactic_sig": "Lemma spec_same_level : forall A ( P : Z -> Z -> A -> Prop ) ( f : forall n , dom_t n -> dom_t n -> A ) , ( forall n x y , P ( ZnZ.to_Z x ) ( ZnZ.to_Z y ) ( f n x y ) ) -> forall x y , P [ x ] [ y ] ( same_level f x y ) .",
                "tactic_sig_no_out_arg": "Lemma spec_same_level : forall A ( P : Z -> Z -> A -> Prop ) ( f : forall n , dom_t n -> dom_t n -> A ) , ( forall n x y , P ( ZnZ.to_Z x ) ( ZnZ.to_Z y ) ( f n x y ) ) -> forall x y , P [ x ] [ y ] ( same_level f x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n  (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n  (_ : forall (n : nat) (x y : dom_t n),\n       P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) (x y : t),\nP (to_Z x) (to_Z y) (same_level f x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n  (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n  (_ : forall (n : nat) (x y : dom_t n),\n       P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) (x y : t),\nP (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c2_goal : P (to_Z x) (to_Z y) (same_level f x y)",
                    "c2_A : Type",
                    "c2_P : forall (_ : Z) (_ : Z) (_ : A), Prop",
                    "c2_f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A",
                    "c2_H : forall (n : nat) (x y : dom_t n), P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := fun _i => _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := fun _i => _i ) .",
                "tactic_args": [
                    "c2_goal : P (to_Z x) (to_Z y) (same_level f x y)",
                    "_global_spec_same_level_dep : forall (res : Type)\n         (P : forall (_ : nat) (_ : Z) (_ : Z) (_ : res), Prop)\n         (_ : forall (n m : nat) (z z' : Z) (r : res) \n                (_ : le n m) (_ : P m z z' r), P n z z' r)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P n (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (level x) (to_Z x) (to_Z y) (same_level f x y)",
                    "c2_P : forall (_ : Z) (_ : Z) (_ : A), Prop",
                    "_global__ : ?T\nwhere\n?T : [A : Type\n      P : forall (_ : Z) (_ : Z) (_ : A), Prop\n      f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A\n      H : forall (n : nat) (x y : dom_t n),\n          P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)\n      x : t\n      y : t |- Type]\n?y : [A : Type\n      P : forall (_ : Z) (_ : Z) (_ : A), Prop\n      f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A\n      H : forall (n : nat) (x y : dom_t n),\n          P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)\n      x : t\n      y : t |- ?T]",
                    "c2_P : forall (_ : Z) (_ : Z) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c3_goal : forall (n m : nat) (z z' : Z) (r : A) (_ : le n m) (_ : P z z' r),\nP z z' r",
                    "c4_goal : forall (n : nat) (x y : dom_t n), P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (n m : nat) (z z' : Z) (r : A) (_ : le n m) (_ : P z z' r),\nP z z' r",
                    "c2_P : forall (_ : Z) (_ : Z) (_ : A), Prop",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n), P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)",
                    "c2_H : forall (n : nat) (x y : dom_t n), P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)",
                    "c2_f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A",
                    "c2_P : forall (_ : Z) (_ : Z) (_ : A), Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pos : forall x , 0 <= [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_pos : forall x , 0 <= [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Z.le 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Z.le 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : Z.le 0 (to_Z x)",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c2_goal : Z.le 0 (to_Z x)",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c3_x : dom_t n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "now case ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "now case ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c3_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c3_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "digits_dom_op_incr",
        "proof": [
            {
                "tactic_sig": "Lemma digits_dom_op_incr : forall n m , ( n <= m ) % nat -> ( ZnZ.digits ( dom_op n ) <= ZnZ.digits ( dom_op m ) ) % positive .",
                "tactic_sig_no_out_arg": "Lemma digits_dom_op_incr : forall n m , ( n <= m ) % nat -> ( ZnZ.digits ( dom_op n ) <= ZnZ.digits ( dom_op m ) ) % positive .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n m : nat) (_ : le n m),\nPos.le (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op m))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n m : nat) (_ : le n m),\nPos.le (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op m))"
                ],
                "tactic_res": [
                    "c2_goal : Pos.le (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op m))",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_H : le n m"
                ]
            },
            {
                "tactic_sig": "change ( Zpos ( ZnZ.digits ( dom_op _i ) ) <= Zpos ( ZnZ.digits ( dom_op _i ) ) ) .",
                "tactic_sig_no_out_arg": "change ( Zpos ( ZnZ.digits ( dom_op _i ) ) <= Zpos ( ZnZ.digits ( dom_op _i ) ) ) .",
                "tactic_args": [
                    "c2_goal : Pos.le (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op m))",
                    "c2_n : nat",
                    "c2_m : nat"
                ],
                "tactic_res": [
                    "c3_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (Zpos (ZnZ.digits (dom_op m)))"
                ]
            },
            {
                "tactic_sig": "rewrite !digits_dom_op , !Pshiftl_nat_Zpower .",
                "tactic_sig_no_out_arg": "rewrite !digits_dom_op , !Pshiftl_nat_Zpower .",
                "tactic_args": [
                    "c3_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (Zpos (ZnZ.digits (dom_op m)))"
                ],
                "tactic_res": [
                    "c4_goal : Z.le (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat n)))\n  (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat m)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Z.le (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat n)))\n  (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat m)))",
                    "_global_Z.mul_le_mono_nonneg_l : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul p n) (Z.mul p m)"
                ],
                "tactic_res": [
                    "c5_goal : Z.le 0 (Zpos (ZnZ.digits W0.ops))",
                    "c6_goal : Z.le (Z.pow 2 (Z.of_nat n)) (Z.pow 2 (Z.of_nat m))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.le 0 (Zpos (ZnZ.digits W0.ops))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Z.le (Z.pow 2 (Z.of_nat n)) (Z.pow 2 (Z.of_nat m))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt 0 2",
                    "c8_goal : Z.le (Z.of_nat n) (Z.of_nat m)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.le (Z.of_nat n) (Z.of_nat m)",
                    "c2_H : le n m",
                    "c2_n : nat",
                    "c2_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_0 : [ zero ] = 0 .",
                "tactic_sig_no_out_arg": "Theorem spec_0 : [ zero ] = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z zero) 0"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z zero) 0",
                    "_global_zero : t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (mk_t 0 ZnZ.zero)) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (mk_t 0 ZnZ.zero)) 0",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0"
                ]
            },
            {
                "tactic_sig": "exact ZnZ.spec_0 .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_0 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_1",
        "proof": [
            {
                "tactic_sig": "Theorem spec_1 : [ one ] = 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_1 : [ one ] = 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z one) 1"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z one) 1",
                    "_global_one : t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (mk_t 0 ZnZ.one)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (mk_t 0 ZnZ.one)) 1",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (ZnZ.to_Z ZnZ.one) 1"
                ]
            },
            {
                "tactic_sig": "exact ZnZ.spec_1 .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_1 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (ZnZ.to_Z ZnZ.one) 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "succ_fold",
        "proof": [
            {
                "tactic_sig": "Lemma succ_fold : succ = iter_t succn .",
                "tactic_sig_no_out_arg": "Lemma succ_fold : succ = iter_t succn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq succ\n  (iter_t\n     (fun n : nat =>\n      let op := dom_op n in\n      let succ_c := ZnZ.succ_c in\n      let one := ZnZ.one in\n      fun x : dom_t n =>\n      match succ_c x with\n      | CarryType.C0 r => mk_t n r\n      | CarryType.C1 r => mk_t_S n (WW one r)\n      end))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq succ\n  (iter_t\n     (fun n : nat =>\n      let op := dom_op n in\n      let succ_c := ZnZ.succ_c in\n      let one := ZnZ.one in\n      fun x : dom_t n =>\n      match succ_c x with\n      | CarryType.C0 r => mk_t n r\n      | CarryType.C1 r => mk_t_S n (WW one r)\n      end))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq succ\n  (let f0 :=\n     let op := W0.ops in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : W0.t =>\n     match succ_c x with\n     | CarryType.C0 r => N0 r\n     | CarryType.C1 r => N1 (WW one r)\n     end in\n   let f1 :=\n     let op := w1_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w1 =>\n     match succ_c x with\n     | CarryType.C0 r => N1 r\n     | CarryType.C1 r => N2 (WW one r)\n     end in\n   let f2 :=\n     let op := w2_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w2 =>\n     match succ_c x with\n     | CarryType.C0 r => N2 r\n     | CarryType.C1 r => N3 (WW one r)\n     end in\n   let f3 :=\n     let op := w3_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w3 =>\n     match succ_c x with\n     | CarryType.C0 r => N3 r\n     | CarryType.C1 r => N4 (WW one r)\n     end in\n   let f4 :=\n     let op := w4_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w4 =>\n     match succ_c x with\n     | CarryType.C0 r => N4 r\n     | CarryType.C1 r => N5 (WW one r)\n     end in\n   let f5 :=\n     let op := w5_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w5 =>\n     match succ_c x with\n     | CarryType.C0 r => N5 r\n     | CarryType.C1 r => N6 (WW one r)\n     end in\n   let f6 :=\n     let op := w6_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w6 =>\n     match succ_c x with\n     | CarryType.C0 r => N6 r\n     | CarryType.C1 r => Nn 0 (WW one r)\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : word w6 (S n) =>\n     match succ_c x with\n     | CarryType.C0 r => Nn n r\n     | CarryType.C1 r => Nn (S n) (WW one r)\n     end in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq succ\n  (let f0 :=\n     let op := W0.ops in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : W0.t =>\n     match succ_c x with\n     | CarryType.C0 r => N0 r\n     | CarryType.C1 r => N1 (WW one r)\n     end in\n   let f1 :=\n     let op := w1_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w1 =>\n     match succ_c x with\n     | CarryType.C0 r => N1 r\n     | CarryType.C1 r => N2 (WW one r)\n     end in\n   let f2 :=\n     let op := w2_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w2 =>\n     match succ_c x with\n     | CarryType.C0 r => N2 r\n     | CarryType.C1 r => N3 (WW one r)\n     end in\n   let f3 :=\n     let op := w3_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w3 =>\n     match succ_c x with\n     | CarryType.C0 r => N3 r\n     | CarryType.C1 r => N4 (WW one r)\n     end in\n   let f4 :=\n     let op := w4_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w4 =>\n     match succ_c x with\n     | CarryType.C0 r => N4 r\n     | CarryType.C1 r => N5 (WW one r)\n     end in\n   let f5 :=\n     let op := w5_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w5 =>\n     match succ_c x with\n     | CarryType.C0 r => N5 r\n     | CarryType.C1 r => N6 (WW one r)\n     end in\n   let f6 :=\n     let op := w6_op in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : w6 =>\n     match succ_c x with\n     | CarryType.C0 r => N6 r\n     | CarryType.C1 r => Nn 0 (WW one r)\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let succ_c := ZnZ.succ_c in\n     let one := ZnZ.one in\n     fun x : word w6 (S n) =>\n     match succ_c x with\n     | CarryType.C0 r => Nn n r\n     | CarryType.C1 r => Nn (S n) (WW one r)\n     end in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_succ",
        "proof": [
            {
                "tactic_sig": "Theorem spec_succ : forall n , [ succ n ] = [ n ] + 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_succ : forall n , [ succ n ] = [ n ] + 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : t, Logic.eq (to_Z (succ n)) (Z.add (to_Z n) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall n : t, Logic.eq (to_Z (succ n)) (Z.add (to_Z n) 1)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (succ x)) (Z.add (to_Z x) 1)",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (succ x)) (Z.add (to_Z x) 1)",
                    "_global_succ_fold : Logic.eq succ\n         (iter_t\n            (fun n : nat =>\n             let op := dom_op n in\n             let succ_c := ZnZ.succ_c in\n             let one := ZnZ.one in\n             fun x : dom_t n =>\n             match succ_c x with\n             | CarryType.C0 r => mk_t n r\n             | CarryType.C1 r => mk_t_S n (WW one r)\n             end))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let succ_c := ZnZ.succ_c in\n         let one := ZnZ.one in\n         fun x : dom_t n =>\n         match succ_c x with\n         | CarryType.C0 r => mk_t n r\n         | CarryType.C1 r => mk_t_S n (WW one r)\n         end) x)) (Z.add (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let succ_c := ZnZ.succ_c in\n         let one := ZnZ.one in\n         fun x : dom_t n =>\n         match succ_c x with\n         | CarryType.C0 r => mk_t n r\n         | CarryType.C1 r => mk_t_S n (WW one r)\n         end) x)) (Z.add (to_Z x) 1)",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match ZnZ.succ_c x with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) 1)",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_succ_c _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_succ_c _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match ZnZ.succ_c x with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) 1)",
                    "c4_x : dom_t n"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  _ : Logic.eq\n        (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.succ_c x)) (Z.add (ZnZ.to_Z x) 1),\nLogic.eq\n  (to_Z\n     match ZnZ.succ_c x with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "case ZnZ.succ_c .",
                "tactic_sig_no_out_arg": "case ZnZ.succ_c .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : Logic.eq\n        (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.succ_c x)) (Z.add (ZnZ.to_Z x) 1),\nLogic.eq\n  (to_Z\n     match ZnZ.succ_c x with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c6_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) 1)),\nLogic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) 1)",
                    "c7_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.add (ZnZ.to_Z x) 1)),\nLogic.eq (to_Z (mk_t_S n (WW ZnZ.one d))) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) 1)),\nLogic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) 1)",
                    "c8_d : dom_t n",
                    "c8_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) 1)",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (ZnZ.to_Z d) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c9_goal : Logic.eq (ZnZ.to_Z d) (Z.add (ZnZ.to_Z x) 1)",
                    "c8_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) 1)",
                    "c4_x : dom_t n",
                    "c8_d : dom_t n",
                    "c4_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.add (ZnZ.to_Z x) 1)),\nLogic.eq (to_Z (mk_t_S n (WW ZnZ.one d))) (Z.add (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.one d))) (Z.add (ZnZ.to_Z x) 1)",
                    "c10_d : dom_t n",
                    "c10_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 d)) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      d : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n            (Z.add (ZnZ.to_Z x) 1) |- Type]"
                ],
                "tactic_res": [
                    "c10_H : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.one d))) (Z.add (ZnZ.to_Z x) 1)",
                    "_global_spec_mk_t_S : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (to_Z (mk_t_S n x))\n         (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.one d))\n  (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.one d))\n  (Z.add (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.one) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z d)) (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.one) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z d)) (Z.add (ZnZ.to_Z x) 1)",
                    "_global_ZnZ.spec_1 : Logic.eq (ZnZ.to_Z ZnZ.one) 1\nwhere\n?n : [n : nat\n      x : dom_t n\n      d : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n            (Z.add (ZnZ.to_Z x) 1) |- nat]"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.add (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.add (ZnZ.to_Z x) 1)",
                    "c10_H : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.add (ZnZ.to_Z x) 1)",
                    "c4_x : dom_t n",
                    "c10_d : dom_t n",
                    "c4_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_2",
        "proof": [
            {
                "tactic_sig": "Lemma spec_2 : [ two ] = 2 .",
                "tactic_sig_no_out_arg": "Lemma spec_2 : [ two ] = 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z two) 2"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z two) 2",
                    "_global_two : t"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (succ one)) 2"
                ]
            },
            {
                "tactic_sig": "now rewrite spec_succ , spec_1 .",
                "tactic_sig_no_out_arg": "now rewrite spec_succ , spec_1 .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (succ one)) 2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_fold",
        "proof": [
            {
                "tactic_sig": "Lemma add_fold : add = same_level addn .",
                "tactic_sig_no_out_arg": "Lemma add_fold : add = same_level addn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq add\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let add_c := ZnZ.add_c in\n      let one := ZnZ.one in\n      fun x y : dom_t n =>\n      match add_c x y with\n      | CarryType.C0 r => mk_t n r\n      | CarryType.C1 r => mk_t_S n (WW one r)\n      end))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq add\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let add_c := ZnZ.add_c in\n      let one := ZnZ.one in\n      fun x y : dom_t n =>\n      match add_c x y with\n      | CarryType.C0 r => mk_t n r\n      | CarryType.C1 r => mk_t_S n (WW one r)\n      end))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq add\n  (let f0 :=\n     let op := W0.ops in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : W0.t =>\n     match add_c x y with\n     | CarryType.C0 r => N0 r\n     | CarryType.C1 r => N1 (WW one r)\n     end in\n   let f1 :=\n     let op := w1_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w1 =>\n     match add_c x y with\n     | CarryType.C0 r => N1 r\n     | CarryType.C1 r => N2 (WW one r)\n     end in\n   let f2 :=\n     let op := w2_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w2 =>\n     match add_c x y with\n     | CarryType.C0 r => N2 r\n     | CarryType.C1 r => N3 (WW one r)\n     end in\n   let f3 :=\n     let op := w3_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w3 =>\n     match add_c x y with\n     | CarryType.C0 r => N3 r\n     | CarryType.C1 r => N4 (WW one r)\n     end in\n   let f4 :=\n     let op := w4_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w4 =>\n     match add_c x y with\n     | CarryType.C0 r => N4 r\n     | CarryType.C1 r => N5 (WW one r)\n     end in\n   let f5 :=\n     let op := w5_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w5 =>\n     match add_c x y with\n     | CarryType.C0 r => N5 r\n     | CarryType.C1 r => N6 (WW one r)\n     end in\n   let f6 :=\n     let op := w6_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w6 =>\n     match add_c x y with\n     | CarryType.C0 r => N6 r\n     | CarryType.C1 r => Nn 0 (WW one r)\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : word w6 (S n) =>\n     match add_c x y with\n     | CarryType.C0 r => Nn n r\n     | CarryType.C1 r => Nn (S n) (WW one r)\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq add\n  (let f0 :=\n     let op := W0.ops in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : W0.t =>\n     match add_c x y with\n     | CarryType.C0 r => N0 r\n     | CarryType.C1 r => N1 (WW one r)\n     end in\n   let f1 :=\n     let op := w1_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w1 =>\n     match add_c x y with\n     | CarryType.C0 r => N1 r\n     | CarryType.C1 r => N2 (WW one r)\n     end in\n   let f2 :=\n     let op := w2_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w2 =>\n     match add_c x y with\n     | CarryType.C0 r => N2 r\n     | CarryType.C1 r => N3 (WW one r)\n     end in\n   let f3 :=\n     let op := w3_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w3 =>\n     match add_c x y with\n     | CarryType.C0 r => N3 r\n     | CarryType.C1 r => N4 (WW one r)\n     end in\n   let f4 :=\n     let op := w4_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w4 =>\n     match add_c x y with\n     | CarryType.C0 r => N4 r\n     | CarryType.C1 r => N5 (WW one r)\n     end in\n   let f5 :=\n     let op := w5_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w5 =>\n     match add_c x y with\n     | CarryType.C0 r => N5 r\n     | CarryType.C1 r => N6 (WW one r)\n     end in\n   let f6 :=\n     let op := w6_op in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : w6 =>\n     match add_c x y with\n     | CarryType.C0 r => N6 r\n     | CarryType.C1 r => Nn 0 (WW one r)\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let add_c := ZnZ.add_c in\n     let one := ZnZ.one in\n     fun x y : word w6 (S n) =>\n     match add_c x y with\n     | CarryType.C0 r => Nn n r\n     | CarryType.C1 r => Nn (S n) (WW one r)\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_add",
        "proof": [
            {
                "tactic_sig": "Theorem spec_add : forall x y , [ add x y ] = [ x ] + [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_add : forall x y , [ add x y ] = [ x ] + [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (add x y)) (Z.add (to_Z x) (to_Z y))",
                    "_global_add_fold : Logic.eq add\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let add_c := ZnZ.add_c in\n             let one := ZnZ.one in\n             fun x y : dom_t n =>\n             match add_c x y with\n             | CarryType.C0 r => mk_t n r\n             | CarryType.C1 r => mk_t_S n (WW one r)\n             end))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_c := ZnZ.add_c in\n         let one := ZnZ.one in\n         fun x y : dom_t n =>\n         match add_c x y with\n         | CarryType.C0 r => mk_t n r\n         | CarryType.C1 r => mk_t_S n (WW one r)\n         end) x y)) (Z.add (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_c := ZnZ.add_c in\n         let one := ZnZ.one in\n         fun x y : dom_t n =>\n         match add_c x y with\n         | CarryType.C0 r => mk_t n r\n         | CarryType.C1 r => mk_t_S n (WW one r)\n         end) x y)) (Z.add (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_c := ZnZ.add_c in\n       let one := ZnZ.one in\n       fun x0 y0 : dom_t n =>\n       match add_c x0 y0 with\n       | CarryType.C0 r => mk_t n r\n       | CarryType.C1 r => mk_t_S n (WW one r)\n       end) x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_c := ZnZ.add_c in\n       let one := ZnZ.one in\n       fun x0 y0 : dom_t n =>\n       match add_c x0 y0 with\n       | CarryType.C0 r => mk_t n r\n       | CarryType.C1 r => mk_t_S n (WW one r)\n       end) x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_c := ZnZ.add_c in\n       let one := ZnZ.one in\n       fun x y : dom_t n =>\n       match add_c x y with\n       | CarryType.C0 r => mk_t n r\n       | CarryType.C1 r => mk_t_S n (WW one r)\n       end) x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_n : nat",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "cbv beta iota zeta .",
                "tactic_sig_no_out_arg": "cbv beta iota zeta .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_c := ZnZ.add_c in\n       let one := ZnZ.one in\n       fun x y : dom_t n =>\n       match add_c x y with\n       | CarryType.C0 r => mk_t n r\n       | CarryType.C1 r => mk_t_S n (WW one r)\n       end) x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (to_Z\n     match ZnZ.add_c x y with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_add_c _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_add_c _i _i ) .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (to_Z\n     match ZnZ.add_c x y with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : Logic.eq\n        (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.add_c x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y)),\nLogic.eq\n  (to_Z\n     match ZnZ.add_c x y with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.add_c .",
                "tactic_sig_no_out_arg": "case ZnZ.add_c .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : Logic.eq\n        (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.add_c x y)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y)),\nLogic.eq\n  (to_Z\n     match ZnZ.add_c x y with\n     | CarryType.C0 r => mk_t n r\n     | CarryType.C1 r => mk_t_S n (WW ZnZ.one r)\n     end) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))),\nLogic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))),\nLogic.eq (to_Z (mk_t_S n (WW ZnZ.one d)))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros z H .",
                "tactic_args": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))),\nLogic.eq (to_Z (mk_t n d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (mk_t n z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_z : dom_t n",
                    "c10_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros z H .",
                "tactic_args": [
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))),\nLogic.eq (to_Z (mk_t_S n (WW ZnZ.one d)))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.one z)))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c11_z : dom_t n",
                    "c11_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (mk_t n z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (ZnZ.to_Z z) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c12_goal : Logic.eq (ZnZ.to_Z z) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n",
                    "c10_z : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.one z)))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_mk_t_S : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (to_Z (mk_t_S n x))\n         (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.one z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      y : dom_t n\n      z : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n            (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y)) |- Type]",
                    "c13_H : Logic.eq\n  (interp_carry 1 (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c13_H : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.one z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.one) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.one) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z z)) (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_1 : Logic.eq (ZnZ.to_Z ZnZ.one) 1\nwhere\n?n : [n : nat\n      x : dom_t n\n      y : dom_t n\n      z : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n            (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y)) |- nat]"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c13_H : Logic.eq (Z.add (Z.mul 1 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.add (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n",
                    "c11_z : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_fold",
        "proof": [
            {
                "tactic_sig": "Lemma pred_fold : pred = iter_t predn .",
                "tactic_sig_no_out_arg": "Lemma pred_fold : pred = iter_t predn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq pred\n  (iter_t\n     (fun n : nat =>\n      let pred_c := ZnZ.pred_c in\n      fun x : dom_t n =>\n      match pred_c x with\n      | CarryType.C0 r => reduce n r\n      | CarryType.C1 _ => zero\n      end))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq pred\n  (iter_t\n     (fun n : nat =>\n      let pred_c := ZnZ.pred_c in\n      fun x : dom_t n =>\n      match pred_c x with\n      | CarryType.C0 r => reduce n r\n      | CarryType.C1 _ => zero\n      end))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq pred\n  (let f0 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : W0.t =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_0 r\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w1 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_1 r\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w2 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_2 r\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w3 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_3 r\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w4 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_4 r\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w5 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_5 r\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w6 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_6 r\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let pred_c := ZnZ.pred_c in\n     fun x : word w6 (S n) =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_n n r\n     | CarryType.C1 _ => zero\n     end in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq pred\n  (let f0 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : W0.t =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_0 r\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w1 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_1 r\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w2 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_2 r\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w3 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_3 r\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w4 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_4 r\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w5 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_5 r\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let pred_c := ZnZ.pred_c in\n     fun x : w6 =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_6 r\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let pred_c := ZnZ.pred_c in\n     fun x : word w6 (S n) =>\n     match pred_c x with\n     | CarryType.C0 r => reduce_n n r\n     | CarryType.C1 _ => zero\n     end in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pred_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pred_pos : forall x , 0 < [ x ] -> [ pred x ] = [ x ] - 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_pred_pos : forall x , 0 < [ x ] -> [ pred x ] = [ x ] - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nLogic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "custom63 x pred_fold x H x y H' y H' spec_reduce .",
                "tactic_sig_no_out_arg": "custom63 x pred_fold x H x y H' y H' spec_reduce .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nLogic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (ZnZ.to_Z y) (Z.sub (ZnZ.to_Z x) 1)",
                    "c2_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 y)) (Z.sub (ZnZ.to_Z x) 1)",
                    "c2_y : dom_t n",
                    "c2_H : Z.lt 0 (ZnZ.to_Z x)",
                    "c2_x : dom_t n",
                    "c2_n : nat",
                    "c3_goal : Logic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) 1)",
                    "c3_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 y)) (Z.sub (ZnZ.to_Z x) 1)",
                    "c3_y : dom_t n",
                    "c3_H : Z.lt 0 (ZnZ.to_Z x)",
                    "c3_x : dom_t n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c2_goal : Logic.eq (ZnZ.to_Z y) (Z.sub (ZnZ.to_Z x) 1)",
                    "c2_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 y)) (Z.sub (ZnZ.to_Z x) 1)",
                    "c2_y : dom_t n",
                    "c2_x : dom_t n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c4_goal : False"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_to_Z _i ) ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_to_Z _i ) ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c4_goal : False",
                    "c3_x : dom_t n",
                    "c3_y : dom_t n"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z x))\n         (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z y))\n         (Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n))))), False"
                ]
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      H : Z.lt 0 (ZnZ.to_Z x)\n      y : dom_t n\n      H' : Logic.eq\n             (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z y))\n             (Z.sub (ZnZ.to_Z x) 1) |- Type]"
                ],
                "tactic_res": [
                    "c5_H' : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z y))\n  (Z.sub (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z x))\n         (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z y))\n         (Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n))))), False",
                    "c5_H' : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z y))\n  (Z.sub (ZnZ.to_Z x) 1)",
                    "c3_y : dom_t n",
                    "c3_H : Z.lt 0 (ZnZ.to_Z x)",
                    "c3_x : dom_t n",
                    "c3_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pred0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pred0 : forall x , [ x ] = 0 -> [ pred x ] = 0 .",
                "tactic_sig_no_out_arg": "Theorem spec_pred0 : forall x , [ x ] = 0 -> [ pred x ] = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (pred x)) 0"
                ]
            },
            {
                "tactic_sig": "custom63 x pred_fold x H x y H' y H' spec_reduce .",
                "tactic_sig_no_out_arg": "custom63 x pred_fold x H x y H' y H' spec_reduce .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (pred x)) 0"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (ZnZ.to_Z y) 0",
                    "c2_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 y)) (Z.sub (ZnZ.to_Z x) 1)",
                    "c2_y : dom_t n",
                    "c2_H : Logic.eq (ZnZ.to_Z x) 0",
                    "c2_x : dom_t n",
                    "c2_n : nat",
                    "c3_goal : Logic.eq (to_Z zero) 0",
                    "c3_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 y)) (Z.sub (ZnZ.to_Z x) 1)",
                    "c3_y : dom_t n",
                    "c3_H : Logic.eq (ZnZ.to_Z x) 0",
                    "c3_x : dom_t n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      H : Logic.eq (ZnZ.to_Z x) 0\n      y : dom_t n\n      H' : Logic.eq (ZnZ.to_Z y) (Z.sub (ZnZ.to_Z x) 1) |- Type]",
                    "c2_H' : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 y)) (Z.sub (ZnZ.to_Z x) 1)"
                ],
                "tactic_res": [
                    "c2_H' : Logic.eq (ZnZ.to_Z y) (Z.sub (ZnZ.to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "custom36 _i .",
                "tactic_sig_no_out_arg": "custom36 _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (ZnZ.to_Z y) 0",
                    "c2_y : dom_t n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact spec_0 .",
                "tactic_sig_no_out_arg": "exact spec_0 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pred",
        "proof": [
            {
                "tactic_sig": "Lemma spec_pred x : [ pred x ] = Z.max 0 ( [ x ] - 1 ) .",
                "tactic_sig_no_out_arg": "Lemma spec_pred x : [ pred x ] = Z.max 0 ( [ x ] - 1 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z (pred x)) (Z.max 0 (Z.sub (to_Z x) 1))",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z (pred x)) (Z.max 0 (Z.sub (to_Z x) 1))",
                    "_global_Z.max_comm : forall n m : Z, Logic.eq (Z.max n m) (Z.max m n)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pred x)) (Z.max (Z.sub (to_Z x) 1) 0)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.max_spec ( [ _i ] - 1 ) 0 ) as [ ( H , -> ) | ( H , -> ) ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.max_spec ( [ _i ] - 1 ) 0 ) as [ ( H , -> ) | ( H , -> ) ] .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pred x)) (Z.max (Z.sub (to_Z x) 1) 0)",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (pred x)) 0",
                    "c3_H : Z.lt (Z.sub (to_Z x) 1) 0",
                    "c4_goal : Logic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)",
                    "c4_H : Z.le 0 (Z.sub (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (pred x)) 0",
                    "_global_spec_pred0 : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (pred x)) 0"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_pos _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z x) 0",
                    "c1_x : True"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Z.le 0 (to_Z x), Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.le 0 (to_Z x), Logic.eq (to_Z x) 0",
                    "c3_H : Z.lt (Z.sub (to_Z x) 1) 0",
                    "c1_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)",
                    "_global_spec_pred_pos : forall (x : t) (_ : Z.lt 0 (to_Z x)),\n       Logic.eq (to_Z (pred x)) (Z.sub (to_Z x) 1)"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 (to_Z x)",
                    "c4_H : Z.le 0 (Z.sub (to_Z x) 1)",
                    "c1_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sub_fold",
        "proof": [
            {
                "tactic_sig": "Lemma sub_fold : sub = same_level subn .",
                "tactic_sig_no_out_arg": "Lemma sub_fold : sub = same_level subn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq sub\n  (same_level\n     (fun n : nat =>\n      let sub_c := ZnZ.sub_c in\n      fun x y : dom_t n =>\n      match sub_c x y with\n      | CarryType.C0 r => reduce n r\n      | CarryType.C1 _ => zero\n      end))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq sub\n  (same_level\n     (fun n : nat =>\n      let sub_c := ZnZ.sub_c in\n      fun x y : dom_t n =>\n      match sub_c x y with\n      | CarryType.C0 r => reduce n r\n      | CarryType.C1 _ => zero\n      end))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq sub\n  (let f0 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : W0.t =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_0 r\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w1 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_1 r\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w2 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_2 r\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w3 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_3 r\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w4 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_4 r\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w5 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_5 r\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w6 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_6 r\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let sub_c := ZnZ.sub_c in\n     fun x y : word w6 (S n) =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_n n r\n     | CarryType.C1 _ => zero\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq sub\n  (let f0 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : W0.t =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_0 r\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w1 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_1 r\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w2 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_2 r\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w3 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_3 r\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w4 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_4 r\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w5 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_5 r\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let sub_c := ZnZ.sub_c in\n     fun x y : w6 =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_6 r\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let sub_c := ZnZ.sub_c in\n     fun x y : word w6 (S n) =>\n     match sub_c x y with\n     | CarryType.C0 r => reduce_n n r\n     | CarryType.C1 _ => zero\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub_pos : forall x y , [ y ] <= [ x ] -> [ sub x y ] = [ x ] - [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_sub_pos : forall x y , [ y ] <= [ x ] -> [ sub x y ] = [ x ] - [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Z.le (to_Z y) (to_Z x)),\nLogic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Z.le (to_Z y) (to_Z x)),\nLogic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Z.le (to_Z y) (to_Z x),\nLogic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Z.le (to_Z y) (to_Z x),\nLogic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))",
                    "_global_sub_fold : Logic.eq sub\n         (same_level\n            (fun n : nat =>\n             let sub_c := ZnZ.sub_c in\n             fun x y : dom_t n =>\n             match sub_c x y with\n             | CarryType.C0 r => reduce n r\n             | CarryType.C1 _ => zero\n             end))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Z.le (to_Z y) (to_Z x),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let sub_c := ZnZ.sub_c in\n         fun x y : dom_t n =>\n         match sub_c x y with\n         | CarryType.C0 r => reduce n r\n         | CarryType.C1 _ => zero\n         end) x y)) (Z.sub (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : forall _ : Z.le (to_Z y) (to_Z x),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let sub_c := ZnZ.sub_c in\n         fun x y : dom_t n =>\n         match sub_c x y with\n         | CarryType.C0 r => reduce n r\n         | CarryType.C1 _ => zero\n         end) x y)) (Z.sub (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq\n  (to_Z\n     ((let sub_c := ZnZ.sub_c in\n       fun x0 y0 : dom_t n =>\n       match sub_c x0 y0 with\n       | CarryType.C0 r => reduce n r\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq\n  (to_Z\n     ((let sub_c := ZnZ.sub_c in\n       fun x0 y0 : dom_t n =>\n       match sub_c x0 y0 with\n       | CarryType.C0 r => reduce n r\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x),\nLogic.eq\n  (to_Z\n     ((let sub_c := ZnZ.sub_c in\n       fun x y : dom_t n =>\n       match sub_c x y with\n       | CarryType.C0 r => reduce n r\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_n : nat",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall _ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x),\nLogic.eq\n  (to_Z\n     ((let sub_c := ZnZ.sub_c in\n       fun x y : dom_t n =>\n       match sub_c x y with\n       | CarryType.C0 r => reduce n r\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c x y with\n     | CarryType.C0 r => reduce n r\n     | CarryType.C1 _ => zero\n     end) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_sub_c _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_sub_c _i _i ) .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c x y with\n     | CarryType.C0 r => reduce n r\n     | CarryType.C1 _ => zero\n     end) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (ZnZ.sub_c x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c x y with\n     | CarryType.C0 r => reduce n r\n     | CarryType.C1 _ => zero\n     end) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.sub_c .",
                "tactic_sig_no_out_arg": "case ZnZ.sub_c .",
                "tactic_args": [
                    "c7_goal : forall\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (ZnZ.sub_c x y)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c x y with\n     | CarryType.C0 r => reduce n r\n     | CarryType.C1 _ => zero\n     end) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq (to_Z (reduce n d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros z H LE .",
                "tactic_args": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq (to_Z (reduce n d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (reduce n z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_z : dom_t n",
                    "c10_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_LE : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros z H LE .",
                "tactic_args": [
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y)))\n  (_ : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)),\nLogic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c11_z : dom_t n",
                    "c11_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c11_LE : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (reduce n z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (ZnZ.to_Z z) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c12_goal : Logic.eq (ZnZ.to_Z z) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_x : dom_t n",
                    "c5_y : dom_t n",
                    "c10_z : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      y : dom_t n\n      z : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n            (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))\n      LE : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x) |- Type]",
                    "c11_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c11_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z zero) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c13_goal : False"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c13_goal : False",
                    "c11_z : dom_t n"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  _ : and (Z.le 0 (ZnZ.to_Z z))\n        (Z.lt (ZnZ.to_Z z) (base (ZnZ.digits (dom_op n)))), False"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : and (Z.le 0 (ZnZ.to_Z z))\n        (Z.lt (ZnZ.to_Z z) (base (ZnZ.digits (dom_op n)))), False",
                    "c11_LE : Z.le (ZnZ.to_Z y) (ZnZ.to_Z x)",
                    "c11_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z z))\n  (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c11_z : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sub0 : forall x y , [ x ] < [ y ] -> [ sub x y ] = 0 .",
                "tactic_sig_no_out_arg": "Theorem spec_sub0 : forall x y , [ x ] < [ y ] -> [ sub x y ] = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Z.lt (to_Z x) (to_Z y)),\nLogic.eq (to_Z (sub x y)) 0"
                ]
            },
            {
                "tactic_sig": "custom65 x y sub_fold spec_same_level n x y z H LE spec_reduce z H LE .",
                "tactic_sig_no_out_arg": "custom65 x y sub_fold spec_same_level n x y z H LE spec_reduce z H LE .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Z.lt (to_Z x) (to_Z y)),\nLogic.eq (to_Z (sub x y)) 0"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (ZnZ.to_Z z) 0",
                    "c2_LE : Z.lt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c2_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c2_z : dom_t n",
                    "c2_y : dom_t n",
                    "c2_x : dom_t n",
                    "c2_n : nat",
                    "c3_goal : Logic.eq (to_Z zero) 0",
                    "c3_LE : Z.lt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c3_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c3_z : dom_t n",
                    "c3_y : dom_t n",
                    "c3_x : dom_t n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      y : dom_t n\n      z : dom_t n\n      H : Logic.eq (ZnZ.to_Z z) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))\n      LE : Z.lt (ZnZ.to_Z x) (ZnZ.to_Z y) |- Type]",
                    "c2_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 z)) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c2_H : Logic.eq (ZnZ.to_Z z) (Z.sub (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "custom36 _i .",
                "tactic_sig_no_out_arg": "custom36 _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (ZnZ.to_Z z) 0",
                    "c2_z : dom_t n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact spec_0 .",
                "tactic_sig_no_out_arg": "exact spec_0 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sub",
        "proof": [
            {
                "tactic_sig": "Lemma spec_sub : forall x y , [ sub x y ] = Z.max 0 ( [ x ] - [ y ] ) .",
                "tactic_sig_no_out_arg": "Lemma spec_sub : forall x y , [ sub x y ] = Z.max 0 ( [ x ] - [ y ] ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t,\nLogic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : t,\nLogic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.le_gt_cases [ _i ] [ _i ] ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.le_gt_cases [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "c2_y : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "c3_H : Z.le (to_Z y) (to_Z x)",
                    "c4_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "c4_H : Z.lt (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "_global_Z.max_r : forall (n m : Z) (_ : Z.le n m), Logic.eq (Z.max n m) m"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))",
                    "c6_goal : Z.le 0 (Z.sub (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : Z.le 0 (Z.sub (to_Z x) (to_Z y))",
                    "c3_H : Z.le (to_Z y) (to_Z x)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))",
                    "_global_spec_sub_pos : forall (x y : t) (_ : Z.le (to_Z y) (to_Z x)),\n       Logic.eq (to_Z (sub x y)) (Z.sub (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Z.le (to_Z y) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Z.le (to_Z y) (to_Z x)",
                    "c3_H : Z.le (to_Z y) (to_Z x)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (sub x y)) (Z.max 0 (Z.sub (to_Z x) (to_Z y)))",
                    "_global_Z.max_l : forall (n m : Z) (_ : Z.le m n), Logic.eq (Z.max n m) n"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z (sub x y)) 0",
                    "c9_goal : Z.le (Z.sub (to_Z x) (to_Z y)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Z.le (Z.sub (to_Z x) (to_Z y)) 0",
                    "c4_H : Z.lt (to_Z x) (to_Z y)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z (sub x y)) 0",
                    "_global_spec_sub0 : forall (x y : t) (_ : Z.lt (to_Z x) (to_Z y)),\n       Logic.eq (to_Z (sub x y)) 0"
                ],
                "tactic_res": [
                    "c10_goal : Z.lt (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Z.lt (to_Z x) (to_Z y)",
                    "c4_H : Z.lt (to_Z x) (to_Z y)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_comparen_m",
        "proof": [
            {
                "tactic_sig": "Let spec_comparen_m : forall n m ( x : word ( dom_t n ) ( S m ) ) ( y : dom_t n ) , comparen_m n m x y = Z.compare ( eval n ( S m ) x ) ( ZnZ.to_Z y ) .",
                "tactic_sig_no_out_arg": "Let spec_comparen_m : forall n m ( x : word ( dom_t n ) ( S m ) ) ( y : dom_t n ) , comparen_m n m x y = Z.compare ( eval n ( S m ) x ) ( ZnZ.to_Z y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y .",
                "tactic_args": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_x : word (dom_t n) (S m)",
                    "c2_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_comparen_m : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n),\n       comparison",
                    "_global_eval : forall (n m : nat) (_ : word (dom_t n) m), Z"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (compare_mn_1 (dom_t n) (dom_t n) ZnZ.zero ZnZ.compare\n     (ZnZ.compare ZnZ.zero) ZnZ.compare (S m) x y)\n  (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (compare_mn_1 (dom_t n) (dom_t n) ZnZ.zero ZnZ.compare\n     (ZnZ.compare ZnZ.zero) ZnZ.compare (S m) x y)\n  (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_nmake_double : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq ZnZ.to_Z\n         (DoubleBase.double_to_Z (ZnZ.digits w_op) ZnZ.to_Z n)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (compare_mn_1 (dom_t n) (dom_t n) ZnZ.zero ZnZ.compare\n     (ZnZ.compare ZnZ.zero) ZnZ.compare (S m) x y)\n  (Z.compare\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (compare_mn_1 (dom_t n) (dom_t n) ZnZ.zero ZnZ.compare\n     (ZnZ.compare ZnZ.zero) ZnZ.compare (S m) x y)\n  (Z.compare\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (ZnZ.to_Z y))",
                    "_global_spec_compare_mn_1 : forall (wm w : DoubleBase.univ_of_cycles) (w_0 : w)\n         (compare : forall (_ : w) (_ : w), comparison)\n         (compare0_m : forall _ : wm, comparison)\n         (compare_m : forall (_ : wm) (_ : w), comparison)\n         (wm_base : positive) (wm_to_Z : forall _ : wm, Z)\n         (w_to_Z : forall _ : w, Z) (_ : Logic.eq (w_to_Z w_0) 0)\n         (_ : forall x : wm,\n              Logic.eq (compare0_m x) (Z.compare (w_to_Z w_0) (wm_to_Z x)))\n         (_ : forall x : wm,\n              and (Z.le 0 (wm_to_Z x)) (Z.lt (wm_to_Z x) (base wm_base)))\n         (_ : forall x y : w,\n              Logic.eq (compare x y) (Z.compare (w_to_Z x) (w_to_Z y)))\n         (_ : forall (x : wm) (y : w),\n              Logic.eq (compare_m x y) (Z.compare (wm_to_Z x) (w_to_Z y)))\n         (_ : forall x : w,\n              and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base wm_base)))\n         (n : nat) (x : word wm n) (y : w),\n       Logic.eq (compare_mn_1 wm w w_0 compare compare0_m compare_m n x y)\n         (Z.compare (DoubleBase.double_to_Z wm_base wm_to_Z n x) (w_to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0",
                    "c6_goal : forall x : dom_t n,\nLogic.eq (ZnZ.compare ZnZ.zero x)\n  (Z.compare (ZnZ.to_Z ZnZ.zero) (ZnZ.to_Z x))",
                    "c7_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c8_goal : forall x y : dom_t n,\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c9_goal : forall x y : dom_t n,\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c10_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "exact ZnZ.spec_0 .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_0 .",
                "tactic_args": [
                    "c5_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall x : dom_t n,\nLogic.eq (ZnZ.compare ZnZ.zero x)\n  (Z.compare (ZnZ.to_Z ZnZ.zero) (ZnZ.to_Z x))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (ZnZ.compare ZnZ.zero x0)\n  (Z.compare (ZnZ.to_Z ZnZ.zero) (ZnZ.to_Z x0))",
                    "c11_x0 : dom_t n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (ZnZ.compare ZnZ.zero x0)\n  (Z.compare (ZnZ.to_Z ZnZ.zero) (ZnZ.to_Z x0))",
                    "_global_ZnZ.spec_compare : forall x0 y0 : word w6 (S ?n),\n       Logic.eq (ZnZ.compare x0 y0) (Z.compare (ZnZ.to_Z x0) (ZnZ.to_Z y0))\nwhere\n?n : [n : nat  m : nat  x : word (dom_t n) (S m)  y : dom_t n |- nat]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_to_Z .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_to_Z .",
                "tactic_args": [
                    "c7_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_compare .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_compare .",
                "tactic_args": [
                    "c8_goal : forall x y : dom_t n,\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_compare .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_compare .",
                "tactic_args": [
                    "c9_goal : forall x y : dom_t n,\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_to_Z .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_to_Z .",
                "tactic_args": [
                    "c10_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compare_fold",
        "proof": [
            {
                "tactic_sig": "Lemma compare_fold : compare = compare_folded .",
                "tactic_sig_no_out_arg": "Lemma compare_fold : compare = compare_folded .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq compare\n  (iter_sym comparison (fun n : nat => ZnZ.compare) comparen_m\n     comparenm CompOpp)"
                ]
            },
            {
                "tactic_sig": "lazy beta iota delta [ iter_sym dom_op dom_t comparen_m ] .",
                "tactic_sig_no_out_arg": "lazy beta iota delta [ iter_sym dom_op dom_t comparen_m ] .",
                "tactic_args": [
                    "c1_goal : Logic.eq compare\n  (iter_sym comparison (fun n : nat => ZnZ.compare) comparen_m\n     comparenm CompOpp)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq compare\n  (let f0 := ZnZ.compare in\n   let f1 := ZnZ.compare in\n   let f2 := ZnZ.compare in\n   let f3 := ZnZ.compare in\n   let f4 := ZnZ.compare in\n   let f5 := ZnZ.compare in\n   let f6 := ZnZ.compare in\n   let fn0 :=\n     let op := W0.ops in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 W0.t W0.t zero compare compare0 compare (S m) in\n   let fn1 :=\n     let op := w1_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w1 w1 zero compare compare0 compare (S m) in\n   let fn2 :=\n     let op := w2_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w2 w2 zero compare compare0 compare (S m) in\n   let fn3 :=\n     let op := w3_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w3 w3 zero compare compare0 compare (S m) in\n   let fn4 :=\n     let op := w4_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w4 w4 zero compare compare0 compare (S m) in\n   let fn5 :=\n     let op := w5_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w5 w5 zero compare compare0 compare (S m) in\n   let fn6 :=\n     let op := w6_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w6 w6 zero compare compare0 compare (S m) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => CompOpp (fn0 0%nat wy wx)\n       | N2 wy => CompOpp (fn0 1%nat wy wx)\n       | N3 wy => CompOpp (fn0 2%nat wy wx)\n       | N4 wy => CompOpp (fn0 3%nat wy wx)\n       | N5 wy => CompOpp (fn0 4%nat wy wx)\n       | N6 wy => CompOpp (fn0 5%nat wy wx)\n       | Nn m wy =>\n           CompOpp\n             (fn6 m wy\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => CompOpp (fn1 0%nat wy wx)\n       | N3 wy => CompOpp (fn1 1%nat wy wx)\n       | N4 wy => CompOpp (fn1 2%nat wy wx)\n       | N5 wy => CompOpp (fn1 3%nat wy wx)\n       | N6 wy => CompOpp (fn1 4%nat wy wx)\n       | Nn m wy =>\n           CompOpp\n             (fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => CompOpp (fn2 0%nat wy wx)\n       | N4 wy => CompOpp (fn2 1%nat wy wx)\n       | N5 wy => CompOpp (fn2 2%nat wy wx)\n       | N6 wy => CompOpp (fn2 3%nat wy wx)\n       | Nn m wy =>\n           CompOpp (fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 wx)))))\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => CompOpp (fn3 0%nat wy wx)\n       | N5 wy => CompOpp (fn3 1%nat wy wx)\n       | N6 wy => CompOpp (fn3 2%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 (WW W0 (WW W0 wx))))\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => CompOpp (fn4 0%nat wy wx)\n       | N6 wy => CompOpp (fn4 1%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 (WW W0 wx)))\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => CompOpp (fn5 0%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 wx))\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => CompOpp (fn6 m wy wx)\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => comparenm n m wx wy\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq compare\n  (let f0 := ZnZ.compare in\n   let f1 := ZnZ.compare in\n   let f2 := ZnZ.compare in\n   let f3 := ZnZ.compare in\n   let f4 := ZnZ.compare in\n   let f5 := ZnZ.compare in\n   let f6 := ZnZ.compare in\n   let fn0 :=\n     let op := W0.ops in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 W0.t W0.t zero compare compare0 compare (S m) in\n   let fn1 :=\n     let op := w1_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w1 w1 zero compare compare0 compare (S m) in\n   let fn2 :=\n     let op := w2_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w2 w2 zero compare compare0 compare (S m) in\n   let fn3 :=\n     let op := w3_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w3 w3 zero compare compare0 compare (S m) in\n   let fn4 :=\n     let op := w4_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w4 w4 zero compare compare0 compare (S m) in\n   let fn5 :=\n     let op := w5_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w5 w5 zero compare compare0 compare (S m) in\n   let fn6 :=\n     let op := w6_op in\n     let zero := ZnZ.zero in\n     let compare := ZnZ.compare in\n     let compare0 := compare zero in\n     fun m : nat =>\n     compare_mn_1 w6 w6 zero compare compare0 compare (S m) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => CompOpp (fn0 0%nat wy wx)\n       | N2 wy => CompOpp (fn0 1%nat wy wx)\n       | N3 wy => CompOpp (fn0 2%nat wy wx)\n       | N4 wy => CompOpp (fn0 3%nat wy wx)\n       | N5 wy => CompOpp (fn0 4%nat wy wx)\n       | N6 wy => CompOpp (fn0 5%nat wy wx)\n       | Nn m wy =>\n           CompOpp\n             (fn6 m wy\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => CompOpp (fn1 0%nat wy wx)\n       | N3 wy => CompOpp (fn1 1%nat wy wx)\n       | N4 wy => CompOpp (fn1 2%nat wy wx)\n       | N5 wy => CompOpp (fn1 3%nat wy wx)\n       | N6 wy => CompOpp (fn1 4%nat wy wx)\n       | Nn m wy =>\n           CompOpp\n             (fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => CompOpp (fn2 0%nat wy wx)\n       | N4 wy => CompOpp (fn2 1%nat wy wx)\n       | N5 wy => CompOpp (fn2 2%nat wy wx)\n       | N6 wy => CompOpp (fn2 3%nat wy wx)\n       | Nn m wy =>\n           CompOpp (fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 wx)))))\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => CompOpp (fn3 0%nat wy wx)\n       | N5 wy => CompOpp (fn3 1%nat wy wx)\n       | N6 wy => CompOpp (fn3 2%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 (WW W0 (WW W0 wx))))\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => CompOpp (fn4 0%nat wy wx)\n       | N6 wy => CompOpp (fn4 1%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 (WW W0 wx)))\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => CompOpp (fn5 0%nat wy wx)\n       | Nn m wy => CompOpp (fn6 m wy (WW W0 wx))\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => CompOpp (fn6 m wy wx)\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => comparenm n m wx wy\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_compare",
        "proof": [
            {
                "tactic_sig": "Theorem spec_compare : forall x y , compare x y = Z.compare [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_compare : forall x y , compare x y = Z.compare [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_compare_fold : Logic.eq compare\n         (iter_sym comparison (fun n : nat => ZnZ.compare) comparen_m\n            comparenm CompOpp)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (iter_sym comparison (fun n : nat => ZnZ.compare) comparen_m\n     comparenm CompOpp x y) (Z.compare (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (iter_sym comparison (fun n : nat => ZnZ.compare) comparen_m\n     comparenm CompOpp x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_spec_iter_sym : forall (res : Type) (P : forall (_ : Z) (_ : Z) (_ : res), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y))\n         (fg : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n),\n               res)\n         (_ : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n              P (eval n (S m) x) (ZnZ.to_Z y) (fg n m x y))\n         (fnm : forall (n m : nat) (_ : word (dom_t 6) (S n))\n                  (_ : word (dom_t 6) (S m)), res)\n         (_ : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\n              P (to_Z (Nn n x)) (to_Z (Nn m y)) (fnm n m x y))\n         (opp : forall _ : res, res)\n         (_ : forall (u v : Z) (r : res) (_ : P u v r), P v u (opp r))\n         (x y : t), P (to_Z x) (to_Z y) (iter_sym res f fg fnm opp x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))",
                    "c6_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\nLogic.eq (comparenm n m x y)\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "c7_goal : forall (u v : Z) (r : comparison) (_ : Logic.eq r (Z.compare u v)),\nLogic.eq (CompOpp r) (Z.compare v u)"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c8_n : nat",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_compare : forall x y : word w6 (S ?n),\n       Logic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))",
                    "c9_n : nat",
                    "c9_m : nat",
                    "c9_x : word (dom_t n) (S m)",
                    "c9_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (comparen_m n m x y) (Z.compare (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_spec_comparen_m : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n       Logic.eq (comparen_m n m x y)\n         (Z.compare (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y .",
                "tactic_args": [
                    "c6_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\nLogic.eq (comparenm n m x y)\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (comparenm n m x y)\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "c10_n : nat",
                    "c10_m : nat",
                    "c10_x : word w6 (S n)",
                    "c10_y : word w6 (S m)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (comparenm n m x y)\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_comparenm : forall (n m : nat) (_ : word w6 (S n)) (_ : word w6 (S m)), comparison"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c10_n : nat",
                    "c10_m : nat",
                    "c10_x : word w6 (S n)",
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c10_n : nat",
                    "c10_m : nat",
                    "c10_y : word w6 (S m)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))",
                    "_global_to_Z : forall _ : t, Z"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (ZnZ.compare (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n     (castm (diff_l n m) (extend_tr y (fst (diff n m)))))\n  (Z.compare\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "_global_ZnZ.spec_compare : forall x y : word w6 (S ?n),\n       Logic.eq (ZnZ.compare x y) (Z.compare (ZnZ.to_Z x) (ZnZ.to_Z y))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (u v : Z) (r : comparison) (_ : Logic.eq r (Z.compare u v)),\nLogic.eq (CompOpp r) (Z.compare v u)"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (CompOpp r) (Z.compare v u)",
                    "c14_u : Z",
                    "c14_v : Z",
                    "c14_r : comparison",
                    "c14_H : Logic.eq r (Z.compare u v)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c14_goal : Logic.eq (CompOpp r) (Z.compare v u)"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (CompOpp (Z.compare u v)) (Z.compare v u)"
                ]
            },
            {
                "tactic_sig": "now rewrite <- Z.compare_antisym .",
                "tactic_sig_no_out_arg": "now rewrite <- Z.compare_antisym .",
                "tactic_args": [
                    "c15_goal : Logic.eq (CompOpp (Z.compare u v)) (Z.compare v u)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_eqb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_eqb x y : eqb x y = Z.eqb [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_eqb x y : eqb x y = Z.eqb [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "_global_eq_iff_eq_true : forall b1 b2 : bool,\n       iff (Logic.eq b1 b2) (iff (Logic.eq b1 true) (Logic.eq b2 true))"
                ],
                "tactic_res": [
                    "c2_goal : iff (Logic.eq (eqb x y) true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : iff (Logic.eq (eqb x y) true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)",
                    "_global_eqb : forall (_ : t) (_ : t), bool"
                ],
                "tactic_res": [
                    "c3_goal : iff\n  (Logic.eq match compare x y with\n            | Eq => true\n            | _ => false\n            end true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i , _i .",
                "tactic_args": [
                    "c3_goal : iff\n  (Logic.eq match compare x y with\n            | Eq => true\n            | _ => false\n            end true) (Logic.eq (Z.eqb (to_Z x) (to_Z y)) true)",
                    "_global_Z.eqb_eq : forall n m : Z, iff (Logic.eq (Z.eqb n m) true) (Logic.eq n m)",
                    "_global_Z.compare_eq_iff : forall n m : Z, iff (Logic.eq (Z.compare n m) Eq) (Logic.eq n m)",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq)"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Eq => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq",
                    "c6_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => true\n  | _ => false\n  end true"
                ]
            },
            {
                "tactic_sig": "now destruct Z.compare .",
                "tactic_sig_no_out_arg": "now destruct Z.compare .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : Logic.eq\n        match Z.compare (to_Z x) (to_Z y) with\n        | Eq => true\n        | _ => false\n        end true, Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now intros -> .",
                "tactic_sig_no_out_arg": "now intros -> .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (Z.compare (to_Z x) (to_Z y)) Eq,\nLogic.eq\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => true\n  | _ => false\n  end true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ltb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_ltb x y : ltb x y = Z.ltb [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_ltb x y : ltb x y = Z.ltb [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "custom27 eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_sig_no_out_arg": "custom27 eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                    "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
            },
            {
                "tactic_sig": "custom45 .",
                "tactic_sig_no_out_arg": "custom45 .",
                "tactic_args": [
                    "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_leb",
        "proof": [
            {
                "tactic_sig": "Theorem spec_leb x y : leb x y = Z.leb [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_leb x y : leb x y = Z.leb [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))",
                    "_global_eq_iff_eq_true : forall b1 b2 : bool,\n       iff (Logic.eq b1 b2) (iff (Logic.eq b1 true) (Logic.eq b2 true))"
                ],
                "tactic_res": [
                    "c2_goal : iff (Logic.eq (leb x y) true) (Logic.eq (Z.leb (to_Z x) (to_Z y)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : iff (Logic.eq (leb x y) true) (Logic.eq (Z.leb (to_Z x) (to_Z y)) true)",
                    "_global_Z.leb_le : forall n m : Z, iff (Logic.eq (Z.leb n m) true) (Z.le n m)"
                ],
                "tactic_res": [
                    "c3_goal : iff (Logic.eq (leb x y) true) (Z.le (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : iff (Logic.eq (leb x y) true) (Z.le (to_Z x) (to_Z y))",
                    "_global_Z.le : forall (_ : Z) (_ : Z), Prop",
                    "_global_leb : forall (_ : t) (_ : t), bool"
                ],
                "tactic_res": [
                    "c4_goal : iff\n  (Logic.eq match compare x y with\n            | Gt => false\n            | _ => true\n            end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : iff\n  (Logic.eq match compare x y with\n            | Gt => false\n            | _ => true\n            end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
            },
            {
                "tactic_sig": "now destruct Z.compare .",
                "tactic_sig_no_out_arg": "now destruct Z.compare .",
                "tactic_args": [
                    "c5_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))",
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_max",
        "proof": [
            {
                "tactic_sig": "Theorem spec_max : forall n m , [ max n m ] = Z.max [ n ] [ m ] .",
                "tactic_sig_no_out_arg": "Theorem spec_max : forall n m , [ max n m ] = Z.max [ n ] [ m ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t, Logic.eq (to_Z (max n m)) (Z.max (to_Z n) (to_Z m))"
                ]
            },
            {
                "tactic_sig": "custom9 n m max Z.max spec_compare .",
                "tactic_sig_no_out_arg": "custom9 n m max Z.max spec_compare .",
                "tactic_args": [
                    "c1_goal : forall n m : t, Logic.eq (to_Z (max n m)) (Z.max (to_Z n) (to_Z m))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_min",
        "proof": [
            {
                "tactic_sig": "Theorem spec_min : forall n m , [ min n m ] = Z.min [ n ] [ m ] .",
                "tactic_sig_no_out_arg": "Theorem spec_min : forall n m , [ min n m ] = Z.min [ n ] [ m ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : t, Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall n m : t, Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))",
                    "c2_n : True",
                    "c2_m : True"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (min n m)) (Z.min (to_Z n) (to_Z m))",
                    "_global_min : forall (_ : t) (_ : t), t",
                    "_global_Z.min : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z match compare n m with\n               | Gt => m\n               | _ => n\n               end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Gt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct Z.compare as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct Z.compare .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z match Z.compare (to_Z n) (to_Z m) with\n        | Gt => m\n        | _ => n\n        end)\n  match Z.compare (to_Z n) (to_Z m) with\n  | Gt => to_Z m\n  | _ => to_Z n\n  end",
                    "c2_n : True",
                    "c2_m : True"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c6_goal : Logic.eq (to_Z n) (to_Z n)",
                    "c7_goal : Logic.eq (to_Z m) (to_Z m)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z n) (to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z n) (to_Z n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z m) (to_Z m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mul_fold",
        "proof": [
            {
                "tactic_sig": "Lemma mul_fold : mul = mul_folded .",
                "tactic_sig_no_out_arg": "Lemma mul_fold : mul = mul_folded .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq mul\n  (iter_sym t\n     (fun n : nat =>\n      let mul_c := ZnZ.mul_c in\n      fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y))) wn_mul\n     mulnm (fun x : t => x))"
                ]
            },
            {
                "tactic_sig": "lazy beta iota delta [ iter_sym dom_op dom_t reduce succ_t extend zeron wn_mul DoubleMul.w_mul_add mk_t_w' ] .",
                "tactic_sig_no_out_arg": "lazy beta iota delta [ iter_sym dom_op dom_t reduce succ_t extend zeron wn_mul DoubleMul.w_mul_add mk_t_w' ] .",
                "tactic_args": [
                    "c1_goal : Logic.eq mul\n  (iter_sym t\n     (fun n : nat =>\n      let mul_c := ZnZ.mul_c in\n      fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y))) wn_mul\n     mulnm (fun x : t => x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq mul\n  (let f0 :=\n     let mul_c := ZnZ.mul_c in fun x y : W0.t => reduce_1 (mul_c x y)\n     in\n   let f1 :=\n     let mul_c := ZnZ.mul_c in fun x y : w1 => reduce_2 (mul_c x y) in\n   let f2 :=\n     let mul_c := ZnZ.mul_c in fun x y : w2 => reduce_3 (mul_c x y) in\n   let f3 :=\n     let mul_c := ZnZ.mul_c in fun x y : w3 => reduce_4 (mul_c x y) in\n   let f4 :=\n     let mul_c := ZnZ.mul_c in fun x y : w4 => reduce_5 (mul_c x y) in\n   let f5 :=\n     let mul_c := ZnZ.mul_c in fun x y : w5 => reduce_6 (mul_c x y) in\n   let f6 :=\n     let mul_c := ZnZ.mul_c in fun x y : w6 => reduce_n 0 (mul_c x y)\n     in\n   let fn0 :=\n     let op := W0.ops in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : W0.t =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_0w m r\n     else mk_t_0w (S m) (WW (DoubleBase.extend_aux m (WW zero0 w)) r)\n     in\n   let fn1 :=\n     let op := w1_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w1 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_1w m r\n     else mk_t_1w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn2 :=\n     let op := w2_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w2 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_2w m r\n     else mk_t_2w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn3 :=\n     let op := w3_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w3 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_3w m r\n     else mk_t_3w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn4 :=\n     let op := w4_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w4 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_4w m r\n     else mk_t_4w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn5 :=\n     let op := w5_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w5 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_5w m r\n     else mk_t_5w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn6 :=\n     let op := w6_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w6 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then Nn m r\n     else Nn (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => fn0 0%nat wy wx\n       | N2 wy => fn0 1%nat wy wx\n       | N3 wy => fn0 2%nat wy wx\n       | N4 wy => fn0 3%nat wy wx\n       | N5 wy => fn0 4%nat wy wx\n       | N6 wy => fn0 5%nat wy wx\n       | Nn m wy =>\n           fn6 m wy\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => fn1 0%nat wy wx\n       | N3 wy => fn1 1%nat wy wx\n       | N4 wy => fn1 2%nat wy wx\n       | N5 wy => fn1 3%nat wy wx\n       | N6 wy => fn1 4%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx)))))\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => fn2 0%nat wy wx\n       | N4 wy => fn2 1%nat wy wx\n       | N5 wy => fn2 2%nat wy wx\n       | N6 wy => fn2 3%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 wx))))\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => fn3 0%nat wy wx\n       | N5 wy => fn3 1%nat wy wx\n       | N6 wy => fn3 2%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 wx)))\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => fn4 0%nat wy wx\n       | N6 wy => fn4 1%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 wx))\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => fn5 0%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 wx)\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn6 m wy wx\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => mulnm n m wx wy\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq mul\n  (let f0 :=\n     let mul_c := ZnZ.mul_c in fun x y : W0.t => reduce_1 (mul_c x y)\n     in\n   let f1 :=\n     let mul_c := ZnZ.mul_c in fun x y : w1 => reduce_2 (mul_c x y) in\n   let f2 :=\n     let mul_c := ZnZ.mul_c in fun x y : w2 => reduce_3 (mul_c x y) in\n   let f3 :=\n     let mul_c := ZnZ.mul_c in fun x y : w3 => reduce_4 (mul_c x y) in\n   let f4 :=\n     let mul_c := ZnZ.mul_c in fun x y : w4 => reduce_5 (mul_c x y) in\n   let f5 :=\n     let mul_c := ZnZ.mul_c in fun x y : w5 => reduce_6 (mul_c x y) in\n   let f6 :=\n     let mul_c := ZnZ.mul_c in fun x y : w6 => reduce_n 0 (mul_c x y)\n     in\n   let fn0 :=\n     let op := W0.ops in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : W0.t =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_0w m r\n     else mk_t_0w (S m) (WW (DoubleBase.extend_aux m (WW zero0 w)) r)\n     in\n   let fn1 :=\n     let op := w1_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w1 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_1w m r\n     else mk_t_1w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn2 :=\n     let op := w2_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w2 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_2w m r\n     else mk_t_2w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn3 :=\n     let op := w3_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w3 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_3w m r\n     else mk_t_3w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn4 :=\n     let op := w4_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w4 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_4w m r\n     else mk_t_4w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn5 :=\n     let op := w5_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w5 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then mk_t_5w m r\n     else mk_t_5w (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   let fn6 :=\n     let op := w6_op in\n     let zero := ZnZ.zero in\n     let succ := ZnZ.succ in\n     let add_c := ZnZ.add_c in\n     let mul_c := ZnZ.mul_c in\n     let ww := ZnZ.WW in\n     let ow := ZnZ.OW in\n     let eq0 := ZnZ.eq0 in\n     let mul_add :=\n       fun x y r : w6 =>\n       match mul_c x y with\n       | W0 => pair zero r\n       | WW h l =>\n           match add_c l r with\n           | CarryType.C0 lr => pair h lr\n           | CarryType.C1 lr => pair (succ h) lr\n           end\n       end in\n     let mul_add_n1 := DoubleMul.double_mul_add_n1 zero ww ow mul_add\n       in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     let (w, r) := mul_add_n1 (S m) x y zero in\n     if eq0 w\n     then Nn m r\n     else Nn (S m) (WW (DoubleBase.extend_aux m (WW W0 w)) r) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => fn0 0%nat wy wx\n       | N2 wy => fn0 1%nat wy wx\n       | N3 wy => fn0 2%nat wy wx\n       | N4 wy => fn0 3%nat wy wx\n       | N5 wy => fn0 4%nat wy wx\n       | N6 wy => fn0 5%nat wy wx\n       | Nn m wy =>\n           fn6 m wy\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => fn1 0%nat wy wx\n       | N3 wy => fn1 1%nat wy wx\n       | N4 wy => fn1 2%nat wy wx\n       | N5 wy => fn1 3%nat wy wx\n       | N6 wy => fn1 4%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx)))))\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => fn2 0%nat wy wx\n       | N4 wy => fn2 1%nat wy wx\n       | N5 wy => fn2 2%nat wy wx\n       | N6 wy => fn2 3%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 (WW W0 wx))))\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => fn3 0%nat wy wx\n       | N5 wy => fn3 1%nat wy wx\n       | N6 wy => fn3 2%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 (WW W0 wx)))\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => fn4 0%nat wy wx\n       | N6 wy => fn4 1%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 (WW W0 wx))\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => fn5 0%nat wy wx\n       | Nn m wy => fn6 m wy (WW W0 wx)\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn6 m wy wx\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => mulnm n m wx wy\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_muln",
        "proof": [
            {
                "tactic_sig": "Lemma spec_muln : forall n ( x : word _ ( S n ) ) y , [ Nn ( S n ) ( ZnZ.mul_c ( Ops := make_op n ) x y ) ] = [ Nn n x ] * [ Nn n y ] .",
                "tactic_sig_no_out_arg": "Lemma spec_muln : forall n ( x : word _ ( S n ) ) y , [ Nn ( S n ) ( ZnZ.mul_c ( Ops := make_op n ) x y ) ] = [ Nn n x ] * [ Nn n y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x y : word w6 (S n)),\nLogic.eq (to_Z (Nn (S n) (ZnZ.mul_c x y)))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn n y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x y : word w6 (S n)),\nLogic.eq (to_Z (Nn (S n) (ZnZ.mul_c x y)))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn n y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (Nn (S n) (ZnZ.mul_c x y)))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn n y)))",
                    "c2_n : nat",
                    "c2_x : word w6 (S n)",
                    "c2_y : word w6 (S n)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (Nn (S n) (ZnZ.mul_c x y)))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn n y)))",
                    "_global_to_Z : forall _ : t, Z"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (ZnZ.to_Z (ZnZ.mul_c x y)) (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (ZnZ.to_Z (ZnZ.mul_c x y)) (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_mul_c : forall x0 y0 : word w6 (S ?n),\n       Logic.eq\n         (zn2z_to_Z (base (ZnZ.digits (make_op ?n))) ZnZ.to_Z\n            (ZnZ.mul_c x0 y0)) (Z.mul (ZnZ.to_Z x0) (ZnZ.to_Z y0))\nwhere\n?n : [n : nat  x : word w6 (S n)  y : word w6 (S n) |- nat]"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (ZnZ.mul_c x y))\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z (ZnZ.mul_c x y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_global_make_op_S : forall n : nat,\n       Logic.eq (make_op (S n))\n         (DoubleCyclic.mk_zn2z_ops_karatsuba (make_op n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ZnZ.mul_c .",
                "tactic_sig_no_out_arg": "case ZnZ.mul_c .",
                "tactic_args": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (ZnZ.mul_c x y))\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z (ZnZ.mul_c x y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (ZnZ.to_Z W0)\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z W0)",
                    "c6_goal : forall w w0 : word w6 (S n),\nLogic.eq (ZnZ.to_Z (WW w w0))\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z (WW w w0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (ZnZ.to_Z W0)\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z W0)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall w w0 : word w6 (S n),\nLogic.eq (ZnZ.to_Z (WW w w0))\n  (zn2z_to_Z (base (ZnZ.digits (make_op n))) ZnZ.to_Z (WW w w0))",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul_add_n1",
        "proof": [
            {
                "tactic_sig": "Lemma spec_mul_add_n1 : forall n m x y z , let ( q , r ) := DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW ( DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c ) ( S m ) x y z in ZnZ.to_Z q * ( base ( ZnZ.digits ( nmake_op _ ( dom_op n ) ( S m ) ) ) ) + eval n ( S m ) r = eval n ( S m ) x * ZnZ.to_Z y + ZnZ.to_Z z .",
                "tactic_sig_no_out_arg": "Lemma spec_mul_add_n1 : forall n m x y z , let ( q , r ) := DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW ( DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c ) ( S m ) x y z in ZnZ.to_Z q * ( base ( ZnZ.digits ( nmake_op _ ( dom_op n ) ( S m ) ) ) ) + eval n ( S m ) r = eval n ( S m ) x * ZnZ.to_Z y + ZnZ.to_Z z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y z : dom_t n),\nlet (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y z .",
                "tactic_args": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y z : dom_t n),\nlet (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))"
                ],
                "tactic_res": [
                    "c2_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_x : word (dom_t n) (S m)",
                    "c2_y : dom_t n",
                    "c2_z : dom_t n"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))",
                    "_global_digits_nmake : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq (ZnZ.digits (nmake_op ww w_op n))\n         (Pos.shiftl_nat (ZnZ.digits w_op) n)"
                ],
                "tactic_res": [
                    "c3_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))",
                    "_global_eval : forall (n m : nat) (_ : word (dom_t n) m), Z"
                ],
                "tactic_res": [
                    "c4_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (ZnZ.to_Z r))\n  (Z.add (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y)) (ZnZ.to_Z z))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (ZnZ.to_Z r))\n  (Z.add (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y)) (ZnZ.to_Z z))",
                    "_global_nmake_double : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq ZnZ.to_Z\n         (DoubleBase.double_to_Z (ZnZ.digits w_op) ZnZ.to_Z n)"
                ],
                "tactic_res": [
                    "c5_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) r))\n  (Z.add\n     (Z.mul\n        (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z \n           (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : let (q, r) :=\n  DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n    (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c) \n    (S m) x y z in\nLogic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (Pos.shiftl_nat (ZnZ.digits (dom_op n)) (S m))))\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) r))\n  (Z.add\n     (Z.mul\n        (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z \n           (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z z))",
                    "_global_DoubleMul.spec_double_mul_add_n1 : forall (w : DoubleBase.univ_of_cycles) (w_0 : w)\n         (w_WW : forall (_ : w) (_ : w), zn2z w)\n         (w_0W : forall _ : w, zn2z w) (w_digits : positive)\n         (w_to_Z : forall _ : w, Z) (_ : Logic.eq (w_to_Z w_0) 0)\n         (_ : forall h l : w,\n              Logic.eq (DoubleBase.ww_to_Z w_digits w_to_Z (w_WW h l))\n                (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l)))\n         (_ : forall l : w,\n              Logic.eq (DoubleBase.ww_to_Z w_digits w_to_Z (w_0W l))\n                (w_to_Z l))\n         (w_mul_add : forall (_ : w) (_ : w) (_ : w), prod w w)\n         (_ : forall x y r : w,\n              let (h, l) := w_mul_add x y r in\n              Logic.eq (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n                (Z.add (Z.mul (w_to_Z x) (w_to_Z y)) (w_to_Z r))) \n         (n : nat) (x : word w n) (y r : w),\n       let (h, l) :=\n         DoubleMul.double_mul_add_n1 w_0 w_WW w_0W w_mul_add n x y r in\n       Logic.eq\n         (Z.add (Z.mul (w_to_Z h) (DoubleBase.double_wB w_digits n))\n            (DoubleBase.double_to_Z w_digits w_to_Z n l))\n         (Z.add\n            (Z.mul (DoubleBase.double_to_Z w_digits w_to_Z n x) (w_to_Z y))\n            (w_to_Z r))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0",
                    "c7_goal : forall h l : dom_t n,\nLogic.eq\n  (DoubleBase.ww_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (ZnZ.WW h l))\n  (Z.add (Z.mul (ZnZ.to_Z h) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z l))",
                    "c8_goal : forall l : dom_t n,\nLogic.eq\n  (DoubleBase.ww_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (ZnZ.OW l))\n  (ZnZ.to_Z l)",
                    "c9_goal : forall x y r : dom_t n,\nlet (h, l) :=\n  DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c x y r in\nLogic.eq\n  (Z.add (Z.mul (ZnZ.to_Z h) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z l))\n  (Z.add (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y)) (ZnZ.to_Z r))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0",
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat  m : nat  x : word (dom_t n) (S m)  y : dom_t n  z : dom_t n\n     |- nat]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_WW .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_WW .",
                "tactic_args": [
                    "c7_goal : forall h l : dom_t n,\nLogic.eq\n  (DoubleBase.ww_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (ZnZ.WW h l))\n  (Z.add (Z.mul (ZnZ.to_Z h) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z l))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_OW .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_OW .",
                "tactic_args": [
                    "c8_goal : forall l : dom_t n,\nLogic.eq\n  (DoubleBase.ww_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (ZnZ.OW l))\n  (ZnZ.to_Z l)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : forall x y r : dom_t n,\nlet (h, l) :=\n  DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c x y r in\nLogic.eq\n  (Z.add (Z.mul (ZnZ.to_Z h) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z l))\n  (Z.add (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y)) (ZnZ.to_Z r))",
                    "_global_DoubleCyclic.spec_mul_add : forall x y z : word w6 (S ?n),\n       let (zh, zl) := DoubleCyclic.mul_add x y z in\n       Logic.eq\n         (zn2z_to_Z (base (ZnZ.digits (make_op ?n))) ZnZ.to_Z (WW zh zl))\n         (Z.add (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y)) (ZnZ.to_Z z))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_wn_mul",
        "proof": [
            {
                "tactic_sig": "Lemma spec_wn_mul : forall n m x y , [ wn_mul n m x y ] = ( eval n ( S m ) x ) * ZnZ.to_Z y .",
                "tactic_sig_no_out_arg": "Lemma spec_wn_mul : forall n m x y , [ wn_mul n m x y ] = ( eval n ( S m ) x ) * ZnZ.to_Z y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_x : word (dom_t n) (S m)",
                    "c2_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_wn_mul : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n), t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (let (w, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      if ZnZ.eq0 w\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m w) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_mul_add_n1 _i _i _i _i ZnZ.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_mul_add_n1 _i _i _i _i ZnZ.zero ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (let (w, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      if ZnZ.eq0 w\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m w) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_x : word (dom_t n) (S m)",
                    "c2_y : dom_t n"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : let (q, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      Logic.eq\n        (Z.add\n           (Z.mul (ZnZ.to_Z q)\n              (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n           (eval n (S m) r))\n        (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y))\n           (ZnZ.to_Z ZnZ.zero)),\nLogic.eq\n  (to_Z\n     (let (w, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      if ZnZ.eq0 w\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m w) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "case DoubleMul.double_mul_add_n1 .",
                "tactic_sig_no_out_arg": "case DoubleMul.double_mul_add_n1 .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : let (q, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      Logic.eq\n        (Z.add\n           (Z.mul (ZnZ.to_Z q)\n              (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n           (eval n (S m) r))\n        (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y))\n           (ZnZ.to_Z ZnZ.zero)),\nLogic.eq\n  (to_Z\n     (let (w, r) :=\n        DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW\n          (DoubleMul.w_mul_add ZnZ.zero ZnZ.succ ZnZ.add_c ZnZ.mul_c)\n          (S m) x y ZnZ.zero in\n      if ZnZ.eq0 w\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m w) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall (d : dom_t n) (w : word (dom_t n) (S m))\n  (_ : Logic.eq\n         (Z.add\n            (Z.mul (ZnZ.to_Z d)\n               (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n            (eval n (S m) w))\n         (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y))\n            (ZnZ.to_Z ZnZ.zero))),\nLogic.eq\n  (to_Z\n     (if ZnZ.eq0 d\n      then mk_t_w' n m w\n      else mk_t_w' n (S m) (WW (extend n m d) w)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros q r Hqr .",
                "tactic_args": [
                    "c5_goal : forall (d : dom_t n) (w : word (dom_t n) (S m))\n  (_ : Logic.eq\n         (Z.add\n            (Z.mul (ZnZ.to_Z d)\n               (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n            (eval n (S m) w))\n         (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y))\n            (ZnZ.to_Z ZnZ.zero))),\nLogic.eq\n  (to_Z\n     (if ZnZ.eq0 d\n      then mk_t_w' n m w\n      else mk_t_w' n (S m) (WW (extend n m d) w)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "c6_q : dom_t n",
                    "c6_r : word (dom_t n) (S m)",
                    "c6_Hqr : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z ZnZ.zero))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i in _i .",
                "tactic_args": [
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat\n      m : nat\n      x : word (dom_t n) (S m)\n      y : dom_t n\n      q : dom_t n\n      r : word (dom_t n) (S m)\n      Hqr : Logic.eq\n              (Z.add\n                 (Z.mul (ZnZ.to_Z q)\n                    (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n                 (eval n (S m) r)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))\n     |- nat]",
                    "_global_Z.add_0_r : forall n : Z, Logic.eq (Z.add n 0) n",
                    "c6_Hqr : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))\n  (Z.add (Z.mul (eval n (S m) x) (ZnZ.to_Z y)) (ZnZ.to_Z ZnZ.zero))"
                ],
                "tactic_res": [
                    "c6_Hqr : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "c6_Hqr : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_eq0 _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_eq0 _i ) .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c6_q : dom_t n"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  _ : forall _ : Logic.eq (ZnZ.eq0 q) true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.eq0 .",
                "tactic_sig_no_out_arg": "case ZnZ.eq0 .",
                "tactic_args": [
                    "c8_goal : forall\n  _ : forall _ : Logic.eq (ZnZ.eq0 q) true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq\n  (to_Z\n     (if ZnZ.eq0 q\n      then mk_t_w' n m r\n      else mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : forall _ : Logic.eq true true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c10_goal : forall _ : forall _ : Logic.eq false true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq (to_Z (mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c9_goal : forall _ : forall _ : Logic.eq true true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c11_HH : forall _ : Logic.eq true true, Logic.eq (ZnZ.to_Z q) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c10_goal : forall _ : forall _ : Logic.eq false true, Logic.eq (ZnZ.to_Z q) 0,\nLogic.eq (to_Z (mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (to_Z (mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c12_HH : forall _ : Logic.eq false true, Logic.eq (ZnZ.to_Z q) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c11_HH : forall _ : Logic.eq true true, Logic.eq (ZnZ.to_Z q) 0"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul 0 (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c14_goal : Logic.eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Logic.eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z (mk_t_w' n m r))\n  (Z.add\n     (Z.mul 0 (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (to_Z (mk_t_w' n m r)) (eval n (S m) r)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (to_Z (mk_t_w' n m r)) (eval n (S m) r)",
                    "_global_spec_mk_t_w' : forall (n m : nat) (x : word (dom_t n) (S m)),\n       Logic.eq (to_Z (mk_t_w' n m x)) (eval n (S m) x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (to_Z (mk_t_w' n (S m) (WW (extend n m q) r)))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "_global_spec_mk_t_w' : forall (n m : nat) (x : word (dom_t n) (S m)),\n       Logic.eq (to_Z (mk_t_w' n m x)) (eval n (S m) x)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (eval n (S (S m)) (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))"
                ]
            },
            {
                "tactic_sig": "set ( m' := S _i ) in * .",
                "tactic_sig_no_out_arg": "set ( m' := S _i ) in * .",
                "tactic_args": [
                    "c16_goal : Logic.eq (eval n (S (S m)) (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) (S m)))))\n     (eval n (S m) r))",
                    "c2_m : nat"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (eval n (S m') (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (eval n m' r))",
                    "c17_r : word (dom_t n) m'",
                    "c17_m' : nat"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq (eval n (S m') (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (eval n m' r))",
                    "_global_eval : forall (n m : nat) (_ : word (dom_t n) m), Z"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (ZnZ.to_Z (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq (ZnZ.to_Z (WW (extend n m q) r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))",
                    "_global_nmake_WW : forall (ww : DoubleBase.univ_of_cycles) (ww_op : ZnZ.Ops ww) \n         (n : nat)\n         (xh\n          xl : (fix word (w : Set) (n0 : nat) {struct n0} : Set :=\n                  match n0 with\n                  | 0%nat => w\n                  | S n1 => zn2z (word w n1)\n                  end) ww n),\n       Logic.eq (ZnZ.to_Z (WW xh xl))\n         (Z.add\n            (Z.mul (ZnZ.to_Z xh) (base (ZnZ.digits (nmake_op ww ww_op n))))\n            (ZnZ.to_Z xl))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z (extend n m q))\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.add\n     (Z.mul (ZnZ.to_Z (extend n m q))\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))\n  (Z.add\n     (Z.mul (ZnZ.to_Z q)\n        (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n     (ZnZ.to_Z r))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq\n  (Z.mul (ZnZ.to_Z (extend n m q))\n     (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n  (Z.mul (ZnZ.to_Z q)\n     (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c20_goal : Logic.eq\n  (Z.mul (ZnZ.to_Z (extend n m q))\n     (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))\n  (Z.mul (ZnZ.to_Z q)\n     (base (ZnZ.digits (nmake_op (dom_t n) (dom_op n) m'))))"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (ZnZ.to_Z (extend n m q)) (ZnZ.to_Z q)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c21_goal : Logic.eq (ZnZ.to_Z (extend n m q)) (ZnZ.to_Z q)",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (ZnZ.to_Z (extend n m q)) (to_Z (mk_t n q))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c22_goal : Logic.eq (ZnZ.to_Z (extend n m q)) (to_Z (mk_t n q))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq (to_Z (mk_t n q)) (ZnZ.to_Z (extend n m q))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : Logic.eq (to_Z (mk_t n q)) (ZnZ.to_Z (extend n m q))",
                    "_global_spec_extend : forall (n m : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (eval n (S m) (extend n m x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mul",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mul : forall x y , [ mul x y ] = [ x ] * [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mul : forall x y , [ mul x y ] = [ x ] * [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))",
                    "_global_mul_fold : Logic.eq mul\n         (iter_sym t\n            (fun n : nat =>\n             let mul_c := ZnZ.mul_c in\n             fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y))) wn_mul\n            mulnm (fun x : t => x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_sym t\n        (fun n : nat =>\n         let mul_c := ZnZ.mul_c in\n         fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y)))\n        wn_mul mulnm (fun x : t => x) x y)) (Z.mul (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_sym t\n        (fun n : nat =>\n         let mul_c := ZnZ.mul_c in\n         fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y)))\n        wn_mul mulnm (fun x : t => x) x y)) (Z.mul (to_Z x) (to_Z y))",
                    "_global_spec_iter_sym : forall (res : Type) (P : forall (_ : Z) (_ : Z) (_ : res), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y))\n         (fg : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n),\n               res)\n         (_ : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n              P (eval n (S m) x) (ZnZ.to_Z y) (fg n m x y))\n         (fnm : forall (n m : nat) (_ : word (dom_t 6) (S n))\n                  (_ : word (dom_t 6) (S m)), res)\n         (_ : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\n              P (to_Z (Nn n x)) (to_Z (Nn m y)) (fnm n m x y))\n         (opp : forall _ : res, res)\n         (_ : forall (u v : Z) (r : res) (_ : P u v r), P v u (opp r))\n         (x y : t), P (to_Z x) (to_Z y) (iter_sym res f fg fnm opp x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let mul_c := ZnZ.mul_c in\n       fun x0 y0 : dom_t n => reduce (S n) (succ_t n (mul_c x0 y0))) x\n        y)) (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "c6_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\nLogic.eq (to_Z (mulnm n m x y)) (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "c7_goal : forall (u v : Z) (r : t) (_ : Logic.eq (to_Z r) (Z.mul u v)),\nLogic.eq (to_Z r) (Z.mul v u)"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let mul_c := ZnZ.mul_c in\n       fun x0 y0 : dom_t n => reduce (S n) (succ_t n (mul_c x0 y0))) x\n        y)) (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     ((let mul_c := ZnZ.mul_c in\n       fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y))) x y))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c8_n : nat",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "cbv zeta beta .",
                "tactic_sig_no_out_arg": "cbv zeta beta .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     ((let mul_c := ZnZ.mul_c in\n       fun x y : dom_t n => reduce (S n) (succ_t n (mul_c x y))) x y))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Z (reduce (S n) (succ_t n (ZnZ.mul_c x y))))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , <- _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z (reduce (S n) (succ_t n (ZnZ.mul_c x y))))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)",
                    "_global_spec_succ_t : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (ZnZ.to_Z (succ_t n x))\n         (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z x)",
                    "_global_ZnZ.spec_mul_c : forall x0 y0 : word w6 (S ?n),\n       Logic.eq\n         (zn2z_to_Z (base (ZnZ.digits (make_op ?n))) ZnZ.to_Z\n            (ZnZ.mul_c x0 y0)) (Z.mul (ZnZ.to_Z x0) (ZnZ.to_Z y0))\nwhere\n?n : [n : nat  x : dom_t n  y : dom_t n |- nat]"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.mul_c x y))\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.mul_c x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.mul_c x y))\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.mul_c x y))",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\nLogic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_spec_wn_mul : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n       Logic.eq (to_Z (wn_mul n m x y)) (Z.mul (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y .",
                "tactic_args": [
                    "c6_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\nLogic.eq (to_Z (mulnm n m x y)) (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (to_Z (mulnm n m x y)) (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "c11_n : nat",
                    "c11_m : nat",
                    "c11_x : word w6 (S n)",
                    "c11_y : word w6 (S m)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z (mulnm n m x y)) (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_mulnm : forall (n m : nat) (_ : word w6 (S n)) (_ : word w6 (S m)), t'"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (to_Z\n     (reduce_n (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (to_Z\n     (reduce_n (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_spec_reduce_n : forall (n : nat) (x : word w6 (S n)),\n       Logic.eq (to_Z (reduce_n n x)) (to_Z (Nn n x))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (to_Z\n     (Nn (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (to_Z\n     (Nn (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c11_n : nat",
                    "c11_m : nat",
                    "c11_x : word w6 (S n)",
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c11_n : nat",
                    "c11_m : nat",
                    "c11_y : word w6 (S m)"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (to_Z\n     (Nn (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (to_Z\n     (Nn (S (Nat.max n m))\n        (ZnZ.mul_c (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.mul\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))",
                    "_global_spec_muln : forall (n : nat) (x y : word w6 (S n)),\n       Logic.eq (to_Z (Nn (S n) (ZnZ.mul_c x y)))\n         (Z.mul (to_Z (Nn n x)) (to_Z (Nn n y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (u v : Z) (r : t) (_ : Logic.eq (to_Z r) (Z.mul u v)),\nLogic.eq (to_Z r) (Z.mul v u)"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (to_Z r) (Z.mul v u)",
                    "c15_u : Z",
                    "c15_v : Z",
                    "c15_r : True",
                    "c15_H : Logic.eq (to_Z r) (Z.mul u v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (to_Z r) (Z.mul v u)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (to_Z r) (Z.mul u v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Logic.eq (to_Z r) (Z.mul u v)",
                    "c15_H : Logic.eq (to_Z r) (Z.mul u v)",
                    "c15_r : True",
                    "c15_u : Z",
                    "c15_v : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_gt_fold",
        "proof": [
            {
                "tactic_sig": "Lemma div_gt_fold : div_gt = div_gt_folded .",
                "tactic_sig_no_out_arg": "Lemma div_gt_fold : div_gt = div_gt_folded .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq div_gt\n  (iter (prod t t)\n     (fun n : nat =>\n      let div_gt := ZnZ.div_gt in\n      fun x y : dom_t n =>\n      let (u, v) := div_gt x y in pair (reduce n u) (reduce n v))\n     (fun n : nat =>\n      let div_gt := ZnZ.div_gt in\n      fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n      let y' := DoubleBase.get_low (zeron n) (S m) y in\n      let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v))\n     wn_divn1 div_gtnm)"
                ]
            },
            {
                "tactic_sig": "lazy beta iota delta [ iter dom_op dom_t reduce zeron wn_divn1 mk_t_w' mk_t ] .",
                "tactic_sig_no_out_arg": "lazy beta iota delta [ iter dom_op dom_t reduce zeron wn_divn1 mk_t_w' mk_t ] .",
                "tactic_args": [
                    "c1_goal : Logic.eq div_gt\n  (iter (prod t t)\n     (fun n : nat =>\n      let div_gt := ZnZ.div_gt in\n      fun x y : dom_t n =>\n      let (u, v) := div_gt x y in pair (reduce n u) (reduce n v))\n     (fun n : nat =>\n      let div_gt := ZnZ.div_gt in\n      fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n      let y' := DoubleBase.get_low (zeron n) (S m) y in\n      let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v))\n     wn_divn1 div_gtnm)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq div_gt\n  (let f0 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : W0.t =>\n     let (u, v) := div_gt x y in pair (reduce_0 u) (reduce_0 v) in\n   let f1 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w1 =>\n     let (u, v) := div_gt x y in pair (reduce_1 u) (reduce_1 v) in\n   let f2 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w2 =>\n     let (u, v) := div_gt x y in pair (reduce_2 u) (reduce_2 v) in\n   let f3 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w3 =>\n     let (u, v) := div_gt x y in pair (reduce_3 u) (reduce_3 v) in\n   let f4 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w4 =>\n     let (u, v) := div_gt x y in pair (reduce_4 u) (reduce_4 v) in\n   let f5 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w5 =>\n     let (u, v) := div_gt x y in pair (reduce_5 u) (reduce_5 v) in\n   let f6 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w6 =>\n     let (u, v) := div_gt x y in pair (reduce_6 u) (reduce_6 v) in\n   let f0n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : W0.t) (y : word W0.t (S m)) =>\n     let y' := DoubleBase.get_low zero0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_0 u) (reduce_0 v) in\n   let fn0 :=\n     let op := W0.ops in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_0w m u) (N0 v) in\n   let f1n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w1) (y : word w1 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_1 u) (reduce_1 v) in\n   let fn1 :=\n     let op := w1_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_1w m u) (N1 v) in\n   let f2n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w2) (y : word w2 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_2 u) (reduce_2 v) in\n   let fn2 :=\n     let op := w2_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_2w m u) (N2 v) in\n   let f3n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w3) (y : word w3 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_3 u) (reduce_3 v) in\n   let fn3 :=\n     let op := w3_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_3w m u) (N3 v) in\n   let f4n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w4) (y : word w4 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_4 u) (reduce_4 v) in\n   let fn4 :=\n     let op := w4_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_4w m u) (N4 v) in\n   let f5n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w5) (y : word w5 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_5 u) (reduce_5 v) in\n   let fn5 :=\n     let op := w5_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_5w m u) (N5 v) in\n   let f6n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w6) (y : word w6 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_6 u) (reduce_6 v) in\n   let fn6 :=\n     let op := w6_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     let (u, v) := ddivn1 (S m) x y in pair (Nn m u) (N6 v) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f0n 0%nat wx wy\n       | N2 wy => f0n 1%nat wx wy\n       | N3 wy => f0n 2%nat wx wy\n       | N4 wy => f0n 3%nat wx wy\n       | N5 wy => f0n 4%nat wx wy\n       | N6 wy => f0n 5%nat wx wy\n       | Nn m wy =>\n           f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => f1n 0%nat wx wy\n       | N3 wy => f1n 1%nat wx wy\n       | N4 wy => f1n 2%nat wx wy\n       | N5 wy => f1n 3%nat wx wy\n       | N6 wy => f1n 4%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => f2n 0%nat wx wy\n       | N4 wy => f2n 1%nat wx wy\n       | N5 wy => f2n 2%nat wx wy\n       | N6 wy => f2n 3%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => f3n 0%nat wx wy\n       | N5 wy => f3n 1%nat wx wy\n       | N6 wy => f3n 2%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 wx))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => f4n 0%nat wx wy\n       | N6 wy => f4n 1%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 wx)) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => f5n 0%nat wx wy\n       | Nn m wy => f6n m (WW W0 wx) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => f6n m wx wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => div_gtnm n m wx wy\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq div_gt\n  (let f0 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : W0.t =>\n     let (u, v) := div_gt x y in pair (reduce_0 u) (reduce_0 v) in\n   let f1 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w1 =>\n     let (u, v) := div_gt x y in pair (reduce_1 u) (reduce_1 v) in\n   let f2 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w2 =>\n     let (u, v) := div_gt x y in pair (reduce_2 u) (reduce_2 v) in\n   let f3 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w3 =>\n     let (u, v) := div_gt x y in pair (reduce_3 u) (reduce_3 v) in\n   let f4 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w4 =>\n     let (u, v) := div_gt x y in pair (reduce_4 u) (reduce_4 v) in\n   let f5 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w5 =>\n     let (u, v) := div_gt x y in pair (reduce_5 u) (reduce_5 v) in\n   let f6 :=\n     let div_gt := ZnZ.div_gt in\n     fun x y : w6 =>\n     let (u, v) := div_gt x y in pair (reduce_6 u) (reduce_6 v) in\n   let f0n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : W0.t) (y : word W0.t (S m)) =>\n     let y' := DoubleBase.get_low zero0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_0 u) (reduce_0 v) in\n   let fn0 :=\n     let op := W0.ops in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_0w m u) (N0 v) in\n   let f1n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w1) (y : word w1 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_1 u) (reduce_1 v) in\n   let fn1 :=\n     let op := w1_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_1w m u) (N1 v) in\n   let f2n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w2) (y : word w2 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_2 u) (reduce_2 v) in\n   let fn2 :=\n     let op := w2_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_2w m u) (N2 v) in\n   let f3n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w3) (y : word w3 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_3 u) (reduce_3 v) in\n   let fn3 :=\n     let op := w3_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_3w m u) (N3 v) in\n   let f4n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w4) (y : word w4 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_4 u) (reduce_4 v) in\n   let fn4 :=\n     let op := w4_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_4w m u) (N4 v) in\n   let f5n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w5) (y : word w5 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_5 u) (reduce_5 v) in\n   let fn5 :=\n     let op := w5_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     let (u, v) := ddivn1 (S m) x y in pair (mk_t_5w m u) (N5 v) in\n   let f6n :=\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : w6) (y : word w6 (S m)) =>\n     let y' := DoubleBase.get_low W0 (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce_6 u) (reduce_6 v) in\n   let fn6 :=\n     let op := w6_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let ww := ZnZ.WW in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let ddivn1 :=\n       DoubleDivn1.double_divn1 zd zero ww head0 add_mul_div div21\n         compare sub in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     let (u, v) := ddivn1 (S m) x y in pair (Nn m u) (N6 v) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f0n 0%nat wx wy\n       | N2 wy => f0n 1%nat wx wy\n       | N3 wy => f0n 2%nat wx wy\n       | N4 wy => f0n 3%nat wx wy\n       | N5 wy => f0n 4%nat wx wy\n       | N6 wy => f0n 5%nat wx wy\n       | Nn m wy =>\n           f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => f1n 0%nat wx wy\n       | N3 wy => f1n 1%nat wx wy\n       | N4 wy => f1n 2%nat wx wy\n       | N5 wy => f1n 3%nat wx wy\n       | N6 wy => f1n 4%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => f2n 0%nat wx wy\n       | N4 wy => f2n 1%nat wx wy\n       | N5 wy => f2n 2%nat wx wy\n       | N6 wy => f2n 3%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => f3n 0%nat wx wy\n       | N5 wy => f3n 1%nat wx wy\n       | N6 wy => f3n 2%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 wx))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => f4n 0%nat wx wy\n       | N6 wy => f4n 1%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 wx)) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => f5n 0%nat wx wy\n       | Nn m wy => f6n m (WW W0 wx) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => f6n m wx wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => div_gtnm n m wx wy\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_get_endn",
        "proof": [
            {
                "tactic_sig": "Lemma spec_get_endn : forall n m x y , eval n m x <= [ mk_t n y ] -> [ mk_t n ( DoubleBase.get_low ( zeron n ) m x ) ] = eval n m x .",
                "tactic_sig_no_out_arg": "Lemma spec_get_endn : forall n m x y , eval n m x <= [ mk_t n y ] -> [ mk_t n ( DoubleBase.get_low ( zeron n ) m x ) ] = eval n m x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) m) (y : dom_t n)\n  (_ : Z.le (eval n m x) (to_Z (mk_t n y))),\nLogic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (eval n m x)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H .",
                "tactic_args": [
                    "c1_goal : forall (n m : nat) (x : word (dom_t n) m) (y : dom_t n)\n  (_ : Z.le (eval n m x) (to_Z (mk_t n y))),\nLogic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (eval n m x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (eval n m x)",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_x : word (dom_t n) m",
                    "c2_y : dom_t n",
                    "c2_H : Z.le (eval n m x) (to_Z (mk_t n y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (eval n m x)",
                    "_global_eval : forall (n m : nat) (_ : word (dom_t n) m), Z"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (ZnZ.to_Z x)",
                    "_global_nmake_double : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq ZnZ.to_Z\n         (DoubleBase.double_to_Z (ZnZ.digits w_op) ZnZ.to_Z n)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) m x))\n  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)",
                    "c5_H : Z.le (eval n m x) (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) m x))\n  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)",
                    "_global_DoubleBase.spec_get_low : forall (w : DoubleBase.univ_of_cycles) (w_0 : w) \n         (w_digits : positive) (w_to_Z : forall _ : w, Z)\n         (_ : Logic.eq (w_to_Z w_0) 0)\n         (_ : forall x : w,\n              and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits)))\n         (n : nat) (x : word w n)\n         (_ : Z.lt (DoubleBase.double_to_Z w_digits w_to_Z n x)\n                (base w_digits)),\n       Logic.eq (w_to_Z (DoubleBase.get_low w_0 n x))\n         (DoubleBase.double_to_Z w_digits w_to_Z n x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (zeron n)) 0",
                    "c7_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c8_goal : Z.lt (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)\n  (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (zeron n)) 0",
                    "_global_spec_zeron : forall n : nat, Logic.eq (ZnZ.to_Z (zeron n)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ZnZ.spec_to_Z .",
                "tactic_sig_no_out_arg": "exact ZnZ.spec_to_Z .",
                "tactic_args": [
                    "c7_goal : forall x : dom_t n,\nand (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c8_goal : Z.lt (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)\n  (base (ZnZ.digits (dom_op n)))",
                    "_global_Z.le_lt_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.lt m p), Z.lt n p",
                    "_global_ZnZ.to_Z : forall _ : word w6 (S ?n), Z\nwhere\n?n : [n : nat\n      m : nat\n      x : word (dom_t n) m\n      y : dom_t n\n      H : Z.le (eval n m x) (ZnZ.to_Z y) |- nat]",
                    "c2_y : dom_t n"
                ],
                "tactic_res": [
                    "c9_goal : Z.le (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)\n  (ZnZ.to_Z y)",
                    "c10_goal : Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : Z.le (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z m x)\n  (ZnZ.to_Z y)",
                    "_global_nmake_double : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq ZnZ.to_Z\n         (DoubleBase.double_to_Z (ZnZ.digits w_op) ZnZ.to_Z n)"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (ZnZ.to_Z x) (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Z.le (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c5_H : Z.le (eval n m x) (ZnZ.to_Z y)",
                    "c2_y : dom_t n",
                    "c2_x : word (dom_t n) m",
                    "c2_n : nat",
                    "c2_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "case ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c10_goal : Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))",
                    "c2_y : dom_t n"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : Z.le 0 (ZnZ.to_Z y))\n  (_ : Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))),\nZ.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (_ : Z.le 0 (ZnZ.to_Z y))\n  (_ : Z.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))),\nZ.lt (ZnZ.to_Z y) (base (ZnZ.digits (dom_op n)))",
                    "c2_y : dom_t n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_gt_aux",
        "proof": [
            {
                "tactic_sig": "Lemma spec_div_gt_aux : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> let ( q , r ) := div_gt x y in [ x ] = [ q ] * [ y ] + [ r ] /\\ 0 <= [ r ] < [ y ] .",
                "tactic_sig_no_out_arg": "Lemma spec_div_gt_aux : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> let ( q , r ) := div_gt x y in [ x ] = [ q ] * [ y ] + [ r ] /\\ 0 <= [ r ] < [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))",
                    "_global_div_gt_fold : Logic.eq div_gt\n         (iter (prod t t)\n            (fun n : nat =>\n             let div_gt := ZnZ.div_gt in\n             fun x y : dom_t n =>\n             let (u, v) := div_gt x y in pair (reduce n u) (reduce n v))\n            (fun n : nat =>\n             let div_gt := ZnZ.div_gt in\n             fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n             let y' := DoubleBase.get_low (zeron n) (S m) y in\n             let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v))\n            wn_divn1 div_gtnm)"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) :=\n  iter (prod t t)\n    (fun n : nat =>\n     let div_gt := ZnZ.div_gt in\n     fun x y : dom_t n =>\n     let (u, v) := div_gt x y in pair (reduce n u) (reduce n v))\n    (fun n : nat =>\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n     let y' := DoubleBase.get_low (zeron n) (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v))\n    wn_divn1 div_gtnm x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) :=\n  iter (prod t t)\n    (fun n : nat =>\n     let div_gt := ZnZ.div_gt in\n     fun x y : dom_t n =>\n     let (u, v) := div_gt x y in pair (reduce n u) (reduce n v))\n    (fun n : nat =>\n     let div_gt := ZnZ.div_gt in\n     fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n     let y' := DoubleBase.get_low (zeron n) (S m) y in\n     let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v))\n    wn_divn1 div_gtnm x y in\nand (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y)))",
                    "_global_spec_iter : forall (res : Type) (P : forall (_ : Z) (_ : Z) (_ : res), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y))\n         (fd : forall (n m : nat) (_ : dom_t n) (_ : word (dom_t n) (S m)),\n               res)\n         (fg : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n),\n               res)\n         (_ : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m)),\n              P (ZnZ.to_Z x) (eval n (S m) y) (fd n m x y))\n         (_ : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n              P (eval n (S m) x) (ZnZ.to_Z y) (fg n m x y))\n         (fnm : forall (n m : nat) (_ : word (dom_t 6) (S n))\n                  (_ : word (dom_t 6) (S m)), res)\n         (_ : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\n              P (to_Z (Nn n x)) (to_Z (Nn m y)) (fnm n m x y)) \n         (x y : t), P (to_Z x) (to_Z y) (iter res f fd fg fnm x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (_ : Z.lt 0 (ZnZ.to_Z y)),\nlet (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun x0 y0 : dom_t n =>\n   let (u, v) := div_gt x0 y0 in pair (reduce n u) (reduce n v)) x y in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c5_goal : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m))\n  (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nlet (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun (m0 : nat) (x0 : dom_t n) (y0 : word (dom_t n) (S m0)) =>\n   let y' := DoubleBase.get_low (zeron n) (S m0) y0 in\n   let (u, v) := div_gt x0 y' in pair (reduce n u) (reduce n v)) m x y in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))",
                    "c6_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n)\n  (_ : Z.gt (eval n (S m) x) (ZnZ.to_Z y)) (_ : Z.lt 0 (ZnZ.to_Z y)),\nlet (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c7_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m))\n  (_ : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y)))\n  (_ : Z.lt 0 (to_Z (Nn m y))),\nlet (q, r) := div_gtnm n m x y in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y H1 H2 .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (_ : Z.lt 0 (ZnZ.to_Z y)),\nlet (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun x0 y0 : dom_t n =>\n   let (u, v) := div_gt x0 y0 in pair (reduce n u) (reduce n v)) x y in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c8_goal : let (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun x y : dom_t n =>\n   let (u, v) := div_gt x y in pair (reduce n u) (reduce n v)) x y in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c8_n : nat",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c8_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : let (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun x y : dom_t n =>\n   let (u, v) := div_gt x y in pair (reduce n u) (reduce n v)) x y in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c9_goal : let (q, r) :=\n  let (u, v) := ZnZ.div_gt x y in pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_div_gt _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_div_gt _i _i _i _i ) .",
                "tactic_args": [
                    "c9_goal : let (q, r) :=\n  let (u, v) := ZnZ.div_gt x y in pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c8_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : let (q, r) := ZnZ.div_gt x y in\n      and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z q) (ZnZ.to_Z y)) (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) :=\n  let (u, v) := ZnZ.div_gt x y in pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.div_gt .",
                "tactic_sig_no_out_arg": "case ZnZ.div_gt .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : let (q, r) := ZnZ.div_gt x y in\n      and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z q) (ZnZ.to_Z y)) (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) :=\n  let (u, v) := ZnZ.div_gt x y in pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x) (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c11_goal : forall (d d0 : dom_t n)\n  (_ : and\n         (Logic.eq (ZnZ.to_Z x)\n            (Z.add (Z.mul (ZnZ.to_Z d) (ZnZ.to_Z y)) (ZnZ.to_Z d0)))\n         (and (Z.le 0 (ZnZ.to_Z d0)) (Z.lt (ZnZ.to_Z d0) (ZnZ.to_Z y)))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n d)) (ZnZ.to_Z y))\n        (to_Z (reduce n d0))))\n  (and (Z.le 0 (to_Z (reduce n d0)))\n     (Z.lt (to_Z (reduce n d0)) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros u v .",
                "tactic_args": [
                    "c11_goal : forall (d d0 : dom_t n)\n  (_ : and\n         (Logic.eq (ZnZ.to_Z x)\n            (Z.add (Z.mul (ZnZ.to_Z d) (ZnZ.to_Z y)) (ZnZ.to_Z d0)))\n         (and (Z.le 0 (ZnZ.to_Z d0)) (Z.lt (ZnZ.to_Z d0) (ZnZ.to_Z y)))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n d)) (ZnZ.to_Z y))\n        (to_Z (reduce n d0))))\n  (and (Z.le 0 (to_Z (reduce n d0)))\n     (Z.lt (to_Z (reduce n d0)) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c12_goal : forall\n  _ : and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n        (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n u)) (ZnZ.to_Z y))\n        (to_Z (reduce n v))))\n  (and (Z.le 0 (to_Z (reduce n v)))\n     (Z.lt (to_Z (reduce n v)) (ZnZ.to_Z y)))",
                    "c12_u : dom_t n",
                    "c12_v : dom_t n"
                ]
            },
            {
                "tactic_sig": "rewrite 2 _i .",
                "tactic_sig_no_out_arg": "rewrite 2 _i .",
                "tactic_args": [
                    "c12_goal : forall\n  _ : and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n        (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n u)) (ZnZ.to_Z y))\n        (to_Z (reduce n v))))\n  (and (Z.le 0 (to_Z (reduce n v)))\n     (Z.lt (to_Z (reduce n v)) (ZnZ.to_Z y)))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  _ : and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n        (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n        (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))",
                    "c12_u : dom_t n",
                    "c12_v : dom_t n",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c5_goal : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m))\n  (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nlet (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun (m0 : nat) (x0 : dom_t n) (y0 : word (dom_t n) (S m0)) =>\n   let y' := DoubleBase.get_low (zeron n) (S m0) y0 in\n   let (u, v) := div_gt x0 y' in pair (reduce n u) (reduce n v)) m x y in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c14_goal : let (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n   let y' := DoubleBase.get_low (zeron n) (S m) y in\n   let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v)) m x y in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))",
                    "c14_n : nat",
                    "c14_m : nat",
                    "c14_x : dom_t n",
                    "c14_y : word (dom_t n) (S m)",
                    "c14_H1 : Z.gt (ZnZ.to_Z x) (eval n (S m) y)",
                    "c14_H2 : Z.lt 0 (eval n (S m) y)"
                ]
            },
            {
                "tactic_sig": "cbv zeta beta .",
                "tactic_sig_no_out_arg": "cbv zeta beta .",
                "tactic_args": [
                    "c14_goal : let (q, r) :=\n  (let div_gt := ZnZ.div_gt in\n   fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n   let y' := DoubleBase.get_low (zeron n) (S m) y in\n   let (u, v) := div_gt x y' in pair (reduce n u) (reduce n v)) m x y in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c15_goal : let (q, r) :=\n  let (u, v) := ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n  pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_div_gt _i ( DoubleBase.get_low ( zeron _i ) ( S _i ) _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_div_gt _i ( DoubleBase.get_low ( zeron _i ) ( S _i ) _i ) ) .",
                "tactic_args": [
                    "c15_goal : let (q, r) :=\n  let (u, v) := ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n  pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))",
                    "c14_x : dom_t n",
                    "c14_n : nat",
                    "c14_m : nat",
                    "c14_y : word (dom_t n) (S m)"
                ],
                "tactic_res": [
                    "c16_goal : forall\n  _ : forall\n        (_ : Z.gt (ZnZ.to_Z x)\n               (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n        (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\n      let (q, r) :=\n        ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n      and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add\n              (Z.mul (ZnZ.to_Z q)\n                 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r))\n           (Z.lt (ZnZ.to_Z r)\n              (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))),\nlet (q, r) :=\n  let (u, v) := ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n  pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.div_gt .",
                "tactic_sig_no_out_arg": "case ZnZ.div_gt .",
                "tactic_args": [
                    "c16_goal : forall\n  _ : forall\n        (_ : Z.gt (ZnZ.to_Z x)\n               (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n        (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\n      let (q, r) :=\n        ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n      and\n        (Logic.eq (ZnZ.to_Z x)\n           (Z.add\n              (Z.mul (ZnZ.to_Z q)\n                 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r))\n           (Z.lt (ZnZ.to_Z r)\n              (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))),\nlet (q, r) :=\n  let (u, v) := ZnZ.div_gt x (DoubleBase.get_low (zeron n) (S m) y) in\n  pair (reduce n u) (reduce n v) in\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z q) (eval n (S m) y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c17_goal : forall (d d0 : dom_t n)\n  (_ : forall\n         (_ : Z.gt (ZnZ.to_Z x)\n                (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n         (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\n       and\n         (Logic.eq (ZnZ.to_Z x)\n            (Z.add\n               (Z.mul (ZnZ.to_Z d)\n                  (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n               (ZnZ.to_Z d0)))\n         (and (Z.le 0 (ZnZ.to_Z d0))\n            (Z.lt (ZnZ.to_Z d0)\n               (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n d)) (eval n (S m) y))\n        (to_Z (reduce n d0))))\n  (and (Z.le 0 (to_Z (reduce n d0)))\n     (Z.lt (to_Z (reduce n d0)) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros u v H3 .",
                "tactic_args": [
                    "c17_goal : forall (d d0 : dom_t n)\n  (_ : forall\n         (_ : Z.gt (ZnZ.to_Z x)\n                (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n         (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\n       and\n         (Logic.eq (ZnZ.to_Z x)\n            (Z.add\n               (Z.mul (ZnZ.to_Z d)\n                  (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n               (ZnZ.to_Z d0)))\n         (and (Z.le 0 (ZnZ.to_Z d0))\n            (Z.lt (ZnZ.to_Z d0)\n               (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n d)) (eval n (S m) y))\n        (to_Z (reduce n d0))))\n  (and (Z.le 0 (to_Z (reduce n d0)))\n     (Z.lt (to_Z (reduce n d0)) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c18_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n u)) (eval n (S m) y))\n        (to_Z (reduce n v))))\n  (and (Z.le 0 (to_Z (reduce n v)))\n     (Z.lt (to_Z (reduce n v)) (eval n (S m) y)))",
                    "c18_u : dom_t n",
                    "c18_v : dom_t n",
                    "c18_H3 : forall\n  (_ : Z.gt (ZnZ.to_Z x)\n         (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n  (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add\n        (Z.mul (ZnZ.to_Z u)\n           (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n        (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v))\n     (Z.lt (ZnZ.to_Z v)\n        (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite spec_reduce .",
                "tactic_sig_no_out_arg": "repeat rewrite spec_reduce .",
                "tactic_args": [
                    "c18_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (to_Z (reduce n u)) (eval n (S m) y))\n        (to_Z (reduce n v))))\n  (and (Z.le 0 (to_Z (reduce n v)))\n     (Z.lt (to_Z (reduce n v)) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c19_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_get_endn _i ( S _i ) _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_get_endn _i ( S _i ) _i _i ) .",
                "tactic_args": [
                    "c19_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c14_n : nat",
                    "c14_m : nat",
                    "c14_y : word (dom_t n) (S m)",
                    "c14_x : dom_t n"
                ],
                "tactic_res": [
                    "c20_goal : forall\n  _ : forall _ : Z.le (eval n (S m) y) (to_Z (mk_t n x)),\n      Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) (S m) y)))\n        (eval n (S m) y),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "rewrite !spec_mk_t .",
                "tactic_sig_no_out_arg": "rewrite !spec_mk_t .",
                "tactic_args": [
                    "c20_goal : forall\n  _ : forall _ : Z.le (eval n (S m) y) (to_Z (mk_t n x)),\n      Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) (S m) y)))\n        (eval n (S m) y),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : forall _ : Z.le (eval n (S m) y) (ZnZ.to_Z x),\n      Logic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))\n        (eval n (S m) y),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H4 .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : forall _ : Z.le (eval n (S m) y) (ZnZ.to_Z x),\n      Logic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))\n        (eval n (S m) y),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))"
                ],
                "tactic_res": [
                    "c22_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c22_H4 : forall _ : Z.le (eval n (S m) y) (ZnZ.to_Z x),\nLogic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))\n  (eval n (S m) y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c22_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c22_H4 : forall _ : Z.le (eval n (S m) y) (ZnZ.to_Z x),\nLogic.eq (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))\n  (eval n (S m) y)",
                    "c18_H3 : forall\n  (_ : Z.gt (ZnZ.to_Z x)\n         (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n  (_ : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add\n        (Z.mul (ZnZ.to_Z u)\n           (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))\n        (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v))\n     (Z.lt (ZnZ.to_Z v)\n        (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))))"
                ],
                "tactic_res": [
                    "c23_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c23_H3 : forall (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c24_goal : Z.le (eval n (S m) y) (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c23_H3 : forall (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nand\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (eval n (S m) y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (eval n (S m) y)))",
                    "c18_u : dom_t n",
                    "c18_v : dom_t n",
                    "c14_H2 : Z.lt 0 (eval n (S m) y)",
                    "c14_H1 : Z.gt (ZnZ.to_Z x) (eval n (S m) y)",
                    "c14_y : word (dom_t n) (S m)",
                    "c14_x : dom_t n",
                    "c14_n : nat",
                    "c14_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : Z.le (eval n (S m) y) (ZnZ.to_Z x)",
                    "c14_H1 : Z.gt (ZnZ.to_Z x) (eval n (S m) y)",
                    "c14_y : word (dom_t n) (S m)",
                    "c14_x : dom_t n",
                    "c14_n : nat",
                    "c14_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c6_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n)\n  (_ : Z.gt (eval n (S m) x) (ZnZ.to_Z y)) (_ : Z.lt 0 (ZnZ.to_Z y)),\nlet (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c25_goal : let (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c25_n : nat",
                    "c25_m : nat",
                    "c25_x : word (dom_t n) (S m)",
                    "c25_y : dom_t n",
                    "c25_H1 : Z.gt (eval n (S m) x) (ZnZ.to_Z y)",
                    "c25_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_divn1 _i ( S _i ) _i _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_divn1 _i ( S _i ) _i _i _i ) .",
                "tactic_args": [
                    "c25_goal : let (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "c25_n : nat",
                    "c25_m : nat",
                    "c25_x : word (dom_t n) (S m)",
                    "c25_y : dom_t n",
                    "c25_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ],
                "tactic_res": [
                    "c26_goal : forall\n  _ : let (q, r) :=\n        DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n          ZnZ.WW ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare\n          ZnZ.sub (S m) x y in\n      and\n        (Logic.eq\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) x)\n           (Z.add\n              (Z.mul\n                 (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                    ZnZ.to_Z (S m) q) (ZnZ.to_Z y)) \n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c26_goal : forall\n  _ : let (q, r) :=\n        DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n          ZnZ.WW ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare\n          ZnZ.sub (S m) x y in\n      and\n        (Logic.eq\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) x)\n           (Z.add\n              (Z.mul\n                 (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                    ZnZ.to_Z (S m) q) (ZnZ.to_Z y)) \n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) := wn_divn1 n m x y in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))",
                    "_global_wn_divn1 : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n), prod t t"
                ],
                "tactic_res": [
                    "c27_goal : forall\n  _ : let (q, r) :=\n        DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n          ZnZ.WW ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare\n          ZnZ.sub (S m) x y in\n      and\n        (Logic.eq\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) x)\n           (Z.add\n              (Z.mul\n                 (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                    ZnZ.to_Z (S m) q) (ZnZ.to_Z y)) \n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) :=\n  let (u, v) :=\n    DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero ZnZ.WW\n      ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n      (S m) x y in\n  pair (mk_t_w' n m u) (mk_t n v) in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "case DoubleDivn1.double_divn1 .",
                "tactic_sig_no_out_arg": "case DoubleDivn1.double_divn1 .",
                "tactic_args": [
                    "c27_goal : forall\n  _ : let (q, r) :=\n        DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n          ZnZ.WW ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare\n          ZnZ.sub (S m) x y in\n      and\n        (Logic.eq\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) x)\n           (Z.add\n              (Z.mul\n                 (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                    ZnZ.to_Z (S m) q) (ZnZ.to_Z y)) \n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r)) (Z.lt (ZnZ.to_Z r) (ZnZ.to_Z y))),\nlet (q, r) :=\n  let (u, v) :=\n    DoubleDivn1.double_divn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero ZnZ.WW\n      ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n      (S m) x y in\n  pair (mk_t_w' n m u) (mk_t n v) in\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z q) (ZnZ.to_Z y)) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c28_goal : forall (w : word (dom_t n) (S m)) (d : dom_t n)\n  (_ : and\n         (Logic.eq\n            (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n               (S m) x)\n            (Z.add\n               (Z.mul\n                  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                     ZnZ.to_Z (S m) w) (ZnZ.to_Z y)) \n               (ZnZ.to_Z d)))\n         (and (Z.le 0 (ZnZ.to_Z d)) (Z.lt (ZnZ.to_Z d) (ZnZ.to_Z y)))),\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z (mk_t_w' n m w)) (ZnZ.to_Z y))\n        (to_Z (mk_t n d))))\n  (and (Z.le 0 (to_Z (mk_t n d))) (Z.lt (to_Z (mk_t n d)) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros u v H3 .",
                "tactic_args": [
                    "c28_goal : forall (w : word (dom_t n) (S m)) (d : dom_t n)\n  (_ : and\n         (Logic.eq\n            (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n               (S m) x)\n            (Z.add\n               (Z.mul\n                  (DoubleBase.double_to_Z (ZnZ.digits (dom_op n))\n                     ZnZ.to_Z (S m) w) (ZnZ.to_Z y)) \n               (ZnZ.to_Z d)))\n         (and (Z.le 0 (ZnZ.to_Z d)) (Z.lt (ZnZ.to_Z d) (ZnZ.to_Z y)))),\nand\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z (mk_t_w' n m w)) (ZnZ.to_Z y))\n        (to_Z (mk_t n d))))\n  (and (Z.le 0 (to_Z (mk_t n d))) (Z.lt (to_Z (mk_t n d)) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c29_goal : and\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z (mk_t_w' n m u)) (ZnZ.to_Z y))\n        (to_Z (mk_t n v))))\n  (and (Z.le 0 (to_Z (mk_t n v))) (Z.lt (to_Z (mk_t n v)) (ZnZ.to_Z y)))",
                    "c29_u : word (dom_t n) (S m)",
                    "c29_v : dom_t n",
                    "c29_H3 : and\n  (Logic.eq\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (Z.add\n        (Z.mul\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c29_goal : and\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (to_Z (mk_t_w' n m u)) (ZnZ.to_Z y))\n        (to_Z (mk_t n v))))\n  (and (Z.le 0 (to_Z (mk_t n v))) (Z.lt (to_Z (mk_t n v)) (ZnZ.to_Z y)))",
                    "_global_spec_mk_t_w' : forall (n m : nat) (x : word (dom_t n) (S m)),\n       Logic.eq (to_Z (mk_t_w' n m x)) (eval n (S m) x)",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c30_goal : and\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (eval n (S m) u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- !nmake_double in _i .",
                "tactic_sig_no_out_arg": "rewrite <- !nmake_double in _i .",
                "tactic_args": [
                    "c30_H3 : and\n  (Logic.eq\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (Z.add\n        (Z.mul\n           (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z\n              (S m) u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c30_H3 : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : and\n  (Logic.eq (eval n (S m) x)\n     (Z.add (Z.mul (eval n (S m) u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))",
                    "c30_H3 : and\n  (Logic.eq (ZnZ.to_Z x)\n     (Z.add (Z.mul (ZnZ.to_Z u) (ZnZ.to_Z y)) (ZnZ.to_Z v)))\n  (and (Z.le 0 (ZnZ.to_Z v)) (Z.lt (ZnZ.to_Z v) (ZnZ.to_Z y)))",
                    "c29_v : dom_t n",
                    "c29_u : word (dom_t n) (S m)",
                    "c25_y : dom_t n",
                    "c25_x : word (dom_t n) (S m)",
                    "c25_n : nat",
                    "c25_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c7_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m))\n  (_ : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y)))\n  (_ : Z.lt 0 (to_Z (Nn m y))),\nlet (q, r) := div_gtnm n m x y in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))"
                ],
                "tactic_res": [
                    "c31_goal : let (q, r) := div_gtnm n m x y in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_x : word w6 (S n)",
                    "c31_y : word w6 (S m)",
                    "c31_H1 : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y))",
                    "c31_H2 : Z.lt 0 (to_Z (Nn m y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c31_goal : let (q, r) := div_gtnm n m x y in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))",
                    "_global_div_gtnm : forall (n m : nat) (_ : word w6 (S n)) (_ : word w6 (S m)), prod t' t'"
                ],
                "tactic_res": [
                    "c32_goal : let (q, r) :=\n  let (q, r) :=\n    ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n      (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n  pair (reduce_n (Nat.max n m) q) (reduce_n (Nat.max n m) r) in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_div_gt ( castm ( diff_r _i _i ) ( extend_tr _i ( snd ( diff _i _i ) ) ) ) ( castm ( diff_l _i _i ) ( extend_tr _i ( fst ( diff _i _i ) ) ) ) ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_div_gt ( castm ( diff_r _i _i ) ( extend_tr _i ( snd ( diff _i _i ) ) ) ) ( castm ( diff_l _i _i ) ( extend_tr _i ( fst ( diff _i _i ) ) ) ) ) .",
                "tactic_args": [
                    "c32_goal : let (q, r) :=\n  let (q, r) :=\n    ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n      (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n  pair (reduce_n (Nat.max n m) q) (reduce_n (Nat.max n m) r) in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_x : word w6 (S n)",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_y : word w6 (S m)",
                    "c31_n : nat",
                    "c31_m : nat"
                ],
                "tactic_res": [
                    "c33_goal : forall\n  _ : forall\n        (_ : Z.gt\n               (ZnZ.to_Z\n                  (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (_ : Z.lt 0\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\n      let (q, r) :=\n        ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n          (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n      and\n        (Logic.eq\n           (ZnZ.to_Z\n              (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n           (Z.add\n              (Z.mul (ZnZ.to_Z q)\n                 (ZnZ.to_Z\n                    (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r))\n           (Z.lt (ZnZ.to_Z r)\n              (ZnZ.to_Z\n                 (castm (diff_l n m) (extend_tr y (fst (diff n m))))))),\nlet (q, r) :=\n  let (q, r) :=\n    ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n      (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n  pair (reduce_n (Nat.max n m) q) (reduce_n (Nat.max n m) r) in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.div_gt .",
                "tactic_sig_no_out_arg": "case ZnZ.div_gt .",
                "tactic_args": [
                    "c33_goal : forall\n  _ : forall\n        (_ : Z.gt\n               (ZnZ.to_Z\n                  (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (_ : Z.lt 0\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\n      let (q, r) :=\n        ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n          (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n      and\n        (Logic.eq\n           (ZnZ.to_Z\n              (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n           (Z.add\n              (Z.mul (ZnZ.to_Z q)\n                 (ZnZ.to_Z\n                    (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n              (ZnZ.to_Z r)))\n        (and (Z.le 0 (ZnZ.to_Z r))\n           (Z.lt (ZnZ.to_Z r)\n              (ZnZ.to_Z\n                 (castm (diff_l n m) (extend_tr y (fst (diff n m))))))),\nlet (q, r) :=\n  let (q, r) :=\n    ZnZ.div_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n      (castm (diff_l n m) (extend_tr y (fst (diff n m)))) in\n  pair (reduce_n (Nat.max n m) q) (reduce_n (Nat.max n m) r) in\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z q) (to_Z (Nn m y))) (to_Z r)))\n  (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z (Nn m y))))"
                ],
                "tactic_res": [
                    "c34_goal : forall (w w0 : word w6 (S (Nat.max n m)))\n  (_ : forall\n         (_ : Z.gt\n                (ZnZ.to_Z\n                   (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n                (ZnZ.to_Z\n                   (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n         (_ : Z.lt 0\n                (ZnZ.to_Z\n                   (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\n       and\n         (Logic.eq\n            (ZnZ.to_Z\n               (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n            (Z.add\n               (Z.mul (ZnZ.to_Z w)\n                  (ZnZ.to_Z\n                     (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n               (ZnZ.to_Z w0)))\n         (and (Z.le 0 (ZnZ.to_Z w0))\n            (Z.lt (ZnZ.to_Z w0)\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))),\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (reduce_n (Nat.max n m) w)) (to_Z (Nn m y)))\n        (to_Z (reduce_n (Nat.max n m) w0))))\n  (and (Z.le 0 (to_Z (reduce_n (Nat.max n m) w0)))\n     (Z.lt (to_Z (reduce_n (Nat.max n m) w0)) (to_Z (Nn m y))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros xx yy HH .",
                "tactic_args": [
                    "c34_goal : forall (w w0 : word w6 (S (Nat.max n m)))\n  (_ : forall\n         (_ : Z.gt\n                (ZnZ.to_Z\n                   (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n                (ZnZ.to_Z\n                   (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n         (_ : Z.lt 0\n                (ZnZ.to_Z\n                   (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\n       and\n         (Logic.eq\n            (ZnZ.to_Z\n               (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n            (Z.add\n               (Z.mul (ZnZ.to_Z w)\n                  (ZnZ.to_Z\n                     (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n               (ZnZ.to_Z w0)))\n         (and (Z.le 0 (ZnZ.to_Z w0))\n            (Z.lt (ZnZ.to_Z w0)\n               (ZnZ.to_Z\n                  (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))),\nand\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (reduce_n (Nat.max n m) w)) (to_Z (Nn m y)))\n        (to_Z (reduce_n (Nat.max n m) w0))))\n  (and (Z.le 0 (to_Z (reduce_n (Nat.max n m) w0)))\n     (Z.lt (to_Z (reduce_n (Nat.max n m) w0)) (to_Z (Nn m y))))"
                ],
                "tactic_res": [
                    "c35_goal : and\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (reduce_n (Nat.max n m) xx)) (to_Z (Nn m y)))\n        (to_Z (reduce_n (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (reduce_n (Nat.max n m) yy)))\n     (Z.lt (to_Z (reduce_n (Nat.max n m) yy)) (to_Z (Nn m y))))",
                    "c35_xx : word w6 (S (Nat.max n m))",
                    "c35_yy : word w6 (S (Nat.max n m))",
                    "c35_HH : forall\n  (_ : Z.gt\n         (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n         (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n  (_ : Z.lt 0\n         (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\nand\n  (Logic.eq\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (Z.add\n        (Z.mul (ZnZ.to_Z xx)\n           (ZnZ.to_Z\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (ZnZ.to_Z yy)))\n  (and (Z.le 0 (ZnZ.to_Z yy))\n     (Z.lt (ZnZ.to_Z yy)\n        (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite spec_reduce_n .",
                "tactic_sig_no_out_arg": "repeat rewrite spec_reduce_n .",
                "tactic_args": [
                    "c35_goal : and\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (reduce_n (Nat.max n m) xx)) (to_Z (Nn m y)))\n        (to_Z (reduce_n (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (reduce_n (Nat.max n m) yy)))\n     (Z.lt (to_Z (reduce_n (Nat.max n m) yy)) (to_Z (Nn m y))))"
                ],
                "tactic_res": [
                    "c36_goal : and\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (Nn (Nat.max n m) xx)) (to_Z (Nn m y)))\n        (to_Z (Nn (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (Nn (Nat.max n m) yy)))\n     (Z.lt (to_Z (Nn (Nat.max n m) yy)) (to_Z (Nn m y))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_args": [
                    "c36_goal : and\n  (Logic.eq (to_Z (Nn n x))\n     (Z.add (Z.mul (to_Z (Nn (Nat.max n m) xx)) (to_Z (Nn m y)))\n        (to_Z (Nn (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (Nn (Nat.max n m) yy)))\n     (Z.lt (to_Z (Nn (Nat.max n m) yy)) (to_Z (Nn m y))))",
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_x : word w6 (S n)",
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_y : word w6 (S m)"
                ],
                "tactic_res": [
                    "c37_goal : and\n  (Logic.eq\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (Z.add\n        (Z.mul (to_Z (Nn (Nat.max n m) xx))\n           (to_Z\n              (Nn (Nat.max n m)\n                 (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n        (to_Z (Nn (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (Nn (Nat.max n m) yy)))\n     (Z.lt (to_Z (Nn (Nat.max n m) yy))\n        (to_Z\n           (Nn (Nat.max n m)\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c37_goal : and\n  (Logic.eq\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (Z.add\n        (Z.mul (to_Z (Nn (Nat.max n m) xx))\n           (to_Z\n              (Nn (Nat.max n m)\n                 (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n        (to_Z (Nn (Nat.max n m) yy))))\n  (and (Z.le 0 (to_Z (Nn (Nat.max n m) yy)))\n     (Z.lt (to_Z (Nn (Nat.max n m) yy))\n        (to_Z\n           (Nn (Nat.max n m)\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))))",
                    "_global_to_Z : forall _ : t, Z"
                ],
                "tactic_res": [
                    "c38_goal : and\n  (Logic.eq\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (Z.add\n        (Z.mul (ZnZ.to_Z xx)\n           (ZnZ.to_Z\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (ZnZ.to_Z yy)))\n  (and (Z.le 0 (ZnZ.to_Z yy))\n     (Z.lt (ZnZ.to_Z yy)\n        (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : and\n  (Logic.eq\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (Z.add\n        (Z.mul (ZnZ.to_Z xx)\n           (ZnZ.to_Z\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (ZnZ.to_Z yy)))\n  (and (Z.le 0 (ZnZ.to_Z yy))\n     (Z.lt (ZnZ.to_Z yy)\n        (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))",
                    "c35_HH : forall\n  (_ : Z.gt\n         (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n         (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n  (_ : Z.lt 0\n         (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))),\nand\n  (Logic.eq\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (Z.add\n        (Z.mul (ZnZ.to_Z xx)\n           (ZnZ.to_Z\n              (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n        (ZnZ.to_Z yy)))\n  (and (Z.le 0 (ZnZ.to_Z yy))\n     (Z.lt (ZnZ.to_Z yy)\n        (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ],
                "tactic_res": [
                    "c39_goal : Z.gt (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n  (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c40_goal : Z.lt 0 (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_x : word w6 (S n)",
                    "c39_H1 : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c39_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z (Nn m y))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_y : word w6 (S m)",
                    "c39_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c39_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : Z.gt (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n  (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c39_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "c31_y : word w6 (S m)",
                    "c31_x : word w6 (S n)",
                    "c31_n : nat",
                    "c31_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c31_n : nat",
                    "c31_m : nat",
                    "c31_y : word w6 (S m)",
                    "c40_H2 : Z.lt 0 (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c40_H2 : Z.lt 0\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : Z.lt 0 (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c40_H2 : Z.lt 0\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "c31_y : word w6 (S m)",
                    "c31_n : nat",
                    "c31_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_gt",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_gt : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> let ( q , r ) := div_gt x y in [ q ] = [ x ] / [ y ] /\\ [ r ] = [ x ] mod [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div_gt : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> let ( q , r ) := div_gt x y in [ q ] = [ x ] / [ y ] /\\ [ r ] = [ x ] mod [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))"
                ],
                "tactic_res": [
                    "c2_goal : let (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))",
                    "c2_x : True",
                    "c2_y : True",
                    "c2_H1 : Z.gt (to_Z x) (to_Z y)",
                    "c2_H2 : Z.lt 0 (to_Z y)"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_div_gt_aux _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_div_gt_aux _i _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : let (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))",
                    "c2_x : True",
                    "c2_y : True",
                    "c2_H1 : Z.gt (to_Z x) (to_Z y)",
                    "c2_H2 : Z.lt 0 (to_Z y)"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and\n        (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n        (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "case div_gt .",
                "tactic_sig_no_out_arg": "case div_gt .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and\n        (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r)))\n        (and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))),\nlet (q, r) := div_gt x y in\nand (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))"
                ],
                "tactic_res": [
                    "c4_goal : forall (t0 t : t)\n  (_ : and\n         (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z t0) (to_Z y)) (to_Z t)))\n         (and (Z.le 0 (to_Z t)) (Z.lt (to_Z t) (to_Z y)))),\nand (Logic.eq (to_Z t0) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z t) (Z.modulo (to_Z x) (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros q r ( H3 , H4 ) .",
                "tactic_args": [
                    "c4_goal : forall (t0 t : t)\n  (_ : and\n         (Logic.eq (to_Z x) (Z.add (Z.mul (to_Z t0) (to_Z y)) (to_Z t)))\n         (and (Z.le 0 (to_Z t)) (Z.lt (to_Z t) (to_Z y)))),\nand (Logic.eq (to_Z t0) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z t) (Z.modulo (to_Z x) (to_Z y)))"
                ],
                "tactic_res": [
                    "c5_goal : and (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))",
                    "c5_q : True",
                    "c5_r : True",
                    "c5_H3 : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))",
                    "c5_H4 : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n  (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y))",
                    "c7_goal : Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply ( _i [ _i ] [ _i ] [ _i ] [ _i ] ) .",
                "tactic_sig_no_out_arg": "apply ( _i [ _i ] [ _i ] [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y))",
                    "_global_Zdiv_unique : forall (a b q r : Z) (_ : and (Z.le 0 r) (Z.lt r b))\n         (_ : Logic.eq a (Z.add (Z.mul b q) r)), Logic.eq q (Z.div a b)",
                    "c2_x : True",
                    "c2_y : True",
                    "c5_q : True",
                    "c5_r : True"
                ],
                "tactic_res": [
                    "c8_goal : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c9_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z y) (to_Z q)) (to_Z r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c5_H4 : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c5_r : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z y) (to_Z q)) (to_Z r))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))",
                    "c5_H3 : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))",
                    "c5_q : True",
                    "c5_r : True",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply ( _i [ _i ] [ _i ] [ _i ] [ _i ] ) .",
                "tactic_sig_no_out_arg": "apply ( _i [ _i ] [ _i ] [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_Zmod_unique : forall (a b q r : Z) (_ : and (Z.le 0 r) (Z.lt r b))\n         (_ : Logic.eq a (Z.add (Z.mul b q) r)), Logic.eq r (Z.modulo a b)",
                    "c2_x : True",
                    "c2_y : True",
                    "c5_q : True",
                    "c5_r : True"
                ],
                "tactic_res": [
                    "c11_goal : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c12_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z y) (to_Z q)) (to_Z r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c5_H4 : and (Z.le 0 (to_Z r)) (Z.lt (to_Z r) (to_Z y))",
                    "c5_r : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z y) (to_Z q)) (to_Z r))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))",
                    "c5_H3 : Logic.eq (to_Z x) (Z.add (Z.mul (to_Z q) (to_Z y)) (to_Z r))",
                    "c5_q : True",
                    "c5_r : True",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div_eucl",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div_eucl : forall x y , let ( q , r ) := div_eucl x y in ( [ q ] , [ r ] ) = Z.div_eucl [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div_eucl : forall x y , let ( q , r ) := div_eucl x y in ( [ q ] , [ r ] ) = Z.div_eucl [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t,\nlet (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t,\nlet (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : let (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : let (q, r) := div_eucl x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "_global_div_eucl : forall (_ : t) (_ : t), prod t t"
                ],
                "tactic_res": [
                    "c3_goal : let (q, r) :=\n  if eqb y zero\n  then pair zero x\n  else\n   match compare x y with\n   | Eq => pair one zero\n   | Lt => pair zero x\n   | Gt => div_gt x y\n   end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c3_goal : let (q, r) :=\n  if eqb y zero\n  then pair zero x\n  else\n   match compare x y with\n   | Eq => pair one zero\n   | Lt => pair zero x\n   | Gt => div_gt x y\n   end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "_global_spec_eqb : forall x y : t, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c4_goal : let (q, r) :=\n  if Z.eqb (to_Z y) 0\n  then pair zero x\n  else\n   match Z.compare (to_Z x) (to_Z y) with\n   | Eq => pair one zero\n   | Lt => pair zero x\n   | Gt => div_gt x y\n   end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c4_goal : let (q, r) :=\n  if Z.eqb (to_Z y) 0\n  then pair zero x\n  else\n   match Z.compare (to_Z x) (to_Z y) with\n   | Eq => pair one zero\n   | Lt => pair zero x\n   | Gt => div_gt x y\n   end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nlet (q, r) :=\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => pair one zero\n  | Lt => pair zero x\n  | Gt => div_gt x y\n  end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros -> .",
                "tactic_sig_no_out_arg": "intros -> .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) 0)",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "destruct [ _i ] as [  | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct [ _i ] .",
                "tactic_args": [
                    "c8_goal : Logic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) 0)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (pair 0 0) (Z.div_eucl 0 0)",
                    "c10_goal : Logic.eq (pair 0 (Zpos p)) (Z.div_eucl (Zpos p) 0)",
                    "c10_p : positive",
                    "c11_goal : Logic.eq (pair 0 (Zneg p)) (Z.div_eucl (Zneg p) 0)",
                    "c11_p : positive"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Logic.eq (pair 0 0) (Z.div_eucl 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Logic.eq (pair 0 (Zpos p)) (Z.div_eucl (Zpos p) 0)",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Logic.eq (pair 0 (Zneg p)) (Z.div_eucl (Zneg p) 0)",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H' .",
                "tactic_args": [
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nlet (q, r) :=\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => pair one zero\n  | Lt => pair zero x\n  | Gt => div_gt x y\n  end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c12_goal : let (q, r) :=\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => pair one zero\n  | Lt => pair zero x\n  | Gt => div_gt x y\n  end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c12_H' : not (Logic.eq (to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "assert ( H : 0 < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "assert ( H : 0 < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto with zarith ) .",
                "tactic_args": [
                    "c2_y : True",
                    "c2_y : True",
                    "c12_H' : not (Logic.eq (to_Z y) 0)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c12_H : Z.lt 0 (to_Z y)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c12_H' : not (Logic.eq (to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c12_goal : let (q, r) :=\n  match Z.compare (to_Z x) (to_Z y) with\n  | Eq => pair one zero\n  | Lt => pair zero x\n  | Gt => div_gt x y\n  end in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq (pair (to_Z one) (to_Z zero)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c14_goal : forall _ : Z.lt (to_Z x) (to_Z y),\nLogic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c15_goal : forall _ : Z.lt (to_Z y) (to_Z x),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Cmp .",
                "tactic_args": [
                    "c13_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq (pair (to_Z one) (to_Z zero)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (pair (to_Z one) (to_Z zero)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c16_Cmp : Logic.eq (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_sig_no_out_arg": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_args": [
                    "c16_goal : Logic.eq (pair (to_Z one) (to_Z zero)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (pair 1 0) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Cmp .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt (to_Z x) (to_Z y),\nLogic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c18_Cmp : Z.lt (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_sig_no_out_arg": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_args": [
                    "c18_goal : Logic.eq (pair (to_Z zero) (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Cmp .",
                "tactic_args": [
                    "c15_goal : forall _ : Z.lt (to_Z y) (to_Z x),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c20_goal : let (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c20_Cmp : Z.lt (to_Z y) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq (pair 1 0) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c16_Cmp : Logic.eq (to_Z x) (to_Z y)"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( Z_div_same [ _i ] ( Z.lt_gt _ _ _i ) ) ( Z_mod_same [ _i ] ( Z.lt_gt _ _ _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Z_div_same [ _i ] ( Z.lt_gt _ _ _i ) ) ( Z_mod_same [ _i ] ( Z.lt_gt _ _ _i ) ) .",
                "tactic_args": [
                    "c21_goal : Logic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))",
                    "c2_y : True",
                    "c12_H : Z.lt 0 (to_Z y)",
                    "c2_y : True",
                    "c12_H : Z.lt 0 (to_Z y)"
                ],
                "tactic_res": [
                    "c22_goal : forall (_ : Logic.eq (Z.div (to_Z y) (to_Z y)) 1)\n  (_ : Logic.eq (Z.modulo (to_Z y) (to_Z y)) 0),\nLogic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c22_goal : forall (_ : Logic.eq (Z.div (to_Z y) (to_Z y)) 1)\n  (_ : Logic.eq (Z.modulo (to_Z y) (to_Z y)) 0),\nLogic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))",
                    "_global_Z.div : forall (_ : Z) (_ : Z), Z",
                    "_global_Z.modulo : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c23_goal : forall\n  (_ : Logic.eq (let (q, _) := Z.div_eucl (to_Z y) (to_Z y) in q) 1)\n  (_ : Logic.eq (let (_, r) := Z.div_eucl (to_Z y) (to_Z y) in r) 0),\nLogic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c23_goal : forall\n  (_ : Logic.eq (let (q, _) := Z.div_eucl (to_Z y) (to_Z y) in q) 1)\n  (_ : Logic.eq (let (_, r) := Z.div_eucl (to_Z y) (to_Z y) in r) 0),\nLogic.eq (pair 1 0) (Z.div_eucl (to_Z y) (to_Z y))"
                ],
                "tactic_res": [
                    "c24_goal : forall (z z0 : Z) (_ : Logic.eq z 1) (_ : Logic.eq z0 0),\nLogic.eq (pair 1 0) (pair z z0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c24_goal : forall (z z0 : Z) (_ : Logic.eq z 1) (_ : Logic.eq z0 0),\nLogic.eq (pair 1 0) (pair z z0)"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq (pair 1 0) (pair z z0)",
                    "c25_z : Z",
                    "c25_z0 : Z",
                    "c25_H0 : Logic.eq z 1",
                    "c25_H1 : Logic.eq z0 0"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c25_goal : Logic.eq (pair 1 0) (pair z z0)"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (pair 1 0) (pair 1 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Logic.eq (pair 1 0) (pair 1 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( LeLt : 0 <= [ _i ] < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( LeLt : 0 <= [ _i ] < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto ) .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True",
                    "c2_x : True",
                    "c18_Cmp : Z.lt (to_Z x) (to_Z y)",
                    "c12_H : Z.lt 0 (to_Z y)"
                ],
                "tactic_res": [
                    "c19_LeLt : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( Zdiv_small _ _ _i ) ( Zmod_small _ _ _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Zdiv_small _ _ _i ) ( Zmod_small _ _ _i ) .",
                "tactic_args": [
                    "c19_goal : Logic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c19_LeLt : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))",
                    "c19_LeLt : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c27_goal : forall (_ : Logic.eq (Z.div (to_Z x) (to_Z y)) 0)\n  (_ : Logic.eq (Z.modulo (to_Z x) (to_Z y)) (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c27_goal : forall (_ : Logic.eq (Z.div (to_Z x) (to_Z y)) 0)\n  (_ : Logic.eq (Z.modulo (to_Z x) (to_Z y)) (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "_global_Z.div : forall (_ : Z) (_ : Z), Z",
                    "_global_Z.modulo : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  (_ : Logic.eq (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q) 0)\n  (_ : Logic.eq (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)\n         (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c28_goal : forall\n  (_ : Logic.eq (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q) 0)\n  (_ : Logic.eq (let (_, r) := Z.div_eucl (to_Z x) (to_Z y) in r)\n         (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c29_goal : forall (z z0 : Z) (_ : Logic.eq z 0) (_ : Logic.eq z0 (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (pair z z0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c29_goal : forall (z z0 : Z) (_ : Logic.eq z 0) (_ : Logic.eq z0 (to_Z x)),\nLogic.eq (pair 0 (to_Z x)) (pair z z0)"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq (pair 0 (to_Z x)) (pair z z0)",
                    "c30_z : Z",
                    "c30_z0 : Z",
                    "c30_H0 : Logic.eq z 0",
                    "c30_H1 : Logic.eq z0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c30_goal : Logic.eq (pair 0 (to_Z x)) (pair z z0)"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (pair 0 (to_Z x)) (pair 0 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : Logic.eq (pair 0 (to_Z x)) (pair 0 (to_Z x))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( spec_div_gt _ _ ( Z.lt_gt _ _ _i ) _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_div_gt _ _ ( Z.lt_gt _ _ _i ) _i ) .",
                "tactic_args": [
                    "c20_goal : let (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "c20_Cmp : Z.lt (to_Z y) (to_Z x)",
                    "c12_H : Z.lt 0 (to_Z y)"
                ],
                "tactic_res": [
                    "c32_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n        (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y))),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and (Logic.eq (to_Z q) (Z.div (to_Z x) (to_Z y)))\n        (Logic.eq (to_Z r) (Z.modulo (to_Z x) (to_Z y))),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))",
                    "_global_Z.div : forall (_ : Z) (_ : Z), Z",
                    "_global_Z.modulo : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c33_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and\n        (Logic.eq (to_Z q)\n           (let (q0, _) := Z.div_eucl (to_Z x) (to_Z y) in q0))\n        (Logic.eq (to_Z r)\n           (let (_, r0) := Z.div_eucl (to_Z x) (to_Z y) in r0)),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c33_goal : forall\n  _ : let (q, r) := div_gt x y in\n      and\n        (Logic.eq (to_Z q)\n           (let (q0, _) := Z.div_eucl (to_Z x) (to_Z y) in q0))\n        (Logic.eq (to_Z r)\n           (let (_, r0) := Z.div_eucl (to_Z x) (to_Z y) in r0)),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c34_goal : forall (z z0 : Z)\n  (_ : let (q, r) := div_gt x y in\n       and (Logic.eq (to_Z q) z) (Logic.eq (to_Z r) z0)),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (pair z z0)"
                ]
            },
            {
                "tactic_sig": "case div_gt .",
                "tactic_sig_no_out_arg": "case div_gt .",
                "tactic_args": [
                    "c34_goal : forall (z z0 : Z)\n  (_ : let (q, r) := div_gt x y in\n       and (Logic.eq (to_Z q) z) (Logic.eq (to_Z r) z0)),\nlet (q, r) := div_gt x y in\nLogic.eq (pair (to_Z q) (to_Z r)) (pair z z0)"
                ],
                "tactic_res": [
                    "c35_goal : forall (t0 t : t) (z z0 : Z)\n  (_ : and (Logic.eq (to_Z t0) z) (Logic.eq (to_Z t) z0)),\nLogic.eq (pair (to_Z t0) (to_Z t)) (pair z z0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros a b c d ( H1 , H2 ) .",
                "tactic_args": [
                    "c35_goal : forall (t0 t : t) (z z0 : Z)\n  (_ : and (Logic.eq (to_Z t0) z) (Logic.eq (to_Z t) z0)),\nLogic.eq (pair (to_Z t0) (to_Z t)) (pair z z0)"
                ],
                "tactic_res": [
                    "c36_goal : Logic.eq (pair (to_Z a) (to_Z b)) (pair c d)",
                    "c36_a : True",
                    "c36_b : True",
                    "c36_c : Z",
                    "c36_d : Z",
                    "c36_H1 : Logic.eq (to_Z a) c",
                    "c36_H2 : Logic.eq (to_Z b) d"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c36_goal : Logic.eq (pair (to_Z a) (to_Z b)) (pair c d)"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq (pair (to_Z a) (to_Z b)) (pair (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : Logic.eq (pair (to_Z a) (to_Z b)) (pair (to_Z a) (to_Z b))",
                    "c36_a : True",
                    "c36_b : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div",
        "proof": [
            {
                "tactic_sig": "Theorem spec_div : forall x y , [ div x y ] = [ x ] / [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_div : forall x y , [ div x y ] = [ x ] / [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (div x y)) (Z.div (to_Z x) (to_Z y))",
                    "_global_div : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (fst (div_eucl x y))) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_div_eucl _i _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (fst (div_eucl x y))) (Z.div (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (fst (div_eucl x y))) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case div_eucl .",
                "tactic_sig_no_out_arg": "case div_eucl .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : let (q, r) := div_eucl x y in\n      Logic.eq (pair (to_Z q) (to_Z r)) (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z (fst (div_eucl x y))) (Z.div (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall (t0 t1 : t)\n  (_ : Logic.eq (pair (to_Z t0) (to_Z t1))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (fst (pair t0 t1))) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "simpl fst .",
                "tactic_sig_no_out_arg": "simpl fst .",
                "tactic_args": [
                    "c5_goal : forall (t0 t1 : t)\n  (_ : Logic.eq (pair (to_Z t0) (to_Z t1))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z (fst (pair t0 t1))) (Z.div (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c6_goal : forall (t0 t : t)\n  (_ : Logic.eq (pair (to_Z t0) (to_Z t))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z t0) (Z.div (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros xx yy .",
                "tactic_args": [
                    "c6_goal : forall (t0 t : t)\n  (_ : Logic.eq (pair (to_Z t0) (to_Z t))\n         (Z.div_eucl (to_Z x) (to_Z y))),\nLogic.eq (to_Z t0) (Z.div (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : Logic.eq (pair (to_Z xx) (to_Z yy))\n        (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z xx) (Z.div (to_Z x) (to_Z y))",
                    "c7_xx : True",
                    "c7_yy : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : Logic.eq (pair (to_Z xx) (to_Z yy))\n        (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z xx) (Z.div (to_Z x) (to_Z y))",
                    "_global_Z.div : forall (_ : Z) (_ : Z), Z"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  _ : Logic.eq (pair (to_Z xx) (to_Z yy))\n        (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z xx) (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ]
            },
            {
                "tactic_sig": "case Z.div_eucl .",
                "tactic_sig_no_out_arg": "case Z.div_eucl .",
                "tactic_args": [
                    "c8_goal : forall\n  _ : Logic.eq (pair (to_Z xx) (to_Z yy))\n        (Z.div_eucl (to_Z x) (to_Z y)),\nLogic.eq (to_Z xx) (let (q, _) := Z.div_eucl (to_Z x) (to_Z y) in q)"
                ],
                "tactic_res": [
                    "c9_goal : forall (z z0 : Z) (_ : Logic.eq (pair (to_Z xx) (to_Z yy)) (pair z z0)),\nLogic.eq (to_Z xx) z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros qq rr H .",
                "tactic_args": [
                    "c9_goal : forall (z z0 : Z) (_ : Logic.eq (pair (to_Z xx) (to_Z yy)) (pair z z0)),\nLogic.eq (to_Z xx) z"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z xx) qq",
                    "c10_qq : Z",
                    "c10_rr : Z",
                    "c10_H : Logic.eq (pair (to_Z xx) (to_Z yy)) (pair qq rr)"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z xx) qq",
                    "c10_H : Logic.eq (pair (to_Z xx) (to_Z yy)) (pair qq rr)"
                ],
                "tactic_res": [
                    "c11_goal : forall (_ : Logic.eq (to_Z yy) rr) (_ : Logic.eq (to_Z xx) qq),\nLogic.eq (to_Z xx) qq"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : forall (_ : Logic.eq (to_Z yy) rr) (_ : Logic.eq (to_Z xx) qq),\nLogic.eq (to_Z xx) qq",
                    "c10_qq : Z",
                    "c10_rr : Z",
                    "c7_xx : True",
                    "c7_yy : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mod_gt_fold",
        "proof": [
            {
                "tactic_sig": "Lemma mod_gt_fold : mod_gt = mod_gt_folded .",
                "tactic_sig_no_out_arg": "Lemma mod_gt_fold : mod_gt = mod_gt_folded .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq mod_gt\n  (iter t\n     (fun n : nat =>\n      let modulo_gt := ZnZ.modulo_gt in\n      fun x y : dom_t n => reduce n (modulo_gt x y))\n     (fun n : nat =>\n      let modulo_gt := ZnZ.modulo_gt in\n      fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n      reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n     wn_modn1 mod_gtnm)"
                ]
            },
            {
                "tactic_sig": "lazy beta iota delta [ iter dom_op dom_t reduce wn_modn1 zeron ] .",
                "tactic_sig_no_out_arg": "lazy beta iota delta [ iter dom_op dom_t reduce wn_modn1 zeron ] .",
                "tactic_args": [
                    "c1_goal : Logic.eq mod_gt\n  (iter t\n     (fun n : nat =>\n      let modulo_gt := ZnZ.modulo_gt in\n      fun x y : dom_t n => reduce n (modulo_gt x y))\n     (fun n : nat =>\n      let modulo_gt := ZnZ.modulo_gt in\n      fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n      reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n     wn_modn1 mod_gtnm)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq mod_gt\n  (let f0 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : W0.t => reduce_0 (modulo_gt x y) in\n   let f1 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w1 => reduce_1 (modulo_gt x y) in\n   let f2 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w2 => reduce_2 (modulo_gt x y) in\n   let f3 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w3 => reduce_3 (modulo_gt x y) in\n   let f4 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w4 => reduce_4 (modulo_gt x y) in\n   let f5 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w5 => reduce_5 (modulo_gt x y) in\n   let f6 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w6 => reduce_6 (modulo_gt x y) in\n   let f0n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : W0.t) (y : word W0.t (S m)) =>\n     reduce_0 (modulo_gt x (DoubleBase.get_low zero0 (S m) y)) in\n   let fn0 :=\n     let op := W0.ops in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     reduce_0 (dmodn1 (S m) x y) in\n   let f1n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w1) (y : word w1 (S m)) =>\n     reduce_1 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn1 :=\n     let op := w1_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     reduce_1 (dmodn1 (S m) x y) in\n   let f2n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w2) (y : word w2 (S m)) =>\n     reduce_2 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn2 :=\n     let op := w2_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     reduce_2 (dmodn1 (S m) x y) in\n   let f3n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w3) (y : word w3 (S m)) =>\n     reduce_3 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn3 :=\n     let op := w3_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     reduce_3 (dmodn1 (S m) x y) in\n   let f4n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w4) (y : word w4 (S m)) =>\n     reduce_4 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn4 :=\n     let op := w4_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     reduce_4 (dmodn1 (S m) x y) in\n   let f5n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w5) (y : word w5 (S m)) =>\n     reduce_5 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn5 :=\n     let op := w5_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     reduce_5 (dmodn1 (S m) x y) in\n   let f6n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w6) (y : word w6 (S m)) =>\n     reduce_6 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn6 :=\n     let op := w6_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     reduce_6 (dmodn1 (S m) x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f0n 0%nat wx wy\n       | N2 wy => f0n 1%nat wx wy\n       | N3 wy => f0n 2%nat wx wy\n       | N4 wy => f0n 3%nat wx wy\n       | N5 wy => f0n 4%nat wx wy\n       | N6 wy => f0n 5%nat wx wy\n       | Nn m wy =>\n           f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => f1n 0%nat wx wy\n       | N3 wy => f1n 1%nat wx wy\n       | N4 wy => f1n 2%nat wx wy\n       | N5 wy => f1n 3%nat wx wy\n       | N6 wy => f1n 4%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => f2n 0%nat wx wy\n       | N4 wy => f2n 1%nat wx wy\n       | N5 wy => f2n 2%nat wx wy\n       | N6 wy => f2n 3%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => f3n 0%nat wx wy\n       | N5 wy => f3n 1%nat wx wy\n       | N6 wy => f3n 2%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 wx))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => f4n 0%nat wx wy\n       | N6 wy => f4n 1%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 wx)) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => f5n 0%nat wx wy\n       | Nn m wy => f6n m (WW W0 wx) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => f6n m wx wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => mod_gtnm n m wx wy\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq mod_gt\n  (let f0 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : W0.t => reduce_0 (modulo_gt x y) in\n   let f1 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w1 => reduce_1 (modulo_gt x y) in\n   let f2 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w2 => reduce_2 (modulo_gt x y) in\n   let f3 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w3 => reduce_3 (modulo_gt x y) in\n   let f4 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w4 => reduce_4 (modulo_gt x y) in\n   let f5 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w5 => reduce_5 (modulo_gt x y) in\n   let f6 :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun x y : w6 => reduce_6 (modulo_gt x y) in\n   let f0n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : W0.t) (y : word W0.t (S m)) =>\n     reduce_0 (modulo_gt x (DoubleBase.get_low zero0 (S m) y)) in\n   let fn0 :=\n     let op := W0.ops in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word W0.t (S m)) (y : W0.t) =>\n     reduce_0 (dmodn1 (S m) x y) in\n   let f1n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w1) (y : word w1 (S m)) =>\n     reduce_1 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn1 :=\n     let op := w1_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w1 (S m)) (y : w1) =>\n     reduce_1 (dmodn1 (S m) x y) in\n   let f2n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w2) (y : word w2 (S m)) =>\n     reduce_2 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn2 :=\n     let op := w2_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w2 (S m)) (y : w2) =>\n     reduce_2 (dmodn1 (S m) x y) in\n   let f3n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w3) (y : word w3 (S m)) =>\n     reduce_3 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn3 :=\n     let op := w3_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w3 (S m)) (y : w3) =>\n     reduce_3 (dmodn1 (S m) x y) in\n   let f4n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w4) (y : word w4 (S m)) =>\n     reduce_4 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn4 :=\n     let op := w4_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w4 (S m)) (y : w4) =>\n     reduce_4 (dmodn1 (S m) x y) in\n   let f5n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w5) (y : word w5 (S m)) =>\n     reduce_5 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn5 :=\n     let op := w5_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w5 (S m)) (y : w5) =>\n     reduce_5 (dmodn1 (S m) x y) in\n   let f6n :=\n     let modulo_gt := ZnZ.modulo_gt in\n     fun (m : nat) (x : w6) (y : word w6 (S m)) =>\n     reduce_6 (modulo_gt x (DoubleBase.get_low W0 (S m) y)) in\n   let fn6 :=\n     let op := w6_op in\n     let zd := ZnZ.zdigits op in\n     let zero := ZnZ.zero in\n     let head0 := ZnZ.head0 in\n     let add_mul_div := ZnZ.add_mul_div in\n     let div21 := ZnZ.div21 in\n     let compare := ZnZ.compare in\n     let sub := ZnZ.sub in\n     let dmodn1 :=\n       DoubleDivn1.double_modn1 zd zero head0 add_mul_div div21 compare\n         sub in\n     fun (m : nat) (x : word w6 (S m)) (y : w6) =>\n     reduce_6 (dmodn1 (S m) x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f0n 0%nat wx wy\n       | N2 wy => f0n 1%nat wx wy\n       | N3 wy => f0n 2%nat wx wy\n       | N4 wy => f0n 3%nat wx wy\n       | N5 wy => f0n 4%nat wx wy\n       | N6 wy => f0n 5%nat wx wy\n       | Nn m wy =>\n           f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => fn0 0%nat wx wy\n       | N1 wy => f1 wx wy\n       | N2 wy => f1n 0%nat wx wy\n       | N3 wy => f1n 1%nat wx wy\n       | N4 wy => f1n 2%nat wx wy\n       | N5 wy => f1n 3%nat wx wy\n       | N6 wy => f1n 4%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => fn0 1%nat wx wy\n       | N1 wy => fn1 0%nat wx wy\n       | N2 wy => f2 wx wy\n       | N3 wy => f2n 0%nat wx wy\n       | N4 wy => f2n 1%nat wx wy\n       | N5 wy => f2n 2%nat wx wy\n       | N6 wy => f2n 3%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => fn0 2%nat wx wy\n       | N1 wy => fn1 1%nat wx wy\n       | N2 wy => fn2 0%nat wx wy\n       | N3 wy => f3 wx wy\n       | N4 wy => f3n 0%nat wx wy\n       | N5 wy => f3n 1%nat wx wy\n       | N6 wy => f3n 2%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 (WW W0 wx))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => fn0 3%nat wx wy\n       | N1 wy => fn1 2%nat wx wy\n       | N2 wy => fn2 1%nat wx wy\n       | N3 wy => fn3 0%nat wx wy\n       | N4 wy => f4 wx wy\n       | N5 wy => f4n 0%nat wx wy\n       | N6 wy => f4n 1%nat wx wy\n       | Nn m wy => f6n m (WW W0 (WW W0 wx)) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => fn0 4%nat wx wy\n       | N1 wy => fn1 3%nat wx wy\n       | N2 wy => fn2 2%nat wx wy\n       | N3 wy => fn3 1%nat wx wy\n       | N4 wy => fn4 0%nat wx wy\n       | N5 wy => f5 wx wy\n       | N6 wy => f5n 0%nat wx wy\n       | Nn m wy => f6n m (WW W0 wx) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy => fn0 5%nat wx wy\n       | N1 wy => fn1 4%nat wx wy\n       | N2 wy => fn2 3%nat wx wy\n       | N3 wy => fn3 2%nat wx wy\n       | N4 wy => fn4 1%nat wx wy\n       | N5 wy => fn5 0%nat wx wy\n       | N6 wy => f6 wx wy\n       | Nn m wy => f6n m wx wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn6 n wx\n             (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => fn6 n wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => fn6 n wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => fn6 n wx (WW W0 (WW W0 wy))\n       | N5 wy => fn6 n wx (WW W0 wy)\n       | N6 wy => fn6 n wx wy\n       | Nn m wy => mod_gtnm n m wx wy\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_mod_gt",
        "proof": [
            {
                "tactic_sig": "Theorem spec_mod_gt : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> [ mod_gt x y ] = [ x ] mod [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_mod_gt : forall x y , [ x ] > [ y ] -> 0 < [ y ] -> [ mod_gt x y ] = [ x ] mod [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_mod_gt_fold : Logic.eq mod_gt\n         (iter t\n            (fun n : nat =>\n             let modulo_gt := ZnZ.modulo_gt in\n             fun x y : dom_t n => reduce n (modulo_gt x y))\n            (fun n : nat =>\n             let modulo_gt := ZnZ.modulo_gt in\n             fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n             reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n            wn_modn1 mod_gtnm)"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq\n  (to_Z\n     (iter t\n        (fun n : nat =>\n         let modulo_gt := ZnZ.modulo_gt in\n         fun x y : dom_t n => reduce n (modulo_gt x y))\n        (fun n : nat =>\n         let modulo_gt := ZnZ.modulo_gt in\n         fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n         reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n        wn_modn1 mod_gtnm x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : forall (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\nLogic.eq\n  (to_Z\n     (iter t\n        (fun n : nat =>\n         let modulo_gt := ZnZ.modulo_gt in\n         fun x y : dom_t n => reduce n (modulo_gt x y))\n        (fun n : nat =>\n         let modulo_gt := ZnZ.modulo_gt in\n         fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n         reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n        wn_modn1 mod_gtnm x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_spec_iter : forall (res : Type) (P : forall (_ : Z) (_ : Z) (_ : res), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y))\n         (fd : forall (n m : nat) (_ : dom_t n) (_ : word (dom_t n) (S m)),\n               res)\n         (fg : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n),\n               res)\n         (_ : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m)),\n              P (ZnZ.to_Z x) (eval n (S m) y) (fd n m x y))\n         (_ : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n),\n              P (eval n (S m) x) (ZnZ.to_Z y) (fg n m x y))\n         (fnm : forall (n m : nat) (_ : word (dom_t 6) (S n))\n                  (_ : word (dom_t 6) (S m)), res)\n         (_ : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m)),\n              P (to_Z (Nn n x)) (to_Z (Nn m y)) (fnm n m x y)) \n         (x y : t), P (to_Z x) (to_Z y) (iter res f fd fg fnm x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (_ : Z.lt 0 (ZnZ.to_Z y)),\nLogic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun x0 y0 : dom_t n => reduce n (modulo_gt x0 y0)) x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c5_goal : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m))\n  (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nLogic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun (m0 : nat) (x0 : dom_t n) (y0 : word (dom_t n) (S m0)) =>\n       reduce n (modulo_gt x0 (DoubleBase.get_low (zeron n) (S m0) y0)))\n        m x y)) (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))",
                    "c6_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n)\n  (_ : Z.gt (eval n (S m) x) (ZnZ.to_Z y)) (_ : Z.lt 0 (ZnZ.to_Z y)),\nLogic.eq (to_Z (wn_modn1 n m x y))\n  (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))",
                    "c7_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m))\n  (_ : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y)))\n  (_ : Z.lt 0 (to_Z (Nn m y))),\nLogic.eq (to_Z (mod_gtnm n m x y))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y H1 H2 .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n) (_ : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (_ : Z.lt 0 (ZnZ.to_Z y)),\nLogic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun x0 y0 : dom_t n => reduce n (modulo_gt x0 y0)) x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun x y : dom_t n => reduce n (modulo_gt x y)) x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c8_n : nat",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c8_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun x y : dom_t n => reduce n (modulo_gt x y)) x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Z (reduce n (ZnZ.modulo_gt x y)))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z (reduce n (ZnZ.modulo_gt x y)))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (ZnZ.to_Z (ZnZ.modulo_gt x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_modulo_gt _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_modulo_gt _i _i _i _i ) .",
                "tactic_args": [
                    "c10_goal : Logic.eq (ZnZ.to_Z (ZnZ.modulo_gt x y))\n  (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c8_x : dom_t n",
                    "c8_y : dom_t n",
                    "c8_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z y)",
                    "c8_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c5_goal : forall (n m : nat) (x : dom_t n) (y : word (dom_t n) (S m))\n  (_ : Z.gt (ZnZ.to_Z x) (eval n (S m) y))\n  (_ : Z.lt 0 (eval n (S m) y)),\nLogic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun (m0 : nat) (x0 : dom_t n) (y0 : word (dom_t n) (S m0)) =>\n       reduce n (modulo_gt x0 (DoubleBase.get_low (zeron n) (S m0) y0)))\n        m x y)) (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n       reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y))) m\n        x y)) (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))",
                    "c11_n : nat",
                    "c11_m : nat",
                    "c11_x : dom_t n",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_H1 : Z.gt (ZnZ.to_Z x) (eval n (S m) y)",
                    "c11_H2 : Z.lt 0 (eval n (S m) y)"
                ]
            },
            {
                "tactic_sig": "cbv zeta beta .",
                "tactic_sig_no_out_arg": "cbv zeta beta .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (to_Z\n     ((let modulo_gt := ZnZ.modulo_gt in\n       fun (m : nat) (x : dom_t n) (y : word (dom_t n) (S m)) =>\n       reduce n (modulo_gt x (DoubleBase.get_low (zeron n) (S m) y))) m\n        x y)) (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (to_Z\n     (reduce n (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y))))\n  (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (to_Z\n     (reduce n (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y))))\n  (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)",
                    "c13_H1 : Z.gt (ZnZ.to_Z x) (eval n (S m) y)"
                ],
                "tactic_res": [
                    "c13_H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ( _i _i ) _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ( _i _i ) _i _i ) .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x) (eval n (S m) y))",
                    "_global_spec_get_endn : forall (n m : nat) (x : word (dom_t n) m) (y : dom_t n)\n         (_ : Z.le (eval n m x) (to_Z (mk_t n y))),\n       Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n         (eval n m x)",
                    "c11_n : nat",
                    "_global_S : forall _ : nat, nat",
                    "c11_m : nat",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x)\n     (to_Z (mk_t n (DoubleBase.get_low (zeron n) (S m) y))))",
                    "c15_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))",
                    "c13_H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c11_n : nat",
                    "c11_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x)\n     (to_Z (mk_t n (DoubleBase.get_low (zeron n) (S m) y))))",
                    "_global_spec_mk_t : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (mk_t n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x)\n     (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (ZnZ.to_Z (ZnZ.modulo_gt x (DoubleBase.get_low (zeron n) (S m) y)))\n  (Z.modulo (ZnZ.to_Z x)\n     (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y)))",
                    "_global_ZnZ.spec_modulo_gt : forall (a b : word w6 (S ?n)) (_ : Z.gt (ZnZ.to_Z a) (ZnZ.to_Z b))\n         (_ : Z.lt 0 (ZnZ.to_Z b)),\n       Logic.eq (ZnZ.to_Z (ZnZ.modulo_gt a b))\n         (Z.modulo (ZnZ.to_Z a) (ZnZ.to_Z b))\nwhere\n?n : [n : nat\n      m : nat\n      x : dom_t n\n      y : word (dom_t n) (S m)\n      H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)\n      H2 : Z.lt 0 (eval n (S m) y) |- nat]"
                ],
                "tactic_res": [
                    "c17_goal : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c18_goal : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ( _i _i ) _i _i ) , !spec_mk_t in _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ( _i _i ) _i _i ) , !spec_mk_t in _i .",
                "tactic_args": [
                    "c17_goal : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "_global_spec_get_endn : forall (n m : nat) (x : word (dom_t n) m) (y : dom_t n)\n         (_ : Z.le (eval n m x) (to_Z (mk_t n y))),\n       Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n         (eval n m x)",
                    "c11_n : nat",
                    "_global_S : forall _ : nat, nat",
                    "c11_m : nat",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c13_H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)"
                ],
                "tactic_res": [
                    "c19_goal : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c19_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c20_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c19_H1 : Z.gt (ZnZ.to_Z x) (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c11_n : nat",
                    "c11_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))",
                    "c13_H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c11_n : nat",
                    "c11_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ( _i _i ) _i _i ) , !spec_mk_t in _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ( _i _i ) _i _i ) , !spec_mk_t in _i .",
                "tactic_args": [
                    "c18_goal : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "_global_spec_get_endn : forall (n m : nat) (x : word (dom_t n) m) (y : dom_t n)\n         (_ : Z.le (eval n m x) (to_Z (mk_t n y))),\n       Logic.eq (to_Z (mk_t n (DoubleBase.get_low (zeron n) m x)))\n         (eval n m x)",
                    "c11_n : nat",
                    "_global_S : forall _ : nat, nat",
                    "c11_m : nat",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c11_H2 : Z.lt 0 (eval n (S m) y)"
                ],
                "tactic_res": [
                    "c21_goal : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c21_H2 : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c22_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c21_H2 : Z.lt 0 (ZnZ.to_Z (DoubleBase.get_low (zeron n) (S m) y))",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_n : nat",
                    "c11_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.le (eval n (S m) y) (to_Z (mk_t n x))",
                    "c13_H1 : Z.gt (to_Z (mk_t n x)) (eval n (S m) y)",
                    "c11_y : word (dom_t n) (S m)",
                    "c11_x : dom_t n",
                    "c11_n : nat",
                    "c11_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c6_goal : forall (n m : nat) (x : word (dom_t n) (S m)) (y : dom_t n)\n  (_ : Z.gt (eval n (S m) x) (ZnZ.to_Z y)) (_ : Z.lt 0 (ZnZ.to_Z y)),\nLogic.eq (to_Z (wn_modn1 n m x y))\n  (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq (to_Z (wn_modn1 n m x y))\n  (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))",
                    "c23_n : nat",
                    "c23_m : nat",
                    "c23_x : word (dom_t n) (S m)",
                    "c23_y : dom_t n",
                    "c23_H1 : Z.gt (eval n (S m) x) (ZnZ.to_Z y)",
                    "c23_H2 : Z.lt 0 (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c23_goal : Logic.eq (to_Z (wn_modn1 n m x y))\n  (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_wn_modn1 : forall (n m : nat) (_ : word (dom_t n) (S m)) (_ : dom_t n), t"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq\n  (to_Z\n     (reduce n\n        (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n           ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub\n           (S m) x y))) (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : Logic.eq\n  (to_Z\n     (reduce n\n        (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n           ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub\n           (S m) x y))) (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y)) (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c25_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y)) (Z.modulo (eval n (S m) x) (ZnZ.to_Z y))",
                    "_global_eval : forall (n m : nat) (_ : word (dom_t n) m), Z"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y)) (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y)) (Z.modulo (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_nmake_double : forall (n : nat) (ww : DoubleBase.univ_of_cycles) (w_op : ZnZ.Ops ww),\n       Logic.eq ZnZ.to_Z\n         (DoubleBase.double_to_Z (ZnZ.digits w_op) ZnZ.to_Z n)"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y))\n  (Z.modulo\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c27_goal : Logic.eq\n  (ZnZ.to_Z\n     (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n        ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub \n        (S m) x y))\n  (Z.modulo\n     (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z (S m) x)\n     (ZnZ.to_Z y))",
                    "_global_spec_modn1 : forall (n n0 : nat) (a : word (dom_t n) n0) \n         (b : dom_t n) (_ : Z.lt 0 (ZnZ.to_Z b)),\n       Logic.eq\n         (ZnZ.to_Z\n            (DoubleDivn1.double_modn1 (ZnZ.zdigits (dom_op n)) ZnZ.zero\n               ZnZ.head0 ZnZ.add_mul_div ZnZ.div21 ZnZ.compare ZnZ.sub n0 a b))\n         (Z.modulo\n            (DoubleBase.double_to_Z (ZnZ.digits (dom_op n)) ZnZ.to_Z n0 a)\n            (ZnZ.to_Z b))",
                    "c23_n : nat"
                ],
                "tactic_res": [
                    "c28_goal : Z.lt 0 (ZnZ.to_Z y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : Z.lt 0 (ZnZ.to_Z y)",
                    "c23_H2 : Z.lt 0 (ZnZ.to_Z y)",
                    "c23_y : dom_t n",
                    "c23_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m x y H1 H2 .",
                "tactic_args": [
                    "c7_goal : forall (n m : nat) (x : word w6 (S n)) (y : word w6 (S m))\n  (_ : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y)))\n  (_ : Z.lt 0 (to_Z (Nn m y))),\nLogic.eq (to_Z (mod_gtnm n m x y))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ],
                "tactic_res": [
                    "c29_goal : Logic.eq (to_Z (mod_gtnm n m x y))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_x : word w6 (S n)",
                    "c29_y : word w6 (S m)",
                    "c29_H1 : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y))",
                    "c29_H2 : Z.lt 0 (to_Z (Nn m y))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c29_goal : Logic.eq (to_Z (mod_gtnm n m x y))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_mod_gtnm : forall (n m : nat) (_ : word w6 (S n)) (_ : word w6 (S m)), t'"
                ],
                "tactic_res": [
                    "c30_goal : Logic.eq\n  (to_Z\n     (reduce_n (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite spec_reduce_n .",
                "tactic_sig_no_out_arg": "repeat rewrite spec_reduce_n .",
                "tactic_args": [
                    "c30_goal : Logic.eq\n  (to_Z\n     (reduce_n (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq\n  (to_Z\n     (Nn (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) , ( _i _i _i _i ) .",
                "tactic_args": [
                    "c31_goal : Logic.eq\n  (to_Z\n     (Nn (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo (to_Z (Nn n x)) (to_Z (Nn m y)))",
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_x : word w6 (S n)",
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_y : word w6 (S m)"
                ],
                "tactic_res": [
                    "c32_goal : Logic.eq\n  (to_Z\n     (Nn (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c32_goal : Logic.eq\n  (to_Z\n     (Nn (Nat.max n m)\n        (ZnZ.modulo_gt\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))\n  (Z.modulo\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n     (to_Z\n        (Nn (Nat.max n m)\n           (castm (diff_l n m) (extend_tr y (fst (diff n m)))))))",
                    "_global_to_Z : forall _ : t, Z"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq\n  (ZnZ.to_Z\n     (ZnZ.modulo_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n  (Z.modulo\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c33_goal : Logic.eq\n  (ZnZ.to_Z\n     (ZnZ.modulo_gt (castm (diff_r n m) (extend_tr x (snd (diff n m))))\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))\n  (Z.modulo\n     (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n     (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "_global_ZnZ.spec_modulo_gt : forall (a b : word w6 (S ?n)) (_ : Z.gt (ZnZ.to_Z a) (ZnZ.to_Z b))\n         (_ : Z.lt 0 (ZnZ.to_Z b)),\n       Logic.eq (ZnZ.to_Z (ZnZ.modulo_gt a b))\n         (Z.modulo (ZnZ.to_Z a) (ZnZ.to_Z b))\nwhere\n?n : [n : nat\n      m : nat\n      x : word w6 (S n)\n      y : word w6 (S m)\n      H1 : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y))\n      H2 : Z.lt 0 (to_Z (Nn m y)) |- nat]"
                ],
                "tactic_res": [
                    "c34_goal : Z.gt (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n  (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c35_goal : Z.lt 0 (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_l : forall (n m : nat) (x1 : word w6 (S n)),\n       Logic.eq (to_Z (Nn n x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_r n m) (extend_tr x1 (snd (diff n m))))))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_x : word w6 (S n)",
                    "c34_H1 : Z.gt (to_Z (Nn n x)) (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c34_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z (Nn m y))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_y : word w6 (S m)",
                    "c34_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c34_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Z.gt (ZnZ.to_Z (castm (diff_r n m) (extend_tr x (snd (diff n m)))))\n  (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c34_H1 : Z.gt\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_r n m) (extend_tr x (snd (diff n m))))))\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "c29_y : word w6 (S m)",
                    "c29_x : word w6 (S n)",
                    "c29_n : nat",
                    "c29_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_spec_cast_r : forall (n m : nat) (x1 : word w6 (S m)),\n       Logic.eq (to_Z (Nn m x1))\n         (to_Z\n            (Nn (Nat.max n m)\n               (castm (diff_l n m) (extend_tr x1 (fst (diff n m))))))",
                    "c29_n : nat",
                    "c29_m : nat",
                    "c29_y : word w6 (S m)",
                    "c35_H2 : Z.lt 0 (to_Z (Nn m y))"
                ],
                "tactic_res": [
                    "c35_H2 : Z.lt 0\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : Z.lt 0 (ZnZ.to_Z (castm (diff_l n m) (extend_tr y (fst (diff n m)))))",
                    "c35_H2 : Z.lt 0\n  (to_Z\n     (Nn (Nat.max n m)\n        (castm (diff_l n m) (extend_tr y (fst (diff n m))))))",
                    "c29_y : word w6 (S m)",
                    "c29_n : nat",
                    "c29_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_modulo",
        "proof": [
            {
                "tactic_sig": "Theorem spec_modulo : forall x y , [ modulo x y ] = [ x ] mod [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_modulo : forall x y , [ modulo x y ] = [ x ] mod [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t,\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : t,\nLogic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (modulo x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_modulo : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb y zero\n      then x\n      else\n       match compare x y with\n       | Eq => zero\n       | Lt => x\n       | Gt => mod_gt x y\n       end)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb y zero\n      then x\n      else\n       match compare x y with\n       | Eq => zero\n       | Lt => x\n       | Gt => mod_gt x y\n       end)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_spec_eqb : forall x y : t, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z y) 0\n      then x\n      else\n       match Z.compare (to_Z x) (to_Z y) with\n       | Eq => zero\n       | Lt => x\n       | Gt => mod_gt x y\n       end)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z y) 0\n      then x\n      else\n       match Z.compare (to_Z x) (to_Z y) with\n       | Eq => zero\n       | Lt => x\n       | Gt => mod_gt x y\n       end)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))",
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nLogic.eq\n  (to_Z\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => zero\n     | Lt => x\n     | Gt => mod_gt x y\n     end) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros -> .",
                "tactic_sig_no_out_arg": "intros -> .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z y) 0,\nLogic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (to_Z x) (Z.modulo (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "destruct [ _i ] as [  | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct [ _i ] .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z x) (Z.modulo (to_Z x) 0)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq 0 (Z.modulo 0 0)",
                    "c9_goal : Logic.eq (Zpos p) (Z.modulo (Zpos p) 0)",
                    "c9_p : positive",
                    "c10_goal : Logic.eq (Zneg p) (Z.modulo (Zneg p) 0)",
                    "c10_p : positive"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Logic.eq 0 (Z.modulo 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Zpos p) (Z.modulo (Zpos p) 0)",
                    "c9_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Zneg p) (Z.modulo (Zneg p) 0)",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H' .",
                "tactic_args": [
                    "c6_goal : forall _ : not (Logic.eq (to_Z y) 0),\nLogic.eq\n  (to_Z\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => zero\n     | Lt => x\n     | Gt => mod_gt x y\n     end) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => zero\n     | Lt => x\n     | Gt => mod_gt x y\n     end) (Z.modulo (to_Z x) (to_Z y))",
                    "c11_H' : not (Logic.eq (to_Z y) 0)"
                ]
            },
            {
                "tactic_sig": "assert ( H : 0 < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto with zarith ) .",
                "tactic_sig_no_out_arg": "assert ( H : 0 < [ _i ] ) by ( generalize ( spec_pos _i ) ; auto with zarith ) .",
                "tactic_args": [
                    "c2_y : True",
                    "c2_y : True",
                    "c11_H' : not (Logic.eq (to_Z y) 0)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c11_H : Z.lt 0 (to_Z y)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c11_H' : not (Logic.eq (to_Z y) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z x) (to_Z y) with\n     | Eq => zero\n     | Lt => x\n     | Gt => mod_gt x y\n     end) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq (to_Z zero) (Z.modulo (to_Z x) (to_Z y))",
                    "c13_goal : forall _ : Z.lt (to_Z x) (to_Z y),\nLogic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))",
                    "c14_goal : forall _ : Z.lt (to_Z y) (to_Z x),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_sig_no_out_arg": "rewrite ?spec_0 , ?spec_1 .",
                "tactic_args": [
                    "c12_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq (to_Z zero) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq 0 (Z.modulo (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (to_Z x) (to_Z y),\nLogic.eq 0 (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq 0 (Z.modulo (to_Z x) (to_Z y))",
                    "c16_H0 : Logic.eq (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.lt (to_Z x) (to_Z y),\nLogic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))",
                    "c17_H0 : Z.lt (to_Z x) (to_Z y)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall _ : Z.lt (to_Z y) (to_Z x),\nLogic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "c18_H0 : Z.lt (to_Z y) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq 0 (Z.modulo (to_Z x) (to_Z y))",
                    "c16_H0 : Logic.eq (to_Z x) (to_Z y)"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq 0 (Z.modulo (to_Z y) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c19_goal : Logic.eq 0 (Z.modulo (to_Z y) (to_Z y))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq (Z.modulo (to_Z y) (to_Z y)) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : Logic.eq (Z.modulo (to_Z y) (to_Z y)) 0",
                    "_global_Z_mod_same : forall (a : Z) (_ : Z.gt a 0), Logic.eq (Z.modulo a a) 0"
                ],
                "tactic_res": [
                    "c21_goal : Z.gt (to_Z y) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.gt (to_Z y) 0",
                    "c11_H : Z.lt 0 (to_Z y)",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c17_goal : Logic.eq (to_Z x) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.modulo (to_Z x) (to_Z y)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.modulo (to_Z x) (to_Z y)) (to_Z x)",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)),\n       Logic.eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c23_goal : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_pos _i ) .",
                "tactic_args": [
                    "c23_goal : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : Z.le 0 (to_Z x),\nand (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : forall _ : Z.le 0 (to_Z x),\nand (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (to_Z y))",
                    "c17_H0 : Z.lt (to_Z x) (to_Z y)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))",
                    "_global_spec_mod_gt : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\n       Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c25_goal : Z.gt (to_Z x) (to_Z y)",
                    "c26_goal : Z.lt 0 (to_Z y)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : Z.gt (to_Z x) (to_Z y)",
                    "c18_H0 : Z.lt (to_Z y) (to_Z x)",
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 (to_Z y)",
                    "c11_H : Z.lt 0 (to_Z y)",
                    "c2_y : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "square_fold",
        "proof": [
            {
                "tactic_sig": "Lemma square_fold : square = iter_t squaren .",
                "tactic_sig_no_out_arg": "Lemma square_fold : square = iter_t squaren .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq square\n  (iter_t\n     (fun n : nat =>\n      let square_c := ZnZ.square_c in\n      fun x : dom_t n => reduce (S n) (succ_t n (square_c x))))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq square\n  (iter_t\n     (fun n : nat =>\n      let square_c := ZnZ.square_c in\n      fun x : dom_t n => reduce (S n) (succ_t n (square_c x))))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq square\n  (let f0 :=\n     let square_c := ZnZ.square_c in\n     fun x : W0.t => reduce_1 (square_c x) in\n   let f1 :=\n     let square_c := ZnZ.square_c in\n     fun x : w1 => reduce_2 (square_c x) in\n   let f2 :=\n     let square_c := ZnZ.square_c in\n     fun x : w2 => reduce_3 (square_c x) in\n   let f3 :=\n     let square_c := ZnZ.square_c in\n     fun x : w3 => reduce_4 (square_c x) in\n   let f4 :=\n     let square_c := ZnZ.square_c in\n     fun x : w4 => reduce_5 (square_c x) in\n   let f5 :=\n     let square_c := ZnZ.square_c in\n     fun x : w5 => reduce_6 (square_c x) in\n   let f6 :=\n     let square_c := ZnZ.square_c in\n     fun x : w6 => reduce_n 0 (square_c x) in\n   let fn :=\n     fun n : nat =>\n     let square_c := ZnZ.square_c in\n     fun x : word w6 (S n) => reduce_n (S n) (square_c x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq square\n  (let f0 :=\n     let square_c := ZnZ.square_c in\n     fun x : W0.t => reduce_1 (square_c x) in\n   let f1 :=\n     let square_c := ZnZ.square_c in\n     fun x : w1 => reduce_2 (square_c x) in\n   let f2 :=\n     let square_c := ZnZ.square_c in\n     fun x : w2 => reduce_3 (square_c x) in\n   let f3 :=\n     let square_c := ZnZ.square_c in\n     fun x : w3 => reduce_4 (square_c x) in\n   let f4 :=\n     let square_c := ZnZ.square_c in\n     fun x : w4 => reduce_5 (square_c x) in\n   let f5 :=\n     let square_c := ZnZ.square_c in\n     fun x : w5 => reduce_6 (square_c x) in\n   let f6 :=\n     let square_c := ZnZ.square_c in\n     fun x : w6 => reduce_n 0 (square_c x) in\n   let fn :=\n     fun n : nat =>\n     let square_c := ZnZ.square_c in\n     fun x : word w6 (S n) => reduce_n (S n) (square_c x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_square",
        "proof": [
            {
                "tactic_sig": "Theorem spec_square : forall x , [ square x ] = [ x ] * [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_square : forall x , [ square x ] = [ x ] * [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))",
                    "_global_square_fold : Logic.eq square\n         (iter_t\n            (fun n : nat =>\n             let square_c := ZnZ.square_c in\n             fun x : dom_t n => reduce (S n) (succ_t n (square_c x))))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let square_c := ZnZ.square_c in\n         fun x : dom_t n => reduce (S n) (succ_t n (square_c x))) x))\n  (Z.mul (to_Z x) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let square_c := ZnZ.square_c in\n         fun x : dom_t n => reduce (S n) (succ_t n (square_c x))) x))\n  (Z.mul (to_Z x) (to_Z x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (succ_t n (ZnZ.square_c x)))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z x))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (succ_t n (ZnZ.square_c x)))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z x))",
                    "_global_spec_succ_t : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (ZnZ.to_Z (succ_t n x))\n         (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.square_c x))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z x))"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_square_c _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_square_c _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (ZnZ.square_c x))\n  (Z.mul (ZnZ.to_Z x) (ZnZ.to_Z x))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sqrt_fold",
        "proof": [
            {
                "tactic_sig": "Lemma sqrt_fold : sqrt = iter_t sqrtn .",
                "tactic_sig_no_out_arg": "Lemma sqrt_fold : sqrt = iter_t sqrtn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq sqrt\n  (iter_t\n     (fun n : nat =>\n      let sqrt := ZnZ.sqrt in fun x : dom_t n => reduce n (sqrt x)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq sqrt\n  (iter_t\n     (fun n : nat =>\n      let sqrt := ZnZ.sqrt in fun x : dom_t n => reduce n (sqrt x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq sqrt\n  (let f0 := let sqrt := ZnZ.sqrt in fun x : W0.t => reduce_0 (sqrt x)\n     in\n   let f1 := let sqrt := ZnZ.sqrt in fun x : w1 => reduce_1 (sqrt x) in\n   let f2 := let sqrt := ZnZ.sqrt in fun x : w2 => reduce_2 (sqrt x) in\n   let f3 := let sqrt := ZnZ.sqrt in fun x : w3 => reduce_3 (sqrt x) in\n   let f4 := let sqrt := ZnZ.sqrt in fun x : w4 => reduce_4 (sqrt x) in\n   let f5 := let sqrt := ZnZ.sqrt in fun x : w5 => reduce_5 (sqrt x) in\n   let f6 := let sqrt := ZnZ.sqrt in fun x : w6 => reduce_6 (sqrt x) in\n   let fn :=\n     fun n : nat =>\n     let sqrt := ZnZ.sqrt in\n     fun x : word w6 (S n) => reduce_n n (sqrt x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq sqrt\n  (let f0 := let sqrt := ZnZ.sqrt in fun x : W0.t => reduce_0 (sqrt x)\n     in\n   let f1 := let sqrt := ZnZ.sqrt in fun x : w1 => reduce_1 (sqrt x) in\n   let f2 := let sqrt := ZnZ.sqrt in fun x : w2 => reduce_2 (sqrt x) in\n   let f3 := let sqrt := ZnZ.sqrt in fun x : w3 => reduce_3 (sqrt x) in\n   let f4 := let sqrt := ZnZ.sqrt in fun x : w4 => reduce_4 (sqrt x) in\n   let f5 := let sqrt := ZnZ.sqrt in fun x : w5 => reduce_5 (sqrt x) in\n   let f6 := let sqrt := ZnZ.sqrt in fun x : w6 => reduce_6 (sqrt x) in\n   let fn :=\n     fun n : nat =>\n     let sqrt := ZnZ.sqrt in\n     fun x : word w6 (S n) => reduce_n n (sqrt x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sqrt_aux",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sqrt_aux : forall x , [ sqrt x ] ^ 2 <= [ x ] < ( [ sqrt x ] + 1 ) ^ 2 .",
                "tactic_sig_no_out_arg": "Theorem spec_sqrt_aux : forall x , [ sqrt x ] ^ 2 <= [ x ] < ( [ sqrt x ] + 1 ) ^ 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t,\nand (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.add (to_Z (sqrt x)) 1) 2))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t,\nand (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.add (to_Z (sqrt x)) 1) 2))"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.add (to_Z (sqrt x)) 1) 2))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : and (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.add (to_Z (sqrt x)) 1) 2))",
                    "_global_sqrt_fold : Logic.eq sqrt\n         (iter_t\n            (fun n : nat =>\n             let sqrt := ZnZ.sqrt in fun x : dom_t n => reduce n (sqrt x)))"
                ],
                "tactic_res": [
                    "c3_goal : and\n  (Z.le\n     (Z.pow\n        (to_Z\n           (iter_t\n              (fun n : nat =>\n               let sqrt := ZnZ.sqrt in\n               fun x : dom_t n => reduce n (sqrt x)) x)) 2) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow\n        (Z.add\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let sqrt := ZnZ.sqrt in\n                  fun x : dom_t n => reduce n (sqrt x)) x)) 1) 2))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : and\n  (Z.le\n     (Z.pow\n        (to_Z\n           (iter_t\n              (fun n : nat =>\n               let sqrt := ZnZ.sqrt in\n               fun x : dom_t n => reduce n (sqrt x)) x)) 2) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow\n        (Z.add\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let sqrt := ZnZ.sqrt in\n                  fun x : dom_t n => reduce n (sqrt x)) x)) 1) 2))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : and (Z.le (Z.pow (ZnZ.to_Z (ZnZ.sqrt x)) 2) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow (Z.add (ZnZ.to_Z (ZnZ.sqrt x)) 1) 2))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_sqrt _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_sqrt _i ) .",
                "tactic_args": [
                    "c4_goal : and (Z.le (Z.pow (ZnZ.to_Z (ZnZ.sqrt x)) 2) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow (Z.add (ZnZ.to_Z (ZnZ.sqrt x)) 1) 2))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_sqrt",
        "proof": [
            {
                "tactic_sig": "Theorem spec_sqrt : forall x , [ sqrt x ] = Z.sqrt [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_sqrt : forall x , [ sqrt x ] = Z.sqrt [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (sqrt x)) (Z.sqrt (to_Z x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Z.sqrt (to_Z x)) (to_Z (sqrt x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Z.sqrt (to_Z x)) (to_Z (sqrt x))",
                    "_global_Z.sqrt_unique : forall (a b : Z)\n         (_ : and (Z.le (Z.mul b b) a) (Z.lt a (Z.mul (Z.succ b) (Z.succ b)))),\n       Logic.eq (Z.sqrt a) b"
                ],
                "tactic_res": [
                    "c4_goal : and (Z.le (Z.mul (to_Z (sqrt x)) (to_Z (sqrt x))) (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.mul (Z.succ (to_Z (sqrt x))) (Z.succ (to_Z (sqrt x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ! _i .",
                "tactic_sig_no_out_arg": "rewrite <- ! _i .",
                "tactic_args": [
                    "c4_goal : and (Z.le (Z.mul (to_Z (sqrt x)) (to_Z (sqrt x))) (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.mul (Z.succ (to_Z (sqrt x))) (Z.succ (to_Z (sqrt x)))))",
                    "_global_Z.pow_2_r : forall a : Z, Logic.eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c5_goal : and (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.succ (to_Z (sqrt x))) 2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : and (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow (Z.succ (to_Z (sqrt x))) 2))",
                    "_global_spec_sqrt_aux : forall x : t,\n       and (Z.le (Z.pow (to_Z (sqrt x)) 2) (to_Z x))\n         (Z.lt (to_Z x) (Z.pow (Z.add (to_Z (sqrt x)) 1) 2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow_pos : forall x n , [ pow_pos x n ] = [ x ] ^ Zpos n .",
                "tactic_sig_no_out_arg": "Theorem spec_pow_pos : forall x n , [ pow_pos x n ] = [ x ] ^ Zpos n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x n .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (n : positive),\nLogic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))",
                    "c2_x : True",
                    "c2_n : positive"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : forall x : t, Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall x : t, Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))",
                    "c2_n : positive"
                ],
                "tactic_res": [
                    "c4_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (pow_pos x (xI p))) (Z.pow (to_Z x) (Zpos (xI p)))",
                    "c5_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (pow_pos x (xO p))) (Z.pow (to_Z x) (Zpos (xO p)))",
                    "c6_goal : forall x : t, Logic.eq (to_Z (pow_pos x 1)) (Z.pow (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_n : positive",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl pow_pos .",
                "tactic_sig_no_out_arg": "simpl pow_pos .",
                "tactic_args": [
                    "c4_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (pow_pos x (xI p))) (Z.pow (to_Z x) (Zpos (xI p)))"
                ],
                "tactic_res": [
                    "c7_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (mul (square (pow_pos x p)) x))\n  (Z.pow (to_Z x) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_n : positive",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl pow_pos .",
                "tactic_sig_no_out_arg": "simpl pow_pos .",
                "tactic_args": [
                    "c5_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (pow_pos x (xO p))) (Z.pow (to_Z x) (Zpos (xO p)))"
                ],
                "tactic_res": [
                    "c8_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (square (pow_pos x p))) (Z.pow (to_Z x) (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_n : positive",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl pow_pos .",
                "tactic_sig_no_out_arg": "simpl pow_pos .",
                "tactic_args": [
                    "c6_goal : forall x : t, Logic.eq (to_Z (pow_pos x 1)) (Z.pow (to_Z x) 1)"
                ],
                "tactic_res": [
                    "c9_goal : forall x : t, Logic.eq (to_Z x) (Z.pow (to_Z x) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (mul (square (pow_pos x p)) x))\n  (Z.pow (to_Z x) (Zpos (xI p)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (mul (square (pow_pos x p)) x))\n  (Z.pow (to_Z x) (Zpos (xI p)))",
                    "c10_p : positive",
                    "c10_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c10_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (mul (square (pow_pos x p)) x))\n  (Z.pow (to_Z x) (Zpos (xI p)))",
                    "_global_spec_mul : forall x y : t, Logic.eq (to_Z (mul x y)) (Z.mul (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.mul (to_Z (square (pow_pos x p))) (to_Z x))\n  (Z.pow (to_Z x) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.mul (to_Z (square (pow_pos x p))) (to_Z x))\n  (Z.pow (to_Z x) (Zpos (xI p)))",
                    "_global_spec_square : forall x : t, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq\n  (Z.mul (Z.mul (to_Z (pow_pos x p)) (to_Z (pow_pos x p))) (to_Z x))\n  (Z.pow (to_Z x) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq\n  (Z.mul (Z.mul (to_Z (pow_pos x p)) (to_Z (pow_pos x p))) (to_Z x))\n  (Z.pow (to_Z x) (Zpos (xI p)))",
                    "c10_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x)) (Z.pow (to_Z x) (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x)) (Z.pow (to_Z x) (Zpos (xI p)))",
                    "_global_Pos2Z.inj_xI : forall p : positive,\n       Logic.eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x)) (Z.pow (to_Z x) (Z.add (Z.mul 2 (Zpos p)) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x)) (Z.pow (to_Z x) (Z.add (Z.mul 2 (Zpos p)) 1))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))",
                    "c10_x : True",
                    "c10_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c10_p : positive"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (to_Z x) (Z.mul 2 (Zpos p))) (Z.pow (to_Z x) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i 2 ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i 2 ) .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (to_Z x) (Z.mul 2 (Zpos p))) (Z.pow (to_Z x) 1))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (to_Z x) (Z.mul (Zpos p) 2)) (Z.pow (to_Z x) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (to_Z x) (Z.mul (Zpos p) 2)) (Z.pow (to_Z x) 1))",
                    "_global_Z.pow_mul_r : forall (a b c : Z) (_ : Z.le 0 b) (_ : Z.le 0 c),\n       Logic.eq (Z.pow a (Z.mul b c)) (Z.pow (Z.pow a b) c)",
                    "c10_x : True",
                    "c10_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c10_p : positive"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (Z.pow (to_Z x) (Zpos p)) 2) (Z.pow (to_Z x) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.pow (Z.pow (to_Z x) (Zpos p)) 2) (Z.pow (to_Z x) 1))",
                    "_global_Z.pow_2_r : forall a : Z, Logic.eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (Z.pow (to_Z x) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (Z.pow (to_Z x) 1))",
                    "_global_Z.pow_1_r : forall a : Z, Logic.eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Logic.eq\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))\n  (Z.mul (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n     (to_Z x))",
                    "c10_x : True",
                    "c10_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (p : positive)\n  (_ : forall x : t,\n       Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))) \n  (x : t),\nLogic.eq (to_Z (square (pow_pos x p))) (Z.pow (to_Z x) (Zpos (xO p)))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq (to_Z (square (pow_pos x p))) (Z.pow (to_Z x) (Zpos (xO p)))",
                    "c20_p : positive",
                    "c20_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c20_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : Logic.eq (to_Z (square (pow_pos x p))) (Z.pow (to_Z x) (Zpos (xO p)))",
                    "_global_spec_square : forall x : t, Logic.eq (to_Z (square x)) (Z.mul (to_Z x) (to_Z x))"
                ],
                "tactic_res": [
                    "c21_goal : Logic.eq (Z.mul (to_Z (pow_pos x p)) (to_Z (pow_pos x p)))\n  (Z.pow (to_Z x) (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : Logic.eq (Z.mul (to_Z (pow_pos x p)) (to_Z (pow_pos x p)))\n  (Z.pow (to_Z x) (Zpos (xO p)))",
                    "c20_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Zpos (xO p)))",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Z.mul 2 (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i 2 ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i 2 ) .",
                "tactic_args": [
                    "c23_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Z.mul 2 (Zpos p)))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Z.mul (Zpos p) 2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c24_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (to_Z x) (Z.mul (Zpos p) 2))",
                    "_global_Z.pow_mul_r : forall (a b c : Z) (_ : Z.le 0 b) (_ : Z.le 0 c),\n       Logic.eq (Z.pow a (Z.mul b c)) (Z.pow (Z.pow a b) c)",
                    "c20_x : True",
                    "c20_H : forall x : t, Logic.eq (to_Z (pow_pos x p)) (Z.pow (to_Z x) (Zpos p))",
                    "c20_p : positive"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (Z.pow (to_Z x) (Zpos p)) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c25_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.pow (Z.pow (to_Z x) (Zpos p)) 2)",
                    "_global_Z.pow_2_r : forall a : Z, Logic.eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))\n  (Z.mul (Z.pow (to_Z x) (Zpos p)) (Z.pow (to_Z x) (Zpos p)))",
                    "c20_x : True",
                    "c20_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall x : t, Logic.eq (to_Z x) (Z.pow (to_Z x) 1)"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq (to_Z x) (Z.pow (to_Z x) 1)",
                    "c27_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : Logic.eq (to_Z x) (Z.pow (to_Z x) 1)",
                    "_global_Z.pow_1_r : forall a : Z, Logic.eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq (to_Z x) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : Logic.eq (to_Z x) (to_Z x)",
                    "c27_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow_N",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow_N : forall x n , to_Z ( pow_N x n ) = to_Z x ^ Z.of_N n .",
                "tactic_sig_no_out_arg": "Theorem spec_pow_N : forall x n , to_Z ( pow_N x n ) = to_Z x ^ Z.of_N n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (n : N),\nLogic.eq (to_Z (pow_N x n)) (Z.pow (to_Z x) (Z.of_N n))"
                ]
            },
            {
                "tactic_sig": "destruct n as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct n .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (n : N),\nLogic.eq (to_Z (pow_N x n)) (Z.pow (to_Z x) (Z.of_N n))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pow_N x 0)) (Z.pow (to_Z x) (Z.of_N 0%N))",
                    "c2_x : True",
                    "c3_goal : Logic.eq (to_Z (pow_N x (Npos p))) (Z.pow (to_Z x) (Z.of_N (Npos p)))",
                    "c3_p : positive",
                    "c3_x : True"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pow_N x 0)) (Z.pow (to_Z x) (Z.of_N 0%N))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (ZnZ.to_Z ZnZ.one) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (pow_N x (Npos p))) (Z.pow (to_Z x) (Z.of_N (Npos p)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (ZnZ.to_Z ZnZ.one) 1",
                    "_global_spec_1 : Logic.eq (to_Z one) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (pow_pos x p)) (Z.pow_pos (to_Z x) p)",
                    "_global_spec_pow_pos : forall (x : t) (n : positive),\n       Logic.eq (to_Z (pow_pos x n)) (Z.pow (to_Z x) (Zpos n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_pow",
        "proof": [
            {
                "tactic_sig": "Theorem spec_pow : forall x y , [ pow x y ] = [ x ] ^ [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_pow : forall x y , [ pow x y ] = [ x ] ^ [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y : t, Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (pow x y)) (Z.pow (to_Z x) (to_Z y))",
                    "_global_pow : forall (_ : t) (_ : t), t",
                    "_global_to_N : forall _ : t, N"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (pow_N x (Z.to_N (to_Z y)))) (Z.pow (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "now rewrite spec_pow_N , Z2N.id by apply spec_pos .",
                "tactic_sig_no_out_arg": "now rewrite spec_pow_N , Z2N.id by apply spec_pos .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (pow_N x (Z.to_N (to_Z y)))) (Z.pow (to_Z x) (to_Z y))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "digits_fold",
        "proof": [
            {
                "tactic_sig": "Lemma digits_fold : digits = iter_t digitsn .",
                "tactic_sig_no_out_arg": "Lemma digits_fold : digits = iter_t digitsn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq digits\n  (iter_t\n     (fun n : nat =>\n      let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq digits\n  (iter_t\n     (fun n : nat =>\n      let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq digits\n  (let f0 := let digits := ZnZ.digits W0.ops in fun _ : W0.t => digits\n     in\n   let f1 := let digits := ZnZ.digits w1_op in fun _ : w1 => digits in\n   let f2 := let digits := ZnZ.digits w2_op in fun _ : w2 => digits in\n   let f3 := let digits := ZnZ.digits w3_op in fun _ : w3 => digits in\n   let f4 := let digits := ZnZ.digits w4_op in fun _ : w4 => digits in\n   let f5 := let digits := ZnZ.digits w5_op in fun _ : w5 => digits in\n   let f6 := let digits := ZnZ.digits w6_op in fun _ : w6 => digits in\n   let fn :=\n     fun n : nat =>\n     let digits := ZnZ.digits (make_op n) in\n     fun _ : word w6 (S n) => digits in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq digits\n  (let f0 := let digits := ZnZ.digits W0.ops in fun _ : W0.t => digits\n     in\n   let f1 := let digits := ZnZ.digits w1_op in fun _ : w1 => digits in\n   let f2 := let digits := ZnZ.digits w2_op in fun _ : w2 => digits in\n   let f3 := let digits := ZnZ.digits w3_op in fun _ : w3 => digits in\n   let f4 := let digits := ZnZ.digits w4_op in fun _ : w4 => digits in\n   let f5 := let digits := ZnZ.digits w5_op in fun _ : w5 => digits in\n   let f6 := let digits := ZnZ.digits w6_op in fun _ : w6 => digits in\n   let fn :=\n     fun n : nat =>\n     let digits := ZnZ.digits (make_op n) in\n     fun _ : word w6 (S n) => digits in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_digits",
        "proof": [
            {
                "tactic_sig": "Theorem spec_digits : forall x , 0 <= [ x ] < 2 ^ Zpos ( digits x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_digits : forall x , 0 <= [ x ] < 2 ^ Zpos ( digits x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t,\nand (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t,\nand (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x))))"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x))))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (to_Z x)) (Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x))))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c3_goal : and (Z.le 0 (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : and (Z.le 0 (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "digits_level",
        "proof": [
            {
                "tactic_sig": "Lemma digits_level : forall x , digits x = ZnZ.digits ( dom_op ( level x ) ) .",
                "tactic_sig_no_out_arg": "Lemma digits_level : forall x , digits x = ZnZ.digits ( dom_op ( level x ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (iter_t\n     (fun n : nat =>\n      let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits)\n     x) (ZnZ.digits (dom_op (level x)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (iter_t\n     (fun n : nat =>\n      let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits)\n     x) (ZnZ.digits (dom_op (level x)))",
                    "_global_level : forall _ : t, nat"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (iter_t (fun (n : nat) (_ : dom_t n) => ZnZ.digits (dom_op n)) x)\n  (ZnZ.digits (dom_op (iter_t (fun (n : nat) (_ : dom_t n) => n) x)))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (iter_t (fun (n : nat) (_ : dom_t n) => ZnZ.digits (dom_op n)) x)\n  (ZnZ.digits (dom_op (iter_t (fun (n : nat) (_ : dom_t n) => n) x)))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op n))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : Logic.eq (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zspec_gcd_gt_body",
        "proof": [
            {
                "tactic_sig": "Theorem Zspec_gcd_gt_body : forall a b cont p , [ a ] > [ b ] -> [ a ] < 2 ^ p -> ( forall a1 b1 , [ a1 ] < 2 ^ ( p - 1 ) -> [ a1 ] > [ b1 ] -> Zis_gcd [ a1 ] [ b1 ] [ cont a1 b1 ] ) -> Zis_gcd [ a ] [ b ] [ gcd_gt_body a b cont ] .",
                "tactic_sig_no_out_arg": "Theorem Zspec_gcd_gt_body : forall a b cont p , [ a ] > [ b ] -> [ a ] < 2 ^ p -> ( forall a1 b1 , [ a1 ] < 2 ^ ( p - 1 ) -> [ a1 ] > [ b1 ] -> Zis_gcd [ a1 ] [ b1 ] [ cont a1 b1 ] ) -> Zis_gcd [ a ] [ b ] [ gcd_gt_body a b cont ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a b : t) (cont : forall (_ : t) (_ : t), t) \n  (p : Z) (_ : Z.gt (to_Z a) (to_Z b)) (_ : Z.lt (to_Z a) (Z.pow 2 p))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b cont p H2 H3 H4 .",
                "tactic_args": [
                    "c1_goal : forall (a b : t) (cont : forall (_ : t) (_ : t), t) \n  (p : Z) (_ : Z.gt (to_Z a) (to_Z b)) (_ : Z.lt (to_Z a) (Z.pow 2 p))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))"
                ],
                "tactic_res": [
                    "c2_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))",
                    "c2_a : True",
                    "c2_b : True",
                    "c2_cont : forall (_ : t) (_ : t), t",
                    "c2_p : Z",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_H3 : Z.lt (to_Z a) (Z.pow 2 p)",
                    "c2_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))",
                    "_global_gcd_gt_body : forall (_ : t') (_ : t) (_ : forall (_ : t) (_ : t), t'), t'"
                ],
                "tactic_res": [
                    "c3_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match compare b zero with\n     | Gt =>\n         match compare (mod_gt a b) zero with\n         | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n         | _ => b\n         end\n     | _ => a\n     end)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i , _i .",
                "tactic_args": [
                    "c3_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match compare b zero with\n     | Gt =>\n         match compare (mod_gt a b) zero with\n         | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n         | _ => b\n         end\n     | _ => a\n     end)",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c4_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z b) 0 with\n     | Gt =>\n         match Z.compare (to_Z (mod_gt a b)) 0 with\n         | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n         | _ => b\n         end\n     | _ => a\n     end)"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c4_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z b) 0 with\n     | Gt =>\n         match Z.compare (to_Z (mod_gt a b)) 0 with\n         | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n         | _ => b\n         end\n     | _ => a\n     end)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z b) 0, Zis_gcd (to_Z a) (to_Z b) (to_Z a)",
                    "c6_goal : forall _ : Z.lt (to_Z b) 0, Zis_gcd (to_Z a) (to_Z b) (to_Z a)",
                    "c7_goal : forall _ : Z.lt 0 (to_Z b),\nZis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z (mod_gt a b)) 0 with\n     | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n     | _ => b\n     end)"
                ]
            },
            {
                "tactic_sig": "intros -> .",
                "tactic_sig_no_out_arg": "intros -> .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z b) 0, Zis_gcd (to_Z a) (to_Z b) (to_Z a)"
                ],
                "tactic_res": [
                    "c8_goal : Zis_gcd (to_Z a) 0 (to_Z a)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Zis_gcd (to_Z a) 0 (to_Z a)",
                    "_global_Zis_gcd_0 : forall a : Z, Zis_gcd a 0 a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.lt (to_Z b) 0, Zis_gcd (to_Z a) (to_Z b) (to_Z a)"
                ],
                "tactic_res": [
                    "c9_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z a)",
                    "c9_HH : Z.lt (to_Z b) 0"
                ]
            },
            {
                "tactic_sig": "absurd ( 0 <= [ _i ] ) .",
                "tactic_sig_no_out_arg": "absurd ( 0 <= [ _i ] ) .",
                "tactic_args": [
                    "c9_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z a)",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c10_goal : not (Z.le 0 (to_Z b))",
                    "c11_goal : Z.le 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : not (Z.le 0 (to_Z b))",
                    "c9_HH : Z.lt (to_Z b) 0",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c11_goal : Z.le 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : Z.le 0 (to_Z b))\n  (_ : Z.lt (to_Z b) (Z.pow 2 (Zpos (digits b)))), \nZ.le 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : forall (_ : Z.le 0 (to_Z b))\n  (_ : Z.lt (to_Z b) (Z.pow 2 (Zpos (digits b)))), \nZ.le 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H5 .",
                "tactic_args": [
                    "c7_goal : forall _ : Z.lt 0 (to_Z b),\nZis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z (mod_gt a b)) 0 with\n     | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n     | _ => b\n     end)"
                ],
                "tactic_res": [
                    "c13_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z (mod_gt a b)) 0 with\n     | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n     | _ => b\n     end)",
                    "c13_H5 : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c13_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     match Z.compare (to_Z (mod_gt a b)) 0 with\n     | Gt => cont (mod_gt a b) (mod_gt b (mod_gt a b))\n     | _ => b\n     end)"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : Logic.eq (to_Z (mod_gt a b)) 0,\nZis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "c15_goal : forall _ : Z.lt (to_Z (mod_gt a b)) 0,\nZis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "c16_goal : forall _ : Z.lt 0 (to_Z (mod_gt a b)),\nZis_gcd (to_Z a) (to_Z b)\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H6 .",
                "tactic_args": [
                    "c14_goal : forall _ : Logic.eq (to_Z (mod_gt a b)) 0,\nZis_gcd (to_Z a) (to_Z b) (to_Z b)"
                ],
                "tactic_res": [
                    "c17_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "c17_H6 : Logic.eq (to_Z (mod_gt a b)) 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i [ _i ] ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i [ _i ] ) .",
                "tactic_args": [
                    "c17_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "_global_Z.mul_1_r : forall n : Z, Logic.eq (Z.mul n 1) n",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c18_goal : Zis_gcd (to_Z a) (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i [ _i ] [ _i ] ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c18_goal : Zis_gcd (to_Z a) (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)",
                    "_global_Z_div_mod_eq : forall (a b : Z) (_ : Z.gt b 0),\n       Logic.eq a (Z.add (Z.mul b (Z.div a b)) (Z.modulo a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c19_goal : Zis_gcd\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b)))\n     (Z.modulo (to_Z a) (to_Z b))) (Z.mul (to_Z b) 1)\n  (Z.mul (to_Z b) 1)",
                    "c20_goal : Z.gt (to_Z b) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.gt (to_Z b) 0",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c19_goal : Zis_gcd\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b)))\n     (Z.modulo (to_Z a) (to_Z b))) (Z.mul (to_Z b) 1)\n  (Z.mul (to_Z b) 1)",
                    "_global_spec_mod_gt : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\n       Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c21_goal : Zis_gcd\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) (to_Z (mod_gt a b)))\n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)",
                    "c22_goal : Z.gt (to_Z a) (to_Z b)",
                    "c23_goal : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : Z.lt 0 (to_Z b)",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : Zis_gcd\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) (to_Z (mod_gt a b)))\n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)",
                    "c17_H6 : Logic.eq (to_Z (mod_gt a b)) 0"
                ],
                "tactic_res": [
                    "c24_goal : Zis_gcd (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) 0)\n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : Zis_gcd (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) 0)\n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)",
                    "_global_Z.add_0_r : forall n : Z, Logic.eq (Z.add n 0) n"
                ],
                "tactic_res": [
                    "c25_goal : Zis_gcd (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) \n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : Zis_gcd (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) \n  (Z.mul (to_Z b) 1) (Z.mul (to_Z b) 1)",
                    "_global_Zis_gcd_mult : forall (a b c d : Z) (_ : Zis_gcd a b d),\n       Zis_gcd (Z.mul c a) (Z.mul c b) (Z.mul c d)"
                ],
                "tactic_res": [
                    "c26_goal : Zis_gcd (Z.div (to_Z a) (to_Z b)) 1 1"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Zis_gcd (Z.div (to_Z a) (to_Z b)) 1 1",
                    "_global_Zis_gcd_1 : forall a : Z, Zis_gcd a 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall _ : Z.lt (to_Z (mod_gt a b)) 0,\nZis_gcd (to_Z a) (to_Z b) (to_Z b)"
                ],
                "tactic_res": [
                    "c27_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "c27_H : Z.lt (to_Z (mod_gt a b)) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z b)",
                    "_global_False_ind : forall (P : Prop) (_ : False), P"
                ],
                "tactic_res": [
                    "c28_goal : False"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits ( mod_gt _i _i ) ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits ( mod_gt _i _i ) ) .",
                "tactic_args": [
                    "c28_goal : False",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c29_goal : forall (_ : Z.le 0 (to_Z (mod_gt a b)))\n  (_ : Z.lt (to_Z (mod_gt a b)) (Z.pow 2 (Zpos (digits (mod_gt a b))))),\nFalse"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c29_goal : forall (_ : Z.le 0 (to_Z (mod_gt a b)))\n  (_ : Z.lt (to_Z (mod_gt a b)) (Z.pow 2 (Zpos (digits (mod_gt a b))))),\nFalse",
                    "c27_H : Z.lt (to_Z (mod_gt a b)) 0",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H6 .",
                "tactic_args": [
                    "c16_goal : forall _ : Z.lt 0 (to_Z (mod_gt a b)),\nZis_gcd (to_Z a) (to_Z b)\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))"
                ],
                "tactic_res": [
                    "c30_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "_global_DoubleDiv.Zis_gcd_mod : forall (a b d : Z) (_ : Z.lt 0 b) (_ : Zis_gcd b (Z.modulo a b) d),\n       Zis_gcd a b d"
                ],
                "tactic_res": [
                    "c31_goal : Z.lt 0 (to_Z b)",
                    "c32_goal : Zis_gcd (to_Z b) (Z.modulo (to_Z a) (to_Z b))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : Z.lt 0 (to_Z b)",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : Zis_gcd (to_Z b) (Z.modulo (to_Z a) (to_Z b))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "_global_DoubleDiv.Zis_gcd_mod : forall (a b d : Z) (_ : Z.lt 0 b) (_ : Zis_gcd b (Z.modulo a b) d),\n       Zis_gcd a b d"
                ],
                "tactic_res": [
                    "c33_goal : Z.lt 0 (Z.modulo (to_Z a) (to_Z b))",
                    "c34_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c33_goal : Z.lt 0 (Z.modulo (to_Z a) (to_Z b))",
                    "_global_spec_mod_gt : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\n       Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c35_goal : Z.lt 0 (to_Z (mod_gt a b))",
                    "c36_goal : Z.gt (to_Z a) (to_Z b)",
                    "c37_goal : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c35_goal : Z.lt 0 (to_Z (mod_gt a b))",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c36_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c37_goal : Z.lt 0 (to_Z b)",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F2 : [ _i ] > [ mod_gt _i _i ] ) .",
                "tactic_sig_no_out_arg": "assert ( F2 : [ _i ] > [ mod_gt _i _i ] ) .",
                "tactic_args": [
                    "c34_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c2_b : True",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c38_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c39_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c39_F2 : Z.gt (to_Z b) (to_Z (mod_gt a b))"
                ]
            },
            {
                "tactic_sig": "case ( Z_mod_lt [ _i ] [ _i ] ) .",
                "tactic_sig_no_out_arg": "case ( Z_mod_lt [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c38_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c40_goal : Z.gt (to_Z b) 0",
                    "c41_goal : forall (_ : Z.le 0 (Z.modulo (to_Z a) (to_Z b)))\n  (_ : Z.lt (Z.modulo (to_Z a) (to_Z b)) (to_Z b)),\nZ.gt (to_Z b) (to_Z (mod_gt a b))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c40_goal : Z.gt (to_Z b) 0",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat rewrite <- spec_mod_gt .",
                "tactic_sig_no_out_arg": "repeat rewrite <- spec_mod_gt .",
                "tactic_args": [
                    "c41_goal : forall (_ : Z.le 0 (Z.modulo (to_Z a) (to_Z b)))\n  (_ : Z.lt (Z.modulo (to_Z a) (to_Z b)) (to_Z b)),\nZ.gt (to_Z b) (to_Z (mod_gt a b))"
                ],
                "tactic_res": [
                    "c42_goal : forall (_ : Z.le 0 (to_Z (mod_gt a b)))\n  (_ : Z.lt (to_Z (mod_gt a b)) (to_Z b)),\nZ.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c43_goal : Z.gt (to_Z a) (to_Z b)",
                    "c44_goal : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c42_goal : forall (_ : Z.le 0 (to_Z (mod_gt a b)))\n  (_ : Z.lt (to_Z (mod_gt a b)) (to_Z b)),\nZ.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c43_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c44_goal : Z.lt 0 (to_Z b)",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F3 : [ mod_gt _i _i ] > [ mod_gt _i ( mod_gt _i _i ) ] ) .",
                "tactic_sig_no_out_arg": "assert ( F3 : [ mod_gt _i _i ] > [ mod_gt _i ( mod_gt _i _i ) ] ) .",
                "tactic_args": [
                    "c39_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c2_a : True",
                    "c2_b : True",
                    "c2_b : True",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c45_goal : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c46_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c46_F3 : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))"
                ]
            },
            {
                "tactic_sig": "case ( Z_mod_lt [ _i ] [ mod_gt _i _i ] ) .",
                "tactic_sig_no_out_arg": "case ( Z_mod_lt [ _i ] [ mod_gt _i _i ] ) .",
                "tactic_args": [
                    "c45_goal : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c2_b : True",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c47_goal : Z.gt (to_Z (mod_gt a b)) 0",
                    "c48_goal : forall (_ : Z.le 0 (Z.modulo (to_Z b) (to_Z (mod_gt a b))))\n  (_ : Z.lt (Z.modulo (to_Z b) (to_Z (mod_gt a b))) (to_Z (mod_gt a b))),\nZ.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c47_goal : Z.gt (to_Z (mod_gt a b)) 0",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c48_goal : forall (_ : Z.le 0 (Z.modulo (to_Z b) (to_Z (mod_gt a b))))\n  (_ : Z.lt (Z.modulo (to_Z b) (to_Z (mod_gt a b))) (to_Z (mod_gt a b))),\nZ.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "_global_spec_mod_gt : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\n       Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c49_goal : forall (_ : Z.le 0 (to_Z (mod_gt b (mod_gt a b))))\n  (_ : Z.lt (to_Z (mod_gt b (mod_gt a b))) (to_Z (mod_gt a b))),\nZ.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c50_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c51_goal : Z.lt 0 (to_Z (mod_gt a b))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c49_goal : forall (_ : Z.le 0 (to_Z (mod_gt b (mod_gt a b))))\n  (_ : Z.lt (to_Z (mod_gt b (mod_gt a b))) (to_Z (mod_gt a b))),\nZ.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c50_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c39_F2 : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c51_goal : Z.lt 0 (to_Z (mod_gt a b))",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat rewrite <- spec_mod_gt .",
                "tactic_sig_no_out_arg": "repeat rewrite <- spec_mod_gt .",
                "tactic_args": [
                    "c46_goal : Zis_gcd (Z.modulo (to_Z a) (to_Z b))\n  (Z.modulo (to_Z b) (Z.modulo (to_Z a) (to_Z b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))"
                ],
                "tactic_res": [
                    "c52_goal : Zis_gcd (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c53_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c54_goal : Z.lt 0 (to_Z (mod_gt a b))",
                    "c55_goal : Z.gt (to_Z a) (to_Z b)",
                    "c56_goal : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c53_goal : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c39_F2 : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c54_goal : Z.lt 0 (to_Z (mod_gt a b))",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c55_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c56_goal : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c52_goal : Zis_gcd (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))\n  (to_Z (cont (mod_gt a b) (mod_gt b (mod_gt a b))))",
                    "c2_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ],
                "tactic_res": [
                    "c57_goal : Z.lt (to_Z (mod_gt a b)) (Z.pow 2 (Z.sub p 1))",
                    "c58_goal : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c58_goal : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c46_F3 : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with 2 .",
                "tactic_sig_no_out_arg": "apply _i with 2 .",
                "tactic_args": [
                    "c57_goal : Z.lt (to_Z (mod_gt a b)) (Z.pow 2 (Z.sub p 1))",
                    "_global_Z.mul_lt_mono_pos_r : forall (p n m : Z) (_ : Z.lt 0 p),\n       iff (Z.lt n m) (Z.lt (Z.mul n p) (Z.mul m p))"
                ],
                "tactic_res": [
                    "c59_goal : Z.lt 0 2",
                    "c60_goal : Z.lt (Z.mul (to_Z (mod_gt a b)) 2) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c59_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( [ _i ] + [ _i _i _i ] ) .",
                "tactic_sig_no_out_arg": "apply _i with ( [ _i ] + [ _i _i _i ] ) .",
                "tactic_args": [
                    "c60_goal : Z.lt (Z.mul (to_Z (mod_gt a b)) 2) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_Z.le_lt_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.lt m p), Z.lt n p",
                    "c2_b : True",
                    "_global_mod_gt : forall (_ : t') (_ : t'), t",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c61_goal : Z.le (Z.mul (to_Z (mod_gt a b)) 2) (Z.add (to_Z b) (to_Z (mod_gt a b)))",
                    "c62_goal : Z.lt (Z.add (to_Z b) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c61_goal : Z.le (Z.mul (to_Z (mod_gt a b)) 2) (Z.add (to_Z b) (to_Z (mod_gt a b)))",
                    "c39_F2 : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( ( [ _i ] / [ _i ] ) * [ _i ] + [ _i _i _i ] ) .",
                "tactic_sig_no_out_arg": "apply _i with ( ( [ _i ] / [ _i ] ) * [ _i ] + [ _i _i _i ] ) .",
                "tactic_args": [
                    "c62_goal : Z.lt (Z.add (to_Z b) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_Z.le_lt_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.lt m p), Z.lt n p",
                    "c2_a : True",
                    "c2_b : True",
                    "c2_b : True",
                    "_global_mod_gt : forall (_ : t') (_ : t'), t",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c63_goal : Z.le (Z.add (to_Z b) (to_Z (mod_gt a b)))\n  (Z.add (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b)) (to_Z (mod_gt a b)))",
                    "c64_goal : Z.lt\n  (Z.add (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b)) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c63_goal : Z.le (Z.add (to_Z b) (to_Z (mod_gt a b)))\n  (Z.add (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b)) (to_Z (mod_gt a b)))",
                    "_global_Z.add_le_mono_r : forall n m p : Z, iff (Z.le n m) (Z.le (Z.add n p) (Z.add m p))"
                ],
                "tactic_res": [
                    "c65_goal : Z.le (to_Z b) (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i [ _i ] ) at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i [ _i ] ) at 1 .",
                "tactic_args": [
                    "c65_goal : Z.le (to_Z b) (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b))",
                    "_global_Z.mul_1_l : forall n : Z, Logic.eq (Z.mul 1 n) n",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c66_goal : Z.le (Z.mul 1 (to_Z b)) (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c66_goal : Z.le (Z.mul 1 (to_Z b)) (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b))",
                    "_global_Z.mul_le_mono_nonneg_r : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul n p) (Z.mul m p)"
                ],
                "tactic_res": [
                    "c67_goal : Z.le 0 (to_Z b)",
                    "c68_goal : Z.le 1 (Z.div (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c67_goal : Z.le 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change 1 with ( Z.succ 0 ) .",
                "tactic_sig_no_out_arg": "change 1 with ( Z.succ 0 ) .",
                "tactic_args": [
                    "c68_goal : Z.le 1 (Z.div (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c69_goal : Z.le (Z.succ 0) (Z.div (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c69_goal : Z.le (Z.succ 0) (Z.div (to_Z a) (to_Z b))",
                    "_global_Z.le_succ_l : forall n m : Z, iff (Z.le (Z.succ n) m) (Z.lt n m)"
                ],
                "tactic_res": [
                    "c70_goal : Z.lt 0 (Z.div (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c70_goal : Z.lt 0 (Z.div (to_Z a) (to_Z b))",
                    "_global_Z.div_str_pos : forall (a b : Z) (_ : and (Z.lt 0 b) (Z.le b a)), Z.lt 0 (Z.div a b)"
                ],
                "tactic_res": [
                    "c71_goal : and (Z.lt 0 (to_Z b)) (Z.le (to_Z b) (to_Z a))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c71_goal : and (Z.lt 0 (to_Z b)) (Z.le (to_Z b) (to_Z a))",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c64_goal : Z.lt\n  (Z.add (Z.mul (Z.div (to_Z a) (to_Z b)) (to_Z b)) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c72_goal : Z.lt\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c72_goal : Z.lt\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b))) (to_Z (mod_gt a b)))\n  (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_spec_mod_gt : forall (x y : t) (_ : Z.gt (to_Z x) (to_Z y)) (_ : Z.lt 0 (to_Z y)),\n       Logic.eq (to_Z (mod_gt x y)) (Z.modulo (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c73_goal : Z.lt\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b)))\n     (Z.modulo (to_Z a) (to_Z b))) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "c74_goal : Z.gt (to_Z a) (to_Z b)",
                    "c75_goal : Z.lt 0 (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c74_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c75_goal : Z.lt 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c73_goal : Z.lt\n  (Z.add (Z.mul (to_Z b) (Z.div (to_Z a) (to_Z b)))\n     (Z.modulo (to_Z a) (to_Z b))) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_Z_div_mod_eq : forall (a b : Z) (_ : Z.gt b 0),\n       Logic.eq a (Z.add (Z.mul b (Z.div a b)) (Z.modulo a b))"
                ],
                "tactic_res": [
                    "c76_goal : Z.lt (to_Z a) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "c77_goal : Z.gt (to_Z b) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c77_goal : Z.gt (to_Z b) 0",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , <- _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i , _i , _i .",
                "tactic_args": [
                    "c76_goal : Z.lt (to_Z a) (Z.mul (Z.pow 2 (Z.sub p 1)) 2)",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)",
                    "_global_Z.pow_succ_r : forall (n m : Z) (_ : Z.le 0 m),\n       Logic.eq (Z.pow n (Z.succ m)) (Z.mul n (Z.pow n m))",
                    "_global_Z.sub_1_r : forall n : Z, Logic.eq (Z.sub n 1) (Z.pred n)",
                    "_global_Z.succ_pred : forall n : Z, Logic.eq (Z.succ (Z.pred n)) n"
                ],
                "tactic_res": [
                    "c78_goal : Z.lt (to_Z a) (Z.pow 2 p)",
                    "c79_goal : Z.le 0 (Z.sub p 1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c78_goal : Z.lt (to_Z a) (Z.pow 2 p)",
                    "c2_H3 : Z.lt (to_Z a) (Z.pow 2 p)",
                    "c2_p : Z",
                    "c2_a : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c79_goal : Z.le 0 (Z.sub p 1)",
                    "_global_Z.le_0_sub : forall n m : Z, iff (Z.le 0 (Z.sub m n)) (Z.le n m)"
                ],
                "tactic_res": [
                    "c80_goal : Z.le 1 p"
                ]
            },
            {
                "tactic_sig": "change 1 with ( Z.succ 0 ) .",
                "tactic_sig_no_out_arg": "change 1 with ( Z.succ 0 ) .",
                "tactic_args": [
                    "c80_goal : Z.le 1 p"
                ],
                "tactic_res": [
                    "c81_goal : Z.le (Z.succ 0) p"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c81_goal : Z.le (Z.succ 0) p",
                    "_global_Z.le_succ_l : forall n m : Z, iff (Z.le (Z.succ n) m) (Z.lt n m)"
                ],
                "tactic_res": [
                    "c82_goal : Z.lt 0 p"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c82_goal : Z.lt 0 p",
                    "c2_p : Z",
                    "c46_F3 : Z.gt (to_Z (mod_gt a b)) (to_Z (mod_gt b (mod_gt a b)))",
                    "c39_F2 : Z.gt (to_Z b) (to_Z (mod_gt a b))",
                    "c30_H6 : Z.lt 0 (to_Z (mod_gt a b))",
                    "c13_H5 : Z.lt 0 (to_Z b)",
                    "c2_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c2_H3 : Z.lt (to_Z a) (Z.pow 2 p)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)"
                ],
                "tactic_res": [
                    "c83_goal : Z.lt 0 0",
                    "c83_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub 0 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c83_H3 : Z.lt (to_Z a) (Z.pow 2 0)",
                    "c84_goal : Z.lt 0 (Zpos p)",
                    "c84_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Zpos p) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c84_H3 : Z.lt (to_Z a) (Z.pow 2 (Zpos p))",
                    "c84_p : positive",
                    "c85_goal : Z.lt 0 (Zneg p)",
                    "c85_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Zneg p) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c85_H3 : Z.lt (to_Z a) (Z.pow 2 (Zneg p))",
                    "c85_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c83_H3 : Z.lt (to_Z a) (Z.pow 2 0)"
                ],
                "tactic_res": [
                    "c83_H3 : Z.lt (to_Z a) 1"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c83_goal : Z.lt 0 0",
                    "c83_H3 : Z.lt (to_Z a) 1",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c84_H3 : Z.lt (to_Z a) (Z.pow 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c84_H3 : Z.lt (to_Z a) (Z.pow_pos 2 p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c84_goal : Z.lt 0 (Zpos p)",
                    "c84_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c85_H3 : Z.lt (to_Z a) (Z.pow 2 (Zneg p))"
                ],
                "tactic_res": [
                    "c85_H3 : Z.lt (to_Z a) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c85_goal : Z.lt 0 (Zneg p)",
                    "c85_H3 : Z.lt (to_Z a) 0",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c85_p : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zspec_gcd_gt_aux",
        "proof": [
            {
                "tactic_sig": "Theorem Zspec_gcd_gt_aux : forall p n a b cont , [ a ] > [ b ] -> [ a ] < 2 ^ ( Zpos p + n ) -> ( forall a1 b1 , [ a1 ] < 2 ^ n -> [ a1 ] > [ b1 ] -> Zis_gcd [ a1 ] [ b1 ] [ cont a1 b1 ] ) -> Zis_gcd [ a ] [ b ] [ gcd_gt_aux p cont a b ] .",
                "tactic_sig_no_out_arg": "Theorem Zspec_gcd_gt_aux : forall p n a b cont , [ a ] > [ b ] -> [ a ] < 2 ^ ( Zpos p + n ) -> ( forall a1 b1 , [ a1 ] < 2 ^ n -> [ a1 ] > [ b1 ] -> Zis_gcd [ a1 ] [ b1 ] [ cont a1 b1 ] ) -> Zis_gcd [ a ] [ b ] [ gcd_gt_aux p cont a b ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p : positive) (n : Z) (a b : t)\n  (cont : forall (_ : t) (_ : t), t) (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall (p : positive) (n : Z) (a b : t)\n  (cont : forall (_ : t) (_ : t), t) (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : forall (p : positive)\n  (_ : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.gt (to_Z a) (to_Z b))\n         (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b)))\n  (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xI p) cont a b))",
                    "c4_goal : forall (p : positive)\n  (_ : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.gt (to_Z a) (to_Z b))\n         (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b)))\n  (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xO p) cont a b))",
                    "c5_goal : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux 1 cont a b))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros p Hrec n a b cont H2 H3 H4 .",
                "tactic_args": [
                    "c3_goal : forall (p : positive)\n  (_ : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.gt (to_Z a) (to_Z b))\n         (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b)))\n  (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xI p) cont a b))"
                ],
                "tactic_res": [
                    "c6_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xI p) cont a b))",
                    "c6_p : positive",
                    "c6_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c6_n : Z",
                    "c6_a : True",
                    "c6_b : True",
                    "c6_cont : forall (_ : t) (_ : t), t",
                    "c6_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c6_H3 : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n))",
                    "c6_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xI p) cont a b))",
                    "_global_gcd_gt_aux : forall (_ : positive) (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t),\n       t"
                ],
                "tactic_res": [
                    "c7_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     (gcd_gt_body a b\n        (fun a b : t =>\n         (fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t)\n            (a0 b0 : t) {struct p} : t :=\n            gcd_gt_body a0 b0\n              (fun a1 b1 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n               | 1%positive => cont a1 b1\n               end)) p\n           ((fix gcd_gt_aux\n               (p : positive) (cont : forall (_ : t) (_ : t), t)\n               (a0 b0 : t) {struct p} : t :=\n               gcd_gt_body a0 b0\n                 (fun a1 b1 : t =>\n                  match p with\n                  | xI p0 | xO p0 =>\n                      gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n                  | 1%positive => cont a1 b1\n                  end)) p cont) a b)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ( _i _i ) + _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ( _i _i ) + _i ) .",
                "tactic_args": [
                    "c7_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     (gcd_gt_body a b\n        (fun a b : t =>\n         (fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t)\n            (a0 b0 : t) {struct p} : t :=\n            gcd_gt_body a0 b0\n              (fun a1 b1 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n               | 1%positive => cont a1 b1\n               end)) p\n           ((fix gcd_gt_aux\n               (p : positive) (cont : forall (_ : t) (_ : t), t)\n               (a0 b0 : t) {struct p} : t :=\n               gcd_gt_body a0 b0\n                 (fun a1 b1 : t =>\n                  match p with\n                  | xI p0 | xO p0 =>\n                      gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n                  | 1%positive => cont a1 b1\n                  end)) p cont) a b)))",
                    "_global_Zspec_gcd_gt_body : forall (a b : t) (cont : forall (_ : t) (_ : t), t) \n         (p : Z) (_ : Z.gt (to_Z a) (to_Z b)) (_ : Z.lt (to_Z a) (Z.pow 2 p))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))",
                    "_global_Zpos : forall _ : positive, Z",
                    "_global_xI : forall _ : positive, positive",
                    "c6_p : positive",
                    "c6_n : Z"
                ],
                "tactic_res": [
                    "c8_goal : Z.gt (to_Z a) (to_Z b)",
                    "c9_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n))",
                    "c10_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Z.gt (to_Z a) (to_Z b)",
                    "c6_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c6_a : True",
                    "c6_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n))",
                    "c6_H3 : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xI p)) n))",
                    "c6_a : True",
                    "c6_n : Z",
                    "c6_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a1 b1 H6 H7 .",
                "tactic_args": [
                    "c10_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))"
                ],
                "tactic_res": [
                    "c11_goal : Zis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))",
                    "c11_a1 : True",
                    "c11_b1 : True",
                    "c11_H6 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1))",
                    "c11_H7 : Z.gt (to_Z a1) (to_Z b1)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i + _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i + _i ) .",
                "tactic_args": [
                    "c11_goal : Zis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))",
                    "c6_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "_global_Zpos : forall _ : positive, Z",
                    "c6_p : positive",
                    "c6_n : Z"
                ],
                "tactic_res": [
                    "c12_goal : Z.gt (to_Z a1) (to_Z b1)",
                    "c13_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) (Z.add (Zpos p) n)))",
                    "c14_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Z.gt (to_Z a1) (to_Z b1)",
                    "c11_H7 : Z.gt (to_Z a1) (to_Z b1)",
                    "c11_a1 : True",
                    "c11_b1 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( Zpos _i + ( Zpos _i + _i ) ) with ( Zpos ( xI _i ) + _i - 1 ) .",
                "tactic_sig_no_out_arg": "replace ( Zpos _i + ( Zpos _i + _i ) ) with ( Zpos ( xI _i ) + _i - 1 ) .",
                "tactic_args": [
                    "c13_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) (Z.add (Zpos p) n)))",
                    "c6_p : positive",
                    "c6_p : positive",
                    "c6_n : Z",
                    "c6_p : positive",
                    "c6_n : Z"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1))",
                    "c16_goal : Logic.eq (Z.sub (Z.add (Zpos (xI p)) n) 1)\n  (Z.add (Zpos p) (Z.add (Zpos p) n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1))",
                    "c11_H6 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xI p)) n) 1))",
                    "c11_a1 : True",
                    "c6_n : Z",
                    "c6_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : Logic.eq (Z.sub (Z.add (Zpos (xI p)) n) 1)\n  (Z.add (Zpos p) (Z.add (Zpos p) n))",
                    "_global_Pos2Z.inj_xI : forall p : positive,\n       Logic.eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (Z.sub (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) n) 1)\n  (Z.add (Zpos p) (Z.add (Zpos p) n))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c17_goal : Logic.eq (Z.sub (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) n) 1)\n  (Z.add (Zpos p) (Z.add (Zpos p) n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a2 b2 H9 H10 .",
                "tactic_args": [
                    "c14_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a1 b1))"
                ],
                "tactic_res": [
                    "c18_goal : Zis_gcd (to_Z a2) (to_Z b2)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a2 b2))",
                    "c18_a2 : True",
                    "c18_b2 : True",
                    "c18_H9 : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) n))",
                    "c18_H10 : Z.gt (to_Z a2) (to_Z b2)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c18_goal : Zis_gcd (to_Z a2) (to_Z b2)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a2 b2))",
                    "c6_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c6_n : Z"
                ],
                "tactic_res": [
                    "c19_goal : Z.gt (to_Z a2) (to_Z b2)",
                    "c20_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) n))",
                    "c21_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Z.gt (to_Z a2) (to_Z b2)",
                    "c18_H10 : Z.gt (to_Z a2) (to_Z b2)",
                    "c18_a2 : True",
                    "c18_b2 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) n))",
                    "c18_H9 : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) n))",
                    "c18_a2 : True",
                    "c6_n : Z",
                    "c6_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c6_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c6_cont : forall (_ : t) (_ : t), t",
                    "c6_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros p Hrec n a b cont H2 H3 H4 .",
                "tactic_args": [
                    "c4_goal : forall (p : positive)\n  (_ : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.gt (to_Z a) (to_Z b))\n         (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b)))\n  (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xO p) cont a b))"
                ],
                "tactic_res": [
                    "c22_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xO p) cont a b))",
                    "c22_p : positive",
                    "c22_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c22_n : Z",
                    "c22_a : True",
                    "c22_b : True",
                    "c22_cont : forall (_ : t) (_ : t), t",
                    "c22_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c22_H3 : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n))",
                    "c22_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c22_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (xO p) cont a b))",
                    "_global_gcd_gt_aux : forall (_ : positive) (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t),\n       t"
                ],
                "tactic_res": [
                    "c23_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     (gcd_gt_body a b\n        (fun a b : t =>\n         (fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t)\n            (a0 b0 : t) {struct p} : t :=\n            gcd_gt_body a0 b0\n              (fun a1 b1 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n               | 1%positive => cont a1 b1\n               end)) p\n           ((fix gcd_gt_aux\n               (p : positive) (cont : forall (_ : t) (_ : t), t)\n               (a0 b0 : t) {struct p} : t :=\n               gcd_gt_body a0 b0\n                 (fun a1 b1 : t =>\n                  match p with\n                  | xI p0 | xO p0 =>\n                      gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n                  | 1%positive => cont a1 b1\n                  end)) p cont) a b)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ( _i _i ) + _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ( _i _i ) + _i ) .",
                "tactic_args": [
                    "c23_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z\n     (gcd_gt_body a b\n        (fun a b : t =>\n         (fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t)\n            (a0 b0 : t) {struct p} : t :=\n            gcd_gt_body a0 b0\n              (fun a1 b1 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n               | 1%positive => cont a1 b1\n               end)) p\n           ((fix gcd_gt_aux\n               (p : positive) (cont : forall (_ : t) (_ : t), t)\n               (a0 b0 : t) {struct p} : t :=\n               gcd_gt_body a0 b0\n                 (fun a1 b1 : t =>\n                  match p with\n                  | xI p0 | xO p0 =>\n                      gcd_gt_aux p0 (gcd_gt_aux p0 cont) a1 b1\n                  | 1%positive => cont a1 b1\n                  end)) p cont) a b)))",
                    "_global_Zspec_gcd_gt_body : forall (a b : t) (cont : forall (_ : t) (_ : t), t) \n         (p : Z) (_ : Z.gt (to_Z a) (to_Z b)) (_ : Z.lt (to_Z a) (Z.pow 2 p))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))",
                    "_global_Zpos : forall _ : positive, Z",
                    "_global_xO : forall _ : positive, positive",
                    "c22_p : positive",
                    "c22_n : Z"
                ],
                "tactic_res": [
                    "c24_goal : Z.gt (to_Z a) (to_Z b)",
                    "c25_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n))",
                    "c26_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Z.gt (to_Z a) (to_Z b)",
                    "c22_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c22_a : True",
                    "c22_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n))",
                    "c22_H3 : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (xO p)) n))",
                    "c22_a : True",
                    "c22_n : Z",
                    "c22_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a1 b1 H6 H7 .",
                "tactic_args": [
                    "c26_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))"
                ],
                "tactic_res": [
                    "c27_goal : Zis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))",
                    "c27_a1 : True",
                    "c27_b1 : True",
                    "c27_H6 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1))",
                    "c27_H7 : Z.gt (to_Z a1) (to_Z b1)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i + _i - 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i + _i - 1 ) .",
                "tactic_args": [
                    "c27_goal : Zis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p\n        ((fix gcd_gt_aux\n            (p : positive) (cont : forall (_ : t) (_ : t), t) \n            (a b : t) {struct p} : t :=\n            gcd_gt_body a b\n              (fun a0 b0 : t =>\n               match p with\n               | xI p0 | xO p0 =>\n                   gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n               | 1%positive => cont a0 b0\n               end)) p cont) a1 b1))",
                    "c22_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "_global_Zpos : forall _ : positive, Z",
                    "c22_p : positive",
                    "c22_n : Z"
                ],
                "tactic_res": [
                    "c28_goal : Z.gt (to_Z a1) (to_Z b1)",
                    "c29_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1)))",
                    "c30_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : Z.gt (to_Z a1) (to_Z b1)",
                    "c27_H7 : Z.gt (to_Z a1) (to_Z b1)",
                    "c27_a1 : True",
                    "c27_b1 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( Zpos _i + ( Zpos _i + _i - 1 ) ) with ( Zpos ( xO _i ) + _i - 1 ) .",
                "tactic_sig_no_out_arg": "replace ( Zpos _i + ( Zpos _i + _i - 1 ) ) with ( Zpos ( xO _i ) + _i - 1 ) .",
                "tactic_args": [
                    "c29_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1)))",
                    "c22_p : positive",
                    "c22_p : positive",
                    "c22_n : Z",
                    "c22_p : positive",
                    "c22_n : Z"
                ],
                "tactic_res": [
                    "c31_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1))",
                    "c32_goal : Logic.eq (Z.sub (Z.add (Zpos (xO p)) n) 1)\n  (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1))",
                    "c27_H6 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos (xO p)) n) 1))",
                    "c27_a1 : True",
                    "c22_n : Z",
                    "c22_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c32_goal : Logic.eq (Z.sub (Z.add (Zpos (xO p)) n) 1)\n  (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1))",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq (Z.sub (Z.add (Z.mul 2 (Zpos p)) n) 1)\n  (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c33_goal : Logic.eq (Z.sub (Z.add (Z.mul 2 (Zpos p)) n) 1)\n  (Z.add (Zpos p) (Z.sub (Z.add (Zpos p) n) 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a2 b2 H9 H10 .",
                "tactic_args": [
                    "c30_goal : forall (a1 b1 : t)\n  (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a1 b1))"
                ],
                "tactic_res": [
                    "c34_goal : Zis_gcd (to_Z a2) (to_Z b2)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a2 b2))",
                    "c34_a2 : True",
                    "c34_b2 : True",
                    "c34_H9 : Z.lt (to_Z a2) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1))",
                    "c34_H10 : Z.gt (to_Z a2) (to_Z b2)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i - 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i - 1 ) .",
                "tactic_args": [
                    "c34_goal : Zis_gcd (to_Z a2) (to_Z b2)\n  (to_Z\n     ((fix gcd_gt_aux\n         (p : positive) (cont : forall (_ : t) (_ : t), t) \n         (a b : t) {struct p} : t :=\n         gcd_gt_body a b\n           (fun a0 b0 : t =>\n            match p with\n            | xI p0 | xO p0 => gcd_gt_aux p0 (gcd_gt_aux p0 cont) a0 b0\n            | 1%positive => cont a0 b0\n            end)) p cont a2 b2))",
                    "c22_Hrec : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))",
                    "c22_n : Z"
                ],
                "tactic_res": [
                    "c35_goal : Z.gt (to_Z a2) (to_Z b2)",
                    "c36_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) (Z.sub n 1)))",
                    "c37_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub n 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : Z.gt (to_Z a2) (to_Z b2)",
                    "c34_H10 : Z.gt (to_Z a2) (to_Z b2)",
                    "c34_a2 : True",
                    "c34_b2 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( Zpos _i + ( _i - 1 ) ) with ( Zpos _i + _i - 1 ) .",
                "tactic_sig_no_out_arg": "replace ( Zpos _i + ( _i - 1 ) ) with ( Zpos _i + _i - 1 ) .",
                "tactic_args": [
                    "c36_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.add (Zpos p) (Z.sub n 1)))",
                    "c22_p : positive",
                    "c22_n : Z",
                    "c22_p : positive",
                    "c22_n : Z"
                ],
                "tactic_res": [
                    "c38_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1))",
                    "c39_goal : Logic.eq (Z.sub (Z.add (Zpos p) n) 1) (Z.add (Zpos p) (Z.sub n 1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c38_goal : Z.lt (to_Z a2) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1))",
                    "c34_H9 : Z.lt (to_Z a2) (Z.pow 2 (Z.sub (Z.add (Zpos p) n) 1))",
                    "c34_a2 : True",
                    "c22_n : Z",
                    "c22_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c39_goal : Logic.eq (Z.sub (Z.add (Zpos p) n) 1) (Z.add (Zpos p) (Z.sub n 1))",
                    "c22_n : Z",
                    "c22_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a3 b3 H12 H13 .",
                "tactic_args": [
                    "c37_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub n 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ],
                "tactic_res": [
                    "c40_goal : Zis_gcd (to_Z a3) (to_Z b3) (to_Z (cont a3 b3))",
                    "c40_a3 : True",
                    "c40_b3 : True",
                    "c40_H12 : Z.lt (to_Z a3) (Z.pow 2 (Z.sub n 1))",
                    "c40_H13 : Z.gt (to_Z a3) (to_Z b3)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : Zis_gcd (to_Z a3) (to_Z b3) (to_Z (cont a3 b3))",
                    "c22_H4 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ],
                "tactic_res": [
                    "c41_goal : Z.lt (to_Z a3) (Z.pow 2 n)",
                    "c42_goal : Z.gt (to_Z a3) (to_Z b3)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c42_goal : Z.gt (to_Z a3) (to_Z b3)",
                    "c40_H13 : Z.gt (to_Z a3) (to_Z b3)",
                    "c40_a3 : True",
                    "c40_b3 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c41_goal : Z.lt (to_Z a3) (Z.pow 2 n)",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "c40_H12 : Z.lt (to_Z a3) (Z.pow 2 (Z.sub n 1))"
                ],
                "tactic_res": [
                    "c43_goal : Z.le (Z.pow 2 (Z.sub n 1)) (Z.pow 2 n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c43_goal : Z.le (Z.pow 2 (Z.sub n 1)) (Z.pow 2 n)",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c44_goal : Z.lt 0 2",
                    "c45_goal : Z.le (Z.sub n 1) n"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c44_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c45_goal : Z.le (Z.sub n 1) n",
                    "c22_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n a b cont H H2 H3 .",
                "tactic_args": [
                    "c5_goal : forall (n : Z) (a b : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.gt (to_Z a) (to_Z b))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n)))\n  (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n         (_ : Z.gt (to_Z a1) (to_Z b1)),\n       Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\nZis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux 1 cont a b))"
                ],
                "tactic_res": [
                    "c46_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux 1 cont a b))",
                    "c46_n : Z",
                    "c46_a : True",
                    "c46_b : True",
                    "c46_cont : forall (_ : t) (_ : t), t",
                    "c46_H : Z.gt (to_Z a) (to_Z b)",
                    "c46_H2 : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n))",
                    "c46_H3 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "simpl gcd_gt_aux .",
                "tactic_sig_no_out_arg": "simpl gcd_gt_aux .",
                "tactic_args": [
                    "c46_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux 1 cont a b))"
                ],
                "tactic_res": [
                    "c47_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z (gcd_gt_body a b (fun a b : t => cont a b)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i + 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i + 1 ) .",
                "tactic_args": [
                    "c47_goal : Zis_gcd (to_Z a) (to_Z b)\n  (to_Z (gcd_gt_body a b (fun a b : t => cont a b)))",
                    "_global_Zspec_gcd_gt_body : forall (a b : t) (cont : forall (_ : t) (_ : t), t) \n         (p : Z) (_ : Z.gt (to_Z a) (to_Z b)) (_ : Z.lt (to_Z a) (Z.pow 2 p))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub p 1)))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_body a b cont))",
                    "c46_n : Z"
                ],
                "tactic_res": [
                    "c48_goal : Z.gt (to_Z a) (to_Z b)",
                    "c49_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add n 1))",
                    "c50_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c48_goal : Z.gt (to_Z a) (to_Z b)",
                    "c46_H : Z.gt (to_Z a) (to_Z b)",
                    "c46_a : True",
                    "c46_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add n 1))",
                    "_global_Z.add_comm : forall n m : Z, Logic.eq (Z.add n m) (Z.add m n)"
                ],
                "tactic_res": [
                    "c51_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n))",
                    "c46_H2 : Z.lt (to_Z a) (Z.pow 2 (Z.add 1 n))",
                    "c46_a : True",
                    "c46_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a1 b1 H5 H6 .",
                "tactic_args": [
                    "c50_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1)))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ],
                "tactic_res": [
                    "c52_goal : Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c52_a1 : True",
                    "c52_b1 : True",
                    "c52_H5 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1))",
                    "c52_H6 : Z.gt (to_Z a1) (to_Z b1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c52_goal : Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))",
                    "c46_H3 : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))"
                ],
                "tactic_res": [
                    "c53_goal : Z.lt (to_Z a1) (Z.pow 2 n)",
                    "c54_goal : Z.gt (to_Z a1) (to_Z b1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : Z.gt (to_Z a1) (to_Z b1)",
                    "c52_H6 : Z.gt (to_Z a1) (to_Z b1)",
                    "c52_a1 : True",
                    "c52_b1 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace _i with ( _i + 1 - 1 ) .",
                "tactic_sig_no_out_arg": "replace _i with ( _i + 1 - 1 ) .",
                "tactic_args": [
                    "c53_goal : Z.lt (to_Z a1) (Z.pow 2 n)",
                    "c46_n : Z",
                    "c46_n : Z"
                ],
                "tactic_res": [
                    "c55_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1))",
                    "c56_goal : Logic.eq (Z.sub (Z.add n 1) 1) n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1))",
                    "c52_H5 : Z.lt (to_Z a1) (Z.pow 2 (Z.sub (Z.add n 1) 1))",
                    "c52_a1 : True",
                    "c46_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c56_goal : Logic.eq (Z.sub (Z.add n 1) 1) n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_gcd_gt",
        "proof": [
            {
                "tactic_sig": "Theorem spec_gcd_gt : forall a b , [ a ] > [ b ] -> [ gcd_gt a b ] = Z.gcd [ a ] [ b ] .",
                "tactic_sig_no_out_arg": "Theorem spec_gcd_gt : forall a b , [ a ] > [ b ] -> [ gcd_gt a b ] = Z.gcd [ a ] [ b ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a b : t) (_ : Z.gt (to_Z a) (to_Z b)),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b H2 .",
                "tactic_args": [
                    "c1_goal : forall (a b : t) (_ : Z.gt (to_Z a) (to_Z b)),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_a : True",
                    "c2_b : True",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits ( gcd_gt _i _i ) ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits ( gcd_gt _i _i ) ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : Z.le 0 (to_Z (gcd_gt a b)))\n  (_ : Z.lt (to_Z (gcd_gt a b)) (Z.pow 2 (Zpos (digits (gcd_gt a b))))),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H3 H4 .",
                "tactic_args": [
                    "c3_goal : forall (_ : Z.le 0 (to_Z (gcd_gt a b)))\n  (_ : Z.lt (to_Z (gcd_gt a b)) (Z.pow 2 (Zpos (digits (gcd_gt a b))))),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c4_H3 : Z.le 0 (to_Z (gcd_gt a b))",
                    "c4_H4 : Z.lt (to_Z (gcd_gt a b)) (Z.pow 2 (Zpos (digits (gcd_gt a b))))"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_a : True"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : Z.le 0 (to_Z a))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H5 H6 .",
                "tactic_args": [
                    "c5_goal : forall (_ : Z.le 0 (to_Z a))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c6_H5 : Z.le 0 (to_Z a)",
                    "c6_H6 : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.gcd (to_Z a) (to_Z b)) (to_Z (gcd_gt a b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.gcd (to_Z a) (to_Z b)) (to_Z (gcd_gt a b))",
                    "_global_Zis_gcd_gcd : forall (a b c : Z) (_ : Z.le 0 c) (_ : Zis_gcd a b c),\n       Logic.eq (Z.gcd a b) c"
                ],
                "tactic_res": [
                    "c8_goal : Z.le 0 (to_Z (gcd_gt a b))",
                    "c9_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt a b))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.le 0 (to_Z (gcd_gt a b))",
                    "c4_H3 : Z.le 0 (to_Z (gcd_gt a b))",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt a b))",
                    "_global_gcd_gt : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c10_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (digits a) gcd_cont a b))"
                ]
            },
            {
                "tactic_sig": "apply _i with 0 .",
                "tactic_sig_no_out_arg": "apply _i with 0 .",
                "tactic_args": [
                    "c10_goal : Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux (digits a) gcd_cont a b))",
                    "_global_Zspec_gcd_gt_aux : forall (p : positive) (n : Z) (a b : t)\n         (cont : forall (_ : t) (_ : t), t) (_ : Z.gt (to_Z a) (to_Z b))\n         (_ : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos p) n)))\n         (_ : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 n))\n                (_ : Z.gt (to_Z a1) (to_Z b1)),\n              Zis_gcd (to_Z a1) (to_Z b1) (to_Z (cont a1 b1))),\n       Zis_gcd (to_Z a) (to_Z b) (to_Z (gcd_gt_aux p cont a b))"
                ],
                "tactic_res": [
                    "c11_goal : Z.gt (to_Z a) (to_Z b)",
                    "c12_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (digits a)) 0))",
                    "c13_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 0))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (gcd_cont a1 b1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.gt (to_Z a) (to_Z b)",
                    "c2_H2 : Z.gt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.lt (to_Z a) (Z.pow 2 (Z.add (Zpos (digits a)) 0))",
                    "c6_H6 : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))",
                    "c2_a : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros a1 a2 .",
                "tactic_args": [
                    "c13_goal : forall (a1 b1 : t) (_ : Z.lt (to_Z a1) (Z.pow 2 0))\n  (_ : Z.gt (to_Z a1) (to_Z b1)),\nZis_gcd (to_Z a1) (to_Z b1) (to_Z (gcd_cont a1 b1))"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : Z.lt (to_Z a1) (Z.pow 2 0)) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "c14_a1 : True",
                    "c14_a2 : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : forall (_ : Z.lt (to_Z a1) (Z.pow 2 0)) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "_global_Z.pow_0_r : forall n : Z, Logic.eq (Z.pow n 0) 1"
                ],
                "tactic_res": [
                    "c15_goal : forall (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c15_goal : forall (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "c14_a2 : True"
                ],
                "tactic_res": [
                    "c16_goal : forall (_ : Z.le 0 (to_Z a2))\n  (_ : Z.lt (to_Z a2) (Z.pow 2 (Zpos (digits a2))))\n  (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H7 H8 .",
                "tactic_args": [
                    "c16_goal : forall (_ : Z.le 0 (to_Z a2))\n  (_ : Z.lt (to_Z a2) (Z.pow 2 (Zpos (digits a2))))\n  (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))"
                ],
                "tactic_res": [
                    "c17_goal : forall (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "c17_H7 : Z.le 0 (to_Z a2)",
                    "c17_H8 : Z.lt (to_Z a2) (Z.pow 2 (Zpos (digits a2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall (_ : Z.lt (to_Z a1) 1) (_ : Z.gt (to_Z a1) (to_Z a2)),\nZis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))"
                ],
                "tactic_res": [
                    "c18_goal : Zis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "c18_H : Z.lt (to_Z a1) 1",
                    "c18_H0 : Z.gt (to_Z a1) (to_Z a2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Zis_gcd (to_Z a1) (to_Z a2) (to_Z (gcd_cont a1 a2))",
                    "_global_False_ind : forall (P : Prop) (_ : False), P"
                ],
                "tactic_res": [
                    "c19_goal : False"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : False",
                    "c18_H0 : Z.gt (to_Z a1) (to_Z a2)",
                    "c18_H : Z.lt (to_Z a1) 1",
                    "c17_H7 : Z.le 0 (to_Z a2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_gcd",
        "proof": [
            {
                "tactic_sig": "Theorem spec_gcd : forall a b , [ gcd a b ] = Z.gcd [ a ] [ b ] .",
                "tactic_sig_no_out_arg": "Theorem spec_gcd : forall a b , [ gcd a b ] = Z.gcd [ a ] [ b ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall a b : t, Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros a b .",
                "tactic_args": [
                    "c1_goal : forall a b : t, Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_a : True",
                    "c2_b : True"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_a : True"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : Z.le 0 (to_Z a))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))),\nLogic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H1 H2 .",
                "tactic_args": [
                    "c3_goal : forall (_ : Z.le 0 (to_Z a))\n  (_ : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))),\nLogic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c4_H1 : Z.le 0 (to_Z a)",
                    "c4_H2 : Z.lt (to_Z a) (Z.pow 2 (Zpos (digits a)))"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_b : True"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : Z.le 0 (to_Z b))\n  (_ : Z.lt (to_Z b) (Z.pow 2 (Zpos (digits b)))),\nLogic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H3 H4 .",
                "tactic_args": [
                    "c5_goal : forall (_ : Z.le 0 (to_Z b))\n  (_ : Z.lt (to_Z b) (Z.pow 2 (Zpos (digits b)))),\nLogic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c6_H3 : Z.le 0 (to_Z b)",
                    "c6_H4 : Z.lt (to_Z b) (Z.pow 2 (Zpos (digits b)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (gcd a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_gcd : forall (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (to_Z\n     match compare a b with\n     | Eq => a\n     | Lt => gcd_gt b a\n     | Gt => gcd_gt a b\n     end) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (to_Z\n     match compare a b with\n     | Eq => a\n     | Lt => gcd_gt b a\n     | Gt => gcd_gt a b\n     end) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z a) (to_Z b) with\n     | Eq => a\n     | Lt => gcd_gt b a\n     | Gt => gcd_gt a b\n     end) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z a) (to_Z b) with\n     | Eq => a\n     | Lt => gcd_gt b a\n     | Gt => gcd_gt a b\n     end) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Logic.eq (to_Z a) (to_Z b),\nLogic.eq (to_Z a) (Z.gcd (to_Z a) (to_Z b))",
                    "c10_goal : forall _ : Z.lt (to_Z a) (to_Z b),\nLogic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z a) (to_Z b))",
                    "c11_goal : forall _ : Z.lt (to_Z b) (to_Z a),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH .",
                "tactic_args": [
                    "c9_goal : forall _ : Logic.eq (to_Z a) (to_Z b),\nLogic.eq (to_Z a) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (to_Z a) (Z.gcd (to_Z a) (to_Z b))",
                    "c12_HH : Logic.eq (to_Z a) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (to_Z a) (Z.gcd (to_Z a) (to_Z b))",
                    "c12_HH : Logic.eq (to_Z a) (to_Z b)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (to_Z b) (Z.gcd (to_Z b) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c13_goal : Logic.eq (to_Z b) (Z.gcd (to_Z b) (to_Z b))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.gcd (to_Z b) (to_Z b)) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.gcd (to_Z b) (to_Z b)) (to_Z b)",
                    "_global_Zis_gcd_gcd : forall (a b c : Z) (_ : Z.le 0 c) (_ : Zis_gcd a b c),\n       Logic.eq (Z.gcd a b) c"
                ],
                "tactic_res": [
                    "c15_goal : Z.le 0 (to_Z b)",
                    "c16_goal : Zis_gcd (to_Z b) (to_Z b) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Z.le 0 (to_Z b)",
                    "c6_H3 : Z.le 0 (to_Z b)",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Zis_gcd (to_Z b) (to_Z b) (to_Z b)",
                    "_global_Zis_gcd_refl : forall a : Z, Zis_gcd a a a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt (to_Z a) (to_Z b),\nLogic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z a) (to_Z b))",
                    "c17_H : Z.lt (to_Z a) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "transitivity ( Z.gcd [ _i ] [ _i ] ) .",
                "tactic_sig_no_out_arg": "transitivity ( Z.gcd [ _i ] [ _i ] ) .",
                "tactic_args": [
                    "c17_goal : Logic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z a) (to_Z b))",
                    "c2_b : True",
                    "c2_a : True"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z b) (to_Z a))",
                    "c19_goal : Logic.eq (Z.gcd (to_Z b) (to_Z a)) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq (to_Z (gcd_gt b a)) (Z.gcd (to_Z b) (to_Z a))",
                    "_global_spec_gcd_gt : forall (a b : t) (_ : Z.gt (to_Z a) (to_Z b)),\n       Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c20_goal : Z.gt (to_Z b) (to_Z a)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.gt (to_Z b) (to_Z a)",
                    "c17_H : Z.lt (to_Z a) (to_Z b)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.gcd (to_Z b) (to_Z a)) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_Zis_gcd_gcd : forall (a b c : Z) (_ : Z.le 0 c) (_ : Zis_gcd a b c),\n       Logic.eq (Z.gcd a b) c"
                ],
                "tactic_res": [
                    "c21_goal : Z.le 0 (Z.gcd (to_Z a) (to_Z b))",
                    "c22_goal : Zis_gcd (to_Z b) (to_Z a) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.gcd (to_Z a) (to_Z b))",
                    "_global_Z.gcd_nonneg : forall a b : Z, Z.le 0 (Z.gcd a b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Zis_gcd (to_Z b) (to_Z a) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_Zis_gcd_sym : forall (a b d : Z) (_ : Zis_gcd a b d), Zis_gcd b a d"
                ],
                "tactic_res": [
                    "c23_goal : Zis_gcd (to_Z a) (to_Z b) (Z.gcd (to_Z a) (to_Z b))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : Zis_gcd (to_Z a) (to_Z b) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_Zgcd_is_gcd : forall a b : Z, Zis_gcd a b (Z.gcd a b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt (to_Z b) (to_Z a),\nLogic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c24_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "c24_H : Z.lt (to_Z b) (to_Z a)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))",
                    "_global_spec_gcd_gt : forall (a b : t) (_ : Z.gt (to_Z a) (to_Z b)),\n       Logic.eq (to_Z (gcd_gt a b)) (Z.gcd (to_Z a) (to_Z b))"
                ],
                "tactic_res": [
                    "c25_goal : Z.gt (to_Z a) (to_Z b)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : Z.gt (to_Z a) (to_Z b)",
                    "c24_H : Z.lt (to_Z b) (to_Z a)",
                    "c2_a : True",
                    "c2_b : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "even_fold",
        "proof": [
            {
                "tactic_sig": "Lemma even_fold : even = iter_t ( fun n x => ZnZ.is_even x ) .",
                "tactic_sig_no_out_arg": "Lemma even_fold : even = iter_t ( fun n x => ZnZ.is_even x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq even (iter_t (fun (n : nat) (x : dom_t n) => ZnZ.is_even x))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq even (iter_t (fun (n : nat) (x : dom_t n) => ZnZ.is_even x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq even\n  (let f0 := fun x : W0.t => ZnZ.is_even x in\n   let f1 := fun x : w1 => ZnZ.is_even x in\n   let f2 := fun x : w2 => ZnZ.is_even x in\n   let f3 := fun x : w3 => ZnZ.is_even x in\n   let f4 := fun x : w4 => ZnZ.is_even x in\n   let f5 := fun x : w5 => ZnZ.is_even x in\n   let f6 := fun x : w6 => ZnZ.is_even x in\n   let fn := fun (n : nat) (x : word w6 (S n)) => ZnZ.is_even x in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq even\n  (let f0 := fun x : W0.t => ZnZ.is_even x in\n   let f1 := fun x : w1 => ZnZ.is_even x in\n   let f2 := fun x : w2 => ZnZ.is_even x in\n   let f3 := fun x : w3 => ZnZ.is_even x in\n   let f4 := fun x : w4 => ZnZ.is_even x in\n   let f5 := fun x : w5 => ZnZ.is_even x in\n   let f6 := fun x : w6 => ZnZ.is_even x in\n   let fn := fun (n : nat) (x : word w6 (S n)) => ZnZ.is_even x in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_even_aux",
        "proof": [
            {
                "tactic_sig": "Theorem spec_even_aux : forall x , if even x then [ x ] mod 2 = 0 else [ x ] mod 2 = 1 .",
                "tactic_sig_no_out_arg": "Theorem spec_even_aux : forall x , if even x then [ x ] mod 2 = 0 else [ x ] mod 2 = 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t,\nif even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t,\nif even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ],
                "tactic_res": [
                    "c2_goal : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1",
                    "_global_even_fold : Logic.eq even (iter_t (fun (n : nat) (x : dom_t n) => ZnZ.is_even x))"
                ],
                "tactic_res": [
                    "c3_goal : if iter_t (fun (n : nat) (x : dom_t n) => ZnZ.is_even x) x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : if iter_t (fun (n : nat) (x : dom_t n) => ZnZ.is_even x) x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : if ZnZ.is_even x\nthen Logic.eq (Z.modulo (ZnZ.to_Z x) 2) 0\nelse Logic.eq (Z.modulo (ZnZ.to_Z x) 2) 1",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_is_even _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_is_even _i ) .",
                "tactic_args": [
                    "c4_goal : if ZnZ.is_even x\nthen Logic.eq (Z.modulo (ZnZ.to_Z x) 2) 0\nelse Logic.eq (Z.modulo (ZnZ.to_Z x) 2) 1",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_even",
        "proof": [
            {
                "tactic_sig": "Theorem spec_even : forall x , even x = Z.even [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_even : forall x , even x = Z.even [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (even x) (Z.even (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (even x) (Z.even (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (even x) (Z.even (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "assert ( H := spec_even_aux _i ) .",
                "tactic_sig_no_out_arg": "assert ( H := spec_even_aux _i ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c2_H : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c2_goal : Logic.eq (even x) (Z.even (to_Z x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Z.even (to_Z x)) (even x)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i [ _i ] 2 ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i [ _i ] 2 ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Z.even (to_Z x)) (even x)",
                    "_global_Z.div_mod : forall (a b : Z) (_ : not (Logic.eq b 0)),\n       Logic.eq a (Z.add (Z.mul b (Z.div a b)) (Z.modulo a b))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (even x)",
                    "c5_goal : not (Logic.eq 2 0)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : not (Logic.eq 2 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( even _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( even _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (even x)",
                    "c2_x : True",
                    "c2_H : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  true",
                    "c6_H : Logic.eq (Z.modulo (to_Z x) 2) 0",
                    "c7_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  false",
                    "c7_H : Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.add_0_r .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.add_0_r .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  true",
                    "c6_H : Logic.eq (Z.modulo (to_Z x) 2) 0"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.even (Z.mul 2 (Z.div (to_Z x) 2))) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.add_0_r .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.add_0_r .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  false",
                    "c7_H : Logic.eq (Z.modulo (to_Z x) 2) 1"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.even (Z.mul 2 (Z.div (to_Z x) 2))) true",
                    "_global_Zeven_bool_iff : forall n : Z, iff (Logic.eq (Z.even n) true) (Zeven n)"
                ],
                "tactic_res": [
                    "c10_goal : Zeven (Z.mul 2 (Z.div (to_Z x) 2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Zeven (Z.mul 2 (Z.div (to_Z x) 2))",
                    "_global_Zeven_2p : forall p : Z, Zeven (Z.mul 2 p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) false",
                    "_global_not_true_is_false : forall (b : bool) (_ : not (Logic.eq b true)), Logic.eq b false"
                ],
                "tactic_res": [
                    "c11_goal : not (Logic.eq (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : not (Logic.eq (Z.even (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) true)",
                    "_global_Zeven_bool_iff : forall n : Z, iff (Logic.eq (Z.even n) true) (Zeven n)"
                ],
                "tactic_res": [
                    "c12_goal : not (Zeven (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : not (Zeven (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1))",
                    "_global_Zodd_not_Zeven : forall (n : Z) (_ : Zodd n), not (Zeven n)"
                ],
                "tactic_res": [
                    "c13_goal : Zodd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : Zodd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)",
                    "_global_Zodd_2p_plus_1 : forall p : Z, Zodd (Z.add (Z.mul 2 p) 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_odd",
        "proof": [
            {
                "tactic_sig": "Theorem spec_odd : forall x , odd x = Z.odd [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_odd : forall x , odd x = Z.odd [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (odd x) (Z.odd (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (odd x) (Z.odd (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (odd x) (Z.odd (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (odd x) (Z.odd (to_Z x))",
                    "_global_odd : forall _ : t, bool"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (negb (even x)) (Z.odd (to_Z x))"
                ]
            },
            {
                "tactic_sig": "assert ( H := spec_even_aux _i ) .",
                "tactic_sig_no_out_arg": "assert ( H := spec_even_aux _i ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_H : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c3_goal : Logic.eq (negb (even x)) (Z.odd (to_Z x))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (Z.odd (to_Z x)) (negb (even x))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i [ _i ] 2 ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i [ _i ] 2 ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.odd (to_Z x)) (negb (even x))",
                    "_global_Z.div_mod : forall (a b : Z) (_ : not (Logic.eq b 0)),\n       Logic.eq a (Z.add (Z.mul b (Z.div a b)) (Z.modulo a b))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb (even x))",
                    "c6_goal : not (Logic.eq 2 0)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : not (Logic.eq 2 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( even _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( even _i ) .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb (even x))",
                    "c2_x : True",
                    "c3_H : if even x\nthen Logic.eq (Z.modulo (to_Z x) 2) 0\nelse Logic.eq (Z.modulo (to_Z x) 2) 1"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb true)",
                    "c7_H : Logic.eq (Z.modulo (to_Z x) 2) 0",
                    "c8_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb false)",
                    "c8_H : Logic.eq (Z.modulo (to_Z x) 2) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.add_0_r .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.add_0_r .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb true)",
                    "c7_H : Logic.eq (Z.modulo (to_Z x) 2) 0"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) (negb true)"
                ]
            },
            {
                "tactic_sig": "simpl negb .",
                "tactic_sig_no_out_arg": "simpl negb .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) (negb true)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ?Z.add_0_r .",
                "tactic_sig_no_out_arg": "rewrite _i , ?Z.add_0_r .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) (Z.modulo (to_Z x) 2)))\n  (negb false)",
                    "c8_H : Logic.eq (Z.modulo (to_Z x) 2) 1"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) (negb false)"
                ]
            },
            {
                "tactic_sig": "simpl negb .",
                "tactic_sig_no_out_arg": "simpl negb .",
                "tactic_args": [
                    "c11_goal : Logic.eq (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) (negb false)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) false",
                    "_global_not_true_is_false : forall (b : bool) (_ : not (Logic.eq b true)), Logic.eq b false"
                ],
                "tactic_res": [
                    "c13_goal : not (Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) true)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : not (Logic.eq (Z.odd (Z.mul 2 (Z.div (to_Z x) 2))) true)",
                    "_global_Zodd_bool_iff : forall n : Z, iff (Logic.eq (Z.odd n) true) (Zodd n)"
                ],
                "tactic_res": [
                    "c14_goal : not (Zodd (Z.mul 2 (Z.div (to_Z x) 2)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : not (Zodd (Z.mul 2 (Z.div (to_Z x) 2)))",
                    "_global_Zeven_not_Zodd : forall (n : Z) (_ : Zeven n), not (Zodd n)"
                ],
                "tactic_res": [
                    "c15_goal : Zeven (Z.mul 2 (Z.div (to_Z x) 2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Zeven (Z.mul 2 (Z.div (to_Z x) 2))",
                    "_global_Zeven_2p : forall p : Z, Zeven (Z.mul 2 p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (Z.odd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)) true",
                    "_global_Zodd_bool_iff : forall n : Z, iff (Logic.eq (Z.odd n) true) (Zodd n)"
                ],
                "tactic_res": [
                    "c16_goal : Zodd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : Zodd (Z.add (Z.mul 2 (Z.div (to_Z x) 2)) 1)",
                    "_global_Zodd_2p_plus_1 : forall p : Z, Zodd (Z.add (Z.mul 2 p) 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pheight_correct",
        "proof": [
            {
                "tactic_sig": "Theorem pheight_correct : forall p , Zpos p < 2 ^ ( Zpos ( ZnZ.digits ( dom_op 0 ) ) * 2 ^ ( Z.of_nat ( pheight p ) ) ) .",
                "tactic_sig_no_out_arg": "Theorem pheight_correct : forall p , Zpos p < 2 ^ ( Zpos ( ZnZ.digits ( dom_op 0 ) ) * 2 ^ ( Z.of_nat ( pheight p ) ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p : positive,\nZ.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight p)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall p : positive,\nZ.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight p)))))"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight p)))))",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight p)))))",
                    "_global_pheight : forall _ : positive, nat"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.of_nat\n              (Init.Nat.pred\n                 (Pos.to_nat\n                    (get_height (ZnZ.digits (dom_op 0)) (plength p))))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by apply _i .",
                "tactic_sig_no_out_arg": "rewrite _i by apply _i .",
                "tactic_args": [
                    "c3_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.of_nat\n              (Init.Nat.pred\n                 (Pos.to_nat\n                    (get_height (ZnZ.digits (dom_op 0)) (plength p))))))))",
                    "_global_Nat2Z.inj_pred : forall (n : nat) (_ : Peano.lt 0 n),\n       Logic.eq (Z.of_nat (Nat.pred n)) (Z.pred (Z.of_nat n))",
                    "_global_Pos2Nat.is_pos : forall p : positive, Peano.lt 0 (Pos.to_nat p)"
                ],
                "tactic_res": [
                    "c4_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.pred\n              (Z.of_nat\n                 (Pos.to_nat\n                    (get_height (ZnZ.digits (dom_op 0)) (plength p))))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.pred\n              (Z.of_nat\n                 (Pos.to_nat\n                    (get_height (ZnZ.digits (dom_op 0)) (plength p))))))))",
                    "_global_positive_nat_Z : forall p : positive, Logic.eq (Z.of_nat (Pos.to_nat p)) (Zpos p)"
                ],
                "tactic_res": [
                    "c5_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.pred\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c5_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.pred\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))))))",
                    "_global_Z.sub_1_r : forall n : Z, Logic.eq (Z.sub n 1) (Z.pred n)"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))"
                ]
            },
            {
                "tactic_sig": "assert ( F2 := ( get_height_correct ( ZnZ.digits ( dom_op 0 ) ) ( plength _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( F2 := ( get_height_correct ( ZnZ.digits ( dom_op 0 ) ) ( plength _i ) ) ) .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c6_F2 : Z.le (Zpos (plength p))\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2\n        (Z.sub (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))\n           1)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c6_goal : Z.lt (Zpos p)\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_Zpos : forall _ : positive, Z",
                    "_global_Pos.succ : forall _ : positive, positive",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt (Zpos p) (Zpos (Pos.succ p))",
                    "c8_goal : Z.le (Zpos (Pos.succ p))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Z.lt (Zpos p) (Zpos (Pos.succ p))",
                    "_global_Pos2Z.inj_succ : forall p : positive, Logic.eq (Zpos (Pos.succ p)) (Z.succ (Zpos p))"
                ],
                "tactic_res": [
                    "c9_goal : Z.lt (Zpos p) (Z.succ (Zpos p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Z.lt (Zpos p) (Z.succ (Zpos p))",
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ( _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : Z.le (Zpos (Pos.succ p))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "_global_plength_pred_correct : forall p : positive,\n       Z.le (Zpos p) (Z.pow 2 (Zpos (plength (Pos.pred p))))",
                    "_global_Pos.succ : forall _ : positive, positive",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c10_goal : Z.le (Z.pow 2 (Zpos (plength (Pos.pred (Pos.succ p)))))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Z.le (Z.pow 2 (Zpos (plength (Pos.pred (Pos.succ p)))))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))",
                    "_global_Pos.pred_succ : forall p : positive, Logic.eq (Pos.pred (Pos.succ p)) p"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (Z.pow 2 (Zpos (plength p)))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Z.le (Z.pow 2 (Zpos (plength p)))\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2\n           (Z.sub\n              (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p))) 1))))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c12_goal : Z.lt 0 2",
                    "c13_goal : Z.le (Zpos (plength p))\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2\n        (Z.sub (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))\n           1)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : Z.le (Zpos (plength p))\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2\n        (Z.sub (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))\n           1)))",
                    "c6_F2 : Z.le (Zpos (plength p))\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2\n        (Z.sub (Zpos (get_height (ZnZ.digits (dom_op 0)) (plength p)))\n           1)))",
                    "c2_p : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_of_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_of_pos : forall x , [ of_pos x ] = Zpos x .",
                "tactic_sig_no_out_arg": "Theorem spec_of_pos : forall x , [ of_pos x ] = Zpos x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : positive, Logic.eq (to_Z (of_pos x)) (Zpos x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : positive, Logic.eq (to_Z (of_pos x)) (Zpos x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (of_pos x)) (Zpos x)",
                    "c2_x : positive"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (of_pos x)) (Zpos x)",
                    "_global_of_pos : forall _ : positive, t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (reduce (pheight x) (snd (ZnZ.of_pos x)))) (Zpos x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (reduce (pheight x) (snd (ZnZ.of_pos x)))) (Zpos x)",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (snd (ZnZ.of_pos x))) (Zpos x)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (snd (ZnZ.of_pos x))) (Zpos x)",
                    "_global_ZnZ.of_pos_correct : forall (p : positive)\n         (_ : Z.lt (Zpos p) (base (ZnZ.digits (make_op ?n)))),\n       Logic.eq (ZnZ.to_Z (snd (ZnZ.of_pos p))) (Zpos p)\nwhere\n?n : [x : positive |- nat]"
                ],
                "tactic_res": [
                    "c5_goal : Z.lt (Zpos x) (base (ZnZ.digits (dom_op (pheight x))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : Z.lt (Zpos x) (base (ZnZ.digits (dom_op (pheight x))))",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt (Zpos x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op (pheight x)))))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i _i ) .",
                "tactic_args": [
                    "c6_goal : Z.lt (Zpos x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op (pheight x)))))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_pheight_correct : forall p : positive,\n       Z.lt (Zpos p)\n         (Z.pow 2\n            (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n               (Z.pow 2 (Z.of_nat (pheight p)))))",
                    "c2_x : positive"
                ],
                "tactic_res": [
                    "c7_goal : Z.le\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight x)))))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op (pheight x)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Z.le\n  (Z.pow 2\n     (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n        (Z.pow 2 (Z.of_nat (pheight x)))))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op (pheight x)))))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c8_goal : Z.lt 0 2",
                    "c9_goal : Z.le\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2 (Z.of_nat (pheight x))))\n  (Zpos (ZnZ.digits (dom_op (pheight x))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i ) ) , _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i ) ) , _i .",
                "tactic_args": [
                    "c9_goal : Z.le\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2 (Z.of_nat (pheight x))))\n  (Zpos (ZnZ.digits (dom_op (pheight x))))",
                    "_global_digits_dom_op : forall n : nat,\n       Logic.eq (ZnZ.digits (dom_op n))\n         (Pos.shiftl_nat (ZnZ.digits W0.ops) n)",
                    "_global__ : ?T\nwhere\n?T : [x : positive |- Type]\n?y : [x : positive |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [x : positive |- Type]\n?y : [x : positive |- ?T]",
                    "_global_Pshiftl_nat_Zpower : forall (n : nat) (p : positive),\n       Logic.eq (Zpos (Pos.shiftl_nat p n))\n         (Z.mul (Zpos p) (Z.pow 2 (Z.of_nat n)))"
                ],
                "tactic_res": [
                    "c10_goal : Z.le\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2 (Z.of_nat (pheight x))))\n  (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat (pheight x))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Z.le\n  (Z.mul (Zpos (ZnZ.digits (dom_op 0)))\n     (Z.pow 2 (Z.of_nat (pheight x))))\n  (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat (pheight x))))",
                    "c2_x : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_of_N",
        "proof": [
            {
                "tactic_sig": "Theorem spec_of_N : forall x , [ of_N x ] = Z.of_N x .",
                "tactic_sig_no_out_arg": "Theorem spec_of_N : forall x , [ of_N x ] = Z.of_N x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : N, Logic.eq (to_Z (of_N x)) (Z.of_N x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : N, Logic.eq (to_Z (of_N x)) (Z.of_N x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (of_N x)) (Z.of_N x)",
                    "c2_x : N"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (of_N x)) (Z.of_N x)",
                    "c2_x : N"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (of_N 0)) (Z.of_N 0%N)",
                    "c4_goal : forall p : positive, Logic.eq (to_Z (of_N (Npos p))) (Z.of_N (Npos p))"
                ]
            },
            {
                "tactic_sig": "simpl of_N .",
                "tactic_sig_no_out_arg": "simpl of_N .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (of_N 0)) (Z.of_N 0%N)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z zero) (Z.of_N 0%N)"
                ]
            },
            {
                "tactic_sig": "exact spec_0 .",
                "tactic_sig_no_out_arg": "exact spec_0 .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z zero) (Z.of_N 0%N)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c4_goal : forall p : positive, Logic.eq (to_Z (of_N (Npos p))) (Z.of_N (Npos p))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (to_Z (of_N (Npos p))) (Z.of_N (Npos p))",
                    "c6_p : positive"
                ]
            },
            {
                "tactic_sig": "exact ( spec_of_pos _i ) .",
                "tactic_sig_no_out_arg": "exact ( spec_of_pos _i ) .",
                "tactic_args": [
                    "c6_goal : Logic.eq (to_Z (of_N (Npos p))) (Z.of_N (Npos p))",
                    "c6_p : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "head0_fold",
        "proof": [
            {
                "tactic_sig": "Lemma head0_fold : head0 = iter_t head0n .",
                "tactic_sig_no_out_arg": "Lemma head0_fold : head0 = iter_t head0n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq head0\n  (iter_t\n     (fun n : nat =>\n      let head0 := ZnZ.head0 in fun x : dom_t n => reduce n (head0 x)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq head0\n  (iter_t\n     (fun n : nat =>\n      let head0 := ZnZ.head0 in fun x : dom_t n => reduce n (head0 x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq head0\n  (let f0 :=\n     let head0 := ZnZ.head0 in fun x : W0.t => reduce_0 (head0 x) in\n   let f1 := let head0 := ZnZ.head0 in fun x : w1 => reduce_1 (head0 x)\n     in\n   let f2 := let head0 := ZnZ.head0 in fun x : w2 => reduce_2 (head0 x)\n     in\n   let f3 := let head0 := ZnZ.head0 in fun x : w3 => reduce_3 (head0 x)\n     in\n   let f4 := let head0 := ZnZ.head0 in fun x : w4 => reduce_4 (head0 x)\n     in\n   let f5 := let head0 := ZnZ.head0 in fun x : w5 => reduce_5 (head0 x)\n     in\n   let f6 := let head0 := ZnZ.head0 in fun x : w6 => reduce_6 (head0 x)\n     in\n   let fn :=\n     fun n : nat =>\n     let head0 := ZnZ.head0 in\n     fun x : word w6 (S n) => reduce_n n (head0 x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq head0\n  (let f0 :=\n     let head0 := ZnZ.head0 in fun x : W0.t => reduce_0 (head0 x) in\n   let f1 := let head0 := ZnZ.head0 in fun x : w1 => reduce_1 (head0 x)\n     in\n   let f2 := let head0 := ZnZ.head0 in fun x : w2 => reduce_2 (head0 x)\n     in\n   let f3 := let head0 := ZnZ.head0 in fun x : w3 => reduce_3 (head0 x)\n     in\n   let f4 := let head0 := ZnZ.head0 in fun x : w4 => reduce_4 (head0 x)\n     in\n   let f5 := let head0 := ZnZ.head0 in fun x : w5 => reduce_5 (head0 x)\n     in\n   let f6 := let head0 := ZnZ.head0 in fun x : w6 => reduce_6 (head0 x)\n     in\n   let fn :=\n     fun n : nat =>\n     let head0 := ZnZ.head0 in\n     fun x : word w6 (S n) => reduce_n n (head0 x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_head00",
        "proof": [
            {
                "tactic_sig": "Theorem spec_head00 : forall x , [ x ] = 0 -> [ head0 x ] = Zpos ( digits x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_head00 : forall x , [ x ] = 0 -> [ head0 x ] = Zpos ( digits x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0),\nLogic.eq (to_Z (head0 x)) (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0),\nLogic.eq (to_Z (head0 x)) (Zpos (digits x))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z (head0 x)) (Zpos (digits x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z (head0 x)) (Zpos (digits x))",
                    "_global_head0_fold : Logic.eq head0\n         (iter_t\n            (fun n : nat =>\n             let head0 := ZnZ.head0 in fun x : dom_t n => reduce n (head0 x)))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let head0 := ZnZ.head0 in\n         fun x : dom_t n => reduce n (head0 x)) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let head0 := ZnZ.head0 in\n         fun x : dom_t n => reduce n (head0 x)) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Logic.eq (ZnZ.to_Z x) 0,\nLogic.eq (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_head00 _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_head00 _i ) .",
                "tactic_args": [
                    "c4_goal : forall _ : Logic.eq (ZnZ.to_Z x) 0,\nLogic.eq (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pow2_pos_minus_1",
        "proof": [
            {
                "tactic_sig": "Lemma pow2_pos_minus_1 : forall z , 0<z -> 2 ^ ( z - 1 ) = 2 ^ z / 2 .",
                "tactic_sig_no_out_arg": "Lemma pow2_pos_minus_1 : forall z , 0<z -> 2 ^ ( z - 1 ) = 2 ^ z / 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (z : Z) (_ : Z.lt 0 z),\nLogic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (z : Z) (_ : Z.lt 0 z),\nLogic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)",
                    "c2_z : Z",
                    "c2_H : Z.lt 0 z"
                ]
            },
            {
                "tactic_sig": "apply _i with 0 .",
                "tactic_sig_no_out_arg": "apply _i with 0 .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)",
                    "_global_Zdiv_unique : forall (a b q r : Z) (_ : and (Z.le 0 r) (Z.lt r b))\n         (_ : Logic.eq a (Z.add (Z.mul b q) r)), Logic.eq q (Z.div a b)"
                ],
                "tactic_res": [
                    "c3_goal : and (Z.le 0 0) (Z.lt 0 2)",
                    "c4_goal : Logic.eq (Z.pow 2 z) (Z.add (Z.mul 2 (Z.pow 2 (Z.sub z 1))) 0)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : and (Z.le 0 0) (Z.lt 0 2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change 2 with ( 2 ^ 1 ) at 2 .",
                "tactic_sig_no_out_arg": "change 2 with ( 2 ^ 1 ) at 2 .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.pow 2 z) (Z.add (Z.mul 2 (Z.pow 2 (Z.sub z 1))) 0)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.pow 2 z)\n  (Z.add (Z.mul (Z.pow 2 1) (Z.pow 2 (Z.sub z 1))) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.pow 2 z)\n  (Z.add (Z.mul (Z.pow 2 1) (Z.pow 2 (Z.sub z 1))) 0)",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Z.pow 2 z) (Z.add (Z.pow 2 (Z.add 1 (Z.sub z 1))) 0)",
                    "c7_goal : Z.ge 1 0",
                    "c8_goal : Z.ge (Z.sub z 1) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Z.ge 1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.ge (Z.sub z 1) 0",
                    "c2_H : Z.lt 0 z",
                    "c2_z : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.pow 2 z) (Z.add (Z.pow 2 (Z.add 1 (Z.sub z 1))) 0)",
                    "_global_Z.add_0_r : forall n : Z, Logic.eq (Z.add n 0) n"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.pow 2 z) (Z.pow 2 (Z.add 1 (Z.sub z 1)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.pow 2 z) (Z.pow 2 (Z.add 1 (Z.sub z 1)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq z (Z.add 1 (Z.sub z 1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Logic.eq z (Z.add 1 (Z.sub z 1))",
                    "c2_z : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_head0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_head0 : forall x , 0 < [ x ] -> 2 ^ ( Zpos ( digits x ) - 1 ) <= 2 ^ [ head0 x ] * [ x ] < 2 ^ Zpos ( digits x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_head0 : forall x , 0 < [ x ] -> 2 ^ ( Zpos ( digits x ) - 1 ) <= 2 ^ [ head0 x ] * [ x ] < 2 ^ Zpos ( digits x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nand\n  (Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nand\n  (Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i by ( red ; auto ) .",
                "tactic_sig_no_out_arg": "rewrite _i by ( red ; auto ) .",
                "tactic_args": [
                    "c2_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))",
                    "_global_pow2_pos_minus_1 : forall (z : Z) (_ : Z.lt 0 z),\n       Logic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le (Z.div (Z.pow 2 (Zpos (digits x))) 2)\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c3_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le (Z.div (Z.pow 2 (Zpos (digits x))) 2)\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))",
                    "_global_head0_fold : Logic.eq head0\n         (iter_t\n            (fun n : nat =>\n             let head0 := ZnZ.head0 in fun x : dom_t n => reduce n (head0 x)))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le\n     (Z.div\n        (Z.pow 2\n           (Zpos\n              (iter_t\n                 (fun n : nat =>\n                  let digits := ZnZ.digits (dom_op n) in\n                  fun _ : dom_t n => digits) x))) 2)\n     (Z.mul\n        (Z.pow 2\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let head0 := ZnZ.head0 in\n                  fun x : dom_t n => reduce n (head0 x)) x))) \n        (to_Z x)))\n  (Z.lt\n     (Z.mul\n        (Z.pow 2\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let head0 := ZnZ.head0 in\n                  fun x : dom_t n => reduce n (head0 x)) x))) \n        (to_Z x))\n     (Z.pow 2\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c4_goal : forall _ : Z.lt 0 (to_Z x),\nand\n  (Z.le\n     (Z.div\n        (Z.pow 2\n           (Zpos\n              (iter_t\n                 (fun n : nat =>\n                  let digits := ZnZ.digits (dom_op n) in\n                  fun _ : dom_t n => digits) x))) 2)\n     (Z.mul\n        (Z.pow 2\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let head0 := ZnZ.head0 in\n                  fun x : dom_t n => reduce n (head0 x)) x))) \n        (to_Z x)))\n  (Z.lt\n     (Z.mul\n        (Z.pow 2\n           (to_Z\n              (iter_t\n                 (fun n : nat =>\n                  let head0 := ZnZ.head0 in\n                  fun x : dom_t n => reduce n (head0 x)) x))) \n        (to_Z x))\n     (Z.pow 2\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nand\n  (Z.le (Z.div (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) 2)\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_head0 _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_head0 _i ) .",
                "tactic_args": [
                    "c5_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nand\n  (Z.le (Z.div (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) 2)\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c5_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "tail0_fold",
        "proof": [
            {
                "tactic_sig": "Lemma tail0_fold : tail0 = iter_t tail0n .",
                "tactic_sig_no_out_arg": "Lemma tail0_fold : tail0 = iter_t tail0n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq tail0\n  (iter_t\n     (fun n : nat =>\n      let tail0 := ZnZ.tail0 in fun x : dom_t n => reduce n (tail0 x)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq tail0\n  (iter_t\n     (fun n : nat =>\n      let tail0 := ZnZ.tail0 in fun x : dom_t n => reduce n (tail0 x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq tail0\n  (let f0 :=\n     let tail0 := ZnZ.tail0 in fun x : W0.t => reduce_0 (tail0 x) in\n   let f1 := let tail0 := ZnZ.tail0 in fun x : w1 => reduce_1 (tail0 x)\n     in\n   let f2 := let tail0 := ZnZ.tail0 in fun x : w2 => reduce_2 (tail0 x)\n     in\n   let f3 := let tail0 := ZnZ.tail0 in fun x : w3 => reduce_3 (tail0 x)\n     in\n   let f4 := let tail0 := ZnZ.tail0 in fun x : w4 => reduce_4 (tail0 x)\n     in\n   let f5 := let tail0 := ZnZ.tail0 in fun x : w5 => reduce_5 (tail0 x)\n     in\n   let f6 := let tail0 := ZnZ.tail0 in fun x : w6 => reduce_6 (tail0 x)\n     in\n   let fn :=\n     fun n : nat =>\n     let tail0 := ZnZ.tail0 in\n     fun x : word w6 (S n) => reduce_n n (tail0 x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq tail0\n  (let f0 :=\n     let tail0 := ZnZ.tail0 in fun x : W0.t => reduce_0 (tail0 x) in\n   let f1 := let tail0 := ZnZ.tail0 in fun x : w1 => reduce_1 (tail0 x)\n     in\n   let f2 := let tail0 := ZnZ.tail0 in fun x : w2 => reduce_2 (tail0 x)\n     in\n   let f3 := let tail0 := ZnZ.tail0 in fun x : w3 => reduce_3 (tail0 x)\n     in\n   let f4 := let tail0 := ZnZ.tail0 in fun x : w4 => reduce_4 (tail0 x)\n     in\n   let f5 := let tail0 := ZnZ.tail0 in fun x : w5 => reduce_5 (tail0 x)\n     in\n   let f6 := let tail0 := ZnZ.tail0 in fun x : w6 => reduce_6 (tail0 x)\n     in\n   let fn :=\n     fun n : nat =>\n     let tail0 := ZnZ.tail0 in\n     fun x : word w6 (S n) => reduce_n n (tail0 x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_tail00",
        "proof": [
            {
                "tactic_sig": "Theorem spec_tail00 : forall x , [ x ] = 0 -> [ tail0 x ] = Zpos ( digits x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_tail00 : forall x , [ x ] = 0 -> [ tail0 x ] = Zpos ( digits x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0),\nLogic.eq (to_Z (tail0 x)) (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0),\nLogic.eq (to_Z (tail0 x)) (Zpos (digits x))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z (tail0 x)) (Zpos (digits x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z (tail0 x)) (Zpos (digits x))",
                    "_global_tail0_fold : Logic.eq tail0\n         (iter_t\n            (fun n : nat =>\n             let tail0 := ZnZ.tail0 in fun x : dom_t n => reduce n (tail0 x)))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let tail0 := ZnZ.tail0 in\n         fun x : dom_t n => reduce n (tail0 x)) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let tail0 := ZnZ.tail0 in\n         fun x : dom_t n => reduce n (tail0 x)) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Logic.eq (ZnZ.to_Z x) 0,\nLogic.eq (ZnZ.to_Z (ZnZ.tail0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_tail00 _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_tail00 _i ) .",
                "tactic_args": [
                    "c4_goal : forall _ : Logic.eq (ZnZ.to_Z x) 0,\nLogic.eq (ZnZ.to_Z (ZnZ.tail0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_tail0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_tail0 : forall x , 0 < [ x ] -> exists y , 0 <= y /\\ [ x ] = ( 2 * y + 1 ) * 2 ^ [ tail0 x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_tail0 : forall x , 0 < [ x ] -> exists y , 0 <= y /\\ [ x ] = ( 2 * y + 1 ) * 2 ^ [ tail0 x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (to_Z (tail0 x))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (to_Z (tail0 x))))))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Z.lt 0 (to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (to_Z (tail0 x))))))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Z.lt 0 (to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (to_Z (tail0 x))))))",
                    "_global_tail0_fold : Logic.eq tail0\n         (iter_t\n            (fun n : nat =>\n             let tail0 := ZnZ.tail0 in fun x : dom_t n => reduce n (tail0 x)))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Z.lt 0 (to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1)\n           (Z.pow 2\n              (to_Z\n                 (iter_t\n                    (fun n : nat =>\n                     let tail0 := ZnZ.tail0 in\n                     fun x : dom_t n => reduce n (tail0 x)) x))))))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : Z.lt 0 (to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1)\n           (Z.pow 2\n              (to_Z\n                 (iter_t\n                    (fun n : nat =>\n                     let tail0 := ZnZ.tail0 in\n                     fun x : dom_t n => reduce n (tail0 x)) x))))))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (ZnZ.to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (ZnZ.to_Z (ZnZ.tail0 x))))))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "exact ( ZnZ.spec_tail0 _i ) .",
                "tactic_sig_no_out_arg": "exact ( ZnZ.spec_tail0 _i ) .",
                "tactic_args": [
                    "c4_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nex\n  (fun y : Z =>\n   and (Z.le 0 y)\n     (Logic.eq (ZnZ.to_Z x)\n        (Z.mul (Z.add (Z.mul 2 y) 1) (Z.pow 2 (ZnZ.to_Z (ZnZ.tail0 x))))))",
                    "c4_x : dom_t n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Ndigits_fold",
        "proof": [
            {
                "tactic_sig": "Lemma Ndigits_fold : Ndigits = iter_t Ndigitsn .",
                "tactic_sig_no_out_arg": "Lemma Ndigits_fold : Ndigits = iter_t Ndigitsn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq Ndigits\n  (iter_t\n     (fun n : nat =>\n      let d := reduce n (ZnZ.zdigits (dom_op n)) in\n      fun _ : dom_t n => d))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq Ndigits\n  (iter_t\n     (fun n : nat =>\n      let d := reduce n (ZnZ.zdigits (dom_op n)) in\n      fun _ : dom_t n => d))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq Ndigits\n  (let f0 :=\n     let d := reduce_0 (ZnZ.zdigits W0.ops) in fun _ : W0.t => d in\n   let f1 := let d := reduce_1 (ZnZ.zdigits w1_op) in fun _ : w1 => d\n     in\n   let f2 := let d := reduce_2 (ZnZ.zdigits w2_op) in fun _ : w2 => d\n     in\n   let f3 := let d := reduce_3 (ZnZ.zdigits w3_op) in fun _ : w3 => d\n     in\n   let f4 := let d := reduce_4 (ZnZ.zdigits w4_op) in fun _ : w4 => d\n     in\n   let f5 := let d := reduce_5 (ZnZ.zdigits w5_op) in fun _ : w5 => d\n     in\n   let f6 := let d := reduce_6 (ZnZ.zdigits w6_op) in fun _ : w6 => d\n     in\n   let fn :=\n     fun n : nat =>\n     let d := reduce_n n (ZnZ.zdigits (make_op n)) in\n     fun _ : word w6 (S n) => d in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq Ndigits\n  (let f0 :=\n     let d := reduce_0 (ZnZ.zdigits W0.ops) in fun _ : W0.t => d in\n   let f1 := let d := reduce_1 (ZnZ.zdigits w1_op) in fun _ : w1 => d\n     in\n   let f2 := let d := reduce_2 (ZnZ.zdigits w2_op) in fun _ : w2 => d\n     in\n   let f3 := let d := reduce_3 (ZnZ.zdigits w3_op) in fun _ : w3 => d\n     in\n   let f4 := let d := reduce_4 (ZnZ.zdigits w4_op) in fun _ : w4 => d\n     in\n   let f5 := let d := reduce_5 (ZnZ.zdigits w5_op) in fun _ : w5 => d\n     in\n   let f6 := let d := reduce_6 (ZnZ.zdigits w6_op) in fun _ : w6 => d\n     in\n   let fn :=\n     fun n : nat =>\n     let d := reduce_n n (ZnZ.zdigits (make_op n)) in\n     fun _ : word w6 (S n) => d in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_Ndigits",
        "proof": [
            {
                "tactic_sig": "Theorem spec_Ndigits : forall x , [ Ndigits x ] = Zpos ( digits x ) .",
                "tactic_sig_no_out_arg": "Theorem spec_Ndigits : forall x , [ Ndigits x ] = Zpos ( digits x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (Ndigits x)) (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (Ndigits x)) (Zpos (digits x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (Ndigits x)) (Zpos (digits x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (Ndigits x)) (Zpos (digits x))",
                    "_global_Ndigits_fold : Logic.eq Ndigits\n         (iter_t\n            (fun n : nat =>\n             let d := reduce n (ZnZ.zdigits (dom_op n)) in\n             fun _ : dom_t n => d))",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let d := reduce n (ZnZ.zdigits (dom_op n)) in\n         fun _ : dom_t n => d) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let d := reduce n (ZnZ.zdigits (dom_op n)) in\n         fun _ : dom_t n => d) x))\n  (Zpos\n     (iter_t\n        (fun n : nat =>\n         let digits := ZnZ.digits (dom_op n) in\n         fun _ : dom_t n => digits) x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n  (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n  (Zpos (ZnZ.digits (dom_op n)))",
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "log2_fold",
        "proof": [
            {
                "tactic_sig": "Lemma log2_fold : log2 = fun x => if eqb x zero then zero else iter_t log2n x .",
                "tactic_sig_no_out_arg": "Lemma log2_fold : log2 = fun x => if eqb x zero then zero else iter_t log2n x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq log2\n  (fun x : t =>\n   if eqb x zero\n   then zero\n   else\n    iter_t\n      (fun n : nat =>\n       let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : dom_t n => reduce n (sub_carry zdigits (head0 x0))) x)"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq log2\n  (fun x : t =>\n   if eqb x zero\n   then zero\n   else\n    iter_t\n      (fun n : nat =>\n       let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : dom_t n => reduce n (sub_carry zdigits (head0 x0))) x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq log2\n  (fun x : t =>\n   if eqb x zero\n   then zero\n   else\n    (let f0 :=\n       let op := W0.ops in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : W0.t => reduce_0 (sub_carry zdigits (head0 x0)) in\n     let f1 :=\n       let op := w1_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w1 => reduce_1 (sub_carry zdigits (head0 x0)) in\n     let f2 :=\n       let op := w2_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w2 => reduce_2 (sub_carry zdigits (head0 x0)) in\n     let f3 :=\n       let op := w3_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w3 => reduce_3 (sub_carry zdigits (head0 x0)) in\n     let f4 :=\n       let op := w4_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w4 => reduce_4 (sub_carry zdigits (head0 x0)) in\n     let f5 :=\n       let op := w5_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w5 => reduce_5 (sub_carry zdigits (head0 x0)) in\n     let f6 :=\n       let op := w6_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w6 => reduce_6 (sub_carry zdigits (head0 x0)) in\n     let fn :=\n       fun n : nat =>\n       let op := make_op n in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : word w6 (S n) =>\n       reduce_n n (sub_carry zdigits (head0 x0)) in\n     fun x0 : t =>\n     match x0 with\n     | N0 wx => f0 wx\n     | N1 wx => f1 wx\n     | N2 wx => f2 wx\n     | N3 wx => f3 wx\n     | N4 wx => f4 wx\n     | N5 wx => f5 wx\n     | N6 wx => f6 wx\n     | Nn n wx => fn n wx\n     end) x)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq log2\n  (fun x : t =>\n   if eqb x zero\n   then zero\n   else\n    (let f0 :=\n       let op := W0.ops in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : W0.t => reduce_0 (sub_carry zdigits (head0 x0)) in\n     let f1 :=\n       let op := w1_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w1 => reduce_1 (sub_carry zdigits (head0 x0)) in\n     let f2 :=\n       let op := w2_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w2 => reduce_2 (sub_carry zdigits (head0 x0)) in\n     let f3 :=\n       let op := w3_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w3 => reduce_3 (sub_carry zdigits (head0 x0)) in\n     let f4 :=\n       let op := w4_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w4 => reduce_4 (sub_carry zdigits (head0 x0)) in\n     let f5 :=\n       let op := w5_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w5 => reduce_5 (sub_carry zdigits (head0 x0)) in\n     let f6 :=\n       let op := w6_op in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : w6 => reduce_6 (sub_carry zdigits (head0 x0)) in\n     let fn :=\n       fun n : nat =>\n       let op := make_op n in\n       let zdigits := ZnZ.zdigits op in\n       let head0 := ZnZ.head0 in\n       let sub_carry := ZnZ.sub_carry in\n       fun x0 : word w6 (S n) =>\n       reduce_n n (sub_carry zdigits (head0 x0)) in\n     fun x0 : t =>\n     match x0 with\n     | N0 wx => f0 wx\n     | N1 wx => f1 wx\n     | N2 wx => f2 wx\n     | N3 wx => f3 wx\n     | N4 wx => f4 wx\n     | N5 wx => f5 wx\n     | N6 wx => f6 wx\n     | Nn n wx => fn n wx\n     end) x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_log2_0",
        "proof": [
            {
                "tactic_sig": "Lemma spec_log2_0 : forall x , [ x ] = 0 -> [ log2 x ] = 0 .",
                "tactic_sig_no_out_arg": "Lemma spec_log2_0 : forall x , [ x ] = 0 -> [ log2 x ] = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (log2 x)) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x H .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (log2 x)) 0"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) 0",
                    "c2_x : True",
                    "c2_H : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) 0",
                    "_global_log2_fold : Logic.eq log2\n         (fun x : t =>\n          if eqb x zero\n          then zero\n          else\n           iter_t\n             (fun n : nat =>\n              let op := dom_op n in\n              let zdigits := ZnZ.zdigits op in\n              let head0 := ZnZ.head0 in\n              let sub_carry := ZnZ.sub_carry in\n              fun x0 : dom_t n => reduce n (sub_carry zdigits (head0 x0))) x)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb x zero\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb x zero\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0",
                    "_global_spec_eqb : forall x y : t, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))",
                    "c2_H : Logic.eq (to_Z x) 0"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb 0 (to_Z zero)\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb 0 (to_Z zero)\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (to_Z\n     (if Z.eqb 0 0\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     (if Z.eqb 0 0\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  0"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0"
                ]
            },
            {
                "tactic_sig": "exact spec_0 .",
                "tactic_sig_no_out_arg": "exact spec_0 .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z ZnZ.zero) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "head0_zdigits",
        "proof": [
            {
                "tactic_sig": "Lemma head0_zdigits : forall n ( x : dom_t n ) , 0 < ZnZ.to_Z x -> ZnZ.to_Z ( ZnZ.head0 x ) < ZnZ.to_Z ( ZnZ.zdigits ( dom_op n ) ) .",
                "tactic_sig_no_out_arg": "Lemma head0_zdigits : forall n ( x : dom_t n ) , 0 < ZnZ.to_Z x -> ZnZ.to_Z ( ZnZ.head0 x ) < ZnZ.to_Z ( ZnZ.zdigits ( dom_op n ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : dom_t n) (_ : Z.lt 0 (ZnZ.to_Z x)),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x H .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : dom_t n) (_ : Z.lt 0 (ZnZ.to_Z x)),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "c2_n : nat",
                    "c2_x : dom_t n",
                    "c2_H : Z.lt 0 (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "destruct ( ZnZ.spec_head0 _i _i ) as ( _ , H0 ) .",
                "tactic_sig_no_out_arg": "destruct ( ZnZ.spec_head0 _i _i ) as ( _ , H0 ) .",
                "tactic_args": [
                    "c2_x : dom_t n",
                    "c2_H : Z.lt 0 (ZnZ.to_Z x)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c2_H0 : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n  (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "assert ( H1 := ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H1 := ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_args": [
                    "c2_x : dom_t n"
                ],
                "tactic_res": [
                    "c2_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "assert ( H2 := ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H2 := ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c2_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c2_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c2_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c2_H0 : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i | - * .",
                "tactic_sig_no_out_arg": "rewrite _i in _i | - * .",
                "tactic_args": [
                    "c2_goal : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : Z.lt 0 (ZnZ.to_Z x)\n      H0 : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n             (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n                (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))\n      H2 : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n             (Z.lt (Zpos (ZnZ.digits (dom_op n)))\n                (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))) |- nat]",
                    "c2_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c3_H2 : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n  (Z.lt (Zpos (ZnZ.digits (dom_op n)))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "set ( h := ZnZ.to_Z ( ZnZ.head0 _i ) ) in * .",
                "tactic_sig_no_out_arg": "set ( h := ZnZ.to_Z ( ZnZ.head0 _i ) ) in * .",
                "tactic_args": [
                    "c3_goal : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c2_x : dom_t n"
                ],
                "tactic_res": [
                    "c4_goal : Z.lt h (Zpos (ZnZ.digits (dom_op n)))",
                    "c4_H1 : and (Z.le 0 h) (Z.lt h (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c4_H0 : Z.lt (Z.mul (Z.pow 2 h) (ZnZ.to_Z x))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))",
                    "c4_h : Z"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c4_h : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( d := ZnZ.digits ( dom_op _i ) ) in * .",
                "tactic_sig_no_out_arg": "set ( d := ZnZ.digits ( dom_op _i ) ) in * .",
                "tactic_args": [
                    "c4_goal : Z.lt h (Zpos (ZnZ.digits (dom_op n)))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : Z.lt h (Zpos d)",
                    "c5_H2 : and (Z.le 0 (Zpos d)) (Z.lt (Zpos d) (Z.pow 2 (Zpos d)))",
                    "c5_H1 : and (Z.le 0 h) (Z.lt h (Z.pow 2 (Zpos d)))",
                    "c5_H0 : Z.lt (Z.mul (Z.pow 2 h) (ZnZ.to_Z x)) (Z.pow 2 (Zpos d))",
                    "c5_d : positive"
                ]
            },
            {
                "tactic_sig": "clearbody _i .",
                "tactic_sig_no_out_arg": "clearbody _i .",
                "tactic_args": [
                    "c5_d : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Z_lt_le_dec _i ( Zpos _i ) ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z_lt_le_dec _i ( Zpos _i ) ) .",
                "tactic_args": [
                    "c5_goal : Z.lt h (Zpos d)",
                    "c4_h : Z",
                    "c5_d : positive",
                    "c5_H2 : and (Z.le 0 (Zpos d)) (Z.lt (Zpos d) (Z.pow 2 (Zpos d)))",
                    "c5_H1 : and (Z.le 0 h) (Z.lt h (Z.pow 2 (Zpos d)))",
                    "c5_H0 : Z.lt (Z.mul (Z.pow 2 h) (ZnZ.to_Z x)) (Z.pow 2 (Zpos d))",
                    "c2_H : Z.lt 0 (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt h (Zpos d)",
                    "c6_l : Z.lt h (Zpos d)",
                    "c7_goal : Z.lt h (Zpos d)",
                    "c7_l : Z.le (Zpos d) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Z.lt h (Zpos d)",
                    "c6_l : Z.lt h (Zpos d)",
                    "c5_d : positive",
                    "c4_h : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c7_goal : Z.lt h (Zpos d)"
                ],
                "tactic_res": [
                    "c8_goal : False"
                ]
            },
            {
                "tactic_sig": "assert ( 1 * 2 ^ Zpos _i <= ZnZ.to_Z _i * 2 ^ _i ) .",
                "tactic_sig_no_out_arg": "assert ( 1 * 2 ^ Zpos _i <= ZnZ.to_Z _i * 2 ^ _i ) .",
                "tactic_args": [
                    "c8_goal : False",
                    "c5_d : positive",
                    "c2_x : dom_t n",
                    "c4_h : Z"
                ],
                "tactic_res": [
                    "c9_goal : Z.le (Z.mul 1 (Z.pow 2 (Zpos d))) (Z.mul (ZnZ.to_Z x) (Z.pow 2 h))",
                    "c10_goal : False",
                    "c10_H3 : Z.le (Z.mul 1 (Z.pow 2 (Zpos d))) (Z.mul (ZnZ.to_Z x) (Z.pow 2 h))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Z.le (Z.mul 1 (Z.pow 2 (Zpos d))) (Z.mul (ZnZ.to_Z x) (Z.pow 2 h))",
                    "_global_Z.mul_le_mono_nonneg : forall (n m p q : Z) (_ : Z.le 0 n) (_ : Z.le n m) \n         (_ : Z.le 0 p) (_ : Z.le p q), Z.le (Z.mul n p) (Z.mul m q)"
                ],
                "tactic_res": [
                    "c11_goal : Z.le 0 1",
                    "c12_goal : Z.le 1 (ZnZ.to_Z x)",
                    "c13_goal : Z.le 0 (Z.pow 2 (Zpos d))",
                    "c14_goal : Z.le (Z.pow 2 (Zpos d)) (Z.pow 2 h)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 1 (ZnZ.to_Z x)",
                    "c2_H : Z.lt 0 (ZnZ.to_Z x)",
                    "c2_x : dom_t n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : Z.le 0 (Z.pow 2 (Zpos d))",
                    "c5_d : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.le (Z.pow 2 (Zpos d)) (Z.pow 2 h)",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt 0 2",
                    "c16_goal : Z.le (Zpos d) h"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.le (Zpos d) h",
                    "c7_l : Z.le (Zpos d) h",
                    "c5_d : positive",
                    "c4_h : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)",
                    "c10_H0 : Z.lt (Z.mul (Z.pow 2 h) (ZnZ.to_Z x)) (Z.pow 2 (Zpos d))"
                ],
                "tactic_res": [
                    "c10_H0 : Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 h)) (Z.pow 2 (Zpos d))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : False",
                    "c10_H3 : Z.le (Z.mul 1 (Z.pow 2 (Zpos d))) (Z.mul (ZnZ.to_Z x) (Z.pow 2 h))",
                    "c10_H0 : Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 h)) (Z.pow 2 (Zpos d))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_log2_pos",
        "proof": [
            {
                "tactic_sig": "Lemma spec_log2_pos : forall x , [ x ] <> 0 -> 2 ^ [ log2 x ] <= [ x ] < 2 ^ ( [ log2 x ] + 1 ) .",
                "tactic_sig_no_out_arg": "Lemma spec_log2_pos : forall x , [ x ] <> 0 -> 2 ^ [ log2 x ] <= [ x ] < 2 ^ ( [ log2 x ] + 1 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : not (Logic.eq (to_Z x) 0)),\nand (Z.le (Z.pow 2 (to_Z (log2 x))) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x H .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : not (Logic.eq (to_Z x) 0)),\nand (Z.le (Z.pow 2 (to_Z (log2 x))) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1)))"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le (Z.pow 2 (to_Z (log2 x))) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1)))",
                    "c2_x : True",
                    "c2_H : not (Logic.eq (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : and (Z.le (Z.pow 2 (to_Z (log2 x))) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1)))",
                    "_global_log2_fold : Logic.eq log2\n         (fun x : t =>\n          if eqb x zero\n          then zero\n          else\n           iter_t\n             (fun n : nat =>\n              let op := dom_op n in\n              let zdigits := ZnZ.zdigits op in\n              let head0 := ZnZ.head0 in\n              let sub_carry := ZnZ.sub_carry in\n              fun x0 : dom_t n => reduce n (sub_carry zdigits (head0 x0))) x)"
                ],
                "tactic_res": [
                    "c3_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if eqb x zero\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if eqb x zero\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if eqb x zero\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if eqb x zero\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))",
                    "_global_spec_eqb : forall x y : t, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if Z.eqb (to_Z x) (to_Z zero)\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if Z.eqb (to_Z x) (to_Z zero)\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if Z.eqb (to_Z x) (to_Z zero)\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if Z.eqb (to_Z x) (to_Z zero)\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c5_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if Z.eqb (to_Z x) 0\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if Z.eqb (to_Z x) 0\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c5_goal : and\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (if Z.eqb (to_Z x) 0\n            then zero\n            else\n             iter_t\n               (fun n : nat =>\n                let op := dom_op n in\n                let zdigits := ZnZ.zdigits op in\n                let head0 := ZnZ.head0 in\n                let sub_carry := ZnZ.sub_carry in\n                fun x : dom_t n =>\n                reduce n (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (if Z.eqb (to_Z x) 0\n               then zero\n               else\n                iter_t\n                  (fun n : nat =>\n                   let op := dom_op n in\n                   let zdigits := ZnZ.zdigits op in\n                   let head0 := ZnZ.head0 in\n                   let sub_carry := ZnZ.sub_carry in\n                   fun x : dom_t n =>\n                   reduce n (sub_carry zdigits (head0 x))) x)) 1)))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Logic.eq (to_Z x) 0,\nand (Z.le (Z.pow 2 (to_Z zero)) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z zero) 1)))",
                    "c7_goal : forall _ : not (Logic.eq (to_Z x) 0),\nand\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (iter_t\n              (fun n0 : nat =>\n               let op := dom_op n0 in\n               let zdigits := ZnZ.zdigits op in\n               let head0 := ZnZ.head0 in\n               let sub_carry := ZnZ.sub_carry in\n               fun x : dom_t n0 =>\n               reduce n0 (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (iter_t\n                 (fun n0 : nat =>\n                  let op := dom_op n0 in\n                  let zdigits := ZnZ.zdigits op in\n                  let head0 := ZnZ.head0 in\n                  let sub_carry := ZnZ.sub_carry in\n                  fun x : dom_t n0 =>\n                  reduce n0 (sub_carry zdigits (head0 x))) x)) 1)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (to_Z x) 0,\nand (Z.le (Z.pow 2 (to_Z zero)) (to_Z x))\n  (Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z zero) 1)))",
                    "c2_H : not (Logic.eq (to_Z x) 0)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_H : not (Logic.eq (to_Z x) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c7_goal : forall _ : not (Logic.eq (to_Z x) 0),\nand\n  (Z.le\n     (Z.pow 2\n        (to_Z\n           (iter_t\n              (fun n0 : nat =>\n               let op := dom_op n0 in\n               let zdigits := ZnZ.zdigits op in\n               let head0 := ZnZ.head0 in\n               let sub_carry := ZnZ.sub_carry in\n               fun x : dom_t n0 =>\n               reduce n0 (sub_carry zdigits (head0 x))) x))) \n     (to_Z x))\n  (Z.lt (to_Z x)\n     (Z.pow 2\n        (Z.add\n           (to_Z\n              (iter_t\n                 (fun n0 : nat =>\n                  let op := dom_op n0 in\n                  let zdigits := ZnZ.zdigits op in\n                  let head0 := ZnZ.head0 in\n                  let sub_carry := ZnZ.sub_carry in\n                  fun x : dom_t n0 =>\n                  reduce n0 (sub_carry zdigits (head0 x))) x)) 1)))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : not (Logic.eq (ZnZ.to_Z x) 0),\nand\n  (Z.le\n     (Z.pow 2\n        (ZnZ.to_Z\n           (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))))\n     (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (ZnZ.to_Z\n              (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))) 1)))",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c8_goal : forall _ : not (Logic.eq (ZnZ.to_Z x) 0),\nand\n  (Z.le\n     (Z.pow 2\n        (ZnZ.to_Z\n           (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))))\n     (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (ZnZ.to_Z\n              (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))) 1)))"
                ],
                "tactic_res": [
                    "c9_goal : and\n  (Z.le\n     (Z.pow 2\n        (ZnZ.to_Z\n           (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))))\n     (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (ZnZ.to_Z\n              (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))) 1)))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : and\n  (Z.le\n     (Z.pow 2\n        (ZnZ.to_Z\n           (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))))\n     (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (ZnZ.to_Z\n              (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x))) 1)))",
                    "_global_ZnZ.spec_sub_carry : forall x0 y : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.sub_carry x0 y))\n         (Z.modulo (Z.sub (Z.sub (ZnZ.to_Z x0) (ZnZ.to_Z y)) 1)\n            (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat  x : dom_t n  H : not (Logic.eq (ZnZ.to_Z x) 0) |- nat]"
                ],
                "tactic_res": [
                    "c10_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.modulo\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)\n           (base (ZnZ.digits (dom_op n))))) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (Z.modulo\n              (Z.sub\n                 (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                    (ZnZ.to_Z (ZnZ.head0 x))) 1)\n              (base (ZnZ.digits (dom_op n)))) 1)))"
                ]
            },
            {
                "tactic_sig": "assert ( H0 := ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "assert ( H0 := ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c8_x : dom_t n"
                ],
                "tactic_res": [
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "assert ( H1 := ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( H1 := ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_args": [
                    "c8_x : dom_t n"
                ],
                "tactic_res": [
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "assert ( H2 := ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H2 := ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_args": [
                    "c8_n : nat"
                ],
                "tactic_res": [
                    "c10_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "assert ( H3 := head0_zdigits _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( H3 := head0_zdigits _i _i ) .",
                "tactic_args": [
                    "c8_n : nat",
                    "c8_x : dom_t n"
                ],
                "tactic_res": [
                    "c10_H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c10_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.modulo\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)\n           (base (ZnZ.digits (dom_op n))))) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (Z.modulo\n              (Z.sub\n                 (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                    (ZnZ.to_Z (ZnZ.head0 x))) 1)\n              (base (ZnZ.digits (dom_op n)))) 1)))",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)),\n       Logic.eq (Z.modulo a n) a",
                    "c10_H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "c10_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (base (ZnZ.digits (dom_op n))))",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": [
                    "c11_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1) 1)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.add\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1) 1)))",
                    "_global_Z.sub_simpl_r : forall n m : Z, Logic.eq (Z.add (Z.sub n m) m) n"
                ],
                "tactic_res": [
                    "c12_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( 2 ^ ( _i ( _i _i ) ) ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( 2 ^ ( _i ( _i _i ) ) ) ) .",
                "tactic_args": [
                    "c12_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x)\n     (Z.pow 2\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x)))))",
                    "_global_Z.mul_lt_mono_pos_l : forall (p n m : Z) (_ : Z.lt 0 p),\n       iff (Z.lt n m) (Z.lt (Z.mul p n) (Z.mul p m))",
                    "_global_ZnZ.to_Z : forall _ : word w6 (S ?n), Z\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]",
                    "_global_ZnZ.head0 : forall _ : word w6 (S ?n), word w6 (S ?n)\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]",
                    "c8_x : dom_t n"
                ],
                "tactic_res": [
                    "c13_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))",
                    "c14_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i _i _i ( 2 ^ ( _i ( _i _i ) ) ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i ( 2 ^ ( _i ( _i _i ) ) ) ) .",
                "tactic_args": [
                    "c13_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.sub\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))) 1)) (ZnZ.to_Z x))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))",
                    "_global_Z.mul_le_mono_pos_l : forall (n m p : Z) (_ : Z.lt 0 p),\n       iff (Z.le n m) (Z.le (Z.mul p n) (Z.mul p m))",
                    "_global__ : ?T\nwhere\n?T : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- Type]\n?y : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- Type]\n?y : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- ?T]",
                    "_global_ZnZ.to_Z : forall _ : word w6 (S ?n), Z\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]",
                    "_global_ZnZ.head0 : forall _ : word w6 (S ?n), word w6 (S ?n)\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]",
                    "c8_x : dom_t n"
                ],
                "tactic_res": [
                    "c15_goal : and\n  (Z.le\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))",
                    "c16_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- 2 _i .",
                "tactic_sig_no_out_arg": "rewrite <- 2 _i .",
                "tactic_args": [
                    "c15_goal : and\n  (Z.le\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x)))\n        (Z.pow 2\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c17_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.add (ZnZ.to_Z (ZnZ.head0 x))\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2\n        (Z.add (ZnZ.to_Z (ZnZ.head0 x))\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))",
                    "c18_goal : Z.ge (ZnZ.to_Z (ZnZ.head0 x)) 0",
                    "c19_goal : Z.ge\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n  0",
                    "c20_goal : Z.ge (ZnZ.to_Z (ZnZ.head0 x)) 0",
                    "c21_goal : Z.ge\n  (Z.sub\n     (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n        (ZnZ.to_Z (ZnZ.head0 x))) 1) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : Z.ge (ZnZ.to_Z (ZnZ.head0 x)) 0",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : Z.ge\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n  0",
                    "c10_H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.ge (ZnZ.to_Z (ZnZ.head0 x)) 0",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.ge\n  (Z.sub\n     (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n        (ZnZ.to_Z (ZnZ.head0 x))) 1) 0",
                    "c10_H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite !Z.add_sub_assoc , !Z.add_simpl_l .",
                "tactic_sig_no_out_arg": "rewrite !Z.add_sub_assoc , !Z.add_simpl_l .",
                "tactic_args": [
                    "c17_goal : and\n  (Z.le\n     (Z.pow 2\n        (Z.add (ZnZ.to_Z (ZnZ.head0 x))\n           (Z.sub\n              (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                 (ZnZ.to_Z (ZnZ.head0 x))) 1)))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2\n        (Z.add (ZnZ.to_Z (ZnZ.head0 x))\n           (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n              (ZnZ.to_Z (ZnZ.head0 x))))))"
                ],
                "tactic_res": [
                    "c22_goal : and\n  (Z.le (Z.pow 2 (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) 1))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : and\n  (Z.le (Z.pow 2 (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) 1))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))))",
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]"
                ],
                "tactic_res": [
                    "c23_goal : and\n  (Z.le (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) 1))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by ( red ; auto ) .",
                "tactic_sig_no_out_arg": "rewrite _i by ( red ; auto ) .",
                "tactic_args": [
                    "c23_goal : and\n  (Z.le (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) 1))\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "_global_pow2_pos_minus_1 : forall (z : Z) (_ : Z.lt 0 z),\n       Logic.eq (Z.pow 2 (Z.sub z 1)) (Z.div (Z.pow 2 z) 2)",
                    "c10_H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\nZ.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))",
                    "c10_H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n  (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     (base (ZnZ.digits (dom_op n))))",
                    "c10_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": [
                    "c24_goal : and\n  (Z.le (Z.div (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) 2)\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : and\n  (Z.le (Z.div (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) 2)\n     (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x))) (ZnZ.to_Z x))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "_global_ZnZ.spec_head0 : forall (x0 : word w6 (S ?n)) (_ : Z.lt 0 (ZnZ.to_Z x0)),\n       and\n         (Z.le (Z.div (base (ZnZ.digits (make_op ?n))) 2)\n            (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x0))) (ZnZ.to_Z x0)))\n         (Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z (ZnZ.head0 x0))) (ZnZ.to_Z x0))\n            (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat\n      x : dom_t n\n      H : not (Logic.eq (ZnZ.to_Z x) 0)\n      H0 : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n             (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))\n      H2 : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n             (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n                (base (ZnZ.digits (dom_op n))))\n      H3 : forall _ : Z.lt 0 (ZnZ.to_Z x),\n           Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n     |- nat]"
                ],
                "tactic_res": [
                    "c25_goal : Z.lt 0 (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c25_goal : Z.lt 0 (ZnZ.to_Z x)",
                    "c10_H0 : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c9_H : not (Logic.eq (ZnZ.to_Z x) 0)",
                    "c8_x : dom_t n",
                    "c8_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_log2",
        "proof": [
            {
                "tactic_sig": "Lemma spec_log2 : forall x , [ log2 x ] = Z.log2 [ x ] .",
                "tactic_sig_no_out_arg": "Lemma spec_log2 : forall x , [ log2 x ] = Z.log2 [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "destruct ( Z_lt_ge_dec 0 [ _i ] ) as [ l | g ] .",
                "tactic_sig_no_out_arg": "destruct ( Z_lt_ge_dec 0 [ _i ] ) as [ l | g ] .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c3_l : Z.lt 0 (to_Z x)",
                    "c4_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "c4_g : Z.ge 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "custom41 Z.log2_unique spec_pos spec_log2_pos .",
                "tactic_sig_no_out_arg": "custom41 Z.log2_unique spec_pos spec_log2_pos .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))"
                ],
                "tactic_res": [
                    "c5_goal : not (Logic.eq (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro EQ .",
                "tactic_args": [
                    "c5_goal : not (Logic.eq (to_Z x) 0)"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_EQ : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c6_EQ : Logic.eq (to_Z x) 0"
                ],
                "tactic_res": [
                    "c6_l : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : False",
                    "c6_l : Z.lt 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (log2 x)) (Z.log2 (to_Z x))",
                    "_global_spec_log2_0 : forall (x : t) (_ : Logic.eq (to_Z x) 0), Logic.eq (to_Z (log2 x)) 0"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq 0 (Z.log2 (to_Z x))",
                    "c8_goal : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : Logic.eq 0 (Z.log2 (to_Z x))",
                    "_global_Z.log2_nonpos : forall (n : Z) (_ : Z.le n 0), Logic.eq (Z.log2 n) 0"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq 0 0",
                    "c10_goal : Z.le (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Z.le (to_Z x) 0",
                    "c4_g : Z.ge 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom38 _i .",
                "tactic_sig_no_out_arg": "custom38 _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z x) 0",
                    "c2_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "log2_digits_head0",
        "proof": [
            {
                "tactic_sig": "Lemma log2_digits_head0 : forall x , 0 < [ x ] -> [ log2 x ] = Zpos ( digits x ) - [ head0 x ] - 1 .",
                "tactic_sig_no_out_arg": "Lemma log2_digits_head0 : forall x , 0 < [ x ] -> [ log2 x ] = Zpos ( digits x ) - [ head0 x ] - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nLogic.eq (to_Z (log2 x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x : t) (_ : Z.lt 0 (to_Z x)),\nLogic.eq (to_Z (log2 x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (log2 x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "c2_x : True",
                    "c2_H : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (log2 x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "_global_log2_fold : Logic.eq log2\n         (fun x : t =>\n          if eqb x zero\n          then zero\n          else\n           iter_t\n             (fun n : nat =>\n              let op := dom_op n in\n              let zdigits := ZnZ.zdigits op in\n              let head0 := ZnZ.head0 in\n              let sub_carry := ZnZ.sub_carry in\n              fun x0 : dom_t n => reduce n (sub_carry zdigits (head0 x0))) x)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb x zero\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (if eqb x zero\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "_global_spec_eqb : forall x y : t, Logic.eq (eqb x y) (Z.eqb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z x) (to_Z zero)\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z x) (to_Z zero)\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "_global_spec_0 : Logic.eq (to_Z zero) 0"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z x) 0\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "case Z.eqb_spec .",
                "tactic_sig_no_out_arg": "case Z.eqb_spec .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     (if Z.eqb (to_Z x) 0\n      then zero\n      else\n       iter_t\n         (fun n : nat =>\n          let op := dom_op n in\n          let zdigits := ZnZ.zdigits op in\n          let head0 := ZnZ.head0 in\n          let sub_carry := ZnZ.sub_carry in\n          fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z zero)\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "c7_goal : forall _ : not (Logic.eq (to_Z x) 0),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n0 : nat =>\n         let op := dom_op n0 in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n0 => reduce n0 (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : forall _ : Logic.eq (to_Z x) 0,\nLogic.eq (to_Z zero)\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "c2_H : Z.lt 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c7_goal : forall _ : not (Logic.eq (to_Z x) 0),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n0 : nat =>\n         let op := dom_op n0 in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n0 => reduce n0 (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "revert _i .",
                "tactic_sig_no_out_arg": "revert _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "c2_H : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Z.lt 0 (to_Z x),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c9_goal : forall _ : Z.lt 0 (to_Z x),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)",
                    "_global_digits_fold : Logic.eq digits\n         (iter_t\n            (fun n : nat =>\n             let digits := ZnZ.digits (dom_op n) in fun _ : dom_t n => digits))",
                    "_global_head0_fold : Logic.eq head0\n         (iter_t\n            (fun n : nat =>\n             let head0 := ZnZ.head0 in fun x : dom_t n => reduce n (head0 x)))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub\n     (Z.sub\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))\n        (to_Z\n           (iter_t\n              (fun n : nat =>\n               let head0 := ZnZ.head0 in\n               fun x : dom_t n => reduce n (head0 x)) x))) 1)"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x),\nLogic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let head0 := ZnZ.head0 in\n         let sub_carry := ZnZ.sub_carry in\n         fun x : dom_t n => reduce n (sub_carry zdigits (head0 x))) x))\n  (Z.sub\n     (Z.sub\n        (Zpos\n           (iter_t\n              (fun n : nat =>\n               let digits := ZnZ.digits (dom_op n) in\n               fun _ : dom_t n => digits) x))\n        (to_Z\n           (iter_t\n              (fun n : nat =>\n               let head0 := ZnZ.head0 in\n               fun x : dom_t n => reduce n (head0 x)) x))) 1)",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nLogic.eq\n  (ZnZ.to_Z (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x)))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c11_x : dom_t n",
                    "c11_n : nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nLogic.eq\n  (ZnZ.to_Z (ZnZ.sub_carry (ZnZ.zdigits (dom_op n)) (ZnZ.head0 x)))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "_global_ZnZ.spec_sub_carry : forall x0 y : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.sub_carry x0 y))\n         (Z.modulo (Z.sub (Z.sub (ZnZ.to_Z x0) (ZnZ.to_Z y)) 1)\n            (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat  x : dom_t n |- nat]"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall _ : Z.lt 0 (ZnZ.to_Z x),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c13_H : Z.lt 0 (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "generalize ( head0_zdigits _i _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( head0_zdigits _i _i _i ) .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c11_n : nat",
                    "c11_x : dom_t n",
                    "c13_H : Z.lt 0 (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  _ : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_to_Z ( ZnZ.head0 _i ) ) .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (ZnZ.to_Z (ZnZ.zdigits (dom_op n))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c11_x : dom_t n"
                ],
                "tactic_res": [
                    "c15_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n         (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_to_Z ( ZnZ.zdigits ( dom_op _i ) ) ) .",
                "tactic_args": [
                    "c15_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n         (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c11_n : nat"
                ],
                "tactic_res": [
                    "c16_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n         (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n            (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n         (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : forall\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.zdigits (dom_op n))))\n         (Z.lt (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n            (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x))\n         (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n)))\n           (ZnZ.to_Z (ZnZ.head0 x))) 1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [n : nat  x : dom_t n  H : Z.lt 0 (ZnZ.to_Z x) |- nat]"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  (_ : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n         (Z.lt (Zpos (ZnZ.digits (dom_op n)))\n            (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall\n  (_ : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n         (Z.lt (Zpos (ZnZ.digits (dom_op n)))\n            (base (ZnZ.digits (dom_op n)))))\n  (_ : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n         (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n)))))\n  (_ : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "c18_H0 : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n  (Z.lt (Zpos (ZnZ.digits (dom_op n))) (base (ZnZ.digits (dom_op n))))",
                    "c18_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c18_H2 : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.modulo\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))\n  (Z.sub\n     (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x))) 1)",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)),\n       Logic.eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c19_goal : and\n  (Z.le 0\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1))\n  (Z.lt\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : and\n  (Z.le 0\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1))\n  (Z.lt\n     (Z.sub\n        (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z (ZnZ.head0 x)))\n        1) (base (ZnZ.digits (dom_op n))))",
                    "c18_H2 : Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (Zpos (ZnZ.digits (dom_op n)))",
                    "c18_H1 : and (Z.le 0 (ZnZ.to_Z (ZnZ.head0 x)))\n  (Z.lt (ZnZ.to_Z (ZnZ.head0 x)) (base (ZnZ.digits (dom_op n))))",
                    "c18_H0 : and (Z.le 0 (Zpos (ZnZ.digits (dom_op n))))\n  (Z.lt (Zpos (ZnZ.digits (dom_op n))) (base (ZnZ.digits (dom_op n))))",
                    "c11_x : dom_t n",
                    "c11_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "shiftr_fold",
        "proof": [
            {
                "tactic_sig": "Lemma shiftr_fold : shiftr = same_level shiftrn .",
                "tactic_sig_no_out_arg": "Lemma shiftr_fold : shiftr = same_level shiftrn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq shiftr\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let zdigits := ZnZ.zdigits op in\n      let sub_c := ZnZ.sub_c in\n      let add_mul_div := ZnZ.add_mul_div in\n      let zzero := ZnZ.zero in\n      fun x p : dom_t n =>\n      match sub_c zdigits p with\n      | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n      | CarryType.C1 _ => zero\n      end))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq shiftr\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let zdigits := ZnZ.zdigits op in\n      let sub_c := ZnZ.sub_c in\n      let add_mul_div := ZnZ.add_mul_div in\n      let zzero := ZnZ.zero in\n      fun x p : dom_t n =>\n      match sub_c zdigits p with\n      | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n      | CarryType.C1 _ => zero\n      end))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq shiftr\n  (let f0 :=\n     let op := W0.ops in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : W0.t =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_0 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let op := w1_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w1 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_1 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let op := w2_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w2 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_2 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let op := w3_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w3 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_3 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let op := w4_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w4 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_4 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let op := w5_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w5 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_5 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let op := w6_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w6 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_6 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : word w6 (S n) =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_n n (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq shiftr\n  (let f0 :=\n     let op := W0.ops in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : W0.t =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_0 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f1 :=\n     let op := w1_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w1 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_1 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f2 :=\n     let op := w2_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w2 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_2 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f3 :=\n     let op := w3_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w3 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_3 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f4 :=\n     let op := w4_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w4 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_4 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f5 :=\n     let op := w5_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w5 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_5 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let f6 :=\n     let op := w6_op in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : w6 =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_6 (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let zdigits := ZnZ.zdigits op in\n     let sub_c := ZnZ.sub_c in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zzero := ZnZ.zero in\n     fun x p : word w6 (S n) =>\n     match sub_c zdigits p with\n     | CarryType.C0 d => reduce_n n (add_mul_div d zzero x)\n     | CarryType.C1 _ => zero\n     end in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_pow2_bound",
        "proof": [
            {
                "tactic_sig": "Lemma div_pow2_bound : forall x y z , 0 <= x -> 0 <= y -> x < z -> 0 <= x / 2 ^ y < z .",
                "tactic_sig_no_out_arg": "Lemma div_pow2_bound : forall x y z , 0 <= x -> 0 <= y -> x < z -> 0 <= x / 2 ^ y < z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y z : Z) (_ : Z.le 0 x) (_ : Z.le 0 y) (_ : Z.lt x z),\nand (Z.le 0 (Z.div x (Z.pow 2 y))) (Z.lt (Z.div x (Z.pow 2 y)) z)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y z HH HH1 HH2 .",
                "tactic_args": [
                    "c1_goal : forall (x y z : Z) (_ : Z.le 0 x) (_ : Z.le 0 y) (_ : Z.lt x z),\nand (Z.le 0 (Z.div x (Z.pow 2 y))) (Z.lt (Z.div x (Z.pow 2 y)) z)"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (Z.div x (Z.pow 2 y))) (Z.lt (Z.div x (Z.pow 2 y)) z)",
                    "c2_x : Z",
                    "c2_y : Z",
                    "c2_z : Z",
                    "c2_HH : Z.le 0 x",
                    "c2_HH1 : Z.le 0 y",
                    "c2_HH2 : Z.lt x z"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (Z.div x (Z.pow 2 y))) (Z.lt (Z.div x (Z.pow 2 y)) z)"
                ],
                "tactic_res": [
                    "c3_goal : Z.le 0 (Z.div x (Z.pow 2 y))",
                    "c4_goal : Z.lt (Z.div x (Z.pow 2 y)) z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : Z.le 0 (Z.div x (Z.pow 2 y))",
                    "c2_HH1 : Z.le 0 y",
                    "c2_HH : Z.le 0 x",
                    "c2_x : Z",
                    "c2_y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c4_goal : Z.lt (Z.div x (Z.pow 2 y)) z",
                    "_global_Z.le_lt_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.lt m p), Z.lt n p",
                    "c2_HH2 : Z.lt x z"
                ],
                "tactic_res": [
                    "c5_goal : Z.le (Z.div x (Z.pow 2 y)) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Z.le (Z.div x (Z.pow 2 y)) x",
                    "_global_Zdiv_le_upper_bound : forall (a b q : Z) (_ : Z.lt 0 b) (_ : Z.le a (Z.mul q b)),\n       Z.le (Z.div a b) q"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt 0 (Z.pow 2 y)",
                    "c7_goal : Z.le x (Z.mul x (Z.pow 2 y))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c6_goal : Z.lt 0 (Z.pow 2 y)",
                    "c2_HH1 : Z.le 0 y",
                    "c2_y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "pattern _i at 1 .",
                "tactic_sig_no_out_arg": "pattern _i at 1 .",
                "tactic_args": [
                    "c7_goal : Z.le x (Z.mul x (Z.pow 2 y))",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c8_goal : (fun z : Z => Z.le z (Z.mul x (Z.pow 2 y))) x"
                ]
            },
            {
                "tactic_sig": "replace _i with ( _i * 2 ^ 0 ) .",
                "tactic_sig_no_out_arg": "replace _i with ( _i * 2 ^ 0 ) .",
                "tactic_args": [
                    "c8_goal : (fun z : Z => Z.le z (Z.mul x (Z.pow 2 y))) x",
                    "c2_x : Z",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c9_goal : Z.le (Z.mul x (Z.pow 2 0)) (Z.mul x (Z.pow 2 y))",
                    "c10_goal : Logic.eq (Z.mul x (Z.pow 2 0)) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Z.le (Z.mul x (Z.pow 2 0)) (Z.mul x (Z.pow 2 y))",
                    "_global_Z.mul_le_mono_nonneg_l : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul p n) (Z.mul p m)"
                ],
                "tactic_res": [
                    "c11_goal : Z.le 0 x",
                    "c12_goal : Z.le (Z.pow 2 0) (Z.pow 2 y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Z.le 0 x",
                    "c2_HH : Z.le 0 x",
                    "c2_x : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.pow 2 0) (Z.pow 2 y)",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c13_goal : Z.lt 0 2",
                    "c14_goal : Z.le 0 y"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : Z.le 0 y",
                    "c2_HH1 : Z.le 0 y",
                    "c2_y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (Z.mul x (Z.pow 2 0)) x",
                    "_global_Z.pow_0_r : forall n : Z, Logic.eq (Z.pow n 0) 1"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.mul x 1) x"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.mul x 1) x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftr_pow2",
        "proof": [
            {
                "tactic_sig": "Theorem spec_shiftr_pow2 : forall x n , [ shiftr x n ] = [ x ] / 2 ^ [ n ] .",
                "tactic_sig_no_out_arg": "Theorem spec_shiftr_pow2 : forall x n , [ shiftr x n ] = [ x ] / 2 ^ [ n ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x n : t,\nLogic.eq (to_Z (shiftr x n)) (Z.div (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x n : t,\nLogic.eq (to_Z (shiftr x n)) (Z.div (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftr x y)) (Z.div (to_Z x) (Z.pow 2 (to_Z y)))",
                    "c2_x : True",
                    "c2_y : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftr x y)) (Z.div (to_Z x) (Z.pow 2 (to_Z y)))",
                    "_global_shiftr_fold : Logic.eq shiftr\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let zdigits := ZnZ.zdigits op in\n             let sub_c := ZnZ.sub_c in\n             let add_mul_div := ZnZ.add_mul_div in\n             let zzero := ZnZ.zero in\n             fun x p : dom_t n =>\n             match sub_c zdigits p with\n             | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n             | CarryType.C1 _ => zero\n             end))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let sub_c := ZnZ.sub_c in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zzero := ZnZ.zero in\n         fun x p : dom_t n =>\n         match sub_c zdigits p with\n         | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n         | CarryType.C1 _ => zero\n         end) x y)) (Z.div (to_Z x) (Z.pow 2 (to_Z y)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let zdigits := ZnZ.zdigits op in\n         let sub_c := ZnZ.sub_c in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zzero := ZnZ.zero in\n         fun x p : dom_t n =>\n         match sub_c zdigits p with\n         | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n         | CarryType.C1 _ => zero\n         end) x y)) (Z.div (to_Z x) (Z.pow 2 (to_Z y)))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let sub_c := ZnZ.sub_c in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zzero := ZnZ.zero in\n       fun x0 p : dom_t n =>\n       match sub_c zdigits p with\n       | CarryType.C0 d => reduce n (add_mul_div d zzero x0)\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x p .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let sub_c := ZnZ.sub_c in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zzero := ZnZ.zero in\n       fun x0 p : dom_t n =>\n       match sub_c zdigits p with\n       | CarryType.C0 d => reduce n (add_mul_div d zzero x0)\n       | CarryType.C1 _ => zero\n       end) x y)) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let sub_c := ZnZ.sub_c in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zzero := ZnZ.zero in\n       fun x p : dom_t n =>\n       match sub_c zdigits p with\n       | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n       | CarryType.C1 _ => zero\n       end) x p)) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c5_n : nat",
                    "c5_x : dom_t n",
                    "c5_p : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let zdigits := ZnZ.zdigits op in\n       let sub_c := ZnZ.sub_c in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zzero := ZnZ.zero in\n       fun x p : dom_t n =>\n       match sub_c zdigits p with\n       | CarryType.C0 d => reduce n (add_mul_div d zzero x)\n       | CarryType.C1 _ => zero\n       end) x p)) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (to_Z\n     match ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p with\n     | CarryType.C0 d => reduce n (ZnZ.add_mul_div d ZnZ.zero x)\n     | CarryType.C1 _ => zero\n     end) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "assert ( Hx := ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hx := ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c5_x : dom_t n"
                ],
                "tactic_res": [
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "assert ( Hy := ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hy := ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c5_p : dom_t n"
                ],
                "tactic_res": [
                    "c6_Hy : and (Z.le 0 (ZnZ.to_Z p))\n  (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_sub_c ( ZnZ.zdigits ( dom_op _i ) ) _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_sub_c ( ZnZ.zdigits ( dom_op _i ) ) _i ) .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (to_Z\n     match ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p with\n     | CarryType.C0 d => reduce n (ZnZ.add_mul_div d ZnZ.zero x)\n     | CarryType.C1 _ => zero\n     end) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c5_n : nat",
                    "c5_p : dom_t n"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : Logic.eq\n        (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p))\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p)),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p with\n     | CarryType.C0 d => reduce n (ZnZ.add_mul_div d ZnZ.zero x)\n     | CarryType.C1 _ => zero\n     end) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "case ZnZ.sub_c .",
                "tactic_sig_no_out_arg": "case ZnZ.sub_c .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : Logic.eq\n        (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n           (ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p))\n        (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p)),\nLogic.eq\n  (to_Z\n     match ZnZ.sub_c (ZnZ.zdigits (dom_op n)) p with\n     | CarryType.C0 d => reduce n (ZnZ.add_mul_div d ZnZ.zero x)\n     | CarryType.C1 _ => zero\n     end) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d))\n         (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))),\nLogic.eq (to_Z (reduce n (ZnZ.add_mul_div d ZnZ.zero x)))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d))\n         (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))),\nLogic.eq (to_Z zero) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros d H .",
                "tactic_args": [
                    "c8_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C0 d))\n         (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))),\nLogic.eq (to_Z (reduce n (ZnZ.add_mul_div d ZnZ.zero x)))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (reduce n (ZnZ.add_mul_div d ZnZ.zero x)))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c10_d : dom_t n",
                    "c10_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C0 d))\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq (ZnZ.to_Z d)\n            (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p)) |- Type]"
                ],
                "tactic_res": [
                    "c10_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros d H .",
                "tactic_args": [
                    "c9_goal : forall (d : dom_t n)\n  (_ : Logic.eq\n         (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n            (CarryType.C1 d))\n         (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))),\nLogic.eq (to_Z zero) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq (to_Z zero) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c11_d : dom_t n",
                    "c11_H : Logic.eq\n  (interp_carry (-1) (base (ZnZ.digits (dom_op n))) ZnZ.to_Z\n     (CarryType.C1 d))\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "_global_interp_carry : forall (_ : Z) (_ : Z) (_ : forall _ : ?A, Z) (_ : CarryType.carry ?A),\n       Z\nwhere\n?A : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq (ZnZ.to_Z d)\n            (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p)) |- Type]"
                ],
                "tactic_res": [
                    "c11_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : Logic.eq (to_Z zero) (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c12_goal : Logic.eq (ZnZ.to_Z ZnZ.zero)\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (reduce n (ZnZ.add_mul_div d ZnZ.zero x)))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div d ZnZ.zero x))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq (ZnZ.to_Z d)\n            (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)) |- nat]",
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ],
                "tactic_res": [
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c13_goal : Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div d ZnZ.zero x))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_ZnZ.spec_add_mul_div : forall (x0 y p0 : word w6 (S ?n))\n         (_ : Z.le (ZnZ.to_Z p0) (Zpos (ZnZ.digits (make_op ?n)))),\n       Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div p0 x0 y))\n         (Z.modulo\n            (Z.add (Z.mul (ZnZ.to_Z x0) (Z.pow 2 (ZnZ.to_Z p0)))\n               (Z.div (ZnZ.to_Z y)\n                  (Z.pow 2\n                     (Z.sub (Zpos (ZnZ.digits (make_op ?n))) (ZnZ.to_Z p0)))))\n            (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq (ZnZ.to_Z d)\n            (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)) |- nat]",
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))",
                    "c10_d : dom_t n",
                    "c6_Hy : and (Z.le 0 (ZnZ.to_Z p))\n  (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_p : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (Z.modulo\n     (Z.add (Z.mul (ZnZ.to_Z ZnZ.zero) (Z.pow 2 (ZnZ.to_Z d)))\n        (Z.div (ZnZ.to_Z x)\n           (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (Z.modulo\n     (Z.add (Z.mul (ZnZ.to_Z ZnZ.zero) (Z.pow 2 (ZnZ.to_Z d)))\n        (Z.div (ZnZ.to_Z x)\n           (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq (ZnZ.to_Z d)\n            (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)) |- nat]",
                    "_global_Z.mul_0_l : forall n : Z, Logic.eq (Z.mul 0 n) 0",
                    "_global_Z.add_0_l : forall n : Z, Logic.eq (Z.add 0 n) n"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq\n  (Z.modulo\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq\n  (Z.modulo\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)),\n       Logic.eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c17_goal : and\n  (Z.le 0\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))))\n  (Z.lt\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n     (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c16_goal : Logic.eq\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))\n  (Z.pow 2 (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))\n  (Z.pow 2 (ZnZ.to_Z p))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))\n  (ZnZ.to_Z p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : Logic.eq (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))\n  (ZnZ.to_Z p)",
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))",
                    "c10_d : dom_t n",
                    "c5_p : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : and\n  (Z.le 0\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d)))))\n  (Z.lt\n     (Z.div (ZnZ.to_Z x)\n        (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n     (base (ZnZ.digits (dom_op n))))"
                ],
                "tactic_res": [
                    "c20_goal : Z.le 0\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))",
                    "c21_goal : Z.lt\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n  (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))",
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))",
                    "c10_d : dom_t n",
                    "c6_Hy : and (Z.le 0 (ZnZ.to_Z p))\n  (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Z.lt\n  (Z.div (ZnZ.to_Z x)\n     (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))))\n  (base (ZnZ.digits (dom_op n)))",
                    "_global_div_pow2_bound : forall (x y z : Z) (_ : Z.le 0 x) (_ : Z.le 0 y) (_ : Z.lt x z),\n       and (Z.le 0 (Z.div x (Z.pow 2 y))) (Z.lt (Z.div x (Z.pow 2 y)) z)"
                ],
                "tactic_res": [
                    "c22_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c23_goal : Z.le 0 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))",
                    "c24_goal : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : Z.le 0 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z d))",
                    "c13_H : Logic.eq (ZnZ.to_Z d)\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))",
                    "c10_d : dom_t n",
                    "c6_Hy : and (Z.le 0 (ZnZ.to_Z p))\n  (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Logic.eq (ZnZ.to_Z ZnZ.zero)\n  (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n            (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p)) |- nat]"
                ],
                "tactic_res": [
                    "c25_goal : Logic.eq 0 (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c25_goal : Logic.eq 0 (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Z.div (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))) 0",
                    "_global_Zdiv_small : forall (a b : Z) (_ : and (Z.le 0 a) (Z.lt a b)),\n       Logic.eq (Z.div a b) 0"
                ],
                "tactic_res": [
                    "c27_goal : and (Z.le 0 (ZnZ.to_Z x)) (Z.lt (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c27_goal : and (Z.le 0 (ZnZ.to_Z x)) (Z.lt (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c28_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c29_goal : Z.lt (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c28_goal : Z.le 0 (ZnZ.to_Z x)",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i ( _i ( _i _i ) ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ( _i ( _i _i ) ) ) .",
                "tactic_args": [
                    "c29_goal : Z.lt (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_base : forall _ : positive, Z",
                    "_global_ZnZ.digits : forall (t : Type) (_ : ZnZ.Ops t), positive",
                    "_global_dom_op : forall n : nat, ZnZ.Ops (dom_t n)",
                    "c5_n : nat"
                ],
                "tactic_res": [
                    "c30_goal : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))",
                    "c31_goal : Z.le (base (ZnZ.digits (dom_op n))) (Z.pow 2 (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c30_goal : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))",
                    "c6_Hx : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c31_goal : Z.le (base (ZnZ.digits (dom_op n))) (Z.pow 2 (ZnZ.to_Z p))",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c32_goal : Z.le (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) (Z.pow 2 (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : Z.le (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))) (Z.pow 2 (ZnZ.to_Z p))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c33_goal : Z.lt 0 2",
                    "c34_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c33_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_ZnZ.spec_zdigits : Logic.eq (ZnZ.to_Z (ZnZ.zdigits (make_op ?n)))\n         (Zpos (ZnZ.digits (make_op ?n)))\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      Hx : and (Z.le 0 (ZnZ.to_Z x))\n             (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n))))\n      Hy : and (Z.le 0 (ZnZ.to_Z p))\n             (Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))))\n      d : dom_t n\n      H : Logic.eq\n            (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n            (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)) |- nat]",
                    "c34_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.sub (ZnZ.to_Z (ZnZ.zdigits (dom_op n))) (ZnZ.to_Z p))"
                ],
                "tactic_res": [
                    "c34_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))"
                ]
            },
            {
                "tactic_sig": "generalize ( ZnZ.spec_to_Z _i ) .",
                "tactic_sig_no_out_arg": "generalize ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c34_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)",
                    "c11_d : dom_t n"
                ],
                "tactic_res": [
                    "c35_goal : forall\n  _ : and (Z.le 0 (ZnZ.to_Z d))\n        (Z.lt (ZnZ.to_Z d) (base (ZnZ.digits (dom_op n)))),\nZ.le (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c35_goal : forall\n  _ : and (Z.le 0 (ZnZ.to_Z d))\n        (Z.lt (ZnZ.to_Z d) (base (ZnZ.digits (dom_op n)))),\nZ.le (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)",
                    "c34_H : Logic.eq\n  (Z.add (Z.mul (-1) (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z d))\n  (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p))",
                    "c11_d : dom_t n",
                    "c5_p : dom_t n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftr",
        "proof": [
            {
                "tactic_sig": "Lemma spec_shiftr : forall x p , [ shiftr x p ] = Z.shiftr [ x ] [ p ] .",
                "tactic_sig_no_out_arg": "Lemma spec_shiftr : forall x p , [ shiftr x p ] = Z.shiftr [ x ] [ p ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t,\nLogic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x p : t,\nLogic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))",
                    "c2_x : True",
                    "c2_p : True"
                ]
            },
            {
                "tactic_sig": "now rewrite spec_shiftr_pow2 , Z.shiftr_div_pow2 by apply spec_pos .",
                "tactic_sig_no_out_arg": "now rewrite spec_shiftr_pow2 , Z.shiftr_div_pow2 by apply spec_pos .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftr x p)) (Z.shiftr (to_Z x) (to_Z p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "unsafe_shiftl_fold",
        "proof": [
            {
                "tactic_sig": "Lemma unsafe_shiftl_fold : unsafe_shiftl = same_level unsafe_shiftln .",
                "tactic_sig_no_out_arg": "Lemma unsafe_shiftl_fold : unsafe_shiftl = same_level unsafe_shiftln .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq unsafe_shiftl\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let add_mul_div := ZnZ.add_mul_div in\n      let zero := ZnZ.zero in\n      fun x p : dom_t n => reduce n (add_mul_div p x zero)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq unsafe_shiftl\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let add_mul_div := ZnZ.add_mul_div in\n      let zero := ZnZ.zero in\n      fun x p : dom_t n => reduce n (add_mul_div p x zero)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq unsafe_shiftl\n  (let f0 :=\n     let op := W0.ops in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : W0.t => reduce_0 (add_mul_div p x zero) in\n   let f1 :=\n     let op := w1_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w1 => reduce_1 (add_mul_div p x zero) in\n   let f2 :=\n     let op := w2_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w2 => reduce_2 (add_mul_div p x zero) in\n   let f3 :=\n     let op := w3_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w3 => reduce_3 (add_mul_div p x zero) in\n   let f4 :=\n     let op := w4_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w4 => reduce_4 (add_mul_div p x zero) in\n   let f5 :=\n     let op := w5_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w5 => reduce_5 (add_mul_div p x zero) in\n   let f6 :=\n     let op := w6_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w6 => reduce_6 (add_mul_div p x zero) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : word w6 (S n) => reduce_n n (add_mul_div p x zero) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq unsafe_shiftl\n  (let f0 :=\n     let op := W0.ops in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : W0.t => reduce_0 (add_mul_div p x zero) in\n   let f1 :=\n     let op := w1_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w1 => reduce_1 (add_mul_div p x zero) in\n   let f2 :=\n     let op := w2_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w2 => reduce_2 (add_mul_div p x zero) in\n   let f3 :=\n     let op := w3_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w3 => reduce_3 (add_mul_div p x zero) in\n   let f4 :=\n     let op := w4_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w4 => reduce_4 (add_mul_div p x zero) in\n   let f5 :=\n     let op := w5_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w5 => reduce_5 (add_mul_div p x zero) in\n   let f6 :=\n     let op := w6_op in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : w6 => reduce_6 (add_mul_div p x zero) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let add_mul_div := ZnZ.add_mul_div in\n     let zero := ZnZ.zero in\n     fun x p : word w6 (S n) => reduce_n n (add_mul_div p x zero) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_unsafe_shiftl_aux",
        "proof": [
            {
                "tactic_sig": "Theorem spec_unsafe_shiftl_aux : forall x p K , 0 <= K -> [ x ] < 2 ^ K -> [ p ] + K <= Zpos ( digits x ) -> [ unsafe_shiftl x p ] = [ x ] * 2 ^ [ p ] .",
                "tactic_sig_no_out_arg": "Theorem spec_unsafe_shiftl_aux : forall x p K , 0 <= K -> [ x ] < 2 ^ K -> [ p ] + K <= Zpos ( digits x ) -> [ unsafe_shiftl x p ] = [ x ] * 2 ^ [ p ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x p : t) (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x p .",
                "tactic_args": [
                    "c1_goal : forall (x p : t) (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "c2_x : True",
                    "c2_p : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_unsafe_shiftl_fold : Logic.eq unsafe_shiftl\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let add_mul_div := ZnZ.add_mul_div in\n             let zero := ZnZ.zero in\n             fun x p : dom_t n => reduce n (add_mul_div p x zero)))"
                ],
                "tactic_res": [
                    "c3_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zero := ZnZ.zero in\n         fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zero := ZnZ.zero in\n         fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_digits_level : forall x : t, Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))"
                ],
                "tactic_res": [
                    "c4_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (ZnZ.digits (dom_op (level x))))),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zero := ZnZ.zero in\n         fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt (to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (to_Z p) K) (Zpos (ZnZ.digits (dom_op (level x))))),\nLogic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let add_mul_div := ZnZ.add_mul_div in\n         let zero := ZnZ.zero in\n         fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_spec_same_level_dep : forall (res : Type)\n         (P : forall (_ : nat) (_ : Z) (_ : Z) (_ : res), Prop)\n         (_ : forall (n m : nat) (z z' : Z) (r : res) \n                (_ : Peano.le n m) (_ : P m z z' r), \n              P n z z' r)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), res)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P n (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (level x) (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c5_goal : forall (n m : nat) (z z' : Z) (r : t) (_ : Peano.le n m)\n  (_ : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n         (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))),\n       Logic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))) (K : Z) \n  (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n  (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))",
                    "c6_goal : forall (n : nat) (x y : dom_t n) (K : Z) (_ : Z.le 0 K)\n  (_ : Z.lt (ZnZ.to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (ZnZ.to_Z y) K) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zero := ZnZ.zero in\n       fun x0 p : dom_t n => reduce n (add_mul_div p x0 zero)) x y))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n m z z' r LE H K HK H1 H2 .",
                "tactic_args": [
                    "c5_goal : forall (n m : nat) (z z' : Z) (r : t) (_ : Peano.le n m)\n  (_ : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n         (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))),\n       Logic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))) (K : Z) \n  (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n  (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))",
                    "c7_n : nat",
                    "c7_m : nat",
                    "c7_z : Z",
                    "c7_z' : Z",
                    "c7_r : True",
                    "c7_LE : Peano.le n m",
                    "c7_H : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n  (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))),\nLogic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))",
                    "c7_K : Z",
                    "c7_HK : Z.le 0 K",
                    "c7_H1 : Z.lt z (Z.pow 2 K)",
                    "c7_H2 : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c7_goal : Logic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))",
                    "c7_H : forall (K : Z) (_ : Z.le 0 K) (_ : Z.lt z (Z.pow 2 K))\n  (_ : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))),\nLogic.eq (to_Z r) (Z.mul z (Z.pow 2 z'))",
                    "c7_K : Z"
                ],
                "tactic_res": [
                    "c8_goal : Z.le 0 K",
                    "c9_goal : Z.lt z (Z.pow 2 K)",
                    "c10_goal : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Z.le 0 K",
                    "c7_HK : Z.le 0 K",
                    "c7_K : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Z.lt z (Z.pow 2 K)",
                    "c7_H1 : Z.lt z (Z.pow 2 K)",
                    "c7_K : Z",
                    "c7_z : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "transitivity ( Zpos ( ZnZ.digits ( dom_op _i ) ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Zpos ( ZnZ.digits ( dom_op _i ) ) ) .",
                "tactic_args": [
                    "c10_goal : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op m)))",
                    "c7_n : nat"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c12_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (Zpos (ZnZ.digits (dom_op m)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c7_H2 : Z.le (Z.add z' K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c7_K : Z",
                    "c7_z' : Z",
                    "c7_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : Z.le (Zpos (ZnZ.digits (dom_op n))) (Zpos (ZnZ.digits (dom_op m)))",
                    "_global_digits_dom_op_incr : forall (n m : nat) (_ : Peano.le n m),\n       Pos.le (ZnZ.digits (dom_op n)) (ZnZ.digits (dom_op m))"
                ],
                "tactic_res": [
                    "c13_goal : Peano.le n m"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Peano.le n m",
                    "c7_LE : Peano.le n m",
                    "c7_n : nat",
                    "c7_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c2_p : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x p K HK Hx Hp .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (x y : dom_t n) (K : Z) (_ : Z.le 0 K)\n  (_ : Z.lt (ZnZ.to_Z x) (Z.pow 2 K))\n  (_ : Z.le (Z.add (ZnZ.to_Z y) K) (Zpos (ZnZ.digits (dom_op n)))),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zero := ZnZ.zero in\n       fun x0 p : dom_t n => reduce n (add_mul_div p x0 zero)) x y))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z y)))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zero := ZnZ.zero in\n       fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c14_n : nat",
                    "c14_x : dom_t n",
                    "c14_p : dom_t n",
                    "c14_K : Z",
                    "c14_HK : Z.le 0 K",
                    "c14_Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)",
                    "c14_Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let add_mul_div := ZnZ.add_mul_div in\n       let zero := ZnZ.zero in\n       fun x p : dom_t n => reduce n (add_mul_div p x zero)) x p))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (to_Z (reduce n (ZnZ.add_mul_div p x ZnZ.zero)))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (to_Z (reduce n (ZnZ.add_mul_div p x ZnZ.zero)))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c16_goal : Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div p x ZnZ.zero))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "destruct ( ZnZ.spec_to_Z _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c14_x : dom_t n",
                    "c14_Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c14_Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)",
                    "c14_HK : Z.le 0 K",
                    "c14_p : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": [
                    "c16_H0 : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))",
                    "c16_H : Z.le 0 (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "destruct ( ZnZ.spec_to_Z _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( ZnZ.spec_to_Z _i ) .",
                "tactic_args": [
                    "c14_p : dom_t n",
                    "c16_H0 : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))",
                    "c16_H : Z.le 0 (ZnZ.to_Z x)",
                    "c14_Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c14_Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)",
                    "c14_HK : Z.le 0 K",
                    "c14_x : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": [
                    "c16_H2 : Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n)))",
                    "c16_H1 : Z.le 0 (ZnZ.to_Z p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c16_goal : Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div p x ZnZ.zero))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_ZnZ.spec_add_mul_div : forall (x0 y p0 : word w6 (S ?n))\n         (_ : Z.le (ZnZ.to_Z p0) (Zpos (ZnZ.digits (make_op ?n)))),\n       Logic.eq (ZnZ.to_Z (ZnZ.add_mul_div p0 x0 y))\n         (Z.modulo\n            (Z.add (Z.mul (ZnZ.to_Z x0) (Z.pow 2 (ZnZ.to_Z p0)))\n               (Z.div (ZnZ.to_Z y)\n                  (Z.pow 2\n                     (Z.sub (Zpos (ZnZ.digits (make_op ?n))) (ZnZ.to_Z p0)))))\n            (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      K : Z\n      HK : Z.le 0 K\n      Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)\n      Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))\n      H : Z.le 0 (ZnZ.to_Z x)\n      H0 : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))\n      H1 : Z.le 0 (ZnZ.to_Z p)\n      H2 : Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))) |- nat]"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq\n  (Z.modulo\n     (Z.add (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n        (Z.div (ZnZ.to_Z ZnZ.zero)\n           (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq\n  (Z.modulo\n     (Z.add (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n        (Z.div (ZnZ.to_Z ZnZ.zero)\n           (Z.pow 2 (Z.sub (Zpos (ZnZ.digits (dom_op n))) (ZnZ.to_Z p)))))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      K : Z\n      HK : Z.le 0 K\n      Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)\n      Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))\n      H : Z.le 0 (ZnZ.to_Z x)\n      H0 : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))\n      H1 : Z.le 0 (ZnZ.to_Z p)\n      H2 : Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))) |- nat]",
                    "_global_Zdiv_0_l : forall a : Z, Logic.eq (Z.div 0 a) 0",
                    "_global_Z.add_0_r : forall n : Z, Logic.eq (Z.add n 0) n"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq\n  (Z.modulo (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq\n  (Z.modulo (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (base (ZnZ.digits (dom_op n))))\n  (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)),\n       Logic.eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c19_goal : and (Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))))\n  (Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (base (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : and (Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))))\n  (Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (base (ZnZ.digits (dom_op n))))",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c20_goal : and (Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))))\n  (Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c20_goal : and (Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p))))\n  (Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n     (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ],
                "tactic_res": [
                    "c21_goal : Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c22_goal : Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))",
                    "c16_H : Z.le 0 (ZnZ.to_Z x)",
                    "c14_x : dom_t n",
                    "c14_p : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : Z.lt (Z.mul (ZnZ.to_Z x) (Z.pow 2 (ZnZ.to_Z p)))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c23_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 ^ ( _i _i + _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 ^ ( _i _i + _i ) ) .",
                "tactic_args": [
                    "c23_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_ZnZ.to_Z : forall _ : word w6 (S ?n), Z\nwhere\n?n : [n : nat\n      x : dom_t n\n      p : dom_t n\n      K : Z\n      HK : Z.le 0 K\n      Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)\n      Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))\n      H : Z.le 0 (ZnZ.to_Z x)\n      H0 : Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (dom_op n)))\n      H1 : Z.le 0 (ZnZ.to_Z p)\n      H2 : Z.lt (ZnZ.to_Z p) (base (ZnZ.digits (dom_op n))) |- nat]",
                    "c14_p : dom_t n",
                    "c14_K : Z"
                ],
                "tactic_res": [
                    "c24_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.pow 2 (Z.add (ZnZ.to_Z p) K))",
                    "c25_goal : Z.le (Z.pow 2 (Z.add (ZnZ.to_Z p) K))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.pow 2 (Z.add (ZnZ.to_Z p) K))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c26_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (Z.pow 2 K))",
                    "c27_goal : Z.ge (ZnZ.to_Z p) 0",
                    "c28_goal : Z.ge K 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c27_goal : Z.ge (ZnZ.to_Z p) 0",
                    "c16_H1 : Z.le 0 (ZnZ.to_Z p)",
                    "c14_p : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c28_goal : Z.ge K 0",
                    "c14_HK : Z.le 0 K",
                    "c14_K : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Z.lt (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (ZnZ.to_Z x))\n  (Z.mul (Z.pow 2 (ZnZ.to_Z p)) (Z.pow 2 K))",
                    "_global_Z.mul_lt_mono_pos_l : forall (p n m : Z) (_ : Z.lt 0 p),\n       iff (Z.lt n m) (Z.lt (Z.mul p n) (Z.mul p m))"
                ],
                "tactic_res": [
                    "c29_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z p))",
                    "c30_goal : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c29_goal : Z.lt 0 (Z.pow 2 (ZnZ.to_Z p))",
                    "c16_H1 : Z.le 0 (ZnZ.to_Z p)",
                    "c14_p : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c30_goal : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)",
                    "c14_Hx : Z.lt (ZnZ.to_Z x) (Z.pow 2 K)",
                    "c14_K : Z",
                    "c14_x : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : Z.le (Z.pow 2 (Z.add (ZnZ.to_Z p) K))\n  (Z.pow 2 (Zpos (ZnZ.digits (dom_op n))))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c31_goal : Z.lt 0 2",
                    "c32_goal : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c32_goal : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c14_Hp : Z.le (Z.add (ZnZ.to_Z p) K) (Zpos (ZnZ.digits (dom_op n)))",
                    "c14_K : Z",
                    "c14_p : dom_t n",
                    "c14_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_unsafe_shiftl",
        "proof": [
            {
                "tactic_sig": "Theorem spec_unsafe_shiftl : forall x p , [ p ] <= [ head0 x ] -> [ unsafe_shiftl x p ] = [ x ] * 2 ^ [ p ] .",
                "tactic_sig_no_out_arg": "Theorem spec_unsafe_shiftl : forall x p , [ p ] <= [ head0 x ] -> [ unsafe_shiftl x p ] = [ x ] * 2 ^ [ p ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\nLogic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "c2_x : True",
                    "c2_p : True",
                    "c2_H : Z.le (to_Z p) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec [ _i ] 0 ) as [ EQ|NEQ ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec [ _i ] 0 ) as [ EQ|NEQ ] .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "c2_x : True",
                    "c2_H : Z.le (to_Z p) (to_Z (head0 x))",
                    "c2_p : True"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "c3_EQ : Logic.eq (to_Z x) 0",
                    "c4_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "c4_NEQ : not (Logic.eq (to_Z x) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i with 0 .",
                "tactic_sig_no_out_arg": "apply _i with 0 .",
                "tactic_args": [
                    "c3_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_spec_unsafe_shiftl_aux : forall (x p : t) (K : Z) (_ : Z.le 0 K)\n         (_ : Z.lt (to_Z x) (Z.pow 2 K))\n         (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c5_goal : Z.le 0 0",
                    "c6_goal : Z.lt (to_Z x) (Z.pow 2 0)",
                    "c7_goal : Z.le (Z.add (to_Z p) 0) (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.le 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c6_goal : Z.lt (to_Z x) (Z.pow 2 0)",
                    "c3_EQ : Logic.eq (to_Z x) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c7_goal : Z.le (Z.add (to_Z p) 0) (Zpos (digits x))",
                    "_global_spec_head00 : forall (x : t) (_ : Logic.eq (to_Z x) 0),\n       Logic.eq (to_Z (head0 x)) (Zpos (digits x))"
                ],
                "tactic_res": [
                    "c8_goal : Z.le (Z.add (to_Z p) 0) (Zpos (digits x))",
                    "c8_H : Z.le (to_Z p) (Zpos (digits x))",
                    "c9_goal : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.le (Z.add (to_Z p) 0) (Zpos (digits x))",
                    "c8_H : Z.le (to_Z p) (Zpos (digits x))",
                    "c2_x : True",
                    "c2_p : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z x) 0",
                    "c3_EQ : Logic.eq (to_Z x) 0",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( [ _i _i ] + 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( [ _i _i ] + 1 ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (unsafe_shiftl x p)) (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_spec_unsafe_shiftl_aux : forall (x p : t) (K : Z) (_ : Z.le 0 K)\n         (_ : Z.lt (to_Z x) (Z.pow 2 K))\n         (_ : Z.le (Z.add (to_Z p) K) (Zpos (digits x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))",
                    "_global_log2 : forall _ : t, t",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c10_goal : Z.le 0 (Z.add (to_Z (log2 x)) 1)",
                    "c11_goal : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c12_goal : Z.le (Z.add (to_Z p) (Z.add (to_Z (log2 x)) 1)) (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "generalize ( spec_pos ( log2 _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_pos ( log2 _i ) ) .",
                "tactic_args": [
                    "c10_goal : Z.le 0 (Z.add (to_Z (log2 x)) 1)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : Z.le 0 (to_Z (log2 x)), Z.le 0 (Z.add (to_Z (log2 x)) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : forall _ : Z.le 0 (to_Z (log2 x)), Z.le 0 (Z.add (to_Z (log2 x)) 1)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( spec_log2_pos _i ) as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( spec_log2_pos _i ) .",
                "tactic_args": [
                    "c11_goal : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c2_x : True",
                    "c4_NEQ : not (Logic.eq (to_Z x) 0)",
                    "c2_H : Z.le (to_Z p) (to_Z (head0 x))"
                ],
                "tactic_res": [
                    "c14_goal : not (Logic.eq (to_Z x) 0)",
                    "c15_goal : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c15_H1 : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c15_H0 : Z.le (Z.pow 2 (to_Z (log2 x))) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : not (Logic.eq (to_Z x) 0)",
                    "c4_NEQ : not (Logic.eq (to_Z x) 0)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c15_H1 : Z.lt (to_Z x) (Z.pow 2 (Z.add (to_Z (log2 x)) 1))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.add (to_Z p) (Z.add (to_Z (log2 x)) 1)) (Zpos (digits x))",
                    "_global_log2_digits_head0 : forall (x : t) (_ : Z.lt 0 (to_Z x)),\n       Logic.eq (to_Z (log2 x))\n         (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1)"
                ],
                "tactic_res": [
                    "c16_goal : Z.le\n  (Z.add (to_Z p)\n     (Z.add (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1) 1))\n  (Zpos (digits x))",
                    "c17_goal : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.le\n  (Z.add (to_Z p)\n     (Z.add (Z.sub (Z.sub (Zpos (digits x)) (to_Z (head0 x))) 1) 1))\n  (Zpos (digits x))",
                    "c2_H : Z.le (to_Z p) (to_Z (head0 x))",
                    "c2_x : True",
                    "c2_p : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( spec_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_pos _i ) .",
                "tactic_args": [
                    "c17_goal : Z.lt 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : Z.le 0 (to_Z x), Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : forall _ : Z.le 0 (to_Z x), Z.lt 0 (to_Z x)",
                    "c4_NEQ : not (Logic.eq (to_Z x) 0)",
                    "c2_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_size_fold",
        "proof": [
            {
                "tactic_sig": "Lemma double_size_fold : double_size = iter_t double_size_n .",
                "tactic_sig_no_out_arg": "Lemma double_size_fold : double_size = iter_t double_size_n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq double_size\n  (iter_t\n     (fun n : nat =>\n      let zero := ZnZ.zero in fun x : dom_t n => mk_t_S n (WW zero x)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq double_size\n  (iter_t\n     (fun n : nat =>\n      let zero := ZnZ.zero in fun x : dom_t n => mk_t_S n (WW zero x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq double_size\n  (let f0 := let zero := ZnZ.zero in fun x : W0.t => N1 (WW zero x) in\n   let f1 := let zero := ZnZ.zero in fun x : w1 => N2 (WW zero x) in\n   let f2 := let zero := ZnZ.zero in fun x : w2 => N3 (WW zero x) in\n   let f3 := let zero := ZnZ.zero in fun x : w3 => N4 (WW zero x) in\n   let f4 := let zero := ZnZ.zero in fun x : w4 => N5 (WW zero x) in\n   let f5 := let zero := ZnZ.zero in fun x : w5 => N6 (WW zero x) in\n   let f6 := let zero := ZnZ.zero in fun x : w6 => Nn 0 (WW zero x) in\n   let fn :=\n     fun n : nat =>\n     let zero := ZnZ.zero in\n     fun x : word w6 (S n) => Nn (S n) (WW zero x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq double_size\n  (let f0 := let zero := ZnZ.zero in fun x : W0.t => N1 (WW zero x) in\n   let f1 := let zero := ZnZ.zero in fun x : w1 => N2 (WW zero x) in\n   let f2 := let zero := ZnZ.zero in fun x : w2 => N3 (WW zero x) in\n   let f3 := let zero := ZnZ.zero in fun x : w3 => N4 (WW zero x) in\n   let f4 := let zero := ZnZ.zero in fun x : w4 => N5 (WW zero x) in\n   let f5 := let zero := ZnZ.zero in fun x : w5 => N6 (WW zero x) in\n   let f6 := let zero := ZnZ.zero in fun x : w6 => Nn 0 (WW zero x) in\n   let fn :=\n     fun n : nat =>\n     let zero := ZnZ.zero in\n     fun x : word w6 (S n) => Nn (S n) (WW zero x) in\n   fun x : t =>\n   match x with\n   | N0 wx => f0 wx\n   | N1 wx => f1 wx\n   | N2 wx => f2 wx\n   | N3 wx => f3 wx\n   | N4 wx => f4 wx\n   | N5 wx => f5 wx\n   | N6 wx => f6 wx\n   | Nn n wx => fn n wx\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_size_level",
        "proof": [
            {
                "tactic_sig": "Lemma double_size_level : forall x , level ( double_size x ) = S ( level x ) .",
                "tactic_sig_no_out_arg": "Lemma double_size_level : forall x , level ( double_size x ) = S ( level x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (level (double_size x)) (S (level x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (level (double_size x)) (S (level x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (level (double_size x)) (S (level x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (level (double_size x)) (S (level x))",
                    "_global_double_size_fold : Logic.eq double_size\n         (iter_t\n            (fun n : nat =>\n             let zero := ZnZ.zero in fun x : dom_t n => mk_t_S n (WW zero x)))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (level\n     (iter_t\n        (fun n : nat =>\n         let zero := ZnZ.zero in\n         fun x : dom_t n => mk_t_S n (WW zero x)) x)) \n  (S (level x))"
                ]
            },
            {
                "tactic_sig": "unfold _i at 2 .",
                "tactic_sig_no_out_arg": "unfold _i at 2 .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (level\n     (iter_t\n        (fun n : nat =>\n         let zero := ZnZ.zero in\n         fun x : dom_t n => mk_t_S n (WW zero x)) x)) \n  (S (level x))",
                    "_global_level : forall _ : t, nat"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (level\n     (iter_t (fun (n : nat) (x : dom_t n) => mk_t_S n (WW ZnZ.zero x))\n        x)) (S (iter_t (fun (n : nat) (_ : dom_t n) => n) x))"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (level\n     (iter_t (fun (n : nat) (x : dom_t n) => mk_t_S n (WW ZnZ.zero x))\n        x)) (S (iter_t (fun (n : nat) (_ : dom_t n) => n) x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (level (mk_t_S n (WW ZnZ.zero x))) (S n)",
                    "c5_x : dom_t n",
                    "c5_n : nat"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (level (mk_t_S n (WW ZnZ.zero x))) (S n)",
                    "_global_mk_t_S_level : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (level (mk_t_S n x)) (S n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_size_digits",
        "proof": [
            {
                "tactic_sig": "Theorem spec_double_size_digits : forall x , Zpos ( digits ( double_size x ) ) = 2 * ( Zpos ( digits x ) ) .",
                "tactic_sig_no_out_arg": "Theorem spec_double_size_digits : forall x , Zpos ( digits ( double_size x ) ) = 2 * ( Zpos ( digits x ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t,\nLogic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t,\nLogic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))",
                    "_global_digits_level : forall x : t, Logic.eq (digits x) (ZnZ.digits (dom_op (level x)))",
                    "_global_double_size_level : forall x : t, Logic.eq (level (double_size x)) (S (level x))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Zpos (ZnZ.digits (dom_op (S (level x)))))\n  (Z.mul 2 (Zpos (ZnZ.digits (dom_op (level x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite 2 _i , 2 _i , _i , _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite 2 _i , 2 _i , _i , _i by auto with zarith .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Zpos (ZnZ.digits (dom_op (S (level x)))))\n  (Z.mul 2 (Zpos (ZnZ.digits (dom_op (level x)))))",
                    "_global_digits_dom_op : forall n : nat,\n       Logic.eq (ZnZ.digits (dom_op n))\n         (Pos.shiftl_nat (ZnZ.digits W0.ops) n)",
                    "_global_Pshiftl_nat_Zpower : forall (n : nat) (p : positive),\n       Logic.eq (Zpos (Pos.shiftl_nat p n))\n         (Z.mul (Zpos p) (Z.pow 2 (Z.of_nat n)))",
                    "_global_Nat2Z.inj_succ : forall n : nat, Logic.eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))",
                    "_global_Z.pow_succ_r : forall (n m : Z) (_ : Z.le 0 m),\n       Logic.eq (Z.pow n (Z.succ m)) (Z.mul n (Z.pow n m))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (Z.mul (Zpos (ZnZ.digits W0.ops))\n     (Z.mul 2 (Z.pow 2 (Z.of_nat (level x)))))\n  (Z.mul 2\n     (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat (level x)))))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (Z.mul (Zpos (ZnZ.digits W0.ops))\n     (Z.mul 2 (Z.pow 2 (Z.of_nat (level x)))))\n  (Z.mul 2\n     (Z.mul (Zpos (ZnZ.digits W0.ops)) (Z.pow 2 (Z.of_nat (level x)))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_size",
        "proof": [
            {
                "tactic_sig": "Theorem spec_double_size : forall x , [ double_size x ] = [ x ] .",
                "tactic_sig_no_out_arg": "Theorem spec_double_size : forall x , [ double_size x ] = [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "_global_double_size_fold : Logic.eq double_size\n         (iter_t\n            (fun n : nat =>\n             let zero := ZnZ.zero in fun x : dom_t n => mk_t_S n (WW zero x)))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let zero := ZnZ.zero in\n         fun x : dom_t n => mk_t_S n (WW zero x)) x)) \n  (to_Z x)"
                ]
            },
            {
                "tactic_sig": "destr_t _i as ( n , _i ) .",
                "tactic_sig_no_out_arg": "destr_t _i as ( n , _i ) .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     (iter_t\n        (fun n : nat =>\n         let zero := ZnZ.zero in\n         fun x : dom_t n => mk_t_S n (WW zero x)) x)) \n  (to_Z x)",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.zero x))) (ZnZ.to_Z x)",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (to_Z (mk_t_S n (WW ZnZ.zero x))) (ZnZ.to_Z x)",
                    "_global_spec_mk_t_S : forall (n : nat) (x : zn2z (dom_t n)),\n       Logic.eq (to_Z (mk_t_S n x))\n         (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.zero x))\n  (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : Logic.eq\n  (zn2z_to_Z (base (ZnZ.digits (dom_op n))) ZnZ.to_Z (WW ZnZ.zero x))\n  (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.zero) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z x)) (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq\n  (Z.add (Z.mul (ZnZ.to_Z ZnZ.zero) (base (ZnZ.digits (dom_op n))))\n     (ZnZ.to_Z x)) (ZnZ.to_Z x)",
                    "_global_ZnZ.spec_0 : Logic.eq (ZnZ.to_Z ZnZ.zero) 0\nwhere\n?n : [n : nat  x : dom_t n |- nat]"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.add (Z.mul 0 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z x))\n  (ZnZ.to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.add (Z.mul 0 (base (ZnZ.digits (dom_op n)))) (ZnZ.to_Z x))\n  (ZnZ.to_Z x)",
                    "c4_x : dom_t n",
                    "c4_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_size_head0",
        "proof": [
            {
                "tactic_sig": "Theorem spec_double_size_head0 : forall x , 2 * [ head0 x ] <= [ head0 ( double_size x ) ] .",
                "tactic_sig_no_out_arg": "Theorem spec_double_size_head0 : forall x , 2 * [ head0 x ] <= [ head0 ( double_size x ) ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t,\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t,\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c2_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "assert ( F1 := spec_pos ( head0 _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( F1 := spec_pos ( head0 _i ) ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c2_F1 : Z.le 0 (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "assert ( F2 : 0 < Zpos ( digits _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( F2 : 0 < Zpos ( digits _i ) ) .",
                "tactic_args": [
                    "c2_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 0 (Zpos (digits x))",
                    "c4_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c4_F2 : Z.lt 0 (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : Z.lt 0 (Zpos (digits x))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (Z.compare 0 (Zpos (digits x))) Lt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.compare 0 (Zpos (digits x))) Lt",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( HH := spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( HH := spec_pos _i ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_HH : Z.le 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c4_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c4_HH : Z.le 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c6_HH : Z.lt 0 (to_Z x)",
                    "c7_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c7_HH : Logic.eq 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c6_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c6_HH : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Z.lt 0 (to_Z x),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) .",
                "tactic_args": [
                    "c8_goal : forall _ : Z.lt 0 (to_Z x),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : Z.lt 0 (to_Z (double_size x)),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH1 .",
                "tactic_args": [
                    "c9_goal : forall _ : Z.lt 0 (to_Z (double_size x)),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c10_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c10_HH1 : Z.lt 0 (to_Z (double_size x))"
                ]
            },
            {
                "tactic_sig": "case ( spec_head0 _i _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_head0 _i _i ) .",
                "tactic_args": [
                    "c10_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c6_HH : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c11_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n         (Z.pow 2 (Zpos (digits x)))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ HH2 .",
                "tactic_args": [
                    "c11_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n         (Z.pow 2 (Zpos (digits x)))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c12_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "case ( spec_head0 _ _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_head0 _ _i ) .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c10_HH1 : Z.lt 0 (to_Z (double_size x))"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x))))\n  (_ : Z.lt\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x)))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c13_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x))))\n  (_ : Z.lt\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x)))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c14_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "_global_spec_double_size_digits : forall x : t,\n       Logic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c15_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o _ .",
                "tactic_sig_no_out_arg": "intros HH3 _ .",
                "tactic_args": [
                    "c15_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c16_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c16_HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "case ( Z.le_gt_cases ( [ head0 ( double_size _i ) ] ) ( 2 * [ head0 _i ] ) ) .",
                "tactic_sig_no_out_arg": "case ( Z.le_gt_cases ( [ head0 ( double_size _i ) ] ) ( 2 * [ head0 _i ] ) ) .",
                "tactic_args": [
                    "c16_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c18_goal : forall\n  _ : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH4 .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c19_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c19_HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH4 .",
                "tactic_args": [
                    "c18_goal : forall\n  _ : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x))),\nZ.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c20_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c20_HH4 : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "absurd ( 2 ^ ( 2 * [ head0 _i ] ) * [ _i ] < 2 ^ [ head0 ( double_size _i ) ] * [ _i ] ) .",
                "tactic_sig_no_out_arg": "absurd ( 2 ^ ( 2 * [ head0 _i ] ) * [ _i ] < 2 ^ [ head0 ( double_size _i ) ] * [ _i ] ) .",
                "tactic_args": [
                    "c19_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c2_x : True",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c21_goal : not\n  (Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n     (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))",
                    "c22_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : not\n  (Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n     (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))",
                    "_global_Z.le_ngt : forall n m : Z, iff (Z.le n m) (not (Z.lt m n))"
                ],
                "tactic_res": [
                    "c23_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))",
                    "_global_Z.mul_le_mono_nonneg_r : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul n p) (Z.mul m p)"
                ],
                "tactic_res": [
                    "c24_goal : Z.le 0 (to_Z x)",
                    "c25_goal : Z.le (Z.pow 2 (to_Z (head0 (double_size x))))\n  (Z.pow 2 (Z.mul 2 (to_Z (head0 x))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : Z.le 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : Z.le (Z.pow 2 (to_Z (head0 (double_size x))))\n  (Z.pow 2 (Z.mul 2 (to_Z (head0 x))))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c26_goal : Z.lt 0 2",
                    "c27_goal : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 2",
                    "c4_F2 : Z.lt 0 (Zpos (digits x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))",
                    "c19_HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( HH5 : 2 ^ [ head0 _i ] <= 2 ^ ( Zpos ( digits _i ) - 1 ) ) .",
                "tactic_sig_no_out_arg": "assert ( HH5 : 2 ^ [ head0 _i ] <= 2 ^ ( Zpos ( digits _i ) - 1 ) ) .",
                "tactic_args": [
                    "c22_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c28_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c29_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "c29_HH5 : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Z.le_succ_l : forall n m : Z, iff (Z.le (Z.succ n) m) (Z.lt n m)",
                    "c28_HH : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c28_HH : Z.le (Z.succ 0) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "change ( 1 <= [ _i ] ) in _i .",
                "tactic_sig_no_out_arg": "change ( 1 <= [ _i ] ) in _i .",
                "tactic_args": [
                    "c2_x : True",
                    "c28_HH : Z.le (Z.succ 0) (to_Z x)"
                ],
                "tactic_res": [
                    "c28_HH : Z.le 1 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c28_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c28_HH : Z.le 1 (to_Z x)"
                ],
                "tactic_res": [
                    "c30_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c30_HH : Z.lt 1 (to_Z x)",
                    "c31_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c31_HH : Logic.eq 1 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 ^ 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 ^ 1 ) .",
                "tactic_args": [
                    "c30_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "_global_Z.mul_le_mono_pos_r : forall (n m p : Z) (_ : Z.lt 0 p),\n       iff (Z.le n m) (Z.le (Z.mul n p) (Z.mul m p))"
                ],
                "tactic_res": [
                    "c32_goal : Z.lt 0 (Z.pow 2 1)",
                    "c33_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.mul (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (Z.pow 2 1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c32_goal : Z.lt 0 (Z.pow 2 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( fun _i y z => _i _i ( y - z ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( fun _i y z => _i _i ( y - z ) ) .",
                "tactic_args": [
                    "c33_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.mul (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (Z.pow 2 1))",
                    "c2_x : True",
                    "_global_Z.pow_add_r : forall (a b c : Z) (_ : Z.le 0 b) (_ : Z.le 0 c),\n       Logic.eq (Z.pow a (Z.add b c)) (Z.mul (Z.pow a b) (Z.pow a c))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c34_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.pow 2 (Z.add (Z.sub (Zpos (digits x)) 1) 1))",
                    "c35_goal : Z.le 0 (Z.sub (Zpos (digits x)) 1)",
                    "c36_goal : Z.le 0 1"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c35_goal : Z.le 0 (Z.sub (Zpos (digits x)) 1)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c36_goal : Z.le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c34_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.pow 2 (Z.add (Z.sub (Zpos (digits x)) 1) 1))",
                    "_global_Z.sub_add : forall n m : Z, Logic.eq (Z.add (Z.sub m n) n) m"
                ],
                "tactic_res": [
                    "c37_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i _i _i _i ) .",
                "tactic_args": [
                    "c37_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "_global_Z.lt_le_incl : forall (n m : Z) (_ : Z.lt n m), Z.le n m",
                    "_global__ : ?T\nwhere\n?T : [x : t\n      F1 : Z.le 0 (to_Z (head0 x))\n      F2 : Z.lt 0 (Zpos (digits x))\n      HH : Z.lt 1 (to_Z x)\n      HH1 : Z.lt 0 (to_Z (double_size x))\n      HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n              (Z.pow 2 (Zpos (digits x)))\n      HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n              (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n      HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))\n     |- Type]\n?y : [x : t\n      F1 : Z.le 0 (to_Z (head0 x))\n      F2 : Z.lt 0 (Zpos (digits x))\n      HH : Z.lt 1 (to_Z x)\n      HH1 : Z.lt 0 (to_Z (double_size x))\n      HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n              (Z.pow 2 (Zpos (digits x)))\n      HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n              (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n      HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))\n     |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [x : t\n      F1 : Z.le 0 (to_Z (head0 x))\n      F2 : Z.lt 0 (Zpos (digits x))\n      HH : Z.lt 1 (to_Z x)\n      HH1 : Z.lt 0 (to_Z (double_size x))\n      HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n              (Z.pow 2 (Zpos (digits x)))\n      HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n              (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n      HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))\n     |- Type]\n?y : [x : t\n      F1 : Z.le 0 (to_Z (head0 x))\n      F2 : Z.lt 0 (Zpos (digits x))\n      HH : Z.lt 1 (to_Z x)\n      HH1 : Z.lt 0 (to_Z (double_size x))\n      HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n              (Z.pow 2 (Zpos (digits x)))\n      HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n              (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n      HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))\n     |- ?T]",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))"
                ],
                "tactic_res": [
                    "c38_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : Z.le (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))",
                    "_global_Z.mul_le_mono_nonneg_l : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul p n) (Z.mul p m)"
                ],
                "tactic_res": [
                    "c39_goal : Z.le 0 (Z.pow 2 (to_Z (head0 x)))",
                    "c40_goal : Z.le (Z.pow 2 1) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c39_goal : Z.le 0 (Z.pow 2 (to_Z (head0 x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c40_goal : Z.le (Z.pow 2 1) (to_Z x)",
                    "_global_Z.pow_1_r : forall a : Z, Logic.eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c41_goal : Z.le 2 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c41_goal : Z.le 2 (to_Z x)",
                    "c30_HH : Z.lt 1 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c42_goal : Z.lt 0 2",
                    "c43_goal : Z.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c42_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ( Z.le_gt_cases ( Zpos ( digits _i ) ) [ head0 _i ] ) .",
                "tactic_sig_no_out_arg": "case ( Z.le_gt_cases ( Zpos ( digits _i ) ) [ head0 _i ] ) .",
                "tactic_args": [
                    "c43_goal : Z.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c44_goal : forall _ : Z.le (Zpos (digits x)) (to_Z (head0 x)),\nZ.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)",
                    "c45_goal : forall _ : Z.lt (to_Z (head0 x)) (Zpos (digits x)),\nZ.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros HH6 .",
                "tactic_args": [
                    "c44_goal : forall _ : Z.le (Zpos (digits x)) (to_Z (head0 x)),\nZ.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)"
                ],
                "tactic_res": [
                    "c46_goal : Z.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)",
                    "c46_HH6 : Z.le (Zpos (digits x)) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c45_goal : forall _ : Z.lt (to_Z (head0 x)) (Zpos (digits x)),\nZ.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "absurd ( 2 ^ Zpos ( digits _i ) <= 2 ^ [ head0 _i ] * [ _i ] ) .",
                "tactic_sig_no_out_arg": "absurd ( 2 ^ Zpos ( digits _i ) <= 2 ^ [ head0 _i ] * [ _i ] ) .",
                "tactic_args": [
                    "c46_goal : Z.le (to_Z (head0 x)) (Z.sub (Zpos (digits x)) 1)",
                    "c2_x : True",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c47_goal : not\n  (Z.le (Z.pow 2 (Zpos (digits x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))",
                    "c48_goal : Z.le (Z.pow 2 (Zpos (digits x)))\n  (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c47_goal : not\n  (Z.le (Z.pow 2 (Zpos (digits x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c48_goal : Z.le (Z.pow 2 (Zpos (digits x)))\n  (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))",
                    "c31_HH : Logic.eq 1 (to_Z x)"
                ],
                "tactic_res": [
                    "c49_goal : Z.le (Z.pow 2 (Zpos (digits x))) (Z.mul (Z.pow 2 (to_Z (head0 x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : Z.le (Z.pow 2 (Zpos (digits x))) (Z.mul (Z.pow 2 (to_Z (head0 x))) 1)",
                    "_global_Z.mul_1_r : forall n : Z, Logic.eq (Z.mul n 1) n"
                ],
                "tactic_res": [
                    "c50_goal : Z.le (Z.pow 2 (Zpos (digits x))) (Z.pow 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c50_goal : Z.le (Z.pow 2 (Zpos (digits x))) (Z.pow 2 (to_Z (head0 x)))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c51_goal : Z.lt 0 2",
                    "c52_goal : Z.le (Zpos (digits x)) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c51_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c52_goal : Z.le (Zpos (digits x)) (to_Z (head0 x))",
                    "c46_HH6 : Z.le (Zpos (digits x)) (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i 2 ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i 2 ) .",
                "tactic_args": [
                    "c29_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul 2 (to_Z (head0 x)))) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "_global_Z.mul_comm : forall n m : Z, Logic.eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c53_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul (to_Z (head0 x)) 2)) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c53_goal : Z.lt (Z.mul (Z.pow 2 (Z.mul (to_Z (head0 x)) 2)) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "_global_Z.pow_mul_r : forall (a b c : Z) (_ : Z.le 0 b) (_ : Z.le 0 c),\n       Logic.eq (Z.pow a (Z.mul b c)) (Z.pow (Z.pow a b) c)",
                    "c29_HH5 : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c19_HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))",
                    "c16_HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c10_HH1 : Z.lt 0 (to_Z (double_size x))",
                    "c6_HH : Z.lt 0 (to_Z x)",
                    "c4_F2 : Z.lt 0 (Zpos (digits x))",
                    "c2_F1 : Z.le 0 (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c54_goal : Z.lt (Z.mul (Z.pow (Z.pow 2 (to_Z (head0 x))) 2) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c54_goal : Z.lt (Z.mul (Z.pow (Z.pow 2 (to_Z (head0 x))) 2) (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "_global_Z.pow_2_r : forall a : Z, Logic.eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c55_goal : Z.lt\n  (Z.mul (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (to_Z (head0 x))))\n     (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c55_goal : Z.lt\n  (Z.mul (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (to_Z (head0 x))))\n     (to_Z x))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "c16_HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))"
                ],
                "tactic_res": [
                    "c56_goal : Z.lt\n  (Z.mul (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (to_Z (head0 x))))\n     (to_Z x)) (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c56_goal : Z.lt\n  (Z.mul (Z.mul (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (to_Z (head0 x))))\n     (to_Z x)) (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))",
                    "_global_Z.mul_assoc : forall n m p : Z, Logic.eq (Z.mul n (Z.mul m p)) (Z.mul (Z.mul n m) p)"
                ],
                "tactic_res": [
                    "c57_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * Zpos ( digits _i ) - 1 ) with ( ( Zpos ( digits _i ) - 1 ) + ( Zpos ( digits _i ) ) ) .",
                "tactic_sig_no_out_arg": "replace ( 2 * Zpos ( digits _i ) - 1 ) with ( ( Zpos ( digits _i ) - 1 ) + ( Zpos ( digits _i ) ) ) .",
                "tactic_args": [
                    "c57_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))",
                    "c2_x : True",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c58_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.pow 2 (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x))))",
                    "c59_goal : Logic.eq (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x)))\n  (Z.sub (Z.mul 2 (Zpos (digits x))) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i by auto with zarith .",
                "tactic_sig_no_out_arg": "rewrite _i by auto with zarith .",
                "tactic_args": [
                    "c58_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.pow 2 (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x))))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))",
                    "c29_HH5 : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c19_HH4 : Z.le (to_Z (head0 (double_size x))) (Z.mul 2 (to_Z (head0 x)))",
                    "c16_HH3 : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n  (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c10_HH1 : Z.lt 0 (to_Z (double_size x))",
                    "c6_HH : Z.lt 0 (to_Z x)",
                    "c4_F2 : Z.lt 0 (Zpos (digits x))",
                    "c2_F1 : Z.le 0 (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c60_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.mul (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.pow 2 (Zpos (digits x))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c60_goal : Z.lt\n  (Z.mul (Z.pow 2 (to_Z (head0 x)))\n     (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.mul (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n     (Z.pow 2 (Zpos (digits x))))",
                    "_global_Zmult_lt_compat2 : forall (n m p q : Z) (_ : and (Z.lt 0 n) (Z.le n p))\n         (_ : and (Z.lt 0 m) (Z.lt m q)), Z.lt (Z.mul n m) (Z.mul p q)"
                ],
                "tactic_res": [
                    "c61_goal : and (Z.lt 0 (Z.pow 2 (to_Z (head0 x))))\n  (Z.le (Z.pow 2 (to_Z (head0 x)))\n     (Z.pow 2 (Z.sub (Zpos (digits x)) 1)))",
                    "c62_goal : and (Z.lt 0 (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c61_goal : and (Z.lt 0 (Z.pow 2 (to_Z (head0 x))))\n  (Z.le (Z.pow 2 (to_Z (head0 x)))\n     (Z.pow 2 (Z.sub (Zpos (digits x)) 1)))",
                    "c29_HH5 : Z.le (Z.pow 2 (to_Z (head0 x))) (Z.pow 2 (Z.sub (Zpos (digits x)) 1))",
                    "c2_F1 : Z.le 0 (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c62_goal : and (Z.lt 0 (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n     (Z.pow 2 (Zpos (digits x))))"
                ],
                "tactic_res": [
                    "c63_goal : Z.lt 0 (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))",
                    "c64_goal : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c63_goal : Z.lt 0 (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))",
                    "_global_Z.mul_pos_pos : forall (n m : Z) (_ : Z.lt 0 n) (_ : Z.lt 0 m), Z.lt 0 (Z.mul n m)"
                ],
                "tactic_res": [
                    "c65_goal : Z.lt 0 (Z.pow 2 (to_Z (head0 x)))",
                    "c66_goal : Z.lt 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c65_goal : Z.lt 0 (Z.pow 2 (to_Z (head0 x)))",
                    "c2_F1 : Z.le 0 (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c66_goal : Z.lt 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c64_goal : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c12_HH2 : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c59_goal : Logic.eq (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x)))\n  (Z.sub (Z.mul 2 (Zpos (digits x))) 1)",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c67_goal : Logic.eq (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x)))\n  (Z.sub (Z.mul (Z.mul 2 1) (Zpos (digits x))) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c67_goal : Logic.eq (Z.add (Z.sub (Zpos (digits x)) 1) (Zpos (digits x)))\n  (Z.sub (Z.mul (Z.mul 2 1) (Zpos (digits x))) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "_global_Z.lt_le_incl : forall (n m : Z) (_ : Z.lt n m), Z.le n m"
                ],
                "tactic_res": [
                    "c68_goal : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c68_goal : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c20_HH4 : Z.lt (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat rewrite spec_head00 .",
                "tactic_sig_no_out_arg": "repeat rewrite spec_head00 .",
                "tactic_args": [
                    "c7_goal : Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c69_goal : Z.le (Z.mul 2 (Zpos (digits x))) (Zpos (digits (double_size x)))",
                    "c70_goal : Logic.eq (to_Z (double_size x)) 0",
                    "c71_goal : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c71_goal : Logic.eq (to_Z x) 0",
                    "c7_HH : Logic.eq 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c69_goal : Z.le (Z.mul 2 (Zpos (digits x))) (Zpos (digits (double_size x)))",
                    "_global_spec_double_size_digits : forall x : t,\n       Logic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))"
                ],
                "tactic_res": [
                    "c72_goal : Z.le (Z.mul 2 (Zpos (digits x))) (Z.mul 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c72_goal : Z.le (Z.mul 2 (Zpos (digits x))) (Z.mul 2 (Zpos (digits x)))",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c73_goal : Z.le (Z.mul (Z.mul 2 1) (Zpos (digits x)))\n  (Z.mul (Z.mul 2 1) (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c73_goal : Z.le (Z.mul (Z.mul 2 1) (Zpos (digits x)))\n  (Z.mul (Z.mul 2 1) (Zpos (digits x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c70_goal : Logic.eq (to_Z (double_size x)) 0",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)"
                ],
                "tactic_res": [
                    "c74_goal : Logic.eq (to_Z x) 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : Logic.eq (to_Z x) 0",
                    "c7_HH : Logic.eq 0 (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_size_head0_pos",
        "proof": [
            {
                "tactic_sig": "Theorem spec_double_size_head0_pos : forall x , 0 < [ head0 ( double_size x ) ] .",
                "tactic_sig_no_out_arg": "Theorem spec_double_size_head0_pos : forall x , 0 < [ head0 ( double_size x ) ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Z.lt 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Z.lt 0 (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "assert ( F := Pos2Z.is_pos ( digits _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( F := Pos2Z.is_pos ( digits _i ) ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c2_F : Z.lt 0 (Zpos (digits x))"
                ]
            },
            {
                "tactic_sig": "assert ( F0 := spec_pos ( head0 ( double_size _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( F0 := spec_pos ( head0 ( double_size _i ) ) ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c2_F0 : Z.le 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c2_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c2_F0 : Z.le 0 (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c3_F0 : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c4_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c4_F0 : Logic.eq 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c3_F0 : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F1 := spec_pos ( head0 _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( F1 := spec_pos ( head0 _i ) ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c4_F1 : Z.le 0 (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c4_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c4_F1 : Z.le 0 (to_Z (head0 x))"
                ],
                "tactic_res": [
                    "c5_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c5_F1 : Z.lt 0 (to_Z (head0 x))",
                    "c6_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c6_F1 : Logic.eq 0 (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := ( _i _i ) ) .",
                "tactic_args": [
                    "c5_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_spec_double_size_head0 : forall x : t,\n       Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt 0 (Z.mul 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 (Z.mul 2 (to_Z (head0 x)))",
                    "c5_F1 : Z.lt 0 (to_Z (head0 x))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( F3 := spec_pos _i ) .",
                "tactic_sig_no_out_arg": "assert ( F3 := spec_pos _i ) .",
                "tactic_args": [
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c6_F3 : Z.le 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c6_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c6_F3 : Z.le 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c8_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c8_F3 : Z.lt 0 (to_Z x)",
                    "c9_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c9_F3 : Logic.eq 0 (to_Z x)"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c8_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c8_F3 : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x), Z.lt 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) .",
                "tactic_args": [
                    "c10_goal : forall _ : Z.lt 0 (to_Z x), Z.lt 0 (to_Z (head0 (double_size x)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Z.lt 0 (to_Z (double_size x)),\nZ.lt 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros F4 .",
                "tactic_args": [
                    "c11_goal : forall _ : Z.lt 0 (to_Z (double_size x)),\nZ.lt 0 (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c12_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c12_F4 : Z.lt 0 (to_Z (double_size x))"
                ]
            },
            {
                "tactic_sig": "absurd ( 2 ^ ( Zpos ( xO ( digits _i ) ) - 1 ) < 2 ^ ( Zpos ( digits _i ) ) ) .",
                "tactic_sig_no_out_arg": "absurd ( 2 ^ ( Zpos ( xO ( digits _i ) ) - 1 ) < 2 ^ ( Zpos ( digits _i ) ) ) .",
                "tactic_args": [
                    "c12_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c13_goal : not\n  (Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n     (Z.pow 2 (Zpos (digits x))))",
                    "c14_goal : Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : not\n  (Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n     (Z.pow 2 (Zpos (digits x))))",
                    "_global_Z.le_ngt : forall n m : Z, iff (Z.le n m) (not (Z.lt m n))"
                ],
                "tactic_res": [
                    "c15_goal : Z.le (Z.pow 2 (Zpos (digits x)))\n  (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Z.le (Z.pow 2 (Zpos (digits x)))\n  (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c16_goal : Z.lt 0 2",
                    "c17_goal : Z.le (Zpos (digits x)) (Z.sub (Zpos (xO (digits x))) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : Z.le (Zpos (digits x)) (Z.sub (Zpos (xO (digits x))) 1)",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c18_goal : Z.le (Zpos (digits x)) (Z.sub (Z.mul 2 (Zpos (digits x))) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : Z.le (Zpos (digits x)) (Z.sub (Z.mul 2 (Zpos (digits x))) 1)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ( spec_head0 _i _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_head0 _i _i ) .",
                "tactic_args": [
                    "c14_goal : Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c2_x : True",
                    "c8_F3 : Z.lt 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c19_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n         (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c19_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 x))) (to_Z x))\n         (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c6_F1 : Logic.eq 0 (to_Z (head0 x))"
                ],
                "tactic_res": [
                    "c20_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 0) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 0) (to_Z x)) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1))\n         (Z.mul (Z.pow 2 0) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 0) (to_Z x)) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "_global_Z.pow_0_r : forall n : Z, Logic.eq (Z.pow n 0) 1"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (Z.mul 1 (to_Z x)))\n  (_ : Z.lt (Z.mul 1 (to_Z x)) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (Z.mul 1 (to_Z x)))\n  (_ : Z.lt (Z.mul 1 (to_Z x)) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "_global_Z.mul_1_l : forall n : Z, Logic.eq (Z.mul 1 n) n"
                ],
                "tactic_res": [
                    "c22_goal : forall (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (to_Z x))\n  (_ : Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ HH .",
                "tactic_args": [
                    "c22_goal : forall (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits x)) 1)) (to_Z x))\n  (_ : Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x)))),\nZ.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))"
                ],
                "tactic_res": [
                    "c23_goal : Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "c23_HH : Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c23_goal : Z.lt (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1))\n  (Z.pow 2 (Zpos (digits x)))",
                    "_global_Z.le_lt_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.lt m p), Z.lt n p",
                    "c23_HH : Z.lt (to_Z x) (Z.pow 2 (Zpos (digits x)))"
                ],
                "tactic_res": [
                    "c24_goal : Z.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "case ( spec_head0 _ _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_head0 _ _i ) .",
                "tactic_args": [
                    "c24_goal : Z.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "c12_F4 : Z.lt 0 (to_Z (double_size x))"
                ],
                "tactic_res": [
                    "c25_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x))))\n  (_ : Z.lt\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x)))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c25_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x))))\n  (_ : Z.lt\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x))))\n            (to_Z (double_size x)))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c26_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c26_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Zpos (digits (double_size x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Zpos (digits (double_size x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "_global_spec_double_size_digits : forall x : t,\n       Logic.eq (Zpos (digits (double_size x))) (Z.mul 2 (Zpos (digits x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c27_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c27_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 (to_Z (head0 (double_size x)))) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "c4_F0 : Logic.eq 0 (to_Z (head0 (double_size x)))"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 0) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 0) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul (Z.pow 2 0) (to_Z x)))\n  (_ : Z.lt (Z.mul (Z.pow 2 0) (to_Z x))\n         (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "_global_Z.pow_0_r : forall n : Z, Logic.eq (Z.pow n 0) 1"
                ],
                "tactic_res": [
                    "c29_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul 1 (to_Z x)))\n  (_ : Z.lt (Z.mul 1 (to_Z x)) (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1))\n         (Z.mul 1 (to_Z x)))\n  (_ : Z.lt (Z.mul 1 (to_Z x)) (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "_global_Z.mul_1_l : forall n : Z, Logic.eq (Z.mul 1 n) n"
                ],
                "tactic_res": [
                    "c30_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1)) (to_Z x))\n  (_ : Z.lt (to_Z x) (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : forall\n  (_ : Z.le (Z.pow 2 (Z.sub (Z.mul 2 (Zpos (digits x))) 1)) (to_Z x))\n  (_ : Z.lt (to_Z x) (Z.pow 2 (Z.mul 2 (Zpos (digits x))))),\nZ.le (Z.pow 2 (Z.sub (Zpos (xO (digits x))) 1)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c9_goal : Z.lt 0 (to_Z (head0 (double_size x)))",
                    "c6_F1 : Logic.eq 0 (to_Z (head0 x))"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : Logic.eq 0 (to_Z (head0 x)),\nZ.lt 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ( _i _i ) ) .",
                "tactic_args": [
                    "c31_goal : forall _ : Logic.eq 0 (to_Z (head0 x)),\nZ.lt 0 (to_Z (head0 (double_size x)))",
                    "_global_spec_head00 : forall (x : t) (_ : Logic.eq (to_Z x) 0),\n       Logic.eq (to_Z (head0 x)) (Zpos (digits x))",
                    "_global__ : ?T\nwhere\n?T : [x : t\n      F : Z.lt 0 (Zpos (digits x))\n      F0 : Logic.eq 0 (to_Z (head0 (double_size x)))\n      F1 : Logic.eq 0 (to_Z (head0 x))\n      F3 : Logic.eq 0 (to_Z x) |- Type]\n?y : [x : t\n      F : Z.lt 0 (Zpos (digits x))\n      F0 : Logic.eq 0 (to_Z (head0 (double_size x)))\n      F1 : Logic.eq 0 (to_Z (head0 x))\n      F3 : Logic.eq 0 (to_Z x) |- ?T]",
                    "_global_eq_sym : forall (A : Type) (x y : A) (_ : Logic.eq x y), Logic.eq y x",
                    "c9_F3 : Logic.eq 0 (to_Z x)"
                ],
                "tactic_res": [
                    "c32_goal : forall _ : Logic.eq 0 (Zpos (digits x)),\nZ.lt 0 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c32_goal : forall _ : Logic.eq 0 (Zpos (digits x)),\nZ.lt 0 (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftl_aux_body",
        "proof": [
            {
                "tactic_sig": "Theorem spec_shiftl_aux_body : forall n x p cont , 2 ^ Zpos p <= [ head0 x ] -> ( forall x , 2 ^ ( Zpos p + 1 ) <= [ head0 x ] -> [ cont x n ] = [ x ] * 2 ^ [ n ] ) -> [ shiftl_aux_body cont x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_sig_no_out_arg": "Theorem spec_shiftl_aux_body : forall n x p cont , 2 ^ Zpos p <= [ head0 x ] -> ( forall x , 2 ^ ( Zpos p + 1 ) <= [ head0 x ] -> [ cont x n ] = [ x ] * 2 ^ [ n ] ) -> [ shiftl_aux_body cont x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n x : t) (p : positive) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux_body cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x p cont H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (n x : t) (p : positive) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux_body cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftl_aux_body cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_n : True",
                    "c2_x : True",
                    "c2_p : positive",
                    "c2_cont : forall (_ : t) (_ : t), t",
                    "c2_H1 : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x))",
                    "c2_H2 : forall (x : t) (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftl_aux_body cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_shiftl_aux_body : forall (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare n (head0 x) with\n     | Gt => cont (double_size x) n\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare n (head0 x) with\n     | Gt => cont (double_size x) n\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 x)) with\n     | Gt => cont (double_size x) n\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 x)) with\n     | Gt => cont (double_size x) n\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c6_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c7_goal : forall _ : Z.lt (to_Z (head0 x)) (to_Z n),\nLogic.eq (to_Z (cont (double_size x) n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c8_H : Logic.eq (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c9_H : Z.lt (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c7_goal : forall _ : Z.lt (to_Z (head0 x)) (to_Z n),\nLogic.eq (to_Z (cont (double_size x) n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (to_Z (cont (double_size x) n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c10_H : Z.lt (to_Z (head0 x)) (to_Z n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.le (to_Z n) (to_Z (head0 x))",
                    "c8_H : Logic.eq (to_Z n) (to_Z (head0 x))",
                    "c2_n : True",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c12_goal : Z.le (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le (to_Z n) (to_Z (head0 x))",
                    "c9_H : Z.lt (to_Z n) (to_Z (head0 x))",
                    "c2_n : True",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : Logic.eq (to_Z (cont (double_size x) n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_H2 : forall (x : t) (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c14_goal : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_n : True",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 (double_size x)))",
                    "_global_Z.add_comm : forall n m : Z, Logic.eq (Z.add n m) (Z.add m n)"
                ],
                "tactic_res": [
                    "c16_goal : Z.le (Z.pow 2 (Z.add 1 (Zpos p))) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : Z.le (Z.pow 2 (Z.add 1 (Zpos p))) (to_Z (head0 (double_size x)))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       Logic.eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c17_goal : Z.le (Z.mul (Z.pow 2 1) (Z.pow 2 (Zpos p)))\n  (to_Z (head0 (double_size x)))",
                    "c18_goal : Z.ge 1 0",
                    "c19_goal : Z.ge (Zpos p) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c18_goal : Z.ge 1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : Z.ge (Zpos p) 0",
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i _i ) .",
                "tactic_args": [
                    "c17_goal : Z.le (Z.mul (Z.pow 2 1) (Z.pow 2 (Zpos p)))\n  (to_Z (head0 (double_size x)))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "_global_spec_double_size_head0 : forall x : t,\n       Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c20_goal : Z.le (Z.mul (Z.pow 2 1) (Z.pow 2 (Zpos p))) (Z.mul 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : Z.le (Z.mul (Z.pow 2 1) (Z.pow 2 (Zpos p))) (Z.mul 2 (to_Z (head0 x)))",
                    "_global_Z.pow_1_r : forall a : Z, Logic.eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c21_goal : Z.le (Z.mul 2 (Z.pow 2 (Zpos p))) (Z.mul 2 (to_Z (head0 x)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Z.le (Z.mul 2 (Z.pow 2 (Zpos p))) (Z.mul 2 (to_Z (head0 x)))",
                    "_global_Z.mul_le_mono_nonneg_l : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul p n) (Z.mul p m)"
                ],
                "tactic_res": [
                    "c22_goal : Z.le 0 2",
                    "c23_goal : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c23_goal : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x))",
                    "c2_H1 : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x))",
                    "c2_p : positive",
                    "c2_x : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftl_aux",
        "proof": [
            {
                "tactic_sig": "Theorem spec_shiftl_aux : forall p q x n cont , 2 ^ ( Zpos q ) <= [ head0 x ] -> ( forall x , 2 ^ ( Zpos p + Zpos q ) <= [ head0 x ] -> [ cont x n ] = [ x ] * 2 ^ [ n ] ) -> [ shiftl_aux p cont x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_sig_no_out_arg": "Theorem spec_shiftl_aux : forall p q x n cont , 2 ^ ( Zpos q ) <= [ head0 x ] -> ( forall x , 2 ^ ( Zpos p + Zpos q ) <= [ head0 x ] -> [ cont x n ] = [ x ] * 2 ^ [ n ] ) -> [ shiftl_aux p cont x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall (p q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux (xI p) cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c4_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux (xO p) cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c5_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux 1 cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux (xI p) cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_shiftl_aux : forall (_ : positive) (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t),\n       t"
                ],
                "tactic_res": [
                    "c6_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq\n         (to_Z\n            ((fix shiftl_aux\n                (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n                (x0 n0 : t) {struct p0} : t :=\n                shiftl_aux_body\n                  (fun x1 n1 : t =>\n                   match p0 with\n                   | xI p1 | xO p1 =>\n                       shiftl_aux p1 (shiftl_aux p1 cont0) x1 n1\n                   | 1%positive => cont0 x1 n1\n                   end) x0 n0) p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t =>\n         (fix shiftl_aux\n            (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n            (x1 n1 : t) {struct p0} : t :=\n            shiftl_aux_body\n              (fun x2 n2 : t =>\n               match p0 with\n               | xI p1 | xO p1 =>\n                   shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n               | 1%positive => cont0 x2 n2\n               end) x1 n1) p\n           ((fix shiftl_aux\n               (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n               (x1 n1 : t) {struct p0} : t :=\n               shiftl_aux_body\n                 (fun x2 n2 : t =>\n                  match p0 with\n                  | xI p1 | xO p1 =>\n                      shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n                  | 1%positive => cont0 x2 n2\n                  end) x1 n1) p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "fold shiftl_aux .",
                "tactic_sig_no_out_arg": "fold shiftl_aux .",
                "tactic_args": [
                    "c6_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq\n         (to_Z\n            ((fix shiftl_aux\n                (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n                (x0 n0 : t) {struct p0} : t :=\n                shiftl_aux_body\n                  (fun x1 n1 : t =>\n                   match p0 with\n                   | xI p1 | xO p1 =>\n                       shiftl_aux p1 (shiftl_aux p1 cont0) x1 n1\n                   | 1%positive => cont0 x1 n1\n                   end) x0 n0) p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t =>\n         (fix shiftl_aux\n            (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n            (x1 n1 : t) {struct p0} : t :=\n            shiftl_aux_body\n              (fun x2 n2 : t =>\n               match p0 with\n               | xI p1 | xO p1 =>\n                   shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n               | 1%positive => cont0 x2 n2\n               end) x1 n1) p\n           ((fix shiftl_aux\n               (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n               (x1 n1 : t) {struct p0} : t :=\n               shiftl_aux_body\n                 (fun x2 n2 : t =>\n                  match p0 with\n                  | xI p1 | xO p1 =>\n                      shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n                  | 1%positive => cont0 x2 n2\n                  end) x1 n1) p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c7_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t => shiftl_aux p (shiftl_aux p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux (xO p) cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_shiftl_aux : forall (_ : positive) (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t),\n       t"
                ],
                "tactic_res": [
                    "c8_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq\n         (to_Z\n            ((fix shiftl_aux\n                (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n                (x0 n0 : t) {struct p0} : t :=\n                shiftl_aux_body\n                  (fun x1 n1 : t =>\n                   match p0 with\n                   | xI p1 | xO p1 =>\n                       shiftl_aux p1 (shiftl_aux p1 cont0) x1 n1\n                   | 1%positive => cont0 x1 n1\n                   end) x0 n0) p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t =>\n         (fix shiftl_aux\n            (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n            (x1 n1 : t) {struct p0} : t :=\n            shiftl_aux_body\n              (fun x2 n2 : t =>\n               match p0 with\n               | xI p1 | xO p1 =>\n                   shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n               | 1%positive => cont0 x2 n2\n               end) x1 n1) p\n           ((fix shiftl_aux\n               (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n               (x1 n1 : t) {struct p0} : t :=\n               shiftl_aux_body\n                 (fun x2 n2 : t =>\n                  match p0 with\n                  | xI p1 | xO p1 =>\n                      shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n                  | 1%positive => cont0 x2 n2\n                  end) x1 n1) p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "fold shiftl_aux .",
                "tactic_sig_no_out_arg": "fold shiftl_aux .",
                "tactic_args": [
                    "c8_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq\n         (to_Z\n            ((fix shiftl_aux\n                (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n                (x0 n0 : t) {struct p0} : t :=\n                shiftl_aux_body\n                  (fun x1 n1 : t =>\n                   match p0 with\n                   | xI p1 | xO p1 =>\n                       shiftl_aux p1 (shiftl_aux p1 cont0) x1 n1\n                   | 1%positive => cont0 x1 n1\n                   end) x0 n0) p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t =>\n         (fix shiftl_aux\n            (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n            (x1 n1 : t) {struct p0} : t :=\n            shiftl_aux_body\n              (fun x2 n2 : t =>\n               match p0 with\n               | xI p1 | xO p1 =>\n                   shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n               | 1%positive => cont0 x2 n2\n               end) x1 n1) p\n           ((fix shiftl_aux\n               (p0 : positive) (cont0 : forall (_ : t) (_ : t), t)\n               (x1 n1 : t) {struct p0} : t :=\n               shiftl_aux_body\n                 (fun x2 n2 : t =>\n                  match p0 with\n                  | xI p1 | xO p1 =>\n                      shiftl_aux p1 (shiftl_aux p1 cont0) x2 n2\n                  | 1%positive => cont0 x2 n2\n                  end) x1 n1) p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c9_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t => shiftl_aux p (shiftl_aux p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux 1 cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_shiftl_aux : forall (_ : positive) (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t),\n       t"
                ],
                "tactic_res": [
                    "c10_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux_body (fun x0 n0 : t => cont x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros p Hrec q x n cont H1 H2 .",
                "tactic_args": [
                    "c7_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t => shiftl_aux p (shiftl_aux p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x n : t => shiftl_aux p (shiftl_aux p cont) x n) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c11_p : positive",
                    "c11_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c11_q : positive",
                    "c11_x : True",
                    "c11_n : True",
                    "c11_cont : forall (_ : t) (_ : t), t",
                    "c11_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x))",
                    "c11_H2 : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q))) (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ) .",
                "tactic_args": [
                    "c11_goal : Logic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x n : t => shiftl_aux p (shiftl_aux p cont) x n) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_shiftl_aux_body : forall (n x : t) (p : positive) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux_body cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c11_q : positive"
                ],
                "tactic_res": [
                    "c12_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x))",
                    "c13_goal : forall (x : t) (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x))",
                    "c11_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x))",
                    "c11_x : True",
                    "c11_q : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x1 H3 .",
                "tactic_args": [
                    "c13_goal : forall (x : t) (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x1 n))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z n)))",
                    "c14_x1 : True",
                    "c14_H3 : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x1))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i + 1 ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with ( _i + 1 ) % _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x1 n))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z n)))",
                    "c11_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c11_q : positive",
                    "_global_positive : Set"
                ],
                "tactic_res": [
                    "c15_goal : Z.le (Z.pow 2 (Zpos (Pos.add q 1%positive))) (to_Z (head0 x1))",
                    "c16_goal : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n         (to_Z (head0 x))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Z.le (Z.pow 2 (Zpos (Pos.add q 1%positive))) (to_Z (head0 x1))",
                    "c14_H3 : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x1))",
                    "c14_x1 : True",
                    "c11_q : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x2 H4 .",
                "tactic_args": [
                    "c16_goal : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n         (to_Z (head0 x))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c17_goal : Logic.eq (to_Z (shiftl_aux p cont x2 n))\n  (Z.mul (to_Z x2) (Z.pow 2 (to_Z n)))",
                    "c17_x2 : True",
                    "c17_H4 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n  (to_Z (head0 x2))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i + _i + 1 ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with ( _i + _i + 1 ) % _i .",
                "tactic_args": [
                    "c17_goal : Logic.eq (to_Z (shiftl_aux p cont x2 n))\n  (Z.mul (to_Z x2) (Z.pow 2 (to_Z n)))",
                    "c11_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c11_p : positive",
                    "c11_q : positive",
                    "_global_positive : Set"
                ],
                "tactic_res": [
                    "c18_goal : Z.le (Z.pow 2 (Zpos (Pos.add (Pos.add p q) 1%positive)))\n  (to_Z (head0 x2))",
                    "c19_goal : forall (x : t)\n  (_ : Z.le\n         (Z.pow 2\n            (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n         (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c18_goal : Z.le (Z.pow 2 (Zpos (Pos.add (Pos.add p q) 1%positive)))\n  (to_Z (head0 x2))",
                    "_global_Pos.add_assoc : forall p q r : positive,\n       Logic.eq (Pos.add p (Pos.add q r)) (Pos.add (Pos.add p q) r)"
                ],
                "tactic_res": [
                    "c20_goal : Z.le (Z.pow 2 (Zpos (Pos.add p (Pos.add q 1%positive))))\n  (to_Z (head0 x2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : Z.le (Z.pow 2 (Zpos (Pos.add p (Pos.add q 1%positive))))\n  (to_Z (head0 x2))",
                    "_global_Pos2Z.inj_add : forall p q : positive,\n       Logic.eq (Zpos (Pos.add p q)) (Z.add (Zpos p) (Zpos q))"
                ],
                "tactic_res": [
                    "c21_goal : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n  (to_Z (head0 x2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n  (to_Z (head0 x2))",
                    "c17_H4 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add q 1%positive))))\n  (to_Z (head0 x2))",
                    "c17_x2 : True",
                    "c11_q : positive",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x3 H5 .",
                "tactic_args": [
                    "c19_goal : forall (x : t)\n  (_ : Z.le\n         (Z.pow 2\n            (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n         (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (to_Z (cont x3 n)) (Z.mul (to_Z x3) (Z.pow 2 (to_Z n)))",
                    "c22_x3 : True",
                    "c22_H5 : Z.le\n  (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n  (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq (to_Z (cont x3 n)) (Z.mul (to_Z x3) (Z.pow 2 (to_Z n)))",
                    "c11_H2 : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q))) (to_Z (head0 x))),\nLogic.eq (to_Z (cont x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c23_goal : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q))) (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : Z.le (Z.pow 2 (Z.add (Zpos (xI p)) (Zpos q))) (to_Z (head0 x3))",
                    "_global_Pos2Z.inj_xI : forall p : positive,\n       Logic.eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c24_goal : Z.le (Z.pow 2 (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q)))\n  (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * Zpos _i + 1 + Zpos _i ) with ( Zpos _i + Zpos ( _i + _i + 1 ) ) .",
                "tactic_sig_no_out_arg": "replace ( 2 * Zpos _i + 1 + Zpos _i ) with ( Zpos _i + Zpos ( _i + _i + 1 ) ) .",
                "tactic_args": [
                    "c24_goal : Z.le (Z.pow 2 (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q)))\n  (to_Z (head0 x3))",
                    "c11_p : positive",
                    "c11_q : positive",
                    "c11_p : positive",
                    "c11_p : positive",
                    "c11_q : positive"
                ],
                "tactic_res": [
                    "c25_goal : Z.le\n  (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n  (to_Z (head0 x3))",
                    "c26_goal : Logic.eq (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive)))\n  (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Z.le\n  (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n  (to_Z (head0 x3))",
                    "c22_H5 : Z.le\n  (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive))))\n  (to_Z (head0 x3))",
                    "c22_x3 : True",
                    "c11_q : positive",
                    "c11_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite !Pos2Z.inj_add .",
                "tactic_sig_no_out_arg": "rewrite !Pos2Z.inj_add .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Z.add (Zpos p) (Zpos (Pos.add (Pos.add p q) 1%positive)))\n  (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q))"
                ],
                "tactic_res": [
                    "c27_goal : Logic.eq (Z.add (Zpos p) (Z.add (Z.add (Zpos p) (Zpos q)) 1))\n  (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c27_goal : Logic.eq (Z.add (Zpos p) (Z.add (Z.add (Zpos p) (Zpos q)) 1))\n  (Z.add (Z.add (Z.mul 2 (Zpos p)) 1) (Zpos q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros p Hrec q n x cont H1 H2 .",
                "tactic_args": [
                    "c9_goal : forall (p : positive)\n  (_ : forall (q : positive) (x n : t)\n         (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))) (q : positive) \n  (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x0 n0 : t => shiftl_aux p (shiftl_aux p cont) x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c28_goal : Logic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x n : t => shiftl_aux p (shiftl_aux p cont) x n) n x))\n  (Z.mul (to_Z n) (Z.pow 2 (to_Z x)))",
                    "c28_p : positive",
                    "c28_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c28_q : positive",
                    "c28_n : True",
                    "c28_x : True",
                    "c28_cont : forall (_ : t) (_ : t), t",
                    "c28_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c28_H2 : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ) .",
                "tactic_args": [
                    "c28_goal : Logic.eq\n  (to_Z\n     (shiftl_aux_body\n        (fun x n : t => shiftl_aux p (shiftl_aux p cont) x n) n x))\n  (Z.mul (to_Z n) (Z.pow 2 (to_Z x)))",
                    "_global_spec_shiftl_aux_body : forall (n x : t) (p : positive) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux_body cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c28_q : positive"
                ],
                "tactic_res": [
                    "c29_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c30_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x0))),\nLogic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x0 x))\n  (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c28_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c28_n : True",
                    "c28_q : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x1 H3 .",
                "tactic_args": [
                    "c30_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x0))),\nLogic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x0 x))\n  (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ],
                "tactic_res": [
                    "c31_goal : Logic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x1 x))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z x)))",
                    "c31_x1 : True",
                    "c31_H3 : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x1))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ) .",
                "tactic_args": [
                    "c31_goal : Logic.eq (to_Z (shiftl_aux p (shiftl_aux p cont) x1 x))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z x)))",
                    "c28_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c28_q : positive"
                ],
                "tactic_res": [
                    "c32_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x1))",
                    "c33_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (shiftl_aux p cont x0 x))\n  (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c32_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x1))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "c31_H3 : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x1))"
                ],
                "tactic_res": [
                    "c34_goal : Z.le (Z.pow 2 (Zpos q)) (Z.pow 2 (Z.add (Zpos q) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c34_goal : Z.le (Z.pow 2 (Zpos q)) (Z.pow 2 (Z.add (Zpos q) 1))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c35_goal : Z.lt 0 2",
                    "c36_goal : Z.le (Zpos q) (Z.add (Zpos q) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c35_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c36_goal : Z.le (Zpos q) (Z.add (Zpos q) 1)",
                    "c28_q : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x2 H4 .",
                "tactic_args": [
                    "c33_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (shiftl_aux p cont x0 x))\n  (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ],
                "tactic_res": [
                    "c37_goal : Logic.eq (to_Z (shiftl_aux p cont x2 x))\n  (Z.mul (to_Z x2) (Z.pow 2 (to_Z x)))",
                    "c37_x2 : True",
                    "c37_H4 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q))) (to_Z (head0 x2))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i + _i ) % _i .",
                "tactic_sig_no_out_arg": "apply _i with ( _i + _i ) % _i .",
                "tactic_args": [
                    "c37_goal : Logic.eq (to_Z (shiftl_aux p cont x2 x))\n  (Z.mul (to_Z x2) (Z.pow 2 (to_Z x)))",
                    "c28_Hrec : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux p cont x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c28_p : positive",
                    "c28_q : positive",
                    "_global_positive : Set"
                ],
                "tactic_res": [
                    "c38_goal : Z.le (Z.pow 2 (Zpos (Pos.add p q))) (to_Z (head0 x2))",
                    "c39_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q))))\n         (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : Z.le (Z.pow 2 (Zpos (Pos.add p q))) (to_Z (head0 x2))",
                    "c37_H4 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q))) (to_Z (head0 x2))",
                    "c37_x2 : True",
                    "c28_q : positive",
                    "c28_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x3 H5 .",
                "tactic_args": [
                    "c39_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q))))\n         (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ],
                "tactic_res": [
                    "c40_goal : Logic.eq (to_Z (cont x3 x)) (Z.mul (to_Z x3) (Z.pow 2 (to_Z x)))",
                    "c40_x3 : True",
                    "c40_H5 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q)))) (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : Logic.eq (to_Z (cont x3 x)) (Z.mul (to_Z x3) (Z.pow 2 (to_Z x)))",
                    "c28_H2 : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ],
                "tactic_res": [
                    "c41_goal : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q))) (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c41_goal : Z.le (Z.pow 2 (Z.add (Zpos (xO p)) (Zpos q))) (to_Z (head0 x3))",
                    "_global_Pos2Z.inj_xO : forall p : positive, Logic.eq (Zpos (xO p)) (Z.mul 2 (Zpos p))",
                    "c28_p : positive"
                ],
                "tactic_res": [
                    "c42_goal : Z.le (Z.pow 2 (Z.add (Z.mul 2 (Zpos p)) (Zpos q))) (to_Z (head0 x3))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * Zpos _i + Zpos _i ) with ( Zpos _i + Zpos ( _i + _i ) ) .",
                "tactic_sig_no_out_arg": "replace ( 2 * Zpos _i + Zpos _i ) with ( Zpos _i + Zpos ( _i + _i ) ) .",
                "tactic_args": [
                    "c42_goal : Z.le (Z.pow 2 (Z.add (Z.mul 2 (Zpos p)) (Zpos q))) (to_Z (head0 x3))",
                    "c28_p : positive",
                    "c28_q : positive",
                    "c28_p : positive",
                    "c28_p : positive",
                    "c28_q : positive"
                ],
                "tactic_res": [
                    "c43_goal : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q)))) (to_Z (head0 x3))",
                    "c44_goal : Logic.eq (Z.add (Zpos p) (Zpos (Pos.add p q)))\n  (Z.add (Z.mul 2 (Zpos p)) (Zpos q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c43_goal : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q)))) (to_Z (head0 x3))",
                    "c40_H5 : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos (Pos.add p q)))) (to_Z (head0 x3))",
                    "c40_x3 : True",
                    "c28_q : positive",
                    "c28_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c44_goal : Logic.eq (Z.add (Zpos p) (Zpos (Pos.add p q)))\n  (Z.add (Z.mul 2 (Zpos p)) (Zpos q))",
                    "_global_Pos2Z.inj_add : forall p q : positive,\n       Logic.eq (Zpos (Pos.add p q)) (Z.add (Zpos p) (Zpos q))"
                ],
                "tactic_res": [
                    "c45_goal : Logic.eq (Z.add (Zpos p) (Z.add (Zpos p) (Zpos q)))\n  (Z.add (Z.mul 2 (Zpos p)) (Zpos q))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c45_goal : Logic.eq (Z.add (Zpos p) (Z.add (Zpos p) (Zpos q)))\n  (Z.add (Z.mul 2 (Zpos p)) (Zpos q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros q n x cont H1 H2 .",
                "tactic_args": [
                    "c10_goal : forall (q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n  (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n  (_ : forall (x0 : t)\n         (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\n       Logic.eq (to_Z (cont x0 n)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\nLogic.eq (to_Z (shiftl_aux_body (fun x0 n0 : t => cont x0 n0) x n))\n  (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c46_goal : Logic.eq (to_Z (shiftl_aux_body (fun x n : t => cont x n) n x))\n  (Z.mul (to_Z n) (Z.pow 2 (to_Z x)))",
                    "c46_q : positive",
                    "c46_n : True",
                    "c46_x : True",
                    "c46_cont : forall (_ : t) (_ : t), t",
                    "c46_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c46_H2 : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ) .",
                "tactic_args": [
                    "c46_goal : Logic.eq (to_Z (shiftl_aux_body (fun x n : t => cont x n) n x))\n  (Z.mul (to_Z n) (Z.pow 2 (to_Z x)))",
                    "_global_spec_shiftl_aux_body : forall (n x : t) (p : positive) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos p)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) 1)) (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux_body cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c46_q : positive"
                ],
                "tactic_res": [
                    "c47_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c48_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c46_H1 : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 n))",
                    "c46_n : True",
                    "c46_q : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c48_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos q) 1)) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))",
                    "_global_Z.add_comm : forall n m : Z, Logic.eq (Z.add n m) (Z.add m n)"
                ],
                "tactic_res": [
                    "c49_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c49_goal : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))",
                    "c46_H2 : forall (x0 : t)\n  (_ : Z.le (Z.pow 2 (Z.add 1 (Zpos q))) (to_Z (head0 x0))),\nLogic.eq (to_Z (cont x0 x)) (Z.mul (to_Z x0) (Z.pow 2 (to_Z x)))",
                    "c46_cont : forall (_ : t) (_ : t), t",
                    "c46_x : True",
                    "c46_q : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftl_pow2",
        "proof": [
            {
                "tactic_sig": "Theorem spec_shiftl_pow2 : forall x n , [ shiftl x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_sig_no_out_arg": "Theorem spec_shiftl_pow2 : forall x n , [ shiftl x n ] = [ x ] * 2 ^ [ n ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x n : t,\nLogic.eq (to_Z (shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x n .",
                "tactic_args": [
                    "c1_goal : forall x n : t,\nLogic.eq (to_Z (shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c2_x : True",
                    "c2_n : True"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_shiftl : forall (_ : t) (_ : t), t",
                    "_global_shiftl_aux_body : forall (_ : forall (_ : t) (_ : t), t) (_ : t) (_ : t), t"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare n (head0 x) with\n     | Gt =>\n         match compare n (head0 (double_size x)) with\n         | Gt =>\n             shiftl_aux (digits n) unsafe_shiftl\n               (double_size (double_size x)) n\n         | _ => unsafe_shiftl (double_size x) n\n         end\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Logic.eq\n  (to_Z\n     match compare n (head0 x) with\n     | Gt =>\n         match compare n (head0 (double_size x)) with\n         | Gt =>\n             shiftl_aux (digits n) unsafe_shiftl\n               (double_size (double_size x)) n\n         | _ => unsafe_shiftl (double_size x) n\n         end\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 x)) with\n     | Gt =>\n         match compare n (head0 (double_size x)) with\n         | Gt =>\n             shiftl_aux (digits n) unsafe_shiftl\n               (double_size (double_size x)) n\n         | _ => unsafe_shiftl (double_size x) n\n         end\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 x)) with\n     | Gt =>\n         match compare n (head0 (double_size x)) with\n         | Gt =>\n             shiftl_aux (digits n) unsafe_shiftl\n               (double_size (double_size x)) n\n         | _ => unsafe_shiftl (double_size x) n\n         end\n     | _ => unsafe_shiftl x n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c6_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c7_goal : forall _ : Z.lt (to_Z (head0 x)) (to_Z n),\nLogic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c5_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c8_H : Logic.eq (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 x)),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c9_H : Z.lt (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c7_goal : forall _ : Z.lt (to_Z (head0 x)) (to_Z n),\nLogic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "c10_H : Z.lt (to_Z (head0 x)) (to_Z n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.le (to_Z n) (to_Z (head0 x))",
                    "c8_H : Logic.eq (to_Z n) (to_Z (head0 x))",
                    "c2_x : True",
                    "c2_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Logic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c12_goal : Z.le (to_Z n) (to_Z (head0 x))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le (to_Z n) (to_Z (head0 x))",
                    "c9_H : Z.lt (to_Z n) (to_Z (head0 x))",
                    "c2_x : True",
                    "c2_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) .",
                "tactic_args": [
                    "c10_goal : Logic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : Logic.eq\n  (to_Z\n     match compare n (head0 (double_size x)) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "_global_spec_compare : forall x y : t, Logic.eq (compare x y) (Z.compare (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 (double_size x))) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "case Z.compare_spec .",
                "tactic_sig_no_out_arg": "case Z.compare_spec .",
                "tactic_args": [
                    "c14_goal : Logic.eq\n  (to_Z\n     match Z.compare (to_Z n) (to_Z (head0 (double_size x))) with\n     | Gt =>\n         shiftl_aux (digits n) unsafe_shiftl\n           (double_size (double_size x)) n\n     | _ => unsafe_shiftl (double_size x) n\n     end) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 (double_size x))),\nLogic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "c16_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 (double_size x))),\nLogic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "c17_goal : forall _ : Z.lt (to_Z (head0 (double_size x))) (to_Z n),\nLogic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n)) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c15_goal : forall _ : Logic.eq (to_Z n) (to_Z (head0 (double_size x))),\nLogic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "c18_H1 : Logic.eq (to_Z n) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c16_goal : forall _ : Z.lt (to_Z n) (to_Z (head0 (double_size x))),\nLogic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "c19_H1 : Z.lt (to_Z n) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c17_goal : forall _ : Z.lt (to_Z (head0 (double_size x))) (to_Z n),\nLogic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n)) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n)) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "c20_H1 : Z.lt (to_Z (head0 (double_size x))) (to_Z n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : Logic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c21_goal : Z.le (to_Z n) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le (to_Z n) (to_Z (head0 (double_size x)))",
                    "c18_H1 : Logic.eq (to_Z n) (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c2_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq (to_Z (unsafe_shiftl (double_size x) n))\n  (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c22_goal : Z.le (to_Z n) (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.le (to_Z n) (to_Z (head0 (double_size x)))",
                    "c19_H1 : Z.lt (to_Z n) (to_Z (head0 (double_size x)))",
                    "c2_x : True",
                    "c2_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c20_goal : Logic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n)) (Z.mul (to_Z (double_size x)) (Z.pow 2 (to_Z n)))",
                    "_global_spec_double_size : forall x : t, Logic.eq (to_Z (double_size x)) (to_Z x)",
                    "_global_double_size : forall _ : t, t",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c23_goal : Logic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n))\n  (Z.mul (to_Z (double_size (double_size x))) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "apply _i with 1 % _i .",
                "tactic_sig_no_out_arg": "apply _i with 1 % _i .",
                "tactic_args": [
                    "c23_goal : Logic.eq\n  (to_Z\n     (shiftl_aux (digits n) unsafe_shiftl (double_size (double_size x))\n        n))\n  (Z.mul (to_Z (double_size (double_size x))) (Z.pow 2 (to_Z n)))",
                    "_global_spec_shiftl_aux : forall (p q : positive) (x n : t) (cont : forall (_ : t) (_ : t), t)\n         (_ : Z.le (Z.pow 2 (Zpos q)) (to_Z (head0 x)))\n         (_ : forall (x0 : t)\n                (_ : Z.le (Z.pow 2 (Z.add (Zpos p) (Zpos q)))\n                       (to_Z (head0 x0))),\n              Logic.eq (to_Z (cont x0 n))\n                (Z.mul (to_Z x0) (Z.pow 2 (to_Z n)))),\n       Logic.eq (to_Z (shiftl_aux p cont x n))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))",
                    "_global_positive : Set"
                ],
                "tactic_res": [
                    "c24_goal : Z.le (Z.pow 2 1) (to_Z (head0 (double_size (double_size x))))",
                    "c25_goal : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (digits n)) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ( _i _i ) ) .",
                "tactic_args": [
                    "c24_goal : Z.le (Z.pow 2 1) (to_Z (head0 (double_size (double_size x))))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "_global_spec_double_size_head0 : forall x : t,\n       Z.le (Z.mul 2 (to_Z (head0 x))) (to_Z (head0 (double_size x)))",
                    "_global_double_size : forall _ : t, t",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c26_goal : Z.le (Z.pow 2 1) (Z.mul 2 (to_Z (head0 (double_size x))))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 ^ 1 ) with ( 2 * 1 ) .",
                "tactic_sig_no_out_arg": "replace ( 2 ^ 1 ) with ( 2 * 1 ) .",
                "tactic_args": [
                    "c26_goal : Z.le (Z.pow 2 1) (Z.mul 2 (to_Z (head0 (double_size x))))"
                ],
                "tactic_res": [
                    "c27_goal : Z.le (Z.mul 2 1) (Z.mul 2 (to_Z (head0 (double_size x))))",
                    "c28_goal : Logic.eq (Z.mul 2 1) (Z.pow 2 1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : Z.le (Z.mul 2 1) (Z.mul 2 (to_Z (head0 (double_size x))))",
                    "_global_Z.mul_le_mono_nonneg_l : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul p n) (Z.mul p m)"
                ],
                "tactic_res": [
                    "c29_goal : Z.le 0 2",
                    "c30_goal : Z.le 1 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c29_goal : Z.le 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( spec_double_size_head0_pos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( spec_double_size_head0_pos _i ) .",
                "tactic_args": [
                    "c30_goal : Z.le 1 (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : Z.lt 0 (to_Z (head0 (double_size x))),\nZ.le 1 (to_Z (head0 (double_size x)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c31_goal : forall _ : Z.lt 0 (to_Z (head0 (double_size x))),\nZ.le 1 (to_Z (head0 (double_size x)))",
                    "c2_x : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : Logic.eq (Z.mul 2 1) (Z.pow 2 1)",
                    "_global_Z.pow_1_r : forall a : Z, Logic.eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c32_goal : Logic.eq (Z.mul 2 1) 2"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c32_goal : Logic.eq (Z.mul 2 1) 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x1 H2 .",
                "tactic_args": [
                    "c25_goal : forall (x : t)\n  (_ : Z.le (Z.pow 2 (Z.add (Zpos (digits n)) 1)) (to_Z (head0 x))),\nLogic.eq (to_Z (unsafe_shiftl x n)) (Z.mul (to_Z x) (Z.pow 2 (to_Z n)))"
                ],
                "tactic_res": [
                    "c33_goal : Logic.eq (to_Z (unsafe_shiftl x1 n))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z n)))",
                    "c33_x1 : True",
                    "c33_H2 : Z.le (Z.pow 2 (Z.add (Zpos (digits n)) 1)) (to_Z (head0 x1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c33_goal : Logic.eq (to_Z (unsafe_shiftl x1 n))\n  (Z.mul (to_Z x1) (Z.pow 2 (to_Z n)))",
                    "_global_spec_unsafe_shiftl : forall (x p : t) (_ : Z.le (to_Z p) (to_Z (head0 x))),\n       Logic.eq (to_Z (unsafe_shiftl x p))\n         (Z.mul (to_Z x) (Z.pow 2 (to_Z p)))"
                ],
                "tactic_res": [
                    "c34_goal : Z.le (to_Z n) (to_Z (head0 x1))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c34_goal : Z.le (to_Z n) (to_Z (head0 x1))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "c33_H2 : Z.le (Z.pow 2 (Z.add (Zpos (digits n)) 1)) (to_Z (head0 x1))"
                ],
                "tactic_res": [
                    "c35_goal : Z.le (to_Z n) (Z.pow 2 (Z.add (Zpos (digits n)) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 ^ _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 ^ _i ( _i _i ) ) .",
                "tactic_args": [
                    "c35_goal : Z.le (to_Z n) (Z.pow 2 (Z.add (Zpos (digits n)) 1))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p",
                    "_global_Zpos : forall _ : positive, Z",
                    "_global_digits : forall _ : t, positive",
                    "c2_n : True"
                ],
                "tactic_res": [
                    "c36_goal : Z.le (to_Z n) (Z.pow 2 (Zpos (digits n)))",
                    "c37_goal : Z.le (Z.pow 2 (Zpos (digits n))) (Z.pow 2 (Z.add (Zpos (digits n)) 1))"
                ]
            },
            {
                "tactic_sig": "case ( spec_digits _i ) .",
                "tactic_sig_no_out_arg": "case ( spec_digits _i ) .",
                "tactic_args": [
                    "c36_goal : Z.le (to_Z n) (Z.pow 2 (Zpos (digits n)))",
                    "c2_n : True"
                ],
                "tactic_res": [
                    "c38_goal : forall (_ : Z.le 0 (to_Z n))\n  (_ : Z.lt (to_Z n) (Z.pow 2 (Zpos (digits n)))),\nZ.le (to_Z n) (Z.pow 2 (Zpos (digits n)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c38_goal : forall (_ : Z.le 0 (to_Z n))\n  (_ : Z.lt (to_Z n) (Z.pow 2 (Zpos (digits n)))),\nZ.le (to_Z n) (Z.pow 2 (Zpos (digits n)))",
                    "c2_n : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : Z.le (Z.pow 2 (Zpos (digits n))) (Z.pow 2 (Z.add (Zpos (digits n)) 1))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c39_goal : Z.lt 0 2",
                    "c40_goal : Z.le (Zpos (digits n)) (Z.add (Zpos (digits n)) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c39_goal : Z.lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c40_goal : Z.le (Zpos (digits n)) (Z.add (Zpos (digits n)) 1)",
                    "c2_n : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_shiftl",
        "proof": [
            {
                "tactic_sig": "Lemma spec_shiftl : forall x p , [ shiftl x p ] = Z.shiftl [ x ] [ p ] .",
                "tactic_sig_no_out_arg": "Lemma spec_shiftl : forall x p , [ shiftl x p ] = Z.shiftl [ x ] [ p ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t,\nLogic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x p : t,\nLogic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))",
                    "c2_x : True",
                    "c2_p : True"
                ]
            },
            {
                "tactic_sig": "now rewrite spec_shiftl_pow2 , Z.shiftl_mul_pow2 by apply spec_pos .",
                "tactic_sig_no_out_arg": "now rewrite spec_shiftl_pow2 , Z.shiftl_mul_pow2 by apply spec_pos .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (shiftl x p)) (Z.shiftl (to_Z x) (to_Z p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_testbit",
        "proof": [
            {
                "tactic_sig": "Lemma spec_testbit : forall x p , testbit x p = Z.testbit [ x ] [ p ] .",
                "tactic_sig_no_out_arg": "Lemma spec_testbit : forall x p , testbit x p = Z.testbit [ x ] [ p ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x p : t, Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x p .",
                "tactic_args": [
                    "c1_goal : forall x p : t, Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))",
                    "c2_x : True",
                    "c2_p : True"
                ]
            },
            {
                "tactic_sig": "custom25 testbit spec_odd spec_shiftr Z.testbit_odd .",
                "tactic_sig_no_out_arg": "custom25 testbit spec_odd spec_shiftr Z.testbit_odd .",
                "tactic_args": [
                    "c2_goal : Logic.eq (testbit x p) (Z.testbit (to_Z x) (to_Z p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_div2",
        "proof": [
            {
                "tactic_sig": "Lemma spec_div2 : forall x , [ div2 x ] = Z.div2 [ x ] .",
                "tactic_sig_no_out_arg": "Lemma spec_div2 : forall x , [ div2 x ] = Z.div2 [ x ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall x : t, Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))",
                    "c2_x : True"
                ]
            },
            {
                "tactic_sig": "custom25 div2 spec_shiftr spec_1 Z.div2_spec .",
                "tactic_sig_no_out_arg": "custom25 div2 spec_shiftr spec_1 Z.div2_spec .",
                "tactic_args": [
                    "c2_goal : Logic.eq (to_Z (div2 x)) (Z.div2 (to_Z x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lor_fold",
        "proof": [
            {
                "tactic_sig": "Lemma lor_fold : lor = same_level lorn .",
                "tactic_sig_no_out_arg": "Lemma lor_fold : lor = same_level lorn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq lor\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq lor\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq lor\n  (let f0 :=\n     let op := W0.ops in\n     let lor := ZnZ.lor in fun x y : W0.t => reduce_0 (lor x y) in\n   let f1 :=\n     let op := w1_op in\n     let lor := ZnZ.lor in fun x y : w1 => reduce_1 (lor x y) in\n   let f2 :=\n     let op := w2_op in\n     let lor := ZnZ.lor in fun x y : w2 => reduce_2 (lor x y) in\n   let f3 :=\n     let op := w3_op in\n     let lor := ZnZ.lor in fun x y : w3 => reduce_3 (lor x y) in\n   let f4 :=\n     let op := w4_op in\n     let lor := ZnZ.lor in fun x y : w4 => reduce_4 (lor x y) in\n   let f5 :=\n     let op := w5_op in\n     let lor := ZnZ.lor in fun x y : w5 => reduce_5 (lor x y) in\n   let f6 :=\n     let op := w6_op in\n     let lor := ZnZ.lor in fun x y : w6 => reduce_6 (lor x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lor := ZnZ.lor in\n     fun x y : word w6 (S n) => reduce_n n (lor x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq lor\n  (let f0 :=\n     let op := W0.ops in\n     let lor := ZnZ.lor in fun x y : W0.t => reduce_0 (lor x y) in\n   let f1 :=\n     let op := w1_op in\n     let lor := ZnZ.lor in fun x y : w1 => reduce_1 (lor x y) in\n   let f2 :=\n     let op := w2_op in\n     let lor := ZnZ.lor in fun x y : w2 => reduce_2 (lor x y) in\n   let f3 :=\n     let op := w3_op in\n     let lor := ZnZ.lor in fun x y : w3 => reduce_3 (lor x y) in\n   let f4 :=\n     let op := w4_op in\n     let lor := ZnZ.lor in fun x y : w4 => reduce_4 (lor x y) in\n   let f5 :=\n     let op := w5_op in\n     let lor := ZnZ.lor in fun x y : w5 => reduce_5 (lor x y) in\n   let f6 :=\n     let op := w6_op in\n     let lor := ZnZ.lor in fun x y : w6 => reduce_6 (lor x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lor := ZnZ.lor in\n     fun x y : word w6 (S n) => reduce_n n (lor x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_lor",
        "proof": [
            {
                "tactic_sig": "Theorem spec_lor x y : [ lor x y ] = Z.lor [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_lor x y : [ lor x y ] = Z.lor [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z (lor x y)) (Z.lor (to_Z x) (to_Z y))",
                    "_global_lor_fold : Logic.eq lor\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y))\n        x y)) (Z.lor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y))\n        x y)) (Z.lor (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lor := ZnZ.lor in\n       fun x0 y0 : dom_t n => reduce n (lor x0 y0)) x y))\n  (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lor := ZnZ.lor in\n       fun x0 y0 : dom_t n => reduce n (lor x0 y0)) x y))\n  (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y)) x\n        y)) (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c4_n : nat",
                    "c4_x : dom_t n",
                    "c4_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lor := ZnZ.lor in fun x y : dom_t n => reduce n (lor x y)) x\n        y)) (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.lor x y)))\n  (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.lor x y)))\n  (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.lor x y)) (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.lor x y)) (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_lor : forall x y : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.lor x y)) (Z.lor (ZnZ.to_Z x) (ZnZ.to_Z y))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "land_fold",
        "proof": [
            {
                "tactic_sig": "Lemma land_fold : land = same_level landn .",
                "tactic_sig_no_out_arg": "Lemma land_fold : land = same_level landn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq land\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let land := ZnZ.land in fun x y : dom_t n => reduce n (land x y)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq land\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let land := ZnZ.land in fun x y : dom_t n => reduce n (land x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq land\n  (let f0 :=\n     let op := W0.ops in\n     let land := ZnZ.land in fun x y : W0.t => reduce_0 (land x y) in\n   let f1 :=\n     let op := w1_op in\n     let land := ZnZ.land in fun x y : w1 => reduce_1 (land x y) in\n   let f2 :=\n     let op := w2_op in\n     let land := ZnZ.land in fun x y : w2 => reduce_2 (land x y) in\n   let f3 :=\n     let op := w3_op in\n     let land := ZnZ.land in fun x y : w3 => reduce_3 (land x y) in\n   let f4 :=\n     let op := w4_op in\n     let land := ZnZ.land in fun x y : w4 => reduce_4 (land x y) in\n   let f5 :=\n     let op := w5_op in\n     let land := ZnZ.land in fun x y : w5 => reduce_5 (land x y) in\n   let f6 :=\n     let op := w6_op in\n     let land := ZnZ.land in fun x y : w6 => reduce_6 (land x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let land := ZnZ.land in\n     fun x y : word w6 (S n) => reduce_n n (land x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq land\n  (let f0 :=\n     let op := W0.ops in\n     let land := ZnZ.land in fun x y : W0.t => reduce_0 (land x y) in\n   let f1 :=\n     let op := w1_op in\n     let land := ZnZ.land in fun x y : w1 => reduce_1 (land x y) in\n   let f2 :=\n     let op := w2_op in\n     let land := ZnZ.land in fun x y : w2 => reduce_2 (land x y) in\n   let f3 :=\n     let op := w3_op in\n     let land := ZnZ.land in fun x y : w3 => reduce_3 (land x y) in\n   let f4 :=\n     let op := w4_op in\n     let land := ZnZ.land in fun x y : w4 => reduce_4 (land x y) in\n   let f5 :=\n     let op := w5_op in\n     let land := ZnZ.land in fun x y : w5 => reduce_5 (land x y) in\n   let f6 :=\n     let op := w6_op in\n     let land := ZnZ.land in fun x y : w6 => reduce_6 (land x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let land := ZnZ.land in\n     fun x y : word w6 (S n) => reduce_n n (land x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_land",
        "proof": [
            {
                "tactic_sig": "Theorem spec_land x y : [ land x y ] = Z.land [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_land x y : [ land x y ] = Z.land [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z (land x y)) (Z.land (to_Z x) (to_Z y))",
                    "_global_land_fold : Logic.eq land\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let land := ZnZ.land in fun x y : dom_t n => reduce n (land x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let land := ZnZ.land in\n         fun x y : dom_t n => reduce n (land x y)) x y))\n  (Z.land (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let land := ZnZ.land in\n         fun x y : dom_t n => reduce n (land x y)) x y))\n  (Z.land (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let land := ZnZ.land in\n       fun x0 y0 : dom_t n => reduce n (land x0 y0)) x y))\n  (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let land := ZnZ.land in\n       fun x0 y0 : dom_t n => reduce n (land x0 y0)) x y))\n  (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let land := ZnZ.land in fun x y : dom_t n => reduce n (land x y))\n        x y)) (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c4_n : nat",
                    "c4_x : dom_t n",
                    "c4_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let land := ZnZ.land in fun x y : dom_t n => reduce n (land x y))\n        x y)) (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.land x y)))\n  (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.land x y)))\n  (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.land x y)) (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.land x y)) (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_land : forall x y : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.land x y)) (Z.land (ZnZ.to_Z x) (ZnZ.to_Z y))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lxor_fold",
        "proof": [
            {
                "tactic_sig": "Lemma lxor_fold : lxor = same_level lxorn .",
                "tactic_sig_no_out_arg": "Lemma lxor_fold : lxor = same_level lxorn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq lxor\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lxor := ZnZ.lxor in fun x y : dom_t n => reduce n (lxor x y)))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq lxor\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lxor := ZnZ.lxor in fun x y : dom_t n => reduce n (lxor x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq lxor\n  (let f0 :=\n     let op := W0.ops in\n     let lxor := ZnZ.lxor in fun x y : W0.t => reduce_0 (lxor x y) in\n   let f1 :=\n     let op := w1_op in\n     let lxor := ZnZ.lxor in fun x y : w1 => reduce_1 (lxor x y) in\n   let f2 :=\n     let op := w2_op in\n     let lxor := ZnZ.lxor in fun x y : w2 => reduce_2 (lxor x y) in\n   let f3 :=\n     let op := w3_op in\n     let lxor := ZnZ.lxor in fun x y : w3 => reduce_3 (lxor x y) in\n   let f4 :=\n     let op := w4_op in\n     let lxor := ZnZ.lxor in fun x y : w4 => reduce_4 (lxor x y) in\n   let f5 :=\n     let op := w5_op in\n     let lxor := ZnZ.lxor in fun x y : w5 => reduce_5 (lxor x y) in\n   let f6 :=\n     let op := w6_op in\n     let lxor := ZnZ.lxor in fun x y : w6 => reduce_6 (lxor x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lxor := ZnZ.lxor in\n     fun x y : word w6 (S n) => reduce_n n (lxor x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq lxor\n  (let f0 :=\n     let op := W0.ops in\n     let lxor := ZnZ.lxor in fun x y : W0.t => reduce_0 (lxor x y) in\n   let f1 :=\n     let op := w1_op in\n     let lxor := ZnZ.lxor in fun x y : w1 => reduce_1 (lxor x y) in\n   let f2 :=\n     let op := w2_op in\n     let lxor := ZnZ.lxor in fun x y : w2 => reduce_2 (lxor x y) in\n   let f3 :=\n     let op := w3_op in\n     let lxor := ZnZ.lxor in fun x y : w3 => reduce_3 (lxor x y) in\n   let f4 :=\n     let op := w4_op in\n     let lxor := ZnZ.lxor in fun x y : w4 => reduce_4 (lxor x y) in\n   let f5 :=\n     let op := w5_op in\n     let lxor := ZnZ.lxor in fun x y : w5 => reduce_5 (lxor x y) in\n   let f6 :=\n     let op := w6_op in\n     let lxor := ZnZ.lxor in fun x y : w6 => reduce_6 (lxor x y) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lxor := ZnZ.lxor in\n     fun x y : word w6 (S n) => reduce_n n (lxor x y) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_lxor",
        "proof": [
            {
                "tactic_sig": "Theorem spec_lxor x y : [ lxor x y ] = Z.lxor [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_lxor x y : [ lxor x y ] = Z.lxor [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z (lxor x y)) (Z.lxor (to_Z x) (to_Z y))",
                    "_global_lxor_fold : Logic.eq lxor\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let lxor := ZnZ.lxor in fun x y : dom_t n => reduce n (lxor x y)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lxor := ZnZ.lxor in\n         fun x y : dom_t n => reduce n (lxor x y)) x y))\n  (Z.lxor (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lxor := ZnZ.lxor in\n         fun x y : dom_t n => reduce n (lxor x y)) x y))\n  (Z.lxor (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       fun x0 y0 : dom_t n => reduce n (lxor x0 y0)) x y))\n  (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       fun x0 y0 : dom_t n => reduce n (lxor x0 y0)) x y))\n  (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in fun x y : dom_t n => reduce n (lxor x y))\n        x y)) (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c4_n : nat",
                    "c4_x : dom_t n",
                    "c4_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in fun x y : dom_t n => reduce n (lxor x y))\n        x y)) (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.lxor x y)))\n  (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.lxor x y)))\n  (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.lxor x y)) (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.lxor x y)) (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_lxor : forall x y : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.lxor x y)) (Z.lxor (ZnZ.to_Z x) (ZnZ.to_Z y))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ldiff_fold",
        "proof": [
            {
                "tactic_sig": "Lemma ldiff_fold : ldiff = same_level ldiffn .",
                "tactic_sig_no_out_arg": "Lemma ldiff_fold : ldiff = same_level ldiffn .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq ldiff\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lxor := ZnZ.lxor in\n      let land := ZnZ.land in\n      let m1 := ZnZ.minus_one in\n      fun x y : dom_t n => reduce n (land x (lxor y m1))))"
                ]
            },
            {
                "tactic_sig": "red_t .",
                "tactic_sig_no_out_arg": "red_t .",
                "tactic_args": [
                    "c1_goal : Logic.eq ldiff\n  (same_level\n     (fun n : nat =>\n      let op := dom_op n in\n      let lxor := ZnZ.lxor in\n      let land := ZnZ.land in\n      let m1 := ZnZ.minus_one in\n      fun x y : dom_t n => reduce n (land x (lxor y m1))))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq ldiff\n  (let f0 :=\n     let op := W0.ops in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : W0.t => reduce_0 (land x (lxor y m1)) in\n   let f1 :=\n     let op := w1_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w1 => reduce_1 (land x (lxor y m1)) in\n   let f2 :=\n     let op := w2_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w2 => reduce_2 (land x (lxor y m1)) in\n   let f3 :=\n     let op := w3_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w3 => reduce_3 (land x (lxor y m1)) in\n   let f4 :=\n     let op := w4_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w4 => reduce_4 (land x (lxor y m1)) in\n   let f5 :=\n     let op := w5_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w5 => reduce_5 (land x (lxor y m1)) in\n   let f6 :=\n     let op := w6_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w6 => reduce_6 (land x (lxor y m1)) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : word w6 (S n) => reduce_n n (land x (lxor y m1)) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : Logic.eq ldiff\n  (let f0 :=\n     let op := W0.ops in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : W0.t => reduce_0 (land x (lxor y m1)) in\n   let f1 :=\n     let op := w1_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w1 => reduce_1 (land x (lxor y m1)) in\n   let f2 :=\n     let op := w2_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w2 => reduce_2 (land x (lxor y m1)) in\n   let f3 :=\n     let op := w3_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w3 => reduce_3 (land x (lxor y m1)) in\n   let f4 :=\n     let op := w4_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w4 => reduce_4 (land x (lxor y m1)) in\n   let f5 :=\n     let op := w5_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w5 => reduce_5 (land x (lxor y m1)) in\n   let f6 :=\n     let op := w6_op in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : w6 => reduce_6 (land x (lxor y m1)) in\n   let fn :=\n     fun n : nat =>\n     let op := make_op n in\n     let lxor := ZnZ.lxor in\n     let land := ZnZ.land in\n     let m1 := ZnZ.minus_one in\n     fun x y : word w6 (S n) => reduce_n n (land x (lxor y m1)) in\n   fun x y : t' =>\n   match x with\n   | N0 wx =>\n       match y with\n       | N0 wy => f0 wx wy\n       | N1 wy => f1 (WW zero0 wx) wy\n       | N2 wy => f2 (WW W0 (WW zero0 wx)) wy\n       | N3 wy => f3 (WW W0 (WW W0 (WW zero0 wx))) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx))))) wy\n       | N6 wy =>\n           f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wx)))))))\n             wy\n       end\n   | N1 wx =>\n       match y with\n       | N0 wy => f1 wx (WW zero0 wy)\n       | N1 wy => f1 wx wy\n       | N2 wy => f2 (WW W0 wx) wy\n       | N3 wy => f3 (WW W0 (WW W0 wx)) wy\n       | N4 wy => f4 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       | Nn m wy =>\n           fn m\n             (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wx))))))\n             wy\n       end\n   | N2 wx =>\n       match y with\n       | N0 wy => f2 wx (WW W0 (WW zero0 wy))\n       | N1 wy => f2 wx (WW W0 wy)\n       | N2 wy => f2 wx wy\n       | N3 wy => f3 (WW W0 wx) wy\n       | N4 wy => f4 (WW W0 (WW W0 wx)) wy\n       | N5 wy => f5 (WW W0 (WW W0 (WW W0 wx))) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 (WW W0 wx)))) wy\n       | Nn m wy =>\n           fn m (extend_size m (WW W0 (WW W0 (WW W0 (WW W0 wx))))) wy\n       end\n   | N3 wx =>\n       match y with\n       | N0 wy => f3 wx (WW W0 (WW W0 (WW zero0 wy)))\n       | N1 wy => f3 wx (WW W0 (WW W0 wy))\n       | N2 wy => f3 wx (WW W0 wy)\n       | N3 wy => f3 wx wy\n       | N4 wy => f4 (WW W0 wx) wy\n       | N5 wy => f5 (WW W0 (WW W0 wx)) wy\n       | N6 wy => f6 (WW W0 (WW W0 (WW W0 wx))) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 (WW W0 wx)))) wy\n       end\n   | N4 wx =>\n       match y with\n       | N0 wy => f4 wx (WW W0 (WW W0 (WW W0 (WW zero0 wy))))\n       | N1 wy => f4 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N2 wy => f4 wx (WW W0 (WW W0 wy))\n       | N3 wy => f4 wx (WW W0 wy)\n       | N4 wy => f4 wx wy\n       | N5 wy => f5 (WW W0 wx) wy\n       | N6 wy => f6 (WW W0 (WW W0 wx)) wy\n       | Nn m wy => fn m (extend_size m (WW W0 (WW W0 wx))) wy\n       end\n   | N5 wx =>\n       match y with\n       | N0 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))\n       | N1 wy => f5 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N2 wy => f5 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N3 wy => f5 wx (WW W0 (WW W0 wy))\n       | N4 wy => f5 wx (WW W0 wy)\n       | N5 wy => f5 wx wy\n       | N6 wy => f6 (WW W0 wx) wy\n       | Nn m wy => fn m (extend_size m (WW W0 wx)) wy\n       end\n   | N6 wx =>\n       match y with\n       | N0 wy =>\n           f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy))))))\n       | N1 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N2 wy => f6 wx (WW W0 (WW W0 (WW W0 (WW W0 wy))))\n       | N3 wy => f6 wx (WW W0 (WW W0 (WW W0 wy)))\n       | N4 wy => f6 wx (WW W0 (WW W0 wy))\n       | N5 wy => f6 wx (WW W0 wy)\n       | N6 wy => f6 wx wy\n       | Nn m wy => fn m (extend_size m wx) wy\n       end\n   | Nn n wx =>\n       match y with\n       | N0 wy =>\n           fn n wx\n             (extend_size n\n                (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 (WW zero0 wy)))))))\n       | N1 wy =>\n           fn n wx\n             (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 (WW W0 wy))))))\n       | N2 wy =>\n           fn n wx (extend_size n (WW W0 (WW W0 (WW W0 (WW W0 wy)))))\n       | N3 wy => fn n wx (extend_size n (WW W0 (WW W0 (WW W0 wy))))\n       | N4 wy => fn n wx (extend_size n (WW W0 (WW W0 wy)))\n       | N5 wy => fn n wx (extend_size n (WW W0 wy))\n       | N6 wy => fn n wx (extend_size n wy)\n       | Nn m wy =>\n           let mn := Nat.max n m in\n           let d := diff n m in\n           fn mn (castm (diff_r n m) (extend_tr wx (snd d)))\n             (castm (diff_l n m) (extend_tr wy (fst d)))\n       end\n   end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ldiff_alt",
        "proof": [
            {
                "tactic_sig": "Lemma ldiff_alt x y p : 0 <= x < 2 ^ p -> 0 <= y < 2 ^ p -> Z.ldiff x y = Z.land x ( Z.lxor y ( 2 ^ p - 1 ) ) .",
                "tactic_sig_no_out_arg": "Lemma ldiff_alt x y p : 0 <= x < 2 ^ p -> 0 <= y < 2 ^ p -> Z.ldiff x y = Z.land x ( Z.lxor y ( 2 ^ p - 1 ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : and (Z.le 0 x) (Z.lt x (Z.pow 2 p)))\n  (_ : and (Z.le 0 y) (Z.lt y (Z.pow 2 p))),\nLogic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 p) 1)))",
                    "c1_p : Z",
                    "c1_y : Z",
                    "c1_x : Z"
                ]
            },
            {
                "tactic_sig": "intros ( _o , _o ) ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros ( Hx , Hx' ) ( Hy , Hy' ) .",
                "tactic_args": [
                    "c1_goal : forall (_ : and (Z.le 0 x) (Z.lt x (Z.pow 2 p)))\n  (_ : and (Z.le 0 y) (Z.lt y (Z.pow 2 p))),\nLogic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 p) 1)))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 p) 1)))",
                    "c2_Hx : Z.le 0 x",
                    "c2_Hx' : Z.lt x (Z.pow 2 p)",
                    "c2_Hy : Z.le 0 y",
                    "c2_Hy' : Z.lt y (Z.pow 2 p)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ |p|p ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ |p|p ] .",
                "tactic_args": [
                    "c2_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 p) 1)))",
                    "c1_p : Z",
                    "c2_Hy' : Z.lt y (Z.pow 2 p)",
                    "c2_Hy : Z.le 0 y",
                    "c2_Hx' : Z.lt x (Z.pow 2 p)",
                    "c2_Hx : Z.le 0 x",
                    "c1_x : Z",
                    "c1_y : Z"
                ],
                "tactic_res": [
                    "c3_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 0) 1)))",
                    "c3_Hy' : Z.lt y (Z.pow 2 0)",
                    "c3_Hx' : Z.lt x (Z.pow 2 0)",
                    "c4_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.pow 2 (Zpos p)) 1)))",
                    "c4_Hy' : Z.lt y (Z.pow 2 (Zpos p))",
                    "c4_Hx' : Z.lt x (Z.pow 2 (Zpos p))",
                    "c4_p : positive",
                    "c5_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.pow 2 (Zneg p)) 1)))",
                    "c5_Hy' : Z.lt y (Z.pow 2 (Zneg p))",
                    "c5_Hx' : Z.lt x (Z.pow 2 (Zneg p))",
                    "c5_p : positive"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c3_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 0) 1)))"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y 0))",
                    "c6_Hy' : Z.lt y 1",
                    "c6_Hx' : Z.lt x 1"
                ]
            },
            {
                "tactic_sig": "replace _i with 0 .",
                "tactic_sig_no_out_arg": "replace _i with 0 .",
                "tactic_args": [
                    "c6_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y 0))",
                    "c1_x : Z"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq (Z.ldiff 0 y) (Z.land 0 (Z.lxor y 0))",
                    "c8_goal : Logic.eq 0 x"
                ]
            },
            {
                "tactic_sig": "replace _i with 0 .",
                "tactic_sig_no_out_arg": "replace _i with 0 .",
                "tactic_args": [
                    "c7_goal : Logic.eq (Z.ldiff 0 y) (Z.land 0 (Z.lxor y 0))",
                    "c1_y : Z"
                ],
                "tactic_res": [
                    "c9_goal : Logic.eq (Z.ldiff 0 0) (Z.land 0 (Z.lxor 0 0))",
                    "c10_goal : Logic.eq 0 y"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Logic.eq (Z.ldiff 0 0) (Z.land 0 (Z.lxor 0 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Logic.eq 0 y",
                    "c6_Hy' : Z.lt y 1",
                    "c2_Hy : Z.le 0 y",
                    "c1_y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace _i with 0 .",
                "tactic_sig_no_out_arg": "replace _i with 0 .",
                "tactic_args": [
                    "c8_goal : Logic.eq 0 x",
                    "c1_y : Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.eq 0 x",
                    "c12_goal : Logic.eq 0 y"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Logic.eq 0 x",
                    "c6_Hx' : Z.lt x 1",
                    "c2_Hx : Z.le 0 x",
                    "c1_x : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Logic.eq 0 y",
                    "c6_Hy' : Z.lt y 1",
                    "c2_Hy : Z.le 0 y",
                    "c1_y : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.pow 2 (Zpos p)) 1)))",
                    "_global_Z.shiftl_1_l : forall n : Z, Logic.eq (Z.shiftl 1 n) (Z.pow 2 n)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.shiftl 1 (Zpos p)) 1)))"
                ]
            },
            {
                "tactic_sig": "change ( _ - 1 ) with ( Z.ones ( Z.pos _i ) ) .",
                "tactic_sig_no_out_arg": "change ( _ - 1 ) with ( Z.ones ( Z.pos _i ) ) .",
                "tactic_args": [
                    "c13_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.shiftl 1 (Zpos p)) 1)))",
                    "c4_p : positive"
                ],
                "tactic_res": [
                    "c14_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.ones (Zpos p))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c14_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.ones (Zpos p))))",
                    "_global_Z.ldiff_ones_l_low : forall (a n : Z) (_ : Z.le 0 a) (_ : Z.lt (Z.log2 a) n),\n       Logic.eq (Z.ldiff (Z.ones n) a) (Z.lxor a (Z.ones n))"
                ],
                "tactic_res": [
                    "c15_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.ldiff (Z.ones (Zpos p)) y))",
                    "c16_goal : Z.le 0 y",
                    "c17_goal : Z.lt (Z.log2 y) (Zpos p)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c16_goal : Z.le 0 y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite !Z.ldiff_land , _i .",
                "tactic_sig_no_out_arg": "rewrite !Z.ldiff_land , _i .",
                "tactic_args": [
                    "c15_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.ldiff (Z.ones (Zpos p)) y))",
                    "_global_Z.land_assoc : forall a b c : Z,\n       Logic.eq (Z.land a (Z.land b c)) (Z.land (Z.land a b) c)"
                ],
                "tactic_res": [
                    "c18_goal : Logic.eq (Z.land x (Z.lnot y))\n  (Z.land (Z.land x (Z.ones (Zpos p))) (Z.lnot y))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c18_goal : Logic.eq (Z.land x (Z.lnot y))\n  (Z.land (Z.land x (Z.ones (Zpos p))) (Z.lnot y))"
                ],
                "tactic_res": [
                    "c19_goal : Logic.eq x (Z.land x (Z.ones (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : Logic.eq x (Z.land x (Z.ones (Zpos p)))",
                    "_global_Z.land_ones : forall (a n : Z) (_ : Z.le 0 n),\n       Logic.eq (Z.land a (Z.ones n)) (Z.modulo a (Z.pow 2 n))"
                ],
                "tactic_res": [
                    "c20_goal : Logic.eq x (Z.modulo x (Z.pow 2 (Zpos p)))",
                    "c21_goal : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "try easy .",
                "tactic_sig_no_out_arg": "try easy .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c20_goal : Logic.eq x (Z.modulo x (Z.pow 2 (Zpos p)))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.eq (Z.modulo x (Z.pow 2 (Zpos p))) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Logic.eq (Z.modulo x (Z.pow 2 (Zpos p))) x",
                    "_global_Z.mod_small : forall (a b : Z) (_ : and (Z.le 0 a) (Z.lt a b)),\n       Logic.eq (Z.modulo a b) a"
                ],
                "tactic_res": [
                    "c23_goal : and (Z.le 0 x) (Z.lt x (Z.pow 2 (Zpos p)))"
                ]
            },
            {
                "tactic_sig": "now split .",
                "tactic_sig_no_out_arg": "now split .",
                "tactic_args": [
                    "c23_goal : and (Z.le 0 x) (Z.lt x (Z.pow 2 (Zpos p)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c17_goal : Z.lt (Z.log2 y) (Zpos p)",
                    "c2_Hy : Z.le 0 y"
                ],
                "tactic_res": [
                    "c24_goal : Z.lt (Z.log2 y) (Zpos p)",
                    "c24_Hy : Z.lt 0 y",
                    "c25_goal : Z.lt (Z.log2 y) (Zpos p)",
                    "c25_Hy : Logic.eq 0 y"
                ]
            },
            {
                "tactic_sig": "now apply Z.log2_lt_pow2 .",
                "tactic_sig_no_out_arg": "now apply Z.log2_lt_pow2 .",
                "tactic_args": [
                    "c24_goal : Z.lt (Z.log2 y) (Zpos p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : Logic.eq (Z.ldiff x y)\n  (Z.land x (Z.lxor y (Z.sub (Z.pow 2 (Zneg p)) 1)))"
                ],
                "tactic_res": [
                    "c26_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (-1)))",
                    "c26_Hy' : Z.lt y 0",
                    "c26_Hx' : Z.lt x 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (-1)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ldiff",
        "proof": [
            {
                "tactic_sig": "Theorem spec_ldiff x y : [ ldiff x y ] = Z.ldiff [ x ] [ y ] .",
                "tactic_sig_no_out_arg": "Theorem spec_ldiff x y : [ ldiff x y ] = Z.ldiff [ x ] [ y ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Logic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))",
                    "c1_y : True",
                    "c1_x : True"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Logic.eq (to_Z (ldiff x y)) (Z.ldiff (to_Z x) (to_Z y))",
                    "_global_ldiff_fold : Logic.eq ldiff\n         (same_level\n            (fun n : nat =>\n             let op := dom_op n in\n             let lxor := ZnZ.lxor in\n             let land := ZnZ.land in\n             let m1 := ZnZ.minus_one in\n             fun x y : dom_t n => reduce n (land x (lxor y m1))))"
                ],
                "tactic_res": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lxor := ZnZ.lxor in\n         let land := ZnZ.land in\n         let m1 := ZnZ.minus_one in\n         fun x y : dom_t n => reduce n (land x (lxor y m1))) x y))\n  (Z.ldiff (to_Z x) (to_Z y))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Logic.eq\n  (to_Z\n     (same_level\n        (fun n : nat =>\n         let op := dom_op n in\n         let lxor := ZnZ.lxor in\n         let land := ZnZ.land in\n         let m1 := ZnZ.minus_one in\n         fun x y : dom_t n => reduce n (land x (lxor y m1))) x y))\n  (Z.ldiff (to_Z x) (to_Z y))",
                    "_global_spec_same_level : forall (A : Type) (P : forall (_ : Z) (_ : Z) (_ : A), Prop)\n         (f : forall (n : nat) (_ : dom_t n) (_ : dom_t n), A)\n         (_ : forall (n : nat) (x y : dom_t n),\n              P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) \n         (x y : t), P (to_Z x) (to_Z y) (same_level f x y)"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       let land := ZnZ.land in\n       let m1 := ZnZ.minus_one in\n       fun x0 y0 : dom_t n => reduce n (land x0 (lxor y0 m1))) x y))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c1_x : True",
                    "c1_y : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n x y .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (x y : dom_t n),\nLogic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       let land := ZnZ.land in\n       let m1 := ZnZ.minus_one in\n       fun x0 y0 : dom_t n => reduce n (land x0 (lxor y0 m1))) x y))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       let land := ZnZ.land in\n       let m1 := ZnZ.minus_one in\n       fun x y : dom_t n => reduce n (land x (lxor y m1))) x y))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "c4_n : nat",
                    "c4_x : dom_t n",
                    "c4_y : dom_t n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Logic.eq\n  (to_Z\n     ((let op := dom_op n in\n       let lxor := ZnZ.lxor in\n       let land := ZnZ.land in\n       let m1 := ZnZ.minus_one in\n       fun x y : dom_t n => reduce n (land x (lxor y m1))) x y))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.land x (ZnZ.lxor y ZnZ.minus_one))))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : Logic.eq (to_Z (reduce n (ZnZ.land x (ZnZ.lxor y ZnZ.minus_one))))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_spec_reduce : forall (n : nat) (x : dom_t n),\n       Logic.eq (to_Z (reduce n x)) (ZnZ.to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.land x (ZnZ.lxor y ZnZ.minus_one)))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c6_goal : Logic.eq (ZnZ.to_Z (ZnZ.land x (ZnZ.lxor y ZnZ.minus_one)))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))",
                    "_global_ZnZ.spec_land : forall x0 y0 : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.land x0 y0))\n         (Z.land (ZnZ.to_Z x0) (ZnZ.to_Z y0))\nwhere\n?n : [n : nat  x : dom_t n  y : dom_t n |- nat]",
                    "_global_ZnZ.spec_lxor : forall x0 y0 : word w6 (S ?n),\n       Logic.eq (ZnZ.to_Z (ZnZ.lxor x0 y0))\n         (Z.lxor (ZnZ.to_Z x0) (ZnZ.to_Z y0))\nwhere\n?n : [n : nat  x : dom_t n  y : dom_t n |- nat]",
                    "_global_ZnZ.spec_m1 : Logic.eq (ZnZ.to_Z ZnZ.minus_one)\n         (Z.sub (base (ZnZ.digits (make_op ?n))) 1)\nwhere\n?n : [n : nat  x : dom_t n  y : dom_t n |- nat]"
                ],
                "tactic_res": [
                    "c7_goal : Logic.eq\n  (Z.land (ZnZ.to_Z x)\n     (Z.lxor (ZnZ.to_Z y) (Z.sub (base (ZnZ.digits (dom_op n))) 1)))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c7_goal : Logic.eq\n  (Z.land (ZnZ.to_Z x)\n     (Z.lxor (ZnZ.to_Z y) (Z.sub (base (ZnZ.digits (dom_op n))) 1)))\n  (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (Z.land (ZnZ.to_Z x)\n     (Z.lxor (ZnZ.to_Z y) (Z.sub (base (ZnZ.digits (dom_op n))) 1)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Logic.eq (Z.ldiff (ZnZ.to_Z x) (ZnZ.to_Z y))\n  (Z.land (ZnZ.to_Z x)\n     (Z.lxor (ZnZ.to_Z y) (Z.sub (base (ZnZ.digits (dom_op n))) 1)))",
                    "_global_ldiff_alt : forall (x y p : Z) (_ : and (Z.le 0 x) (Z.lt x (Z.pow 2 p)))\n         (_ : and (Z.le 0 y) (Z.lt y (Z.pow 2 p))),\n       Logic.eq (Z.ldiff x y) (Z.land x (Z.lxor y (Z.sub (Z.pow 2 p) 1)))"
                ],
                "tactic_res": [
                    "c9_goal : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "c10_goal : and (Z.le 0 (ZnZ.to_Z y))\n  (Z.lt (ZnZ.to_Z y) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 (ZnZ.to_Z x))\n  (Z.lt (ZnZ.to_Z x) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "_global_ZnZ.spec_to_Z : forall x0 : word w6 (S ?n),\n       and (Z.le 0 (ZnZ.to_Z x0))\n         (Z.lt (ZnZ.to_Z x0) (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [n : nat  x : dom_t n  y : dom_t n |- nat]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : and (Z.le 0 (ZnZ.to_Z y))\n  (Z.lt (ZnZ.to_Z y) (Z.pow 2 (Zpos (ZnZ.digits (dom_op n)))))",
                    "_global_ZnZ.spec_to_Z : forall x : word w6 (S ?n),\n       and (Z.le 0 (ZnZ.to_Z x))\n         (Z.lt (ZnZ.to_Z x) (base (ZnZ.digits (make_op ?n))))\nwhere\n?n : [ |- nat]"
                ],
                "tactic_res": []
            }
        ]
    }
]