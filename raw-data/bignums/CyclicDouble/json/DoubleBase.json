[
    {
        "lemma_name": "wwB_wBwB",
        "proof": [
            {
                "tactic_sig": "Lemma wwB_wBwB : wwB = wB ^ 2 .",
                "tactic_sig_no_out_arg": "Lemma wwB_wBwB : wwB = wB ^ 2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (base ww_digits) (Z.pow (base w_digits) 2)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : eq (base ww_digits) (Z.pow (base w_digits) 2)",
                    "_global_base : forall _ : positive, Z",
                    "_global_ww_digits : positive"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.pow 2 (Zpos (xO w_digits))) (Z.pow (Z.pow 2 (Zpos w_digits)) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.pow 2 (Zpos (xO w_digits))) (Z.pow (Z.pow 2 (Zpos w_digits)) 2)",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.pow 2 (Zpos (xO w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (Z.pow 2 (Zpos (xO w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))",
                    "_global_Pos2Z.inj_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c4_goal : eq (Z.pow 2 (Z.mul 2 (Zpos w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * Zpos _i ) with ( Zpos _i + Zpos _i ) .",
                "tactic_sig_no_out_arg": "replace ( 2 * Zpos _i ) with ( Zpos _i + Zpos _i ) .",
                "tactic_args": [
                    "c4_goal : eq (Z.pow 2 (Z.mul 2 (Zpos w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))",
                    "c1_w_digits : positive",
                    "c1_w_digits : positive",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c5_goal : eq (Z.pow 2 (Z.add (Zpos w_digits) (Zpos w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))",
                    "c6_goal : eq (Z.add (Zpos w_digits) (Zpos w_digits)) (Z.mul 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (Z.pow 2 (Z.add (Zpos w_digits) (Zpos w_digits)))\n  (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos w_digits)))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c7_goal : Z.ge (Zpos w_digits) 0",
                    "c8_goal : Z.ge (Zpos w_digits) 0"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : Z.ge (Zpos w_digits) 0",
                    "_global_Z.ge : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (Z.compare (Zpos w_digits) 0) Lt)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : not (eq (Z.compare (Zpos w_digits) 0) Lt)"
                ],
                "tactic_res": [
                    "c10_goal : not (eq Gt Lt)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c10_goal : not (eq Gt Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : Z.ge (Zpos w_digits) 0",
                    "_global_Z.ge : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c11_goal : not (eq (Z.compare (Zpos w_digits) 0) Lt)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : not (eq (Z.compare (Zpos w_digits) 0) Lt)"
                ],
                "tactic_res": [
                    "c12_goal : not (eq Gt Lt)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c12_goal : not (eq Gt Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c6_goal : eq (Z.add (Zpos w_digits) (Zpos w_digits)) (Z.mul 2 (Zpos w_digits))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ww_1",
        "proof": [
            {
                "tactic_sig": "Lemma spec_ww_1 : [ [ ww_1 ] ] = 1 .",
                "tactic_sig_no_out_arg": "Lemma spec_ww_1 : [ [ ww_1 ] ] = 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (ww_to_Z ww_1) 1",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : eq (ww_to_Z ww_1) 1"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.add (Z.mul (w_to_Z w_0) (base w_digits)) (w_to_Z w_1)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.add (Z.mul (w_to_Z w_0) (base w_digits)) (w_to_Z w_1)) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_1)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_1)) 1",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1"
                ],
                "tactic_res": [
                    "c4_goal : eq (Z.add (Z.mul 0 (base w_digits)) 1) 1"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c4_goal : eq (Z.add (Z.mul 0 (base w_digits)) 1) 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ww_Bm1",
        "proof": [
            {
                "tactic_sig": "Lemma spec_ww_Bm1 : [ [ ww_Bm1 ] ] = wwB - 1 .",
                "tactic_sig_no_out_arg": "Lemma spec_ww_Bm1 : [ [ ww_Bm1 ] ] = wwB - 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (ww_to_Z ww_Bm1) (Z.sub (base ww_digits) 1)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c1_goal : eq (ww_to_Z ww_Bm1) (Z.sub (base ww_digits) 1)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.add (Z.mul (w_to_Z w_Bm1) (base w_digits)) (w_to_Z w_Bm1))\n  (Z.sub (base ww_digits) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.add (Z.mul (w_to_Z w_Bm1) (base w_digits)) (w_to_Z w_Bm1))\n  (Z.sub (base ww_digits) 1)",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Z.add (Z.mul (Z.sub (base w_digits) 1) (base w_digits))\n     (Z.sub (base w_digits) 1)) (Z.sub (base ww_digits) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (Z.add (Z.mul (Z.sub (base w_digits) 1) (base w_digits))\n     (Z.sub (base w_digits) 1)) (Z.sub (base ww_digits) 1)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Z.add (Z.mul (Z.sub (base w_digits) 1) (base w_digits))\n     (Z.sub (base w_digits) 1)) (Z.sub (Z.pow (base w_digits) 2) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c4_goal : eq\n  (Z.add (Z.mul (Z.sub (base w_digits) 1) (base w_digits))\n     (Z.sub (base w_digits) 1)) (Z.sub (Z.pow (base w_digits) 2) 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lt_0_wB",
        "proof": [
            {
                "tactic_sig": "Lemma lt_0_wB : 0 < wB .",
                "tactic_sig_no_out_arg": "Lemma lt_0_wB : 0 < wB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Z.lt 0 (base w_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Z.lt 0 (base w_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 0 (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Z.lt 0 (Z.pow 2 (Zpos w_digits))",
                    "_global_Z.pow_pos_nonneg : forall (a b : Z) (_ : Z.lt 0 a) (_ : Z.le 0 b), Z.lt 0 (Z.pow a b)"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 0 2",
                    "c4_goal : Z.le 0 (Zpos w_digits)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Z.lt 0 2",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c5_goal : eq (Z.compare 0 2) Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : eq (Z.compare 0 2) Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : Z.le 0 (Zpos w_digits)",
                    "_global_Z.le : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c6_goal : not (eq (Z.compare 0 (Zpos w_digits)) Gt)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c6_goal : not (eq (Z.compare 0 (Zpos w_digits)) Gt)"
                ],
                "tactic_res": [
                    "c7_goal : False",
                    "c7_H : eq (Z.compare 0 (Zpos w_digits)) Gt"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c7_goal : False",
                    "c7_H : eq (Z.compare 0 (Zpos w_digits)) Gt"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lt_0_wwB",
        "proof": [
            {
                "tactic_sig": "Lemma lt_0_wwB : 0 < wwB .",
                "tactic_sig_no_out_arg": "Lemma lt_0_wwB : 0 < wwB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Z.lt 0 (base ww_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Z.lt 0 (base ww_digits)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 0 (Z.pow (base w_digits) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Z.lt 0 (Z.pow (base w_digits) 2)",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 0 (Z.mul (base w_digits) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Z.lt 0 (Z.mul (base w_digits) (base w_digits))",
                    "_global_Z.mul_pos_pos : forall (n m : Z) (_ : Z.lt 0 n) (_ : Z.lt 0 m), Z.lt 0 (Z.mul n m)"
                ],
                "tactic_res": [
                    "c4_goal : Z.lt 0 (base w_digits)",
                    "c5_goal : Z.lt 0 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Z.lt 0 (base w_digits)",
                    "_global_lt_0_wB : Z.lt 0 (base w_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Z.lt 0 (base w_digits)",
                    "_global_lt_0_wB : Z.lt 0 (base w_digits)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wB_pos",
        "proof": [
            {
                "tactic_sig": "Lemma wB_pos : 1 < wB .",
                "tactic_sig_no_out_arg": "Lemma wB_pos : 1 < wB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Z.lt 1 (base w_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Z.lt 1 (base w_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 1 (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 ^ 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 ^ 1 ) .",
                "tactic_args": [
                    "c2_goal : Z.lt 1 (Z.pow 2 (Zpos w_digits))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 1 (Z.pow 2 1)",
                    "c4_goal : Z.le (Z.pow 2 1) (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : Z.lt 1 (Z.pow 2 1)",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c5_goal : eq (Z.compare 1 (Z.pow 2 1)) Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : eq (Z.compare 1 (Z.pow 2 1)) Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Z.le (Z.pow 2 1) (Z.pow 2 (Zpos w_digits))",
                    "_global_Zpower_le_monotone : forall (a b c : Z) (_ : Z.lt 0 a) (_ : and (Z.le 0 b) (Z.le b c)),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt 0 2",
                    "c7_goal : and (Z.le 0 1) (Z.le 1 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : Z.lt 0 2",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c8_goal : eq (Z.compare 0 2) Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c8_goal : eq (Z.compare 0 2) Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (Z.le 0 1) (Z.le 1 (Zpos w_digits))"
                ],
                "tactic_res": [
                    "c9_goal : Z.le 0 1",
                    "c10_goal : Z.le 1 (Zpos w_digits)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : Z.le 0 1",
                    "_global_Z.le : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c11_goal : not (eq (Z.compare 0 1) Gt)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c11_goal : not (eq (Z.compare 0 1) Gt)"
                ],
                "tactic_res": [
                    "c12_goal : False",
                    "c12_H : eq (Z.compare 0 1) Gt"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c10_goal : Z.le 1 (Zpos w_digits)",
                    "_global_Z.le : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c13_goal : not (eq (Z.compare 1 (Zpos w_digits)) Gt)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c13_goal : not (eq (Z.compare 1 (Zpos w_digits)) Gt)"
                ],
                "tactic_res": [
                    "c14_goal : False",
                    "c14_H : eq (Z.compare 1 (Zpos w_digits)) Gt"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c12_goal : False",
                    "c12_H : eq (Z.compare 0 1) Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c14_goal : False",
                    "c1_w_digits : positive",
                    "c14_H : eq (Z.compare 1 (Zpos w_digits)) Gt",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": [
                    "c15_goal : False",
                    "c15_H : eq (Z.compare 1 (Zpos (xI p))) Gt",
                    "c15_p : positive",
                    "c16_goal : False",
                    "c16_H : eq (Z.compare 1 (Zpos (xO p))) Gt",
                    "c16_p : positive",
                    "c17_goal : False",
                    "c17_H : eq (Z.compare 1 1) Gt"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c15_goal : False",
                    "c15_H : eq (Z.compare 1 (Zpos (xI p))) Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c16_goal : False",
                    "c16_H : eq (Z.compare 1 (Zpos (xO p))) Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c17_goal : False",
                    "c17_H : eq (Z.compare 1 1) Gt"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wwB_pos",
        "proof": [
            {
                "tactic_sig": "Lemma wwB_pos : 1 < wwB .",
                "tactic_sig_no_out_arg": "Lemma wwB_pos : 1 < wwB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Z.lt 1 (base ww_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : Z.lt 1 (base ww_digits)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 1 (Z.pow (base w_digits) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i 1 ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i 1 ) .",
                "tactic_args": [
                    "c2_goal : Z.lt 1 (Z.pow (base w_digits) 2)",
                    "_global_Z.mul_1_r : forall n : Z, eq (Z.mul n 1) n"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt (Z.mul 1 1) (Z.pow (base w_digits) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Z.lt (Z.mul 1 1) (Z.pow (base w_digits) 2)",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c4_goal : Z.lt (Z.mul 1 1) (Z.mul (base w_digits) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Z.lt (Z.mul 1 1) (Z.mul (base w_digits) (base w_digits))",
                    "_global_Zmult_lt_compat2 : forall (n m p q : Z) (_ : and (Z.lt 0 n) (Z.le n p))\n         (_ : and (Z.lt 0 m) (Z.lt m q)), Z.lt (Z.mul n m) (Z.mul p q)"
                ],
                "tactic_res": [
                    "c5_goal : and (Z.lt 0 1) (Z.le 1 (base w_digits))",
                    "c6_goal : and (Z.lt 0 1) (Z.lt 1 (base w_digits))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (Z.lt 0 1) (Z.le 1 (base w_digits))"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt 0 1",
                    "c8_goal : Z.le 1 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 1",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c9_goal : eq (Z.compare 0 1) Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c9_goal : eq (Z.compare 0 1) Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Z.le 1 (base w_digits)",
                    "_global_Z.lt_le_incl : forall (n m : Z) (_ : Z.lt n m), Z.le n m"
                ],
                "tactic_res": [
                    "c10_goal : Z.lt 1 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c10_goal : Z.lt 1 (base w_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c6_goal : and (Z.lt 0 1) (Z.lt 1 (base w_digits))"
                ],
                "tactic_res": [
                    "c11_goal : Z.lt 0 1",
                    "c12_goal : Z.lt 1 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c11_goal : Z.lt 0 1",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c13_goal : eq (Z.compare 0 1) Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c13_goal : eq (Z.compare 0 1) Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c12_goal : Z.lt 1 (base w_digits)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wB_div_2",
        "proof": [
            {
                "tactic_sig": "Theorem wB_div_2 : 2 * ( wB / 2 ) = wB .",
                "tactic_sig_no_out_arg": "Theorem wB_div_2 : 2 * ( wB / 2 ) = wB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (Z.mul 2 (Z.div (base w_digits) 2)) (base w_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_0 : w",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_w_1 : w",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_Bm1 : w",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : eq (Z.mul 2 (Z.div (base w_digits) 2)) (base w_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.mul 2 (Z.div (Z.pow 2 (Zpos w_digits)) 2))\n  (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "assert ( 2 ^ Zpos _i = 2 * ( 2 ^ ( Zpos _i - 1 ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( 2 ^ Zpos _i = 2 * ( 2 ^ ( Zpos _i - 1 ) ) ) .",
                "tactic_args": [
                    "c2_goal : eq (Z.mul 2 (Z.div (Z.pow 2 (Zpos w_digits)) 2))\n  (Z.pow 2 (Zpos w_digits))",
                    "c1_w_digits : positive",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))",
                    "c4_goal : eq (Z.mul 2 (Z.div (Z.pow 2 (Zpos w_digits)) 2))\n  (Z.pow 2 (Zpos w_digits))",
                    "c4_H : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ]
            },
            {
                "tactic_sig": "pattern 2 at 2 .",
                "tactic_sig_no_out_arg": "pattern 2 at 2 .",
                "tactic_args": [
                    "c3_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ],
                "tactic_res": [
                    "c5_goal : (fun z : Z =>\n eq (Z.pow 2 (Zpos w_digits))\n   (Z.mul z (Z.pow 2 (Z.sub (Zpos w_digits) 1)))) 2"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c5_goal : (fun z : Z =>\n eq (Z.pow 2 (Zpos w_digits))\n   (Z.mul z (Z.pow 2 (Z.sub (Zpos w_digits) 1)))) 2",
                    "_global_Z.pow_1_r : forall a : Z, eq (Z.pow a 1) a"
                ],
                "tactic_res": [
                    "c6_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul (Z.pow 2 1) (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i by Lia.lia .",
                "tactic_sig_no_out_arg": "rewrite <- _i by Lia.lia .",
                "tactic_args": [
                    "c6_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul (Z.pow 2 1) (Z.pow 2 (Z.sub (Zpos w_digits) 1)))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.pow 2 (Z.add 1 (Z.sub (Zpos w_digits) 1)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c7_goal : eq (Z.pow 2 (Zpos w_digits))\n  (Z.pow 2 (Z.add 1 (Z.sub (Zpos w_digits) 1)))"
                ],
                "tactic_res": [
                    "c8_goal : eq (Zpos w_digits) (Z.add 1 (Z.sub (Zpos w_digits) 1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : eq (Zpos w_digits) (Z.add 1 (Z.sub (Zpos w_digits) 1))",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : eq (Z.mul 2 (Z.div (Z.pow 2 (Zpos w_digits)) 2))\n  (Z.pow 2 (Zpos w_digits))",
                    "c4_H : eq (Z.pow 2 (Zpos w_digits))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Z.mul 2 (Z.div (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1))) 2))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c9_goal : eq (Z.mul 2 (Z.div (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1))) 2))\n  (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1)))"
                ],
                "tactic_res": [
                    "c10_goal : eq (Z.div (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1))) 2)\n  (Z.pow 2 (Z.sub (Zpos w_digits) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (Z.div (Z.mul 2 (Z.pow 2 (Z.sub (Zpos w_digits) 1))) 2)\n  (Z.pow 2 (Z.sub (Zpos w_digits) 1))",
                    "_global_Z.mul_comm : forall n m : Z, eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c11_goal : eq (Z.div (Z.mul (Z.pow 2 (Z.sub (Zpos w_digits) 1)) 2) 2)\n  (Z.pow 2 (Z.sub (Zpos w_digits) 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : eq (Z.div (Z.mul (Z.pow 2 (Z.sub (Zpos w_digits) 1)) 2) 2)\n  (Z.pow 2 (Z.sub (Zpos w_digits) 1))",
                    "_global_Z_div_mult : forall (a b : Z) (_ : Z.gt b 0), eq (Z.div (Z.mul a b) b) a"
                ],
                "tactic_res": [
                    "c12_goal : Z.gt 2 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.gt 2 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wwB_div_2",
        "proof": [
            {
                "tactic_sig": "Theorem wwB_div_2 : wwB / 2 = wB / 2 * wB .",
                "tactic_sig_no_out_arg": "Theorem wwB_div_2 : wwB / 2 = wB / 2 * wB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (Z.div (base ww_digits) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_0 : w",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_w_1 : w",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_Bm1 : w",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : eq (Z.div (base ww_digits) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.div (Z.pow (base w_digits) 2) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.div (Z.pow (base w_digits) 2) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.div (Z.mul (base w_digits) (base w_digits)) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "pattern wB at 1 .",
                "tactic_sig_no_out_arg": "pattern wB at 1 .",
                "tactic_args": [
                    "c3_goal : eq (Z.div (Z.mul (base w_digits) (base w_digits)) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ],
                "tactic_res": [
                    "c4_goal : (fun z : Z =>\n eq (Z.div (Z.mul z (base w_digits)) 2)\n   (Z.mul (Z.div (base w_digits) 2) (base w_digits))) \n  (base w_digits)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : (fun z : Z =>\n eq (Z.div (Z.mul z (base w_digits)) 2)\n   (Z.mul (Z.div (base w_digits) 2) (base w_digits))) \n  (base w_digits)",
                    "_global_wB_div_2 : eq (Z.mul 2 (Z.div (base w_digits) 2)) (base w_digits)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Z.div (Z.mul (Z.mul 2 (Z.div (base w_digits) 2)) (base w_digits)) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c5_goal : eq\n  (Z.div (Z.mul (Z.mul 2 (Z.div (base w_digits) 2)) (base w_digits)) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "_global_Z.mul_assoc : forall n m p : Z, eq (Z.mul n (Z.mul m p)) (Z.mul (Z.mul n m) p)"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  (Z.div (Z.mul 2 (Z.mul (Z.div (base w_digits) 2) (base w_digits))) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "repeat ( rewrite ( Z.mul_comm 2 ) ; rewrite Z_div_mult ) .",
                "tactic_sig_no_out_arg": "repeat ( rewrite ( Z.mul_comm 2 ) ; rewrite Z_div_mult ) .",
                "tactic_args": [
                    "c6_goal : eq\n  (Z.div (Z.mul 2 (Z.mul (Z.div (base w_digits) 2) (base w_digits))) 2)\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.mul (Z.div (base w_digits) 2) (base w_digits))\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "c8_goal : Z.gt 2 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : eq (Z.mul (Z.div (base w_digits) 2) (base w_digits))\n  (Z.mul (Z.div (base w_digits) 2) (base w_digits))",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.gt 2 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mod_wwB",
        "proof": [
            {
                "tactic_sig": "Lemma mod_wwB : forall z x , ( z * wB + [ |x| ] ) mod wwB = ( z mod wB ) * wB + [ |x| ] .",
                "tactic_sig_no_out_arg": "Lemma mod_wwB : forall z x , ( z * wB + [ |x| ] ) mod wwB = ( z mod wB ) * wB + [ |x| ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (z : Z) (x : w),\neq\n  (Z.modulo (Z.add (Z.mul z (base w_digits)) (w_to_Z x))\n     (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros z x .",
                "tactic_args": [
                    "c1_goal : forall (z : Z) (x : w),\neq\n  (Z.modulo (Z.add (Z.mul z (base w_digits)) (w_to_Z x))\n     (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Z.modulo (Z.add (Z.mul z (base w_digits)) (w_to_Z x))\n     (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "c2_z : Z",
                    "c2_x : w"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq\n  (Z.modulo (Z.add (Z.mul z (base w_digits)) (w_to_Z x))\n     (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "_global_Zplus_mod : forall a b n : Z,\n       eq (Z.modulo (Z.add a b) n)\n         (Z.modulo (Z.add (Z.modulo a n) (Z.modulo b n)) n)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Z.modulo\n     (Z.add (Z.modulo (Z.mul z (base w_digits)) (base ww_digits))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ]
            },
            {
                "tactic_sig": "pattern wwB at 1 .",
                "tactic_sig_no_out_arg": "pattern wwB at 1 .",
                "tactic_args": [
                    "c3_goal : eq\n  (Z.modulo\n     (Z.add (Z.modulo (Z.mul z (base w_digits)) (base ww_digits))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ],
                "tactic_res": [
                    "c4_goal : (fun z0 : Z =>\n eq\n   (Z.modulo\n      (Z.add (Z.modulo (Z.mul z (base w_digits)) z0)\n         (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n   (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n      (w_to_Z x))) (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : (fun z0 : Z =>\n eq\n   (Z.modulo\n      (Z.add (Z.modulo (Z.mul z (base w_digits)) z0)\n         (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n   (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n      (w_to_Z x))) (base ww_digits)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Z.modulo\n     (Z.add\n        (Z.modulo (Z.mul z (base w_digits)) (Z.pow (base w_digits) 2))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq\n  (Z.modulo\n     (Z.add\n        (Z.modulo (Z.mul z (base w_digits)) (Z.pow (base w_digits) 2))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  (Z.modulo\n     (Z.add\n        (Z.modulo (Z.mul z (base w_digits))\n           (Z.mul (base w_digits) (base w_digits)))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq\n  (Z.modulo\n     (Z.add\n        (Z.modulo (Z.mul z (base w_digits))\n           (Z.mul (base w_digits) (base w_digits)))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "_global_Zmult_mod_distr_r : forall a b c : Z,\n       eq (Z.modulo (Z.mul a c) (Z.mul b c)) (Z.mul (Z.modulo a b) c)"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (Z.modulo\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i [ |x| ] ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i [ |x| ] ) .",
                "tactic_args": [
                    "c7_goal : eq\n  (Z.modulo\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (Z.modulo (w_to_Z x) (base ww_digits))) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)), eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (Z.modulo\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "c9_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base ww_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq\n  (Z.modulo\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (base ww_digits))\n  (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n     (w_to_Z x))",
                    "_global_Zmod_small : forall (a n : Z) (_ : and (Z.le 0 a) (Z.lt a n)), eq (Z.modulo a n) a"
                ],
                "tactic_res": [
                    "c10_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)))\n  (Z.lt\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (base ww_digits))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)))\n  (Z.lt\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (base ww_digits))",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c11_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)))\n  (Z.lt\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (Z.pow (base w_digits) 2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)))\n  (Z.lt\n     (Z.add (Z.mul (Z.modulo z (base w_digits)) (base w_digits))\n        (w_to_Z x)) (Z.pow (base w_digits) 2))",
                    "_global_beta_mult : forall (h l beta : Z) (_ : and (Z.le 0 h) (Z.lt h beta))\n         (_ : and (Z.le 0 l) (Z.lt l beta)),\n       and (Z.le 0 (Z.add (Z.mul h beta) l))\n         (Z.lt (Z.add (Z.mul h beta) l) (Z.pow beta 2))"
                ],
                "tactic_res": [
                    "c12_goal : and (Z.le 0 (Z.modulo z (base w_digits)))\n  (Z.lt (Z.modulo z (base w_digits)) (base w_digits))",
                    "c13_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "try apply _i .",
                "tactic_sig_no_out_arg": "try apply _i .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try apply _i .",
                "tactic_sig_no_out_arg": "try apply _i .",
                "tactic_args": [
                    "c13_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : and (Z.le 0 (Z.modulo z (base w_digits)))\n  (Z.lt (Z.modulo z (base w_digits)) (base w_digits))",
                    "_global_Z_mod_lt : forall (a b : Z) (_ : Z.gt b 0),\n       and (Z.le 0 (Z.modulo a b)) (Z.lt (Z.modulo a b) b)"
                ],
                "tactic_res": [
                    "c14_goal : Z.gt (base w_digits) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.gt (base w_digits) 0",
                    "_global_Z.lt_gt : forall (n m : Z) (_ : Z.lt n m), Z.gt m n"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt 0 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Z.lt 0 (base w_digits)",
                    "_global_lt_0_wB : Z.lt 0 (base w_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c2_x : w",
                    "c2_z : Z",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c9_H0 : Z.lt (w_to_Z x) (base w_digits)",
                    "c9_H : Z.le 0 (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base ww_digits))"
                ],
                "tactic_res": [
                    "c16_goal : Z.le 0 (w_to_Z x)",
                    "c17_goal : Z.lt (w_to_Z x) (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c16_goal : Z.le 0 (w_to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change [ |x| ] with ( 0 * wB + [ |x| ] ) .",
                "tactic_sig_no_out_arg": "change [ |x| ] with ( 0 * wB + [ |x| ] ) .",
                "tactic_args": [
                    "c17_goal : Z.lt (w_to_Z x) (base ww_digits)"
                ],
                "tactic_res": [
                    "c18_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x)) (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x)) (base ww_digits)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c19_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.pow (base w_digits) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.pow (base w_digits) 2)",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c20_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.mul (base w_digits) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( wB * wB ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( wB * wB ) ) .",
                "tactic_args": [
                    "c20_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.mul (base w_digits) (base w_digits))",
                    "_global_Z.add_0_r : forall n : Z, eq (Z.add n 0) n"
                ],
                "tactic_res": [
                    "c21_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.add (Z.mul (base w_digits) (base w_digits)) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z x))\n  (Z.add (Z.mul (base w_digits) (base w_digits)) 0)",
                    "_global_beta_lex_inv : forall (a b c d beta : Z) (_ : Z.lt a c)\n         (_ : and (Z.le 0 b) (Z.lt b beta))\n         (_ : and (Z.le 0 d) (Z.lt d beta)),\n       Z.lt (Z.add (Z.mul a beta) b) (Z.add (Z.mul c beta) d)"
                ],
                "tactic_res": [
                    "c22_goal : Z.lt 0 (base w_digits)",
                    "c23_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c24_goal : and (Z.le 0 0) (Z.lt 0 (base w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : Z.lt 0 (base w_digits)",
                    "_global_lt_0_wB : Z.lt 0 (base w_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c24_goal : and (Z.le 0 0) (Z.lt 0 (base w_digits))"
                ],
                "tactic_res": [
                    "c25_goal : Z.le 0 0",
                    "c26_goal : Z.lt 0 (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : Z.le 0 0",
                    "_global_Z.le_refl : forall n : Z, Z.le n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 (base w_digits)",
                    "_global_lt_0_wB : Z.lt 0 (base w_digits)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wB_div",
        "proof": [
            {
                "tactic_sig": "Lemma wB_div : forall x y , ( [ |x| ] * wB + [ |y| ] ) / wB = [ |x| ] .",
                "tactic_sig_no_out_arg": "Lemma wB_div : forall x y , ( [ |x| ] * wB + [ |y| ] ) / wB = [ |x| ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : w,\neq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (base w_digits)) (w_to_Z x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : w,\neq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (base w_digits)) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (base w_digits)) (w_to_Z x)",
                    "c2_x : w",
                    "c2_y : w"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (base w_digits)) (w_to_Z x)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Z.div\n     (Z.add (Z.mul (w_to_Z x) (Z.pow 2 (Zpos w_digits))) (w_to_Z y))\n     (Z.pow 2 (Zpos w_digits))) (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (Z.div\n     (Z.add (Z.mul (w_to_Z x) (Z.pow 2 (Zpos w_digits))) (w_to_Z y))\n     (Z.pow 2 (Zpos w_digits))) (w_to_Z x)",
                    "_global_Zdiv_shift_r : forall (a b r t : Z) (_ : and (Z.le 0 a) (Z.le a b)) \n         (_ : Z.le 0 r) (_ : and (Z.le 0 t) (Z.lt t (Z.pow 2 a))),\n       eq (Z.div (Z.add (Z.mul r (Z.pow 2 a)) t) (Z.pow 2 b))\n         (Z.div (Z.mul r (Z.pow 2 a)) (Z.pow 2 b))"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Z.div (Z.mul (w_to_Z x) (Z.pow 2 (Zpos w_digits)))\n     (Z.pow 2 (Zpos w_digits))) (w_to_Z x)",
                    "c5_goal : and (Z.le 0 (Zpos w_digits)) (Z.le (Zpos w_digits) (Zpos w_digits))",
                    "c6_goal : Z.le 0 (w_to_Z x)",
                    "c7_goal : and (Z.le 0 (w_to_Z y)) (Z.lt (w_to_Z y) (Z.pow 2 (Zpos w_digits)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : and (Z.le 0 (Zpos w_digits)) (Z.le (Zpos w_digits) (Zpos w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : and (Z.le 0 (w_to_Z y)) (Z.lt (w_to_Z y) (Z.pow 2 (Zpos w_digits)))",
                    "c2_y : w",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : eq\n  (Z.div (Z.mul (w_to_Z x) (Z.pow 2 (Zpos w_digits)))\n     (Z.pow 2 (Zpos w_digits))) (w_to_Z x)",
                    "_global_Z_div_mult : forall (a b : Z) (_ : Z.gt b 0), eq (Z.div (Z.mul a b) b) a"
                ],
                "tactic_res": [
                    "c8_goal : eq (w_to_Z x) (w_to_Z x)",
                    "c9_goal : Z.gt (Z.pow 2 (Zpos w_digits)) 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : eq (w_to_Z x) (w_to_Z x)",
                    "c2_x : w",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : Z.gt (Z.pow 2 (Zpos w_digits)) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c2_x : w",
                    "c2_y : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c6_H0 : Z.lt (w_to_Z x) (base w_digits)",
                    "c6_H : Z.le 0 (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : Z.le 0 (w_to_Z x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wB_div_plus",
        "proof": [
            {
                "tactic_sig": "Lemma wB_div_plus : forall x y p , 0 <= p -> ( [ |x| ] * wB + [ |y| ] ) / 2 ^ ( Zpos w_digits + p ) = [ |x| ] / 2 ^ p .",
                "tactic_sig_no_out_arg": "Lemma wB_div_plus : forall x y p , 0 <= p -> ( [ |x| ] * wB + [ |y| ] ) / 2 ^ ( Zpos w_digits + p ) = [ |x| ] / 2 ^ p .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : w) (p : Z) (_ : Z.le 0 p),\neq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.pow 2 (Z.add (Zpos w_digits) p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y p Hp .",
                "tactic_args": [
                    "c1_goal : forall (x y : w) (p : Z) (_ : Z.le 0 p),\neq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.pow 2 (Z.add (Zpos w_digits) p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.pow 2 (Z.add (Zpos w_digits) p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "c2_x : w",
                    "c2_y : w",
                    "c2_p : Z",
                    "c2_Hp : Z.le 0 p"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.pow 2 (Z.add (Zpos w_digits) p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "c4_goal : Z.ge (Zpos w_digits) 0",
                    "c5_goal : Z.ge p 0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c4_goal : Z.ge (Zpos w_digits) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.ge p 0",
                    "c2_Hp : Z.le 0 p",
                    "c2_p : Z",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n     (Z.mul (Z.pow 2 (Zpos w_digits)) (Z.pow 2 p)))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "_global_Zdiv_Zdiv : forall (a b c : Z) (_ : Z.le 0 b) (_ : Z.le 0 c),\n       eq (Z.div (Z.div a b) c) (Z.div a (Z.mul b c))"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  (Z.div\n     (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n        (Z.pow 2 (Zpos w_digits))) (Z.pow 2 p))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "c7_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))",
                    "c8_goal : Z.le 0 (Z.pow 2 p)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c7_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c8_goal : Z.le 0 (Z.pow 2 p)",
                    "c2_p : Z",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq\n  (Z.div\n     (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n        (Z.pow 2 (Zpos w_digits))) (Z.pow 2 p))\n  (Z.div (w_to_Z x) (Z.pow 2 p))",
                    "_global_wB_div : forall x y : w,\n       eq\n         (Z.div (Z.add (Z.mul (w_to_Z x) (base w_digits)) (w_to_Z y))\n            (base w_digits)) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c9_goal : eq (Z.div (w_to_Z x) (Z.pow 2 p)) (Z.div (w_to_Z x) (Z.pow 2 p))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq (Z.div (w_to_Z x) (Z.pow 2 p)) (Z.div (w_to_Z x) (Z.pow 2 p))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lt_wB_wwB",
        "proof": [
            {
                "tactic_sig": "Lemma lt_wB_wwB : wB < wwB .",
                "tactic_sig_no_out_arg": "Lemma lt_wB_wwB : wB < wwB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Z.lt (base w_digits) (base ww_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : Z.lt (base w_digits) (base ww_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos ww_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Z.lt (Z.pow 2 (Zpos w_digits)) (Z.pow 2 (Zpos ww_digits))",
                    "_global_Zpower_lt_monotone : forall (a b c : Z) (_ : Z.lt 1 a) (_ : and (Z.le 0 b) (Z.lt b c)),\n       Z.lt (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt 1 2",
                    "c4_goal : and (Z.le 0 (Zpos w_digits)) (Z.lt (Zpos w_digits) (Zpos ww_digits))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : Z.lt 1 2",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( 0 < Zpos _i ) .",
                "tactic_sig_no_out_arg": "assert ( 0 < Zpos _i ) .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 (Zpos w_digits)) (Z.lt (Zpos w_digits) (Zpos ww_digits))",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c5_goal : Z.lt 0 (Zpos w_digits)",
                    "c6_goal : and (Z.le 0 (Zpos w_digits)) (Z.lt (Zpos w_digits) (Zpos ww_digits))",
                    "c6_H : Z.lt 0 (Zpos w_digits)"
                ]
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c5_goal : Z.lt 0 (Zpos w_digits)"
                ],
                "tactic_res": [
                    "c7_goal : eq Lt Lt"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c7_goal : eq Lt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : and (Z.le 0 (Zpos w_digits)) (Z.lt (Zpos w_digits) (Zpos ww_digits))",
                    "_global_ww_digits : positive"
                ],
                "tactic_res": [
                    "c8_goal : and (Z.le 0 (Zpos w_digits))\n  (Z.lt (Zpos w_digits) (Zpos (xO w_digits)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : and (Z.le 0 (Zpos w_digits))\n  (Z.lt (Zpos w_digits) (Zpos (xO w_digits)))",
                    "_global_Pos2Z.inj_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c9_goal : and (Z.le 0 (Zpos w_digits))\n  (Z.lt (Zpos w_digits) (Z.mul 2 (Zpos w_digits)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 (Zpos w_digits))\n  (Z.lt (Zpos w_digits) (Z.mul 2 (Zpos w_digits)))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "w_to_Z_wwB",
        "proof": [
            {
                "tactic_sig": "Lemma w_to_Z_wwB : forall x , x < wB -> x < wwB .",
                "tactic_sig_no_out_arg": "Lemma w_to_Z_wwB : forall x , x < wB -> x < wwB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : Z) (_ : Z.lt x (base w_digits)), Z.lt x (base ww_digits)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x H .",
                "tactic_args": [
                    "c1_goal : forall (x : Z) (_ : Z.lt x (base w_digits)), Z.lt x (base ww_digits)"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt x (base ww_digits)",
                    "c2_x : Z",
                    "c2_H : Z.lt x (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i with wB .",
                "tactic_sig_no_out_arg": "apply _i with wB .",
                "tactic_args": [
                    "c2_goal : Z.lt x (base ww_digits)",
                    "_global_Z.lt_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.lt m p), Z.lt n p"
                ],
                "tactic_res": [
                    "c3_goal : Z.lt x (base w_digits)",
                    "c4_goal : Z.lt (base w_digits) (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c3_goal : Z.lt x (base w_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Z.lt (base w_digits) (base ww_digits)",
                    "_global_lt_wB_wwB : Z.lt (base w_digits) (base ww_digits)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ww_to_Z",
        "proof": [
            {
                "tactic_sig": "Lemma spec_ww_to_Z : forall x , 0 <= [ [ x ] ] < wwB .",
                "tactic_sig_no_out_arg": "Lemma spec_ww_to_Z : forall x , 0 <= [ [ x ] ] < wwB .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : zn2z w,\nand (Z.le 0 (ww_to_Z x)) (Z.lt (ww_to_Z x) (base ww_digits))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct x as [ |h l ] .",
                "tactic_sig_no_out_arg": "destruct x as [ |h l ] .",
                "tactic_args": [
                    "c1_goal : forall x : zn2z w,\nand (Z.le 0 (ww_to_Z x)) (Z.lt (ww_to_Z x) (base ww_digits))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (ww_to_Z W0)) (Z.lt (ww_to_Z W0) (base ww_digits))",
                    "c3_goal : and (Z.le 0 (ww_to_Z (WW h l)))\n  (Z.lt (ww_to_Z (WW h l)) (base ww_digits))",
                    "c3_l : w",
                    "c3_h : w"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (ww_to_Z W0)) (Z.lt (ww_to_Z W0) (base ww_digits))"
                ],
                "tactic_res": [
                    "c4_goal : and (Z.le 0 0) (Z.lt 0 (base ww_digits))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : and (Z.le 0 (ww_to_Z (WW h l)))\n  (Z.lt (ww_to_Z (WW h l)) (base ww_digits))"
                ],
                "tactic_res": [
                    "c5_goal : and (Z.le 0 (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l)))\n  (Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n     (base ww_digits))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 0) (Z.lt 0 (base ww_digits))"
                ],
                "tactic_res": [
                    "c6_goal : Z.le 0 0",
                    "c7_goal : Z.lt 0 (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Z.le 0 0",
                    "_global_Z.le_refl : forall n : Z, Z.le n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 (base ww_digits)",
                    "_global_lt_0_wwB : Z.lt 0 (base ww_digits)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H := _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( H := _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c3_h : w"
                ],
                "tactic_res": [
                    "c5_H : and (Z.le 0 (w_to_Z h)) (Z.lt (w_to_Z h) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "assert ( L := _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( L := _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c3_l : w"
                ],
                "tactic_res": [
                    "c5_L : and (Z.le 0 (w_to_Z l)) (Z.lt (w_to_Z l) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (Z.le 0 (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l)))\n  (Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n     (base ww_digits))"
                ],
                "tactic_res": [
                    "c8_goal : Z.le 0 (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c9_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (base ww_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : Z.le 0 (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "_global_Z.add_nonneg_nonneg : forall (n m : Z) (_ : Z.le 0 n) (_ : Z.le 0 m), Z.le 0 (Z.add n m)"
                ],
                "tactic_res": [
                    "c10_goal : Z.le 0 (Z.mul (w_to_Z h) (base w_digits))",
                    "c11_goal : Z.le 0 (w_to_Z l)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : Z.le 0 (Z.mul (w_to_Z h) (base w_digits))",
                    "c5_H : and (Z.le 0 (w_to_Z h)) (Z.lt (w_to_Z h) (base w_digits))",
                    "c3_h : w",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : Z.le 0 (w_to_Z l)",
                    "c5_L : and (Z.le 0 (w_to_Z l)) (Z.lt (w_to_Z l) (base w_digits))",
                    "c3_l : w",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i wwB ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i wwB ) .",
                "tactic_args": [
                    "c9_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (base ww_digits)",
                    "_global_Z.add_0_r : forall n : Z, eq (Z.add n 0) n"
                ],
                "tactic_res": [
                    "c12_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (base ww_digits) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (base ww_digits) 0)",
                    "_global_wwB_wBwB : eq (base ww_digits) (Z.pow (base w_digits) 2)"
                ],
                "tactic_res": [
                    "c13_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (Z.pow (base w_digits) 2) 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (Z.pow (base w_digits) 2) 0)",
                    "_global_Z.pow_2_r : forall a : Z, eq (Z.pow a 2) (Z.mul a a)"
                ],
                "tactic_res": [
                    "c14_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (Z.mul (base w_digits) (base w_digits)) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.lt (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n  (Z.add (Z.mul (base w_digits) (base w_digits)) 0)",
                    "_global_beta_lex_inv : forall (a b c d beta : Z) (_ : Z.lt a c)\n         (_ : and (Z.le 0 b) (Z.lt b beta))\n         (_ : and (Z.le 0 d) (Z.lt d beta)),\n       Z.lt (Z.add (Z.mul a beta) b) (Z.add (Z.mul c beta) d)"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt (w_to_Z h) (base w_digits)",
                    "c16_goal : and (Z.le 0 (w_to_Z l)) (Z.lt (w_to_Z l) (base w_digits))",
                    "c17_goal : and (Z.le 0 0) (Z.lt 0 (base w_digits))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.lt (w_to_Z h) (base w_digits)",
                    "c5_H : and (Z.le 0 (w_to_Z h)) (Z.lt (w_to_Z h) (base w_digits))",
                    "c3_h : w",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : and (Z.le 0 (w_to_Z l)) (Z.lt (w_to_Z l) (base w_digits))",
                    "c3_l : w",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : and (Z.le 0 0) (Z.lt 0 (base w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_wB_wwB",
        "proof": [
            {
                "tactic_sig": "Lemma double_wB_wwB : forall n , double_wB n * double_wB n = double_wB ( S n ) .",
                "tactic_sig_no_out_arg": "Lemma double_wB_wwB : forall n , double_wB n * double_wB n = double_wB ( S n ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat,\neq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat,\neq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))",
                    "_global_double_wB : forall _ : nat, Z"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Z.mul (base (Pos.shiftl_nat w_digits n))\n     (base (Pos.shiftl_nat w_digits n)))\n  (base (Pos.shiftl_nat w_digits (S n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq\n  (Z.mul (base (Pos.shiftl_nat w_digits n))\n     (base (Pos.shiftl_nat w_digits n)))\n  (base (Pos.shiftl_nat w_digits (S n)))"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Z.mul (base (Pos.shiftl_nat w_digits n))\n     (base (Pos.shiftl_nat w_digits n)))\n  (base (xO (Pos.shiftl_nat w_digits n)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c4_goal : eq\n  (Z.mul (base (Pos.shiftl_nat w_digits n))\n     (base (Pos.shiftl_nat w_digits n)))\n  (base (xO (Pos.shiftl_nat w_digits n)))",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2 (Zpos (xO (Pos.shiftl_nat w_digits n))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i << _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i << _i ) ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2 (Zpos (xO (Pos.shiftl_nat w_digits n))))",
                    "_global_Pos2Z.inj_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))",
                    "_global__ : ?T\nwhere\n?T : [w : univ_of_cycles\n      w_0 : w\n      w_1 : w\n      w_Bm1 : w\n      w_WW : forall (_ : w) (_ : w), zn2z w\n      w_0W : forall _ : w, zn2z w\n      w_digits : positive\n      w_zdigits : w\n      w_add : forall (_ : w) (_ : w), zn2z w\n      w_to_Z : forall _ : w, Z\n      w_compare : forall (_ : w) (_ : w), comparison\n      spec_w_0 : eq (w_to_Z w_0) 0\n      spec_w_1 : eq (w_to_Z w_1) 1\n      spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)\n      spec_w_WW : forall h l : w,\n                  eq (ww_to_Z (w_WW h l))\n                    (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n      spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)\n      spec_to_Z : forall x : w,\n                  and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))\n      spec_w_compare : forall x y : w,\n                       eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))\n      n : nat |- Type]\n?y : [w : univ_of_cycles\n      w_0 : w\n      w_1 : w\n      w_Bm1 : w\n      w_WW : forall (_ : w) (_ : w), zn2z w\n      w_0W : forall _ : w, zn2z w\n      w_digits : positive\n      w_zdigits : w\n      w_add : forall (_ : w) (_ : w), zn2z w\n      w_to_Z : forall _ : w, Z\n      w_compare : forall (_ : w) (_ : w), comparison\n      spec_w_0 : eq (w_to_Z w_0) 0\n      spec_w_1 : eq (w_to_Z w_1) 1\n      spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)\n      spec_w_WW : forall h l : w,\n                  eq (ww_to_Z (w_WW h l))\n                    (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n      spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)\n      spec_to_Z : forall x : w,\n                  and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))\n      spec_w_compare : forall x y : w,\n                       eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))\n      n : nat |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [w : univ_of_cycles\n      w_0 : w\n      w_1 : w\n      w_Bm1 : w\n      w_WW : forall (_ : w) (_ : w), zn2z w\n      w_0W : forall _ : w, zn2z w\n      w_digits : positive\n      w_zdigits : w\n      w_add : forall (_ : w) (_ : w), zn2z w\n      w_to_Z : forall _ : w, Z\n      w_compare : forall (_ : w) (_ : w), comparison\n      spec_w_0 : eq (w_to_Z w_0) 0\n      spec_w_1 : eq (w_to_Z w_1) 1\n      spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)\n      spec_w_WW : forall h l : w,\n                  eq (ww_to_Z (w_WW h l))\n                    (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n      spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)\n      spec_to_Z : forall x : w,\n                  and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))\n      spec_w_compare : forall x y : w,\n                       eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))\n      n : nat |- Type]\n?y : [w : univ_of_cycles\n      w_0 : w\n      w_1 : w\n      w_Bm1 : w\n      w_WW : forall (_ : w) (_ : w), zn2z w\n      w_0W : forall _ : w, zn2z w\n      w_digits : positive\n      w_zdigits : w\n      w_add : forall (_ : w) (_ : w), zn2z w\n      w_to_Z : forall _ : w, Z\n      w_compare : forall (_ : w) (_ : w), comparison\n      spec_w_0 : eq (w_to_Z w_0) 0\n      spec_w_1 : eq (w_to_Z w_1) 1\n      spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)\n      spec_w_WW : forall h l : w,\n                  eq (ww_to_Z (w_WW h l))\n                    (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))\n      spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)\n      spec_to_Z : forall x : w,\n                  and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))\n      spec_w_compare : forall x y : w,\n                       eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))\n      n : nat |- ?T]"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2 (Z.mul 2 (Zpos (Pos.shiftl_nat w_digits n))))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * Zpos ( _i << _i ) ) with ( Zpos ( _i << _i ) + Zpos ( _i << _i ) ) by ring .",
                "tactic_sig_no_out_arg": "replace ( 2 * Zpos ( _i << _i ) ) with ( Zpos ( _i << _i ) + Zpos ( _i << _i ) ) by ring .",
                "tactic_args": [
                    "c6_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2 (Z.mul 2 (Zpos (Pos.shiftl_nat w_digits n))))",
                    "c1_w_digits : positive",
                    "c2_n : nat",
                    "c1_w_digits : positive",
                    "c2_n : nat",
                    "c1_w_digits : positive",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2\n     (Z.add (Zpos (Pos.shiftl_nat w_digits n))\n        (Zpos (Pos.shiftl_nat w_digits n))))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c7_goal : eq\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.pow 2\n     (Z.add (Zpos (Pos.shiftl_nat w_digits n))\n        (Zpos (Pos.shiftl_nat w_digits n))))"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (Z.pow 2\n     (Z.add (Zpos (Pos.shiftl_nat w_digits n))\n        (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq\n  (Z.pow 2\n     (Z.add (Zpos (Pos.shiftl_nat w_digits n))\n        (Zpos (Pos.shiftl_nat w_digits n))))\n  (Z.mul (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))\n     (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n))))",
                    "_global_Zpower_exp : forall (x n m : Z) (_ : Z.ge n 0) (_ : Z.ge m 0),\n       eq (Z.pow x (Z.add n m)) (Z.mul (Z.pow x n) (Z.pow x m))"
                ],
                "tactic_res": [
                    "c9_goal : Z.ge (Zpos (Pos.shiftl_nat w_digits n)) 0",
                    "c10_goal : Z.ge (Zpos (Pos.shiftl_nat w_digits n)) 0"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c9_goal : Z.ge (Zpos (Pos.shiftl_nat w_digits n)) 0"
                ],
                "tactic_res": [
                    "c11_goal : False",
                    "c11_H : eq (Z.compare (Zpos (Pos.shiftl_nat w_digits n)) 0) Lt"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c11_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c10_goal : Z.ge (Zpos (Pos.shiftl_nat w_digits n)) 0"
                ],
                "tactic_res": [
                    "c12_goal : False",
                    "c12_H : eq (Z.compare (Zpos (Pos.shiftl_nat w_digits n)) 0) Lt"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c12_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_wB_pos",
        "proof": [
            {
                "tactic_sig": "Lemma double_wB_pos : forall n , 0 <= double_wB n .",
                "tactic_sig_no_out_arg": "Lemma double_wB_pos : forall n , 0 <= double_wB n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, Z.le 0 (double_wB n)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, Z.le 0 (double_wB n)"
                ],
                "tactic_res": [
                    "c2_goal : Z.le 0 (double_wB n)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : Z.le 0 (double_wB n)",
                    "_global_double_wB : forall _ : nat, Z",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c3_goal : Z.le 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : Z.le 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits n)))",
                    "c2_n : nat",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_wB_more_digits",
        "proof": [
            {
                "tactic_sig": "Lemma double_wB_more_digits : forall n , wB <= double_wB n .",
                "tactic_sig_no_out_arg": "Lemma double_wB_more_digits : forall n , wB <= double_wB n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, Z.le (base w_digits) (double_wB n)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, Z.le (base w_digits) (double_wB n)"
                ],
                "tactic_res": [
                    "c2_goal : Z.le (base w_digits) (double_wB n)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : Z.le (base w_digits) (double_wB n)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : Z.le (base w_digits) (double_wB 0)",
                    "c4_goal : forall (n : nat) (_ : Z.le (base w_digits) (double_wB n)),\nZ.le (base w_digits) (double_wB (S n))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , \"<<\" .",
                "tactic_sig_no_out_arg": "unfold _i , \"<<\" .",
                "tactic_args": [
                    "c3_goal : Z.le (base w_digits) (double_wB 0)",
                    "_global_double_wB : forall _ : nat, Z"
                ],
                "tactic_res": [
                    "c5_goal : Z.le (base w_digits)\n  (base\n     (nat_rect (fun _ : nat => positive) w_digits (fun _ : nat => xO) 0))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.le (base w_digits)\n  (base\n     (nat_rect (fun _ : nat => positive) w_digits (fun _ : nat => xO) 0))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H1 .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : Z.le (base w_digits) (double_wB n)),\nZ.le (base w_digits) (double_wB (S n))"
                ],
                "tactic_res": [
                    "c6_goal : Z.le (base w_digits) (double_wB (S n))",
                    "c6_n : nat",
                    "c6_H1 : Z.le (base w_digits) (double_wB n)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c6_goal : Z.le (base w_digits) (double_wB (S n))",
                    "_global_double_wB_wwB : forall n : nat,\n       eq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))"
                ],
                "tactic_res": [
                    "c7_goal : Z.le (base w_digits) (Z.mul (double_wB n) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( wB * 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( wB * 1 ) .",
                "tactic_args": [
                    "c7_goal : Z.le (base w_digits) (Z.mul (double_wB n) (double_wB n))",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p"
                ],
                "tactic_res": [
                    "c8_goal : Z.le (base w_digits) (Z.mul (base w_digits) 1)",
                    "c9_goal : Z.le (Z.mul (base w_digits) 1) (Z.mul (double_wB n) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Z.le (base w_digits) (Z.mul (base w_digits) 1)",
                    "_global_Z.mul_1_r : forall n : Z, eq (Z.mul n 1) n"
                ],
                "tactic_res": [
                    "c10_goal : Z.le (base w_digits) (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Z.le (base w_digits) (base w_digits)",
                    "_global_Z.le_refl : forall n : Z, Z.le n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : Z.le (Z.mul (base w_digits) 1) (Z.mul (double_wB n) (double_wB n))",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c11_goal : Z.le (Z.mul (Z.pow 2 (Zpos w_digits)) 1)\n  (Z.mul (double_wB n) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : Z.le (Z.mul (Z.pow 2 (Zpos w_digits)) 1)\n  (Z.mul (double_wB n) (double_wB n))",
                    "_global_Z.mul_le_mono_nonneg : forall (n m p q : Z) (_ : Z.le 0 n) (_ : Z.le n m) \n         (_ : Z.le 0 p) (_ : Z.le p q), Z.le (Z.mul n p) (Z.mul m q)"
                ],
                "tactic_res": [
                    "c12_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))",
                    "c13_goal : Z.le (Z.pow 2 (Zpos w_digits)) (double_wB n)",
                    "c14_goal : Z.le 0 1",
                    "c15_goal : Z.le 1 (double_wB n)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : Z.le (Z.pow 2 (Zpos w_digits)) (double_wB n)",
                    "c6_H1 : Z.le (base w_digits) (double_wB n)",
                    "c6_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : Z.le 0 1",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with wB .",
                "tactic_sig_no_out_arg": "apply _i with wB .",
                "tactic_args": [
                    "c15_goal : Z.le 1 (double_wB n)",
                    "_global_Z.le_trans : forall (n m p : Z) (_ : Z.le n m) (_ : Z.le m p), Z.le n p"
                ],
                "tactic_res": [
                    "c16_goal : Z.le 1 (base w_digits)",
                    "c17_goal : Z.le (base w_digits) (double_wB n)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le (base w_digits) (double_wB n)",
                    "c6_H1 : Z.le (base w_digits) (double_wB n)",
                    "c6_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c16_goal : Z.le 1 (base w_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c18_goal : Z.le 1 (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i 2 ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i 2 ) .",
                "tactic_args": [
                    "c18_goal : Z.le 1 (Z.pow 2 (Zpos w_digits))",
                    "_global_Z.pow_0_r : forall n : Z, eq (Z.pow n 0) 1"
                ],
                "tactic_res": [
                    "c19_goal : Z.le (Z.pow 2 0) (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Z.le (Z.pow 2 0) (Z.pow 2 (Zpos w_digits))",
                    "_global_Z.pow_le_mono_r : forall (a b c : Z) (_ : Z.lt 0 a) (_ : Z.le b c),\n       Z.le (Z.pow a b) (Z.pow a c)"
                ],
                "tactic_res": [
                    "c20_goal : Z.lt 0 2",
                    "c21_goal : Z.le 0 (Zpos w_digits)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.lt 0 2",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Zpos w_digits)",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_to_Z",
        "proof": [
            {
                "tactic_sig": "Lemma spec_double_to_Z : forall n ( x : word w n ) , 0 <= [ !n | x! ] < double_wB n .",
                "tactic_sig_no_out_arg": "Lemma spec_double_to_Z : forall n ( x : word w n ) , 0 <= [ !n | x! ] < double_wB n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : word w n),\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i _i _i .",
                "tactic_args": [
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction n .",
                "tactic_sig_no_out_arg": "induction n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : word w n),\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))"
                ],
                "tactic_res": [
                    "c2_goal : forall x : word w 0,\nand (Z.le 0 (double_to_Z 0 x)) (Z.lt (double_to_Z 0 x) (double_wB 0))",
                    "c3_goal : forall x : word w (S n),\nand (Z.le 0 (double_to_Z (S n) x))\n  (Z.lt (double_to_Z (S n) x) (double_wB (S n)))",
                    "c3_IHn : forall x : word w n,\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall x : word w 0,\nand (Z.le 0 (double_to_Z 0 x)) (Z.lt (double_to_Z 0 x) (double_wB 0))"
                ],
                "tactic_res": [
                    "c4_goal : and (Z.le 0 (double_to_Z 0 x)) (Z.lt (double_to_Z 0 x) (double_wB 0))",
                    "c4_x : word w 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall x : word w (S n),\nand (Z.le 0 (double_to_Z (S n) x))\n  (Z.lt (double_to_Z (S n) x) (double_wB (S n)))"
                ],
                "tactic_res": [
                    "c5_goal : and (Z.le 0 (double_to_Z (S n) x))\n  (Z.lt (double_to_Z (S n) x) (double_wB (S n)))",
                    "c5_x : word w (S n)"
                ]
            },
            {
                "tactic_sig": "exact ( _i _i ) .",
                "tactic_sig_no_out_arg": "exact ( _i _i ) .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 (double_to_Z 0 x)) (Z.lt (double_to_Z 0 x) (double_wB 0))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c4_x : word w 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c5_goal : and (Z.le 0 (double_to_Z (S n) x))\n  (Z.lt (double_to_Z (S n) x) (double_wB (S n)))",
                    "_global_double_to_Z : forall (n : nat) (_ : word w n), Z"
                ],
                "tactic_res": [
                    "c6_goal : and\n  (Z.le 0\n     (zn2z_to_Z (double_wB n)\n        ((fix double_to_Z (n : nat) : forall _ : word w n, Z :=\n            match n as n0 return (forall _ : word w n0, Z) with\n            | 0%nat => w_to_Z\n            | S n0 => zn2z_to_Z (double_wB n0) (double_to_Z n0)\n            end) n) x))\n  (Z.lt\n     (zn2z_to_Z (double_wB n)\n        ((fix double_to_Z (n : nat) : forall _ : word w n, Z :=\n            match n as n0 return (forall _ : word w n0, Z) with\n            | 0%nat => w_to_Z\n            | S n0 => zn2z_to_Z (double_wB n0) (double_to_Z n0)\n            end) n) x) (double_wB (S n)))"
                ]
            },
            {
                "tactic_sig": "fold double_to_Z .",
                "tactic_sig_no_out_arg": "fold double_to_Z .",
                "tactic_args": [
                    "c6_goal : and\n  (Z.le 0\n     (zn2z_to_Z (double_wB n)\n        ((fix double_to_Z (n : nat) : forall _ : word w n, Z :=\n            match n as n0 return (forall _ : word w n0, Z) with\n            | 0%nat => w_to_Z\n            | S n0 => zn2z_to_Z (double_wB n0) (double_to_Z n0)\n            end) n) x))\n  (Z.lt\n     (zn2z_to_Z (double_wB n)\n        ((fix double_to_Z (n : nat) : forall _ : word w n, Z :=\n            match n as n0 return (forall _ : word w n0, Z) with\n            | 0%nat => w_to_Z\n            | S n0 => zn2z_to_Z (double_wB n0) (double_to_Z n0)\n            end) n) x) (double_wB (S n)))"
                ],
                "tactic_res": [
                    "c7_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) x))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) x) (double_wB (S n)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) x))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) x) (double_wB (S n)))",
                    "c5_x : word w (S n)",
                    "c3_IHn : forall x : word w n,\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))",
                    "c3_n : nat",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c8_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) W0))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) W0) (double_wB (S n)))",
                    "c9_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1)))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1))\n     (double_wB (S n)))",
                    "c9_w1 : word w n",
                    "c9_w0 : word w n"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) W0))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) W0) (double_wB (S n)))",
                    "_global_zn2z_to_Z : forall (znz : Type) (_ : Z) (_ : forall _ : znz, Z) (_ : zn2z znz), Z"
                ],
                "tactic_res": [
                    "c10_goal : and (Z.le 0 0) (Z.lt 0 (double_wB (S n)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1)))\n  (Z.lt (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1))\n     (double_wB (S n)))",
                    "_global_zn2z_to_Z : forall (znz : Type) (_ : Z) (_ : forall _ : znz, Z) (_ : zn2z znz), Z"
                ],
                "tactic_res": [
                    "c11_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1)))\n  (Z.lt\n     (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n     (double_wB (S n)))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c10_goal : and (Z.le 0 0) (Z.lt 0 (double_wB (S n)))",
                    "_global_double_wB : forall _ : nat, Z",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c12_goal : and (Z.le 0 0)\n  (Z.lt 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits (S n)))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : and (Z.le 0 0)\n  (Z.lt 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits (S n)))))"
                ],
                "tactic_res": [
                    "c13_goal : Z.le 0 0",
                    "c14_goal : Z.lt 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits (S n))))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c13_goal : Z.le 0 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c14_goal : Z.lt 0 (Z.pow 2 (Zpos (Pos.shiftl_nat w_digits (S n))))",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( U0 := _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( U0 := _i _i ) .",
                "tactic_args": [
                    "c3_IHn : forall x : word w n,\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))",
                    "c9_w0 : word w n"
                ],
                "tactic_res": [
                    "c11_U0 : and (Z.le 0 (double_to_Z n w0)) (Z.lt (double_to_Z n w0) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "assert ( U1 := _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( U1 := _i _i ) .",
                "tactic_args": [
                    "c3_IHn : forall x : word w n,\nand (Z.le 0 (double_to_Z n x)) (Z.lt (double_to_Z n x) (double_wB n))",
                    "c9_w1 : word w n"
                ],
                "tactic_res": [
                    "c11_U1 : and (Z.le 0 (double_to_Z n w1)) (Z.lt (double_to_Z n w1) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c11_goal : and\n  (Z.le 0\n     (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1)))\n  (Z.lt\n     (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n     (double_wB (S n)))"
                ],
                "tactic_res": [
                    "c15_goal : Z.le 0\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))",
                    "c16_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (double_wB (S n))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : Z.le 0\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))",
                    "c11_U1 : and (Z.le 0 (double_to_Z n w1)) (Z.lt (double_to_Z n w1) (double_wB n))",
                    "c11_U0 : and (Z.le 0 (double_to_Z n w0)) (Z.lt (double_to_Z n w0) (double_wB n))",
                    "c9_w0 : word w n",
                    "c9_w1 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( ( _i _i - 1 ) * _i _i + _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( ( _i _i - 1 ) * _i _i + _i _i ) .",
                "tactic_args": [
                    "c16_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (double_wB (S n))",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_double_wB : forall _ : nat, Z",
                    "c3_n : nat",
                    "_global_double_wB : forall _ : nat, Z",
                    "c3_n : nat",
                    "_global_double_wB : forall _ : nat, Z",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c17_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))",
                    "c18_goal : Z.le\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))\n  (double_wB (S n))"
                ]
            },
            {
                "tactic_sig": "assert ( double_to_Z _i _i * double_wB _i <= ( double_wB _i - 1 ) * double_wB _i ) .",
                "tactic_sig_no_out_arg": "assert ( double_to_Z _i _i * double_wB _i <= ( double_wB _i - 1 ) * double_wB _i ) .",
                "tactic_args": [
                    "c17_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))",
                    "c3_n : nat",
                    "c9_w0 : word w n",
                    "c3_n : nat",
                    "c3_n : nat",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c19_goal : Z.le (Z.mul (double_to_Z n w0) (double_wB n))\n  (Z.mul (Z.sub (double_wB n) 1) (double_wB n))",
                    "c20_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))",
                    "c20_H : Z.le (Z.mul (double_to_Z n w0) (double_wB n))\n  (Z.mul (Z.sub (double_wB n) 1) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : Z.le (Z.mul (double_to_Z n w0) (double_wB n))\n  (Z.mul (Z.sub (double_wB n) 1) (double_wB n))",
                    "_global_Z.mul_le_mono_nonneg_r : forall (n m p : Z) (_ : Z.le 0 p) (_ : Z.le n m),\n       Z.le (Z.mul n p) (Z.mul m p)"
                ],
                "tactic_res": [
                    "c21_goal : Z.le 0 (double_wB n)",
                    "c22_goal : Z.le (double_to_Z n w0) (Z.sub (double_wB n) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (double_wB n)",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c22_goal : Z.le (double_to_Z n w0) (Z.sub (double_wB n) 1)",
                    "c11_U0 : and (Z.le 0 (double_to_Z n w0)) (Z.lt (double_to_Z n w0) (double_wB n))",
                    "c9_w0 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.lt\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))",
                    "c20_H : Z.le (Z.mul (double_to_Z n w0) (double_wB n))\n  (Z.mul (Z.sub (double_wB n) 1) (double_wB n))",
                    "c11_U1 : and (Z.le 0 (double_to_Z n w1)) (Z.lt (double_to_Z n w1) (double_wB n))",
                    "c9_w0 : word w n",
                    "c9_w1 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c18_goal : Z.le\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))\n  (double_wB (S n))",
                    "_global_double_wB_wwB : forall n : nat,\n       eq (Z.mul (double_wB n) (double_wB n)) (double_wB (S n))"
                ],
                "tactic_res": [
                    "c23_goal : Z.le\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))\n  (Z.mul (double_wB n) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "replace ( ( double_wB _i - 1 ) * double_wB _i + double_wB _i ) with ( double_wB _i * double_wB _i ) .",
                "tactic_sig_no_out_arg": "replace ( ( double_wB _i - 1 ) * double_wB _i + double_wB _i ) with ( double_wB _i * double_wB _i ) .",
                "tactic_args": [
                    "c23_goal : Z.le\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))\n  (Z.mul (double_wB n) (double_wB n))",
                    "c3_n : nat",
                    "c3_n : nat",
                    "c3_n : nat",
                    "c3_n : nat",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c24_goal : Z.le (Z.mul (double_wB n) (double_wB n))\n  (Z.mul (double_wB n) (double_wB n))",
                    "c25_goal : eq (Z.mul (double_wB n) (double_wB n))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c24_goal : Z.le (Z.mul (double_wB n) (double_wB n))\n  (Z.mul (double_wB n) (double_wB n))",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c25_goal : eq (Z.mul (double_wB n) (double_wB n))\n  (Z.add (Z.mul (Z.sub (double_wB n) 1) (double_wB n)) (double_wB n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_get_low",
        "proof": [
            {
                "tactic_sig": "Lemma spec_get_low : forall n x , [ !n | x! ] < wB -> [ |get_low n x| ] = [ !n | x! ] .",
                "tactic_sig_no_out_arg": "Lemma spec_get_low : forall n x , [ !n | x! ] < wB -> [ |get_low n x| ] = [ !n | x! ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : word w n)\n  (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : word w n)\n  (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (x : word w 0) (_ : Z.lt (double_to_Z 0 x) (base w_digits)),\neq (w_to_Z (get_low 0 x)) (double_to_Z 0 x)",
                    "c4_goal : forall (n : nat)\n  (_ : forall (x : word w n)\n         (_ : Z.lt (double_to_Z n x) (base w_digits)),\n       eq (w_to_Z (get_low n x)) (double_to_Z n x)) \n  (x : word w (S n)) (_ : Z.lt (double_to_Z (S n) x) (base w_digits)),\neq (w_to_Z (get_low (S n) x)) (double_to_Z (S n) x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (x : word w 0) (_ : Z.lt (double_to_Z 0 x) (base w_digits)),\neq (w_to_Z (get_low 0 x)) (double_to_Z 0 x)",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n Hrec x .",
                "tactic_args": [
                    "c4_goal : forall (n : nat)\n  (_ : forall (x : word w n)\n         (_ : Z.lt (double_to_Z n x) (base w_digits)),\n       eq (w_to_Z (get_low n x)) (double_to_Z n x)) \n  (x : word w (S n)) (_ : Z.lt (double_to_Z (S n) x) (base w_digits)),\neq (w_to_Z (get_low (S n) x)) (double_to_Z (S n) x)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Z.lt (double_to_Z (S n) x) (base w_digits),\neq (w_to_Z (get_low (S n) x)) (double_to_Z (S n) x)",
                    "c5_n : nat",
                    "c5_Hrec : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c5_x : word w (S n)"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c5_goal : forall _ : Z.lt (double_to_Z (S n) x) (base w_digits),\neq (w_to_Z (get_low (S n) x)) (double_to_Z (S n) x)",
                    "c5_x : word w (S n)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : Z.lt (double_to_Z (S n) W0) (base w_digits),\neq (w_to_Z (get_low (S n) W0)) (double_to_Z (S n) W0)",
                    "c7_goal : forall (w0 w1 : word w n)\n  (_ : Z.lt (double_to_Z (S n) (WW w0 w1)) (base w_digits)),\neq (w_to_Z (get_low (S n) (WW w0 w1))) (double_to_Z (S n) (WW w0 w1))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c5_x : word w (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall _ : Z.lt (double_to_Z (S n) W0) (base w_digits),\neq (w_to_Z (get_low (S n) W0)) (double_to_Z (S n) W0)",
                    "c5_n : nat",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c5_x : word w (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros xx yy .",
                "tactic_args": [
                    "c7_goal : forall (w0 w1 : word w n)\n  (_ : Z.lt (double_to_Z (S n) (WW w0 w1)) (base w_digits)),\neq (w_to_Z (get_low (S n) (WW w0 w1))) (double_to_Z (S n) (WW w0 w1))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Z.lt (double_to_Z (S n) (WW xx yy)) (base w_digits),\neq (w_to_Z (get_low (S n) (WW xx yy))) (double_to_Z (S n) (WW xx yy))",
                    "c8_xx : word w n",
                    "c8_yy : word w n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : forall _ : Z.lt (double_to_Z (S n) (WW xx yy)) (base w_digits),\neq (w_to_Z (get_low (S n) (WW xx yy))) (double_to_Z (S n) (WW xx yy))"
                ],
                "tactic_res": [
                    "c9_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_double_to_Z _i _i ) as [ F1 _ ] .",
                "tactic_sig_no_out_arg": "destruct ( spec_double_to_Z _i _i ) as [ F1 _ ] .",
                "tactic_args": [
                    "c5_n : nat",
                    "c8_xx : word w n",
                    "c8_yy : word w n",
                    "c5_Hrec : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c9_F1 : Z.le 0 (double_to_Z n xx)"
                ]
            },
            {
                "tactic_sig": "Z.le_elim _i .",
                "tactic_sig_no_out_arg": "Z.le_elim _i .",
                "tactic_args": [
                    "c9_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))",
                    "c9_F1 : Z.le 0 (double_to_Z n xx)"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))",
                    "c10_F1 : Z.lt 0 (double_to_Z n xx)",
                    "c11_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))",
                    "c11_F1 : eq 0 (double_to_Z n xx)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))"
                ],
                "tactic_res": [
                    "c12_goal : eq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))",
                    "c12_H : Z.lt\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))\n  (base w_digits)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c12_goal : eq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))"
                ],
                "tactic_res": [
                    "c13_goal : False"
                ]
            },
            {
                "tactic_sig": "assert ( F3 := double_wB_more_digits _i ) .",
                "tactic_sig_no_out_arg": "assert ( F3 := double_wB_more_digits _i ) .",
                "tactic_args": [
                    "c5_n : nat"
                ],
                "tactic_res": [
                    "c13_F3 : Z.le (base w_digits) (double_wB n)"
                ]
            },
            {
                "tactic_sig": "destruct ( spec_double_to_Z _i _i ) as [ F4 _ ] .",
                "tactic_sig_no_out_arg": "destruct ( spec_double_to_Z _i _i ) as [ F4 _ ] .",
                "tactic_args": [
                    "c5_n : nat",
                    "c8_yy : word w n",
                    "c13_F3 : Z.le (base w_digits) (double_wB n)",
                    "c12_H : Z.lt\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))\n  (base w_digits)",
                    "c10_F1 : Z.lt 0 (double_to_Z n xx)",
                    "c5_Hrec : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_1 : w",
                    "c1_w_Bm1 : w"
                ],
                "tactic_res": [
                    "c13_F4 : Z.le 0 (double_to_Z n yy)"
                ]
            },
            {
                "tactic_sig": "assert ( F5 : 1 * wB <= [ !n | xx! ] * double_wB _i ) .",
                "tactic_sig_no_out_arg": "assert ( F5 : 1 * wB <= [ !n | xx! ] * double_wB _i ) .",
                "tactic_args": [
                    "c13_goal : False",
                    "c5_n : nat"
                ],
                "tactic_res": [
                    "c14_goal : Z.le (Z.mul 1 (base w_digits)) (Z.mul (double_to_Z n xx) (double_wB n))",
                    "c15_goal : False",
                    "c15_F5 : Z.le (Z.mul 1 (base w_digits)) (Z.mul (double_to_Z n xx) (double_wB n))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c15_goal : False",
                    "c15_F5 : Z.le (Z.mul 1 (base w_digits)) (Z.mul (double_to_Z n xx) (double_wB n))",
                    "c13_F4 : Z.le 0 (double_to_Z n yy)",
                    "c12_H : Z.lt\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))\n  (base w_digits)",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.le (Z.mul 1 (base w_digits)) (Z.mul (double_to_Z n xx) (double_wB n))",
                    "_global_Z.mul_le_mono_nonneg : forall (n m p q : Z) (_ : Z.le 0 n) (_ : Z.le n m) \n         (_ : Z.le 0 p) (_ : Z.le p q), Z.le (Z.mul n p) (Z.mul m q)"
                ],
                "tactic_res": [
                    "c16_goal : Z.le 0 1",
                    "c17_goal : Z.le 1 (double_to_Z n xx)",
                    "c18_goal : Z.le 0 (base w_digits)",
                    "c19_goal : Z.le (base w_digits) (double_wB n)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c16_goal : Z.le 0 1",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c17_goal : Z.le 1 (double_to_Z n xx)",
                    "c10_F1 : Z.lt 0 (double_to_Z n xx)",
                    "c8_xx : word w n",
                    "c5_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c19_goal : Z.le (base w_digits) (double_wB n)",
                    "c13_F3 : Z.le (base w_digits) (double_wB n)",
                    "c5_n : nat",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c18_goal : Z.le 0 (base w_digits)",
                    "_global_base : forall _ : positive, Z"
                ],
                "tactic_res": [
                    "c20_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.pow 2 (Zpos w_digits))",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c11_goal : forall\n  _ : Z.lt\n        (Z.add (Z.mul (double_to_Z n xx) (double_wB n))\n           (double_to_Z n yy)) (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul (double_to_Z n xx) (double_wB n)) (double_to_Z n yy))",
                    "c11_F1 : eq 0 (double_to_Z n xx)"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : Z.lt (Z.add (Z.mul 0 (double_wB n)) (double_to_Z n yy))\n        (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul 0 (double_wB n)) (double_to_Z n yy))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : Z.lt (Z.add (Z.mul 0 (double_wB n)) (double_to_Z n yy))\n        (base w_digits),\neq (w_to_Z (get_low n yy))\n  (Z.add (Z.mul 0 (double_wB n)) (double_to_Z n yy))",
                    "_global_Z.mul_0_l : forall n : Z, eq (Z.mul 0 n) 0",
                    "_global_Z.add_0_l : forall n : Z, eq (Z.add 0 n) n"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Z.lt (double_to_Z n yy) (base w_digits),\neq (w_to_Z (get_low n yy)) (double_to_Z n yy)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c22_goal : forall _ : Z.lt (double_to_Z n yy) (base w_digits),\neq (w_to_Z (get_low n yy)) (double_to_Z n yy)"
                ],
                "tactic_res": [
                    "c23_goal : eq (w_to_Z (get_low n yy)) (double_to_Z n yy)",
                    "c23_H : Z.lt (double_to_Z n yy) (base w_digits)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : eq (w_to_Z (get_low n yy)) (double_to_Z n yy)",
                    "c5_Hrec : forall (x : word w n) (_ : Z.lt (double_to_Z n x) (base w_digits)),\neq (w_to_Z (get_low n x)) (double_to_Z n x)"
                ],
                "tactic_res": [
                    "c24_goal : Z.lt (double_to_Z n yy) (base w_digits)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Z.lt (double_to_Z n yy) (base w_digits)",
                    "c23_H : Z.lt (double_to_Z n yy) (base w_digits)",
                    "c8_yy : word w n",
                    "c5_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_WW",
        "proof": [
            {
                "tactic_sig": "Lemma spec_double_WW : forall n ( h l : word w n ) , [ !S n|double_WW n h l! ] = [ !n|h! ] * double_wB n + [ !n|l! ] .",
                "tactic_sig_no_out_arg": "Lemma spec_double_WW : forall n ( h l : word w n ) , [ !S n|double_WW n h l! ] = [ !n|h! ] * double_wB n + [ !n|l! ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (h l : word w n),\neq (double_to_Z (S n) (double_WW n h l))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "induction n .",
                "tactic_sig_no_out_arg": "induction n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (h l : word w n),\neq (double_to_Z (S n) (double_WW n h l))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))"
                ],
                "tactic_res": [
                    "c2_goal : forall h l : word w 0,\neq (double_to_Z 1 (double_WW 0 h l))\n  (Z.add (Z.mul (double_to_Z 0 h) (double_wB 0)) (double_to_Z 0 l))",
                    "c3_goal : forall h l : word w (S n),\neq (double_to_Z (S (S n)) (double_WW (S n) h l))\n  (Z.add (Z.mul (double_to_Z (S n) h) (double_wB (S n)))\n     (double_to_Z (S n) l))",
                    "c3_IHn : forall h l : word w n,\neq (double_to_Z (S n) (double_WW n h l))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall h l : word w 0,\neq (double_to_Z 1 (double_WW 0 h l))\n  (Z.add (Z.mul (double_to_Z 0 h) (double_wB 0)) (double_to_Z 0 l))"
                ],
                "tactic_res": [
                    "c4_goal : forall h l : w,\neq (zn2z_to_Z (double_wB 0) w_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (double_wB 0)) (w_to_Z l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall h l : w,\neq (zn2z_to_Z (double_wB 0) w_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (double_wB 0)) (w_to_Z l))"
                ],
                "tactic_res": [
                    "c5_goal : eq (zn2z_to_Z (double_wB 0) w_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (double_wB 0)) (w_to_Z l))",
                    "c5_h : w",
                    "c5_l : w"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c5_goal : eq (zn2z_to_Z (double_wB 0) w_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (double_wB 0)) (w_to_Z l))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall h l : word w (S n),\neq (double_to_Z (S (S n)) (double_WW (S n) h l))\n  (Z.add (Z.mul (double_to_Z (S n) h) (double_wB (S n)))\n     (double_to_Z (S n) l))"
                ],
                "tactic_res": [
                    "c6_goal : forall h l : zn2z (word w n),\neq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match h with\n     | W0 => match l with\n             | W0 => W0\n             | WW _ _ => WW h l\n             end\n     | WW _ _ => WW h l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) h)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall h l : zn2z (word w n),\neq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match h with\n     | W0 => match l with\n             | W0 => W0\n             | WW _ _ => WW h l\n             end\n     | WW _ _ => WW h l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) h)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match h with\n     | W0 => match l with\n             | W0 => W0\n             | WW _ _ => WW h l\n             end\n     | WW _ _ => WW h l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) h)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c7_h : zn2z (word w n)",
                    "c7_l : zn2z (word w n)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match h with\n     | W0 => match l with\n             | W0 => W0\n             | WW _ _ => WW h l\n             end\n     | WW _ _ => WW h l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) h)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c7_h : zn2z (word w n)",
                    "c7_l : zn2z (word w n)",
                    "c3_IHn : forall h l : word w n,\neq (double_to_Z (S n) (double_WW n h l))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c3_n : nat",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match l with\n     | W0 => W0\n     | WW _ _ => WW W0 l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c9_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) (WW (WW w0 w1) l))\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1))\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c9_w1 : word w n",
                    "c9_w0 : word w n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) (WW (WW w0 w1) l))\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1))\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c7_l : zn2z (word w n)",
                    "c9_w0 : word w n",
                    "c9_w1 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c8_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n))\n     match l with\n     | W0 => W0\n     | WW _ _ => WW W0 l\n     end)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) l))",
                    "c7_l : zn2z (word w n)",
                    "c3_IHn : forall h l : word w n,\neq (double_to_Z (S n) (double_WW n h l))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c3_n : nat",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c10_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) W0)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) W0))",
                    "c11_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) (WW W0 (WW w0 w1)))\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n)))\n     (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1)))",
                    "c11_w1 : word w n",
                    "c11_w0 : word w n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) W0)\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n))) (zn2z_to_Z (double_wB n) (double_to_Z n) W0))",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq\n  (zn2z_to_Z (double_wB (S n))\n     (zn2z_to_Z (double_wB n) (double_to_Z n)) (WW W0 (WW w0 w1)))\n  (Z.add\n     (Z.mul (zn2z_to_Z (double_wB n) (double_to_Z n) W0)\n        (double_wB (S n)))\n     (zn2z_to_Z (double_wB n) (double_to_Z n) (WW w0 w1)))",
                    "c11_w0 : word w n",
                    "c11_w1 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_extend_aux",
        "proof": [
            {
                "tactic_sig": "Lemma spec_extend_aux : forall n x , [ !S n|extend_aux n x! ] = [ [ x ] ] .",
                "tactic_sig_no_out_arg": "Lemma spec_extend_aux : forall n x , [ !S n|extend_aux n x! ] = [ [ x ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : zn2z w),\neq (double_to_Z (S n) (extend_aux n x)) (ww_to_Z x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "induction n .",
                "tactic_sig_no_out_arg": "induction n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : zn2z w),\neq (double_to_Z (S n) (extend_aux n x)) (ww_to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : forall x : zn2z w, eq (double_to_Z 1 (extend_aux 0 x)) (ww_to_Z x)",
                    "c3_goal : forall x : zn2z w,\neq (double_to_Z (S (S n)) (extend_aux (S n) x)) (ww_to_Z x)",
                    "c3_IHn : forall x : zn2z w, eq (double_to_Z (S n) (extend_aux n x)) (ww_to_Z x)",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall x : zn2z w, eq (double_to_Z 1 (extend_aux 0 x)) (ww_to_Z x)"
                ],
                "tactic_res": [
                    "c4_goal : forall x : zn2z w, eq (zn2z_to_Z (double_wB 0) w_to_Z x) (ww_to_Z x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : forall x : zn2z w, eq (zn2z_to_Z (double_wB 0) w_to_Z x) (ww_to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall x : zn2z w,\neq (double_to_Z (S (S n)) (extend_aux (S n) x)) (ww_to_Z x)"
                ],
                "tactic_res": [
                    "c5_goal : forall x : zn2z w,\neq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n x))\n  (ww_to_Z x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c5_goal : forall x : zn2z w,\neq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n x))\n  (ww_to_Z x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_extend",
        "proof": [
            {
                "tactic_sig": "Lemma spec_extend : forall n x , [ !S n|extend n x! ] = [ |x| ] .",
                "tactic_sig_no_out_arg": "Lemma spec_extend : forall n x , [ !S n|extend n x! ] = [ |x| ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : w),\neq (double_to_Z (S n) (extend n x)) (w_to_Z x)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n x .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : w),\neq (double_to_Z (S n) (extend n x)) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c2_goal : eq (double_to_Z (S n) (extend n x)) (w_to_Z x)",
                    "c2_n : nat",
                    "c2_x : w"
                ]
            },
            {
                "tactic_sig": "assert ( H := _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( H := _i _i ) .",
                "tactic_args": [
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c2_x : w"
                ],
                "tactic_res": [
                    "c2_H : eq (ww_to_Z (w_0W x)) (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : eq (double_to_Z (S n) (extend n x)) (w_to_Z x)",
                    "_global_extend : forall (n : nat) (_ : w), word w (S n)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (double_to_Z (S n)\n     match w_0W x with\n     | W0 => W0\n     | WW _ _ => extend_aux n (w_0W x)\n     end) (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq\n  (double_to_Z (S n)\n     match w_0W x with\n     | W0 => W0\n     | WW _ _ => extend_aux n (w_0W x)\n     end) (w_to_Z x)",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c2_x : w",
                    "c2_H : eq (ww_to_Z (w_0W x)) (w_to_Z x)",
                    "c2_n : nat",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c4_goal : eq (double_to_Z (S n) W0) (w_to_Z x)",
                    "c4_H : eq (ww_to_Z W0) (w_to_Z x)",
                    "c5_goal : eq (double_to_Z (S n) (extend_aux n (WW w0 w1))) (w_to_Z x)",
                    "c5_H : eq (ww_to_Z (WW w0 w1)) (w_to_Z x)",
                    "c5_w1 : w",
                    "c5_w0 : w"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (double_to_Z (S n) W0) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c6_goal : eq 0 (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : eq 0 (w_to_Z x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : eq (double_to_Z (S n) (extend_aux n (WW w0 w1))) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c7_goal : eq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n (WW w0 w1)))\n  (w_to_Z x)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n (WW w0 w1)))\n  (w_to_Z x)",
                    "c5_H : eq (ww_to_Z (WW w0 w1)) (w_to_Z x)"
                ],
                "tactic_res": [
                    "c8_goal : eq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n (WW w0 w1)))\n  (ww_to_Z (WW w0 w1))"
                ]
            },
            {
                "tactic_sig": "exact ( spec_extend_aux _i ( WW _i _i ) ) .",
                "tactic_sig_no_out_arg": "exact ( spec_extend_aux _i ( WW _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : eq (zn2z_to_Z (double_wB n) (double_to_Z n) (extend_aux n (WW w0 w1)))\n  (ww_to_Z (WW w0 w1))",
                    "c2_n : nat",
                    "c5_w0 : w",
                    "c5_w1 : w"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_0",
        "proof": [
            {
                "tactic_sig": "Lemma spec_double_0 : forall n , [ !n|double_0 n! ] = 0 .",
                "tactic_sig_no_out_arg": "Lemma spec_double_0 : forall n , [ !n|double_0 n! ] = 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (double_to_Z n (double_0 n)) 0",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "destruct n as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (double_to_Z n (double_0 n)) 0",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c2_goal : eq (double_to_Z 0 (double_0 0)) 0",
                    "c3_goal : eq (double_to_Z (S n) (double_0 (S n))) 0",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c2_goal : eq (double_to_Z 0 (double_0 0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c3_goal : eq (double_to_Z (S n) (double_0 (S n))) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_double_split",
        "proof": [
            {
                "tactic_sig": "Lemma spec_double_split : forall n x , let ( h , l ) := double_split n x in [ !S n|x! ] = [ !n|h! ] * double_wB n + [ !n|l! ] .",
                "tactic_sig_no_out_arg": "Lemma spec_double_split : forall n x , let ( h , l ) := double_split n x in [ !S n|x! ] = [ !n|h! ] * double_wB n + [ !n|l! ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (x : zn2z (word w n)),\nlet (h, l) := double_split n x in\neq (double_to_Z (S n) x)\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "destruct x as [  _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (x : zn2z (word w n)),\nlet (h, l) := double_split n x in\neq (double_to_Z (S n) x)\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c2_goal : let (h, l) := double_split n W0 in\neq (double_to_Z (S n) W0)\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c2_n : nat",
                    "c3_goal : let (h, l) := double_split n (WW w0 w1) in\neq (double_to_Z (S n) (WW w0 w1))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c3_w1 : word w n",
                    "c3_w0 : word w n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : let (h, l) := double_split n W0 in\neq (double_to_Z (S n) W0)\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))"
                ],
                "tactic_res": [
                    "c4_goal : let (h, l) :=\n  match n return (prod (word w n) (word w n)) with\n  | 0%nat => pair w_0 w_0\n  | S n0 => pair W0 W0\n  end in\neq 0 (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : let (h, l) := double_split n (WW w0 w1) in\neq (double_to_Z (S n) (WW w0 w1))\n  (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))"
                ],
                "tactic_res": [
                    "c5_goal : eq (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))\n  (Z.add (Z.mul (double_to_Z n w0) (double_wB n)) (double_to_Z n w1))",
                    "c3_w0 : word w n",
                    "c3_w1 : word w n",
                    "c3_n : nat",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : let (h, l) :=\n  match n return (prod (word w n) (word w n)) with\n  | 0%nat => pair w_0 w_0\n  | S n0 => pair W0 W0\n  end in\neq 0 (Z.add (Z.mul (double_to_Z n h) (double_wB n)) (double_to_Z n l))",
                    "c2_n : nat",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c6_goal : eq 0\n  (Z.add (Z.mul (double_to_Z 0 w_0) (double_wB 0)) (double_to_Z 0 w_0))",
                    "c7_goal : eq 0\n  (Z.add (Z.mul (double_to_Z (S n) W0) (double_wB (S n)))\n     (double_to_Z (S n) W0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : eq 0\n  (Z.add (Z.mul (double_to_Z 0 w_0) (double_wB 0)) (double_to_Z 0 w_0))"
                ],
                "tactic_res": [
                    "c8_goal : eq 0 (Z.add (Z.mul (w_to_Z w_0) (double_wB 0)) (w_to_Z w_0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : eq 0\n  (Z.add (Z.mul (double_to_Z (S n) W0) (double_wB (S n)))\n     (double_to_Z (S n) W0))"
                ],
                "tactic_res": [
                    "c9_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : eq 0 (Z.add (Z.mul (w_to_Z w_0) (double_wB 0)) (w_to_Z w_0))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c10_goal : eq 0 (Z.add (Z.mul 0 (double_wB 0)) 0)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c10_goal : eq 0 (Z.add (Z.mul 0 (double_wB 0)) 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wB_lex_inv",
        "proof": [
            {
                "tactic_sig": "Lemma wB_lex_inv : forall a b c d , a < c -> a * wB + [ |b| ] < c * wB + [ |d| ] .",
                "tactic_sig_no_out_arg": "Lemma wB_lex_inv : forall a b c d , a < c -> a * wB + [ |b| ] < c * wB + [ |d| ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\nZ.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n  (Z.add (Z.mul c (base w_digits)) (w_to_Z d))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b c d H1 .",
                "tactic_args": [
                    "c1_goal : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\nZ.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n  (Z.add (Z.mul c (base w_digits)) (w_to_Z d))"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n  (Z.add (Z.mul c (base w_digits)) (w_to_Z d))",
                    "c2_a : Z",
                    "c2_b : w",
                    "c2_c : Z",
                    "c2_d : w",
                    "c2_H1 : Z.lt a c"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c2_goal : Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n  (Z.add (Z.mul c (base w_digits)) (w_to_Z d))",
                    "_global_beta_lex_inv : forall (a b c d beta : Z) (_ : Z.lt a c)\n         (_ : and (Z.le 0 b) (Z.lt b beta))\n         (_ : and (Z.le 0 d) (Z.lt d beta)),\n       Z.lt (Z.add (Z.mul a beta) b) (Z.add (Z.mul c beta) d)",
                    "c2_H1 : Z.lt a c"
                ],
                "tactic_res": [
                    "c3_goal : and (Z.le 0 (w_to_Z b)) (Z.lt (w_to_Z b) (base w_digits))",
                    "c4_goal : and (Z.le 0 (w_to_Z d)) (Z.lt (w_to_Z d) (base w_digits))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : and (Z.le 0 (w_to_Z b)) (Z.lt (w_to_Z b) (base w_digits))",
                    "c2_b : w",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 (w_to_Z d)) (Z.lt (w_to_Z d) (base w_digits))",
                    "c2_d : w",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_digits : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "spec_ww_compare",
        "proof": [
            {
                "tactic_sig": "Lemma spec_ww_compare : forall x y , ww_compare x y = Z.compare [ [ x ] ] [ [ y ] ] .",
                "tactic_sig_no_out_arg": "Lemma spec_ww_compare : forall x y , ww_compare x y = Z.compare [ [ x ] ] [ [ y ] ] .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : zn2z w,\neq (ww_compare x y) (Z.compare (ww_to_Z x) (ww_to_Z y))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0W : forall _ : w, zn2z w",
                    "c1_w_WW : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_Bm1 : w",
                    "c1_w_1 : w",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ]
            },
            {
                "tactic_sig": "destruct x as [ |xh xl ] .",
                "tactic_sig_no_out_arg": "destruct x as [ |xh xl ] .",
                "tactic_args": [
                    "c1_goal : forall x y : zn2z w,\neq (ww_compare x y) (Z.compare (ww_to_Z x) (ww_to_Z y))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c2_goal : forall y : zn2z w,\neq (ww_compare W0 y) (Z.compare (ww_to_Z W0) (ww_to_Z y))",
                    "c3_goal : forall y : zn2z w,\neq (ww_compare (WW xh xl) y)\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z y))",
                    "c3_xl : w",
                    "c3_xh : w"
                ]
            },
            {
                "tactic_sig": "destruct y as [ |yh yl ] .",
                "tactic_sig_no_out_arg": "destruct y as [ |yh yl ] .",
                "tactic_args": [
                    "c2_goal : forall y : zn2z w,\neq (ww_compare W0 y) (Z.compare (ww_to_Z W0) (ww_to_Z y))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c4_goal : eq (ww_compare W0 W0) (Z.compare (ww_to_Z W0) (ww_to_Z W0))",
                    "c5_goal : eq (ww_compare W0 (WW yh yl))\n  (Z.compare (ww_to_Z W0) (ww_to_Z (WW yh yl)))",
                    "c5_yl : w",
                    "c5_yh : w"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (ww_compare W0 W0) (Z.compare (ww_to_Z W0) (ww_to_Z W0))"
                ],
                "tactic_res": [
                    "c6_goal : eq Eq Eq"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : eq Eq Eq"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : eq (ww_compare W0 (WW yh yl))\n  (Z.compare (ww_to_Z W0) (ww_to_Z (WW yh yl)))"
                ],
                "tactic_res": [
                    "c7_goal : eq match w_compare w_0 yh with\n   | Eq => w_compare w_0 yl\n   | _ => Lt\n   end\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ]
            },
            {
                "tactic_sig": "destruct y as [ |yh yl ] .",
                "tactic_sig_no_out_arg": "destruct y as [ |yh yl ] .",
                "tactic_args": [
                    "c3_goal : forall y : zn2z w,\neq (ww_compare (WW xh xl) y)\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z y))",
                    "c3_xh : w",
                    "c3_xl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_compare : forall (_ : w) (_ : w), comparison",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive",
                    "c1_w_0 : w",
                    "c1_w : univ_of_cycles"
                ],
                "tactic_res": [
                    "c8_goal : eq (ww_compare (WW xh xl) W0)\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z W0))",
                    "c9_goal : eq (ww_compare (WW xh xl) (WW yh yl))\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z (WW yh yl)))",
                    "c9_yl : w",
                    "c9_yh : w"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (ww_compare (WW xh xl) W0)\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z W0))"
                ],
                "tactic_res": [
                    "c10_goal : eq match w_compare xh w_0 with\n   | Eq => w_compare xl w_0\n   | _ => Gt\n   end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : eq (ww_compare (WW xh xl) (WW yh yl))\n  (Z.compare (ww_to_Z (WW xh xl)) (ww_to_Z (WW yh yl)))"
                ],
                "tactic_res": [
                    "c11_goal : eq\n  match w_compare xh yh with\n  | Eq => w_compare xl yl\n  | Lt => Lt\n  | Gt => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ]
            },
            {
                "tactic_sig": "rewrite 2 _i , _i .",
                "tactic_sig_no_out_arg": "rewrite 2 _i , _i .",
                "tactic_args": [
                    "c7_goal : eq match w_compare w_0 yh with\n   | Eq => w_compare w_0 yl\n   | _ => Lt\n   end\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c12_goal : eq\n  match Z.compare 0 (w_to_Z yh) with\n  | Eq => Z.compare 0 (w_to_Z yl)\n  | _ => Lt\n  end\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.compare_spec 0 [ |yh| ] ) as [ H|H|H ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.compare_spec 0 [ |yh| ] ) as [ H|H|H ] .",
                "tactic_args": [
                    "c12_goal : eq\n  match Z.compare 0 (w_to_Z yh) with\n  | Eq => Z.compare 0 (w_to_Z yl)\n  | _ => Lt\n  end\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c5_yh : w",
                    "c5_yl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c13_goal : eq (Z.compare 0 (w_to_Z yl))\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c13_H : eq 0 (w_to_Z yh)",
                    "c14_goal : eq Lt\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c14_H : Z.lt 0 (w_to_Z yh)",
                    "c15_goal : eq Lt\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c15_H : Z.lt (w_to_Z yh) 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c13_goal : eq (Z.compare 0 (w_to_Z yl))\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end",
                    "c13_H : eq 0 (w_to_Z yh)"
                ],
                "tactic_res": [
                    "c16_goal : eq (Z.compare 0 (w_to_Z yl))\n  match Z.add (Z.mul 0 (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : eq (Z.compare 0 (w_to_Z yl))\n  match Z.add (Z.mul 0 (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ],
                "tactic_res": [
                    "c17_goal : eq match w_to_Z yl with\n   | 0 => Eq\n   | Zpos _ => Lt\n   | Zneg _ => Gt\n   end match w_to_Z yl with\n       | 0 => Eq\n       | Zpos _ => Lt\n       | Zneg _ => Gt\n       end"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c17_goal : eq match w_to_Z yl with\n   | 0 => Eq\n   | Zpos _ => Lt\n   | Zneg _ => Gt\n   end match w_to_Z yl with\n       | 0 => Eq\n       | Zpos _ => Lt\n       | Zneg _ => Gt\n       end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c14_goal : eq Lt\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ],
                "tactic_res": [
                    "c18_goal : eq\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end Lt"
                ]
            },
            {
                "tactic_sig": "change ( 0 < [ |yh| ] * wB + [ |yl| ] ) .",
                "tactic_sig_no_out_arg": "change ( 0 < [ |yh| ] * wB + [ |yl| ] ) .",
                "tactic_args": [
                    "c18_goal : eq\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end Lt"
                ],
                "tactic_res": [
                    "c19_goal : Z.lt 0 (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))"
                ]
            },
            {
                "tactic_sig": "change 0 with ( 0 * wB + 0 ) .",
                "tactic_sig_no_out_arg": "change 0 with ( 0 * wB + 0 ) .",
                "tactic_args": [
                    "c19_goal : Z.lt 0 (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))"
                ],
                "tactic_res": [
                    "c20_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) 0)\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 2 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 2 .",
                "tactic_args": [
                    "c20_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) 0)\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c21_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_0))\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_0))\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))",
                    "_global_wB_lex_inv : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\n       Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n         (Z.add (Z.mul c (base w_digits)) (w_to_Z d))"
                ],
                "tactic_res": [
                    "c22_goal : Z.lt 0 (w_to_Z yh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c22_goal : Z.lt 0 (w_to_Z yh)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "absurd ( 0 <= [ |yh| ] ) .",
                "tactic_sig_no_out_arg": "absurd ( 0 <= [ |yh| ] ) .",
                "tactic_args": [
                    "c15_goal : eq Lt\n  match Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl) with\n  | 0 => Eq\n  | Zpos _ => Lt\n  | Zneg _ => Gt\n  end"
                ],
                "tactic_res": [
                    "c23_goal : not (Z.le 0 (w_to_Z yh))",
                    "c24_goal : Z.le 0 (w_to_Z yh)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : not (Z.le 0 (w_to_Z yh))",
                    "_global_Z.lt_nge : forall n m : Z, iff (Z.lt n m) (not (Z.le m n))"
                ],
                "tactic_res": [
                    "c25_goal : Z.lt (w_to_Z yh) 0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c25_goal : Z.lt (w_to_Z yh) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c5_yh : w",
                    "c15_H : Z.lt (w_to_Z yh) 0",
                    "c5_yl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w"
                ],
                "tactic_res": [
                    "c24_H1 : Z.lt (w_to_Z yh) (base w_digits)",
                    "c24_H0 : Z.le 0 (w_to_Z yh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c24_goal : Z.le 0 (w_to_Z yh)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite 2 _i , _i .",
                "tactic_sig_no_out_arg": "rewrite 2 _i , _i .",
                "tactic_args": [
                    "c10_goal : eq match w_compare xh w_0 with\n   | Eq => w_compare xl w_0\n   | _ => Gt\n   end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c26_goal : eq\n  match Z.compare (w_to_Z xh) 0 with\n  | Eq => Z.compare (w_to_Z xl) 0\n  | _ => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.compare_spec [ |xh| ] 0 ) as [ H|H|H ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.compare_spec [ |xh| ] 0 ) as [ H|H|H ] .",
                "tactic_args": [
                    "c26_goal : eq\n  match Z.compare (w_to_Z xh) 0 with\n  | Eq => Z.compare (w_to_Z xl) 0\n  | _ => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c3_xh : w",
                    "c3_xl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c27_goal : eq (Z.compare (w_to_Z xl) 0)\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c27_H : eq (w_to_Z xh) 0",
                    "c28_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c28_H : Z.lt (w_to_Z xh) 0",
                    "c29_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c29_H : Z.lt 0 (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : eq (Z.compare (w_to_Z xl) 0)\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)",
                    "c27_H : eq (w_to_Z xh) 0"
                ],
                "tactic_res": [
                    "c30_goal : eq (Z.compare (w_to_Z xl) 0)\n  (Z.compare (Z.add (Z.mul 0 (base w_digits)) (w_to_Z xl)) 0)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : eq (Z.compare (w_to_Z xl) 0)\n  (Z.compare (Z.add (Z.mul 0 (base w_digits)) (w_to_Z xl)) 0)"
                ],
                "tactic_res": [
                    "c31_goal : eq (Z.compare (w_to_Z xl) 0) (Z.compare (w_to_Z xl) 0)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c31_goal : eq (Z.compare (w_to_Z xl) 0) (Z.compare (w_to_Z xl) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "absurd ( 0 <= [ |xh| ] ) .",
                "tactic_sig_no_out_arg": "absurd ( 0 <= [ |xh| ] ) .",
                "tactic_args": [
                    "c28_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)"
                ],
                "tactic_res": [
                    "c32_goal : not (Z.le 0 (w_to_Z xh))",
                    "c33_goal : Z.le 0 (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : not (Z.le 0 (w_to_Z xh))",
                    "_global_Z.lt_nge : forall n m : Z, iff (Z.lt n m) (not (Z.le m n))"
                ],
                "tactic_res": [
                    "c34_goal : Z.lt (w_to_Z xh) 0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c34_goal : Z.lt (w_to_Z xh) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c3_xh : w",
                    "c28_H : Z.lt (w_to_Z xh) 0",
                    "c3_xl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w"
                ],
                "tactic_res": [
                    "c33_H1 : Z.lt (w_to_Z xh) (base w_digits)",
                    "c33_H0 : Z.le 0 (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c33_goal : Z.le 0 (w_to_Z xh)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "comp2ord .",
                "tactic_sig_no_out_arg": "comp2ord .",
                "tactic_args": [
                    "c29_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl)) 0)"
                ],
                "tactic_res": [
                    "c35_goal : Z.lt 0 (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))"
                ]
            },
            {
                "tactic_sig": "change 0 with ( 0 * wB + 0 ) .",
                "tactic_sig_no_out_arg": "change 0 with ( 0 * wB + 0 ) .",
                "tactic_args": [
                    "c35_goal : Z.lt 0 (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))"
                ],
                "tactic_res": [
                    "c36_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) 0)\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 2 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 2 .",
                "tactic_args": [
                    "c36_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) 0)\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0"
                ],
                "tactic_res": [
                    "c37_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_0))\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c37_goal : Z.lt (Z.add (Z.mul 0 (base w_digits)) (w_to_Z w_0))\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))",
                    "_global_wB_lex_inv : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\n       Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n         (Z.add (Z.mul c (base w_digits)) (w_to_Z d))"
                ],
                "tactic_res": [
                    "c38_goal : Z.lt 0 (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c38_goal : Z.lt 0 (w_to_Z xh)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite 2 _i .",
                "tactic_sig_no_out_arg": "rewrite 2 _i .",
                "tactic_args": [
                    "c11_goal : eq\n  match w_compare xh yh with\n  | Eq => w_compare xl yl\n  | Lt => Lt\n  | Gt => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))"
                ],
                "tactic_res": [
                    "c39_goal : eq\n  match Z.compare (w_to_Z xh) (w_to_Z yh) with\n  | Eq => Z.compare (w_to_Z xl) (w_to_Z yl)\n  | Lt => Lt\n  | Gt => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.compare_spec [ |xh| ] [ |yh| ] ) as [ H|H|H ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.compare_spec [ |xh| ] [ |yh| ] ) as [ H|H|H ] .",
                "tactic_args": [
                    "c39_goal : eq\n  match Z.compare (w_to_Z xh) (w_to_Z yh) with\n  | Eq => Z.compare (w_to_Z xl) (w_to_Z yl)\n  | Lt => Lt\n  | Gt => Gt\n  end\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c3_xh : w",
                    "c3_xl : w",
                    "c9_yh : w",
                    "c9_yl : w",
                    "c1_spec_w_compare : forall x y : w, eq (w_compare x y) (Z.compare (w_to_Z x) (w_to_Z y))",
                    "c1_spec_to_Z : forall x : w, and (Z.le 0 (w_to_Z x)) (Z.lt (w_to_Z x) (base w_digits))",
                    "c1_spec_w_0W : forall l : w, eq (ww_to_Z (w_0W l)) (w_to_Z l)",
                    "c1_spec_w_WW : forall h l : w,\neq (ww_to_Z (w_WW h l))\n  (Z.add (Z.mul (w_to_Z h) (base w_digits)) (w_to_Z l))",
                    "c1_spec_w_Bm1 : eq (w_to_Z w_Bm1) (Z.sub (base w_digits) 1)",
                    "c1_spec_w_1 : eq (w_to_Z w_1) 1",
                    "c1_spec_w_0 : eq (w_to_Z w_0) 0",
                    "c1_w_to_Z : forall _ : w, Z",
                    "c1_w_add : forall (_ : w) (_ : w), zn2z w",
                    "c1_w_zdigits : w",
                    "c1_w_digits : positive"
                ],
                "tactic_res": [
                    "c40_goal : eq (Z.compare (w_to_Z xl) (w_to_Z yl))\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c40_H : eq (w_to_Z xh) (w_to_Z yh)",
                    "c41_goal : eq Lt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c41_H : Z.lt (w_to_Z xh) (w_to_Z yh)",
                    "c42_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c42_H : Z.lt (w_to_Z yh) (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c40_goal : eq (Z.compare (w_to_Z xl) (w_to_Z yl))\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))",
                    "c40_H : eq (w_to_Z xh) (w_to_Z yh)"
                ],
                "tactic_res": [
                    "c43_goal : eq (Z.compare (w_to_Z xl) (w_to_Z yl))\n  (Z.compare (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c43_goal : eq (Z.compare (w_to_Z xl) (w_to_Z yl))\n  (Z.compare (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ],
                "tactic_res": [
                    "c44_goal : eq\n  (Z.compare (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))\n  (Z.compare (w_to_Z xl) (w_to_Z yl))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c44_goal : eq\n  (Z.compare (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))\n  (Z.compare (w_to_Z xl) (w_to_Z yl))",
                    "_global_Z.add_compare_mono_l : forall n m p : Z,\n       eq (Z.compare (Z.add n m) (Z.add n p)) (Z.compare m p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "comp2ord .",
                "tactic_sig_no_out_arg": "comp2ord .",
                "tactic_args": [
                    "c41_goal : eq Lt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ],
                "tactic_res": [
                    "c45_goal : Z.lt (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c45_goal : Z.lt (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n  (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))",
                    "_global_wB_lex_inv : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\n       Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n         (Z.add (Z.mul c (base w_digits)) (w_to_Z d))"
                ],
                "tactic_res": [
                    "c46_goal : Z.lt (w_to_Z xh) (w_to_Z yh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c46_goal : Z.lt (w_to_Z xh) (w_to_Z yh)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "comp2ord .",
                "tactic_sig_no_out_arg": "comp2ord .",
                "tactic_args": [
                    "c42_goal : eq Gt\n  (Z.compare (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))\n     (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl)))"
                ],
                "tactic_res": [
                    "c47_goal : Z.lt (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c47_goal : Z.lt (Z.add (Z.mul (w_to_Z yh) (base w_digits)) (w_to_Z yl))\n  (Z.add (Z.mul (w_to_Z xh) (base w_digits)) (w_to_Z xl))",
                    "_global_wB_lex_inv : forall (a : Z) (b : w) (c : Z) (d : w) (_ : Z.lt a c),\n       Z.lt (Z.add (Z.mul a (base w_digits)) (w_to_Z b))\n         (Z.add (Z.mul c (base w_digits)) (w_to_Z d))"
                ],
                "tactic_res": [
                    "c48_goal : Z.lt (w_to_Z yh) (w_to_Z xh)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c48_goal : Z.lt (w_to_Z yh) (w_to_Z xh)"
                ],
                "tactic_res": []
            }
        ]
    }
]