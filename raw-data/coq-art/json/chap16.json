[
    {
        "lemma_name": "verif_divide",
        "proof": [
            {
                "tactic_sig": "Theorem verif_divide : forall m p : nat , 0 < m -> 0 < p -> ( exists q : nat , m = q * p ) -> ( Z_of_nat m mod Z_of_nat p = 0 ) % Z .",
                "tactic_sig_no_out_arg": "Theorem verif_divide : forall m p : nat , 0 < m -> 0 < p -> ( exists q : nat , m = q * p ) -> ( Z_of_nat m mod Z_of_nat p = 0 ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m p : nat) (_ : lt 0 m) (_ : lt 0 p)\n  (_ : ex (fun q : nat => eq m (Init.Nat.mul q p))),\neq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros m p Hltm Hltp ( q , Heq ) .",
                "tactic_args": [
                    "c1_goal : forall (m p : nat) (_ : lt 0 m) (_ : lt 0 p)\n  (_ : ex (fun q : nat => eq m (Init.Nat.mul q p))),\neq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0%Z"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0%Z",
                    "c2_m : nat",
                    "c2_p : nat",
                    "c2_Hltm : lt 0 m",
                    "c2_Hltp : lt 0 p",
                    "c2_q : nat",
                    "c2_Heq : eq m (Init.Nat.mul q p)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0%Z",
                    "c2_Heq : eq m (Init.Nat.mul q p)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.modulo (Z.of_nat (Init.Nat.mul q p)) (Z.of_nat p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq (Z.modulo (Z.of_nat (Init.Nat.mul q p)) (Z.of_nat p)) 0%Z",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c4_goal : eq (Z.modulo (Z.mul (Z.of_nat q) (Z.of_nat p)) (Z.of_nat p)) 0%Z"
                ]
            },
            {
                "tactic_sig": "replace ( Z_of_nat _i * Z_of_nat _i ) % Z with ( 0 + Z_of_nat _i * Z_of_nat _i ) % Z .",
                "tactic_sig_no_out_arg": "replace ( Z_of_nat _i * Z_of_nat _i ) % Z with ( 0 + Z_of_nat _i * Z_of_nat _i ) % Z .",
                "tactic_args": [
                    "c4_goal : eq (Z.modulo (Z.mul (Z.of_nat q) (Z.of_nat p)) (Z.of_nat p)) 0%Z",
                    "c2_q : nat",
                    "c2_p : nat",
                    "c2_q : nat",
                    "c2_p : nat"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Z.modulo (Z.add 0%Z (Z.mul (Z.of_nat q) (Z.of_nat p))) (Z.of_nat p))\n  0%Z",
                    "c6_goal : eq (Z.add 0%Z (Z.mul (Z.of_nat q) (Z.of_nat p)))\n  (Z.mul (Z.of_nat q) (Z.of_nat p))"
                ]
            },
            {
                "tactic_sig": "try ring .",
                "tactic_sig_no_out_arg": "try ring .",
                "tactic_args": [
                    "c6_goal : eq (Z.add 0%Z (Z.mul (Z.of_nat q) (Z.of_nat p)))\n  (Z.mul (Z.of_nat q) (Z.of_nat p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq\n  (Z.modulo (Z.add 0%Z (Z.mul (Z.of_nat q) (Z.of_nat p))) (Z.of_nat p))\n  0%Z",
                    "_global_Z_mod_plus : forall (a b c : Z) (_ : Z.gt c 0),\n       eq (Z.modulo (Z.add a (Z.mul b c)) c) (Z.modulo a c)"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.modulo 0%Z (Z.of_nat p)) 0%Z",
                    "c8_goal : Z.gt (Z.of_nat p) 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (Z.modulo 0%Z (Z.of_nat p)) 0%Z",
                    "c2_p : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c8_goal : Z.gt (Z.of_nat p) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "divisor_smaller",
        "proof": [
            {
                "tactic_sig": "Theorem divisor_smaller : forall m p : nat , 0 < m -> forall q : nat , m = q * p -> q <= m .",
                "tactic_sig_no_out_arg": "Theorem divisor_smaller : forall m p : nat , 0 < m -> forall q : nat , m = q * p -> q <= m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m p : nat) (_ : lt 0 m) (q : nat) (_ : eq m (Init.Nat.mul q p)),\nle q m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros m p Hlt .",
                "tactic_args": [
                    "c1_goal : forall (m p : nat) (_ : lt 0 m) (q : nat) (_ : eq m (Init.Nat.mul q p)),\nle q m"
                ],
                "tactic_res": [
                    "c2_goal : forall (q : nat) (_ : eq m (Init.Nat.mul q p)), le q m",
                    "c2_m : nat",
                    "c2_p : nat",
                    "c2_Hlt : lt 0 m"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall (q : nat) (_ : eq m (Init.Nat.mul q p)), le q m",
                    "c2_p : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (q : nat) (_ : eq m (Init.Nat.mul q 0)), le q m",
                    "c4_goal : forall (n q : nat) (_ : eq m (Init.Nat.mul q (S n))), le q m"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros q Heq .",
                "tactic_args": [
                    "c3_goal : forall (q : nat) (_ : eq m (Init.Nat.mul q 0)), le q m"
                ],
                "tactic_res": [
                    "c5_goal : le q m",
                    "c5_q : nat",
                    "c5_Heq : eq m (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c5_Heq : eq m (Init.Nat.mul q 0)",
                    "c5_Hlt : lt 0 m"
                ],
                "tactic_res": [
                    "c5_Hlt : lt 0 (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)",
                    "c5_Hlt : lt 0 (Init.Nat.mul q 0)"
                ],
                "tactic_res": [
                    "c5_Hlt : lt 0 (Nat.mul 0 q)"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c5_goal : le q m"
                ],
                "tactic_res": [
                    "c6_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c6_goal : lt 0 0",
                    "c5_Hlt : lt 0 (Nat.mul 0 q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' q .",
                "tactic_args": [
                    "c4_goal : forall (n q : nat) (_ : eq m (Init.Nat.mul q (S n))), le q m"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq m (Init.Nat.mul q (S p')), le q m",
                    "c7_p' : nat",
                    "c7_q : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c7_goal : forall _ : eq m (Init.Nat.mul q (S p')), le q m",
                    "c7_q : nat"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq m (Init.Nat.mul 0 (S p')), le 0 m",
                    "c9_goal : forall (n : nat) (_ : eq m (Init.Nat.mul (S n) (S p'))), le (S n) m"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c8_goal : forall _ : eq m (Init.Nat.mul 0 (S p')), le 0 m"
                ],
                "tactic_res": [
                    "c10_goal : le 0 m",
                    "c10_Heq : eq m (Init.Nat.mul 0 (S p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c10_Heq : eq m (Init.Nat.mul 0 (S p'))",
                    "c10_Hlt : lt 0 m"
                ],
                "tactic_res": [
                    "c10_Hlt : lt 0 (Init.Nat.mul 0 (S p'))"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c10_goal : le 0 m"
                ],
                "tactic_res": [
                    "c11_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c11_goal : lt 0 0",
                    "c10_Hlt : lt 0 (Init.Nat.mul 0 (S p'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros q' Heq .",
                "tactic_args": [
                    "c9_goal : forall (n : nat) (_ : eq m (Init.Nat.mul (S n) (S p'))), le (S n) m"
                ],
                "tactic_res": [
                    "c12_goal : le (S q') m",
                    "c12_q' : nat",
                    "c12_Heq : eq m (Init.Nat.mul (S q') (S p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : le (S q') m",
                    "c12_Heq : eq m (Init.Nat.mul (S q') (S p'))"
                ],
                "tactic_res": [
                    "c13_goal : le (S q') (Init.Nat.mul (S q') (S p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : le (S q') (Init.Nat.mul (S q') (S p'))",
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)"
                ],
                "tactic_res": [
                    "c14_goal : le (S q') (Nat.mul (S p') (S q'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : le (S q') (Nat.mul (S p') (S q'))"
                ],
                "tactic_res": [
                    "c15_goal : le (S q') (S (Nat.add q' (Nat.mul p' (S q'))))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c15_goal : le (S q') (S (Nat.add q' (Nat.mul p' (S q'))))",
                    "c7_p' : nat",
                    "c12_q' : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zabs_nat_0",
        "proof": [
            {
                "tactic_sig": "Theorem Zabs_nat_0 : forall x : Z , Z.abs_nat x = 0 -> ( x = 0 ) % Z .",
                "tactic_sig_no_out_arg": "Theorem Zabs_nat_0 : forall x : Z , Z.abs_nat x = 0 -> ( x = 0 ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : Z) (_ : eq (Z.abs_nat x) 0), eq x 0%Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : Z) (_ : eq (Z.abs_nat x) 0), eq x 0%Z"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (Z.abs_nat x) 0, eq x 0%Z",
                    "c2_x : Z"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (Z.abs_nat x) 0, eq x 0%Z",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq (Z.abs_nat 0%Z) 0, eq 0%Z 0%Z",
                    "c4_goal : forall (p : positive) (_ : eq (Z.abs_nat (Zpos p)) 0), eq (Zpos p) 0%Z",
                    "c5_goal : forall (p : positive) (_ : eq (Z.abs_nat (Zneg p)) 0), eq (Zneg p) 0%Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (Z.abs_nat 0%Z) 0, eq 0%Z 0%Z"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq 0 0, eq 0%Z 0%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall _ : eq 0 0, eq 0%Z 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Heq .",
                "tactic_args": [
                    "c4_goal : forall (p : positive) (_ : eq (Z.abs_nat (Zpos p)) 0), eq (Zpos p) 0%Z"
                ],
                "tactic_res": [
                    "c7_goal : eq (Zpos p) 0%Z",
                    "c7_p : positive",
                    "c7_Heq : eq (Z.abs_nat (Zpos p)) 0"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c7_goal : eq (Zpos p) 0%Z"
                ],
                "tactic_res": [
                    "c8_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "pattern 0 at 2 .",
                "tactic_sig_no_out_arg": "pattern 0 at 2 .",
                "tactic_args": [
                    "c8_goal : lt 0 0"
                ],
                "tactic_res": [
                    "c9_goal : (fun n : nat => lt 0 n) 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : (fun n : nat => lt 0 n) 0",
                    "c7_Heq : eq (Z.abs_nat (Zpos p)) 0"
                ],
                "tactic_res": [
                    "c10_goal : lt 0 (Z.abs_nat (Zpos p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : lt 0 (Z.abs_nat (Zpos p))"
                ],
                "tactic_res": [
                    "c11_goal : lt 0 (Pos.to_nat p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : lt 0 (Pos.to_nat p)",
                    "_global_lt_O_nat_of_P : forall p : positive, lt 0 (Pos.to_nat p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Heq .",
                "tactic_args": [
                    "c5_goal : forall (p : positive) (_ : eq (Z.abs_nat (Zneg p)) 0), eq (Zneg p) 0%Z"
                ],
                "tactic_res": [
                    "c12_goal : eq (Zneg p) 0%Z",
                    "c12_p : positive",
                    "c12_Heq : eq (Z.abs_nat (Zneg p)) 0"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c12_goal : eq (Zneg p) 0%Z"
                ],
                "tactic_res": [
                    "c13_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "pattern 0 at 2 .",
                "tactic_sig_no_out_arg": "pattern 0 at 2 .",
                "tactic_args": [
                    "c13_goal : lt 0 0"
                ],
                "tactic_res": [
                    "c14_goal : (fun n : nat => lt 0 n) 0"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c14_goal : (fun n : nat => lt 0 n) 0",
                    "c12_Heq : eq (Z.abs_nat (Zneg p)) 0"
                ],
                "tactic_res": [
                    "c15_goal : lt 0 (Z.abs_nat (Zneg p))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : lt 0 (Z.abs_nat (Zneg p))"
                ],
                "tactic_res": [
                    "c16_goal : lt 0 (Pos.to_nat p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : lt 0 (Pos.to_nat p)",
                    "_global_lt_O_nat_of_P : forall p : positive, lt 0 (Pos.to_nat p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Z_to_nat_and_back",
        "proof": [
            {
                "tactic_sig": "Theorem Z_to_nat_and_back : forall x : Z , ( 0 <= x ) % Z -> ( Z.of_nat ( Z.abs_nat x ) ) = x .",
                "tactic_sig_no_out_arg": "Theorem Z_to_nat_and_back : forall x : Z , ( 0 <= x ) % Z -> ( Z.of_nat ( Z.abs_nat x ) ) = x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Z.le 0 x, eq (Z.of_nat (Z.abs_nat x)) x",
                    "c2_x : Z"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall _ : Z.le 0 x, eq (Z.of_nat (Z.abs_nat x)) x",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Z.le 0 0, eq (Z.of_nat (Z.abs_nat 0%Z)) 0%Z",
                    "c4_goal : forall (p : positive) (_ : Z.le 0 (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)",
                    "c5_goal : forall (p : positive) (_ : Z.le 0 (Zneg p)),\neq (Z.of_nat (Z.abs_nat (Zneg p))) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall _ : Z.le 0 0, eq (Z.of_nat (Z.abs_nat 0%Z)) 0%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Hd .",
                "tactic_args": [
                    "c4_goal : forall (p : positive) (_ : Z.le 0 (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)"
                ],
                "tactic_res": [
                    "c6_goal : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)",
                    "c6_p : positive",
                    "c6_Hd : Z.le 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c6_goal : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)",
                    "c6_p : positive"
                ],
                "tactic_res": [
                    "c7_goal : forall (p : positive) (_ : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos (xI p)))) (Zpos (xI p))",
                    "c8_goal : forall (p : positive) (_ : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos (xO p)))) (Zpos (xO p))",
                    "c9_goal : eq (Z.of_nat (Z.abs_nat 1%Z)) 1%Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : forall (p : positive) (_ : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos (xI p)))) (Zpos (xI p))",
                    "_global_Z.abs_nat : forall _ : Z, nat"
                ],
                "tactic_res": [
                    "c10_goal : forall (p : positive) (_ : eq (Z.of_nat (Pos.to_nat p)) (Zpos p)),\neq (Z.of_nat (Pos.to_nat (xI p))) (Zpos (xI p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hrec .",
                "tactic_args": [
                    "c10_goal : forall (p : positive) (_ : eq (Z.of_nat (Pos.to_nat p)) (Zpos p)),\neq (Z.of_nat (Pos.to_nat (xI p))) (Zpos (xI p))"
                ],
                "tactic_res": [
                    "c11_goal : eq (Z.of_nat (Pos.to_nat (xI p'))) (Zpos (xI p'))",
                    "c11_p' : positive",
                    "c11_Hrec : eq (Z.of_nat (Pos.to_nat p')) (Zpos p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : eq (Z.of_nat (Pos.to_nat (xI p'))) (Zpos (xI p'))",
                    "_global_nat_of_P_xI : forall p : positive,\n       eq (Pos.to_nat (xI p)) (S (Init.Nat.mul 2 (Pos.to_nat p)))"
                ],
                "tactic_res": [
                    "c12_goal : eq (Z.of_nat (S (Init.Nat.mul 2 (Pos.to_nat p')))) (Zpos (xI p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : eq (Z.of_nat (S (Init.Nat.mul 2 (Pos.to_nat p')))) (Zpos (xI p'))",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c13_goal : eq (Z.succ (Z.of_nat (Init.Nat.mul 2 (Pos.to_nat p')))) (Zpos (xI p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq (Z.succ (Z.of_nat (Init.Nat.mul 2 (Pos.to_nat p')))) (Zpos (xI p'))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c14_goal : eq (Z.succ (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))))\n  (Zpos (xI p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : eq (Z.succ (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))))\n  (Zpos (xI p'))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c15_goal : eq (Z.succ (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))))\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c15_goal : eq (Z.succ (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))))\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)",
                    "_global_Z.succ : forall _ : Z, Z"
                ],
                "tactic_res": [
                    "c16_goal : eq (Z.add (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))) 1%Z)\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : eq (Z.add (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))) 1%Z)\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)",
                    "c11_Hrec : eq (Z.of_nat (Pos.to_nat p')) (Zpos p')"
                ],
                "tactic_res": [
                    "c17_goal : eq (Z.add (Z.mul (Z.of_nat 2) (Zpos p')) 1%Z)\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : eq (Z.add (Z.mul (Z.of_nat 2) (Zpos p')) 1%Z)\n  (Z.add (Z.mul 2%Z (Zpos p')) 1%Z)"
                ],
                "tactic_res": [
                    "c18_goal : eq (Zpos (xI p')) (Zpos (xI p'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq (Zpos (xI p')) (Zpos (xI p'))",
                    "c11_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : forall (p : positive) (_ : eq (Z.of_nat (Z.abs_nat (Zpos p))) (Zpos p)),\neq (Z.of_nat (Z.abs_nat (Zpos (xO p)))) (Zpos (xO p))",
                    "_global_Z.abs_nat : forall _ : Z, nat"
                ],
                "tactic_res": [
                    "c19_goal : forall (p : positive) (_ : eq (Z.of_nat (Pos.to_nat p)) (Zpos p)),\neq (Z.of_nat (Pos.to_nat (xO p))) (Zpos (xO p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hrec .",
                "tactic_args": [
                    "c19_goal : forall (p : positive) (_ : eq (Z.of_nat (Pos.to_nat p)) (Zpos p)),\neq (Z.of_nat (Pos.to_nat (xO p))) (Zpos (xO p))"
                ],
                "tactic_res": [
                    "c20_goal : eq (Z.of_nat (Pos.to_nat (xO p'))) (Zpos (xO p'))",
                    "c20_p' : positive",
                    "c20_Hrec : eq (Z.of_nat (Pos.to_nat p')) (Zpos p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : eq (Z.of_nat (Pos.to_nat (xO p'))) (Zpos (xO p'))",
                    "_global_nat_of_P_xO : forall p : positive,\n       eq (Pos.to_nat (xO p)) (Init.Nat.mul 2 (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c21_goal : eq (Z.of_nat (Init.Nat.mul 2 (Pos.to_nat p'))) (Zpos (xO p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : eq (Z.of_nat (Init.Nat.mul 2 (Pos.to_nat p'))) (Zpos (xO p'))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c22_goal : eq (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))) (Zpos (xO p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : eq (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p'))) (Zpos (xO p'))",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c23_goal : eq (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p')))\n  (Z.mul 2%Z (Zpos p'))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_Z.succ : forall _ : Z, Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : eq (Z.mul (Z.of_nat 2) (Z.of_nat (Pos.to_nat p')))\n  (Z.mul 2%Z (Zpos p'))",
                    "c20_Hrec : eq (Z.of_nat (Pos.to_nat p')) (Zpos p')"
                ],
                "tactic_res": [
                    "c24_goal : eq (Z.mul (Z.of_nat 2) (Zpos p')) (Z.mul 2%Z (Zpos p'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c24_goal : eq (Z.mul (Z.of_nat 2) (Zpos p')) (Z.mul 2%Z (Zpos p'))"
                ],
                "tactic_res": [
                    "c25_goal : eq (Zpos (xO p')) (Zpos (xO p'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq (Zpos (xO p')) (Zpos (xO p'))",
                    "c20_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : eq (Z.of_nat (Z.abs_nat 1%Z)) 1%Z"
                ],
                "tactic_res": [
                    "c26_goal : eq 1%Z 1%Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : eq 1%Z 1%Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hd .",
                "tactic_args": [
                    "c5_goal : forall (p : positive) (_ : Z.le 0 (Zneg p)),\neq (Z.of_nat (Z.abs_nat (Zneg p))) (Zneg p)"
                ],
                "tactic_res": [
                    "c27_goal : eq (Z.of_nat (Z.abs_nat (Zneg p'))) (Zneg p')",
                    "c27_p' : positive",
                    "c27_Hd : Z.le 0 (Zneg p')"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c27_goal : eq (Z.of_nat (Z.abs_nat (Zneg p'))) (Zneg p')",
                    "c27_Hd : Z.le 0 (Zneg p')"
                ],
                "tactic_res": [
                    "c28_goal : eq (Z.compare 0%Z (Zneg p')) Gt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : eq (Z.compare 0%Z (Zneg p')) Gt",
                    "c27_p' : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "check_range_correct",
        "proof": [
            {
                "tactic_sig": "Theorem check_range_correct : forall ( v : Z ) ( r : nat ) ( rz : Z ) , ( 0 < v ) % Z -> Z_of_nat ( S r ) = rz -> check_range v r rz = true -> ~ ( exists k : nat , k <= ( S r ) /\\ k <> 1 /\\ ( exists q : nat , Z.abs_nat v = q * k ) ) .",
                "tactic_sig_no_out_arg": "Theorem check_range_correct : forall ( v : Z ) ( r : nat ) ( rz : Z ) , ( 0 < v ) % Z -> Z_of_nat ( S r ) = rz -> check_range v r rz = true -> ~ ( exists k : nat , k <= ( S r ) /\\ k <> 1 /\\ ( exists q : nat , Z.abs_nat v = q * k ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : Z) (r : nat) (rz : Z) (_ : Z.lt 0 v)\n  (_ : eq (Z.of_nat (S r)) rz) (_ : eq (check_range v r rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros v r .",
                "tactic_args": [
                    "c1_goal : forall (v : Z) (r : nat) (rz : Z) (_ : Z.lt 0 v)\n  (_ : eq (Z.of_nat (S r)) rz) (_ : eq (check_range v r rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c2_goal : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r)) rz)\n  (_ : eq (check_range v r rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c2_v : Z",
                    "c2_r : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r)) rz)\n  (_ : eq (check_range v r rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c2_r : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat 1) rz)\n  (_ : eq (check_range v 0 rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k 1)\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c4_goal : forall (n : nat)\n  (_ : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S n)) rz)\n         (_ : eq (check_range v n rz) true),\n       not\n         (ex\n            (fun k : nat =>\n             and (le k (S n))\n               (and (not (eq k 1))\n                  (ex\n                     (fun q : nat =>\n                      eq (Z.abs_nat v) (Init.Nat.mul q k)))))))\n  (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S (S n))) rz)\n  (_ : eq (check_range v (S n) rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S (S n)))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros rz Hlt H1 H2 Hex .",
                "tactic_args": [
                    "c3_goal : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat 1) rz)\n  (_ : eq (check_range v 0 rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k 1)\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c5_goal : False",
                    "c5_rz : Z",
                    "c5_Hlt : Z.lt 0 v",
                    "c5_H1 : eq (Z.of_nat 1) rz",
                    "c5_H2 : eq (check_range v 0 rz) true",
                    "c5_Hex : ex\n  (fun k : nat =>\n   and (le k 1)\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c5_goal : False",
                    "c5_Hex : ex\n  (fun k : nat =>\n   and (le k 1)\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))"
                ],
                "tactic_res": [
                    "c6_goal : forall (x : nat)\n  (_ : and (le x 1)\n         (and (not (eq x 1))\n            (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q x))))),\nFalse"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros k .",
                "tactic_args": [
                    "c6_goal : forall (x : nat)\n  (_ : and (le x 1)\n         (and (not (eq x 1))\n            (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q x))))),\nFalse"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : and (le k 1)\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))),\nFalse",
                    "c7_k : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : and (le k 1)\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))),\nFalse",
                    "c7_k : nat"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  _ : and (le 0 1)\n        (and (not (eq 0 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q 0)))),\nFalse",
                    "c9_goal : forall (n : nat)\n  (_ : and (le (S n) 1)\n         (and (not (eq (S n) 1))\n            (ex\n               (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S n)))))),\nFalse"
                ]
            },
            {
                "tactic_sig": "intros ( _o , ( _o , ( _o , _o ) ) ) .",
                "tactic_sig_no_out_arg": "intros ( Hle , ( Hne1 , ( q , Heq ) ) ) .",
                "tactic_args": [
                    "c8_goal : forall\n  _ : and (le 0 1)\n        (and (not (eq 0 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q 0)))),\nFalse"
                ],
                "tactic_res": [
                    "c10_goal : False",
                    "c10_Hle : le 0 1",
                    "c10_Hne1 : not (eq 0 1)",
                    "c10_q : nat",
                    "c10_Heq : eq (Z.abs_nat v) (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)",
                    "c10_Heq : eq (Z.abs_nat v) (Init.Nat.mul q 0)"
                ],
                "tactic_res": [
                    "c10_Heq : eq (Z.abs_nat v) (Nat.mul 0 q)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c10_Heq : eq (Z.abs_nat v) (Nat.mul 0 q)"
                ],
                "tactic_res": [
                    "c10_Heq : eq (Z.abs_nat v) 0"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_Zabs_nat_0 : forall (x : Z) (_ : eq (Z.abs_nat x) 0), eq x 0%Z",
                    "_global__ : ?T\nwhere\n?T : [v : Z\n      r : nat\n      rz : Z\n      Hlt : Z.lt 0 0\n      H1 : eq (Z.of_nat 1) rz\n      H2 : eq (check_range v 0 rz) true\n      Hex : ex\n              (fun k : nat =>\n               and (le k 1)\n                 (and (not (eq k 1))\n                    (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))\n      k : nat\n      Hle : le 0 1\n      Hne1 : not (eq 0 1)\n      q : nat\n      Heq : eq (Z.abs_nat v) 0 |- Type]\n?y : [v : Z\n      r : nat\n      rz : Z\n      Hlt : Z.lt 0 0\n      H1 : eq (Z.of_nat 1) rz\n      H2 : eq (check_range v 0 rz) true\n      Hex : ex\n              (fun k : nat =>\n               and (le k 1)\n                 (and (not (eq k 1))\n                    (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))\n      k : nat\n      Hle : le 0 1\n      Hne1 : not (eq 0 1)\n      q : nat\n      Heq : eq (Z.abs_nat v) 0 |- ?T]",
                    "c10_Heq : eq (Z.abs_nat v) 0",
                    "c10_Hlt : Z.lt 0 v"
                ],
                "tactic_res": [
                    "c10_Hlt : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "elim ( Z.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Z.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c10_goal : False"
                ],
                "tactic_res": [
                    "c11_goal : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c11_goal : Z.lt 0 0",
                    "c10_Hlt : Z.lt 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o , ( _o , ( _o , _o ) ) ) .",
                "tactic_sig_no_out_arg": "intros k' ( Hle , ( Hne1 , ( q , Heq ) ) ) .",
                "tactic_args": [
                    "c9_goal : forall (n : nat)\n  (_ : and (le (S n) 1)\n         (and (not (eq (S n) 1))\n            (ex\n               (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S n)))))),\nFalse"
                ],
                "tactic_res": [
                    "c12_goal : False",
                    "c12_k' : nat",
                    "c12_Hle : le (S k') 1",
                    "c12_Hne1 : not (eq (S k') 1)",
                    "c12_q : nat",
                    "c12_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c12_goal : False",
                    "c12_Hle : le (S k') 1"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_H0 : eq k' 0",
                    "c14_goal : False",
                    "c14_H : eq m 0",
                    "c14_H0 : le (S k') 0",
                    "c14_m : nat"
                ]
            },
            {
                "tactic_sig": "assert ( H' : _i = 0 ) .",
                "tactic_sig_no_out_arg": "assert ( H' : _i = 0 ) .",
                "tactic_args": [
                    "c13_goal : False",
                    "c12_k' : nat"
                ],
                "tactic_res": [
                    "c15_goal : eq k' 0",
                    "c16_goal : False",
                    "c16_H' : eq k' 0"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c15_goal : eq k' 0",
                    "c13_H0 : eq k' 0",
                    "c12_k' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c16_H' : eq k' 0",
                    "c16_Hne1 : not (eq (S k') 1)"
                ],
                "tactic_res": [
                    "c16_Hne1 : not (eq 1 1)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c16_goal : False",
                    "c16_Hne1 : not (eq 1 1)"
                ],
                "tactic_res": [
                    "c17_goal : eq 1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( H' : S _i <= 0 ) by assumption .",
                "tactic_sig_no_out_arg": "assert ( H' : S _i <= 0 ) by assumption .",
                "tactic_args": [
                    "c12_k' : nat",
                    "c14_H : eq m 0",
                    "c14_H0 : le (S k') 0",
                    "c12_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c12_Hne1 : not (eq (S k') 1)",
                    "c12_Hle : le (S k') 1",
                    "c7_k : nat",
                    "c5_Hex : ex\n  (fun k : nat =>\n   and (le k 1)\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))",
                    "c5_H2 : eq (check_range v 0 rz) true",
                    "c5_H1 : eq (Z.of_nat 1) rz",
                    "c5_Hlt : Z.lt 0 v",
                    "c2_r : nat"
                ],
                "tactic_res": [
                    "c14_H' : le (S k') 0"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c14_goal : False",
                    "c14_H' : le (S k') 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros r' Hrec rz Hlt H1 H2 Hex .",
                "tactic_args": [
                    "c4_goal : forall (n : nat)\n  (_ : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S n)) rz)\n         (_ : eq (check_range v n rz) true),\n       not\n         (ex\n            (fun k : nat =>\n             and (le k (S n))\n               (and (not (eq k 1))\n                  (ex\n                     (fun q : nat =>\n                      eq (Z.abs_nat v) (Init.Nat.mul q k)))))))\n  (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S (S n))) rz)\n  (_ : eq (check_range v (S n) rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S (S n)))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c18_goal : False",
                    "c18_r' : nat",
                    "c18_Hrec : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r')) rz)\n  (_ : eq (check_range v r' rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r'))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c18_rz : Z",
                    "c18_Hlt : Z.lt 0 v",
                    "c18_H1 : eq (Z.of_nat (S (S r'))) rz",
                    "c18_H2 : eq (check_range v (S r') rz) true",
                    "c18_Hex : ex\n  (fun k : nat =>\n   and (le k (S (S r')))\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c18_goal : False",
                    "c18_Hex : ex\n  (fun k : nat =>\n   and (le k (S (S r')))\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))"
                ],
                "tactic_res": [
                    "c19_goal : forall (x : nat)\n  (_ : and (le x (S (S r')))\n         (and (not (eq x 1))\n            (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q x))))),\nFalse"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros k .",
                "tactic_args": [
                    "c19_goal : forall (x : nat)\n  (_ : and (le x (S (S r')))\n         (and (not (eq x 1))\n            (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q x))))),\nFalse"
                ],
                "tactic_res": [
                    "c20_goal : forall\n  _ : and (le k (S (S r')))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))),\nFalse",
                    "c20_k : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c20_goal : forall\n  _ : and (le k (S (S r')))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))),\nFalse",
                    "c20_k : nat"
                ],
                "tactic_res": [
                    "c21_goal : forall\n  _ : and (le 0 (S (S r')))\n        (and (not (eq 0 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q 0)))),\nFalse",
                    "c22_goal : forall (n : nat)\n  (_ : and (le (S n) (S (S r')))\n         (and (not (eq (S n) 1))\n            (ex\n               (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S n)))))),\nFalse"
                ]
            },
            {
                "tactic_sig": "intros ( _o , ( _o , ( _o , _o ) ) ) .",
                "tactic_sig_no_out_arg": "intros ( Hle , ( Hne1 , ( q , Heq ) ) ) .",
                "tactic_args": [
                    "c21_goal : forall\n  _ : and (le 0 (S (S r')))\n        (and (not (eq 0 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q 0)))),\nFalse"
                ],
                "tactic_res": [
                    "c23_goal : False",
                    "c23_Hle : le 0 (S (S r'))",
                    "c23_Hne1 : not (eq 0 1)",
                    "c23_q : nat",
                    "c23_Heq : eq (Z.abs_nat v) (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)",
                    "c23_Heq : eq (Z.abs_nat v) (Init.Nat.mul q 0)"
                ],
                "tactic_res": [
                    "c23_Heq : eq (Z.abs_nat v) (Nat.mul 0 q)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c23_Heq : eq (Z.abs_nat v) (Nat.mul 0 q)"
                ],
                "tactic_res": [
                    "c23_Heq : eq (Z.abs_nat v) 0"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i ) in _i .",
                "tactic_args": [
                    "_global_Zabs_nat_0 : forall (x : Z) (_ : eq (Z.abs_nat x) 0), eq x 0%Z",
                    "_global__ : ?T\nwhere\n?T : [v : Z\n      r : nat\n      r' : nat\n      Hrec : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r')) rz)\n               (_ : eq (check_range v r' rz) true),\n             not\n               (ex\n                  (fun k : nat =>\n                   and (le k (S r'))\n                     (and (not (eq k 1))\n                        (ex\n                           (fun q : nat =>\n                            eq (Z.abs_nat v) (Init.Nat.mul q k))))))\n      rz : Z\n      Hlt : Z.lt 0 0\n      H1 : eq (Z.of_nat (S (S r'))) rz\n      H2 : eq (check_range v (S r') rz) true\n      Hex : ex\n              (fun k : nat =>\n               and (le k (S (S r')))\n                 (and (not (eq k 1))\n                    (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))\n      k : nat\n      Hle : le 0 (S (S r'))\n      Hne1 : not (eq 0 1)\n      q : nat\n      Heq : eq (Z.abs_nat v) 0 |- Type]\n?y : [v : Z\n      r : nat\n      r' : nat\n      Hrec : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r')) rz)\n               (_ : eq (check_range v r' rz) true),\n             not\n               (ex\n                  (fun k : nat =>\n                   and (le k (S r'))\n                     (and (not (eq k 1))\n                        (ex\n                           (fun q : nat =>\n                            eq (Z.abs_nat v) (Init.Nat.mul q k))))))\n      rz : Z\n      Hlt : Z.lt 0 0\n      H1 : eq (Z.of_nat (S (S r'))) rz\n      H2 : eq (check_range v (S r') rz) true\n      Hex : ex\n              (fun k : nat =>\n               and (le k (S (S r')))\n                 (and (not (eq k 1))\n                    (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))\n      k : nat\n      Hle : le 0 (S (S r'))\n      Hne1 : not (eq 0 1)\n      q : nat\n      Heq : eq (Z.abs_nat v) 0 |- ?T]",
                    "c23_Heq : eq (Z.abs_nat v) 0",
                    "c23_Hlt : Z.lt 0 v"
                ],
                "tactic_res": [
                    "c23_Hlt : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "elim ( Z.lt_irrefl 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Z.lt_irrefl 0 ) .",
                "tactic_args": [
                    "c23_goal : False"
                ],
                "tactic_res": [
                    "c24_goal : Z.lt 0 0"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c24_goal : Z.lt 0 0",
                    "c23_Hlt : Z.lt 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o , ( _o , ( _o , _o ) ) ) .",
                "tactic_sig_no_out_arg": "intros k' ( Hle , ( Hne1 , ( q , Heq ) ) ) .",
                "tactic_args": [
                    "c22_goal : forall (n : nat)\n  (_ : and (le (S n) (S (S r')))\n         (and (not (eq (S n) 1))\n            (ex\n               (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S n)))))),\nFalse"
                ],
                "tactic_res": [
                    "c25_goal : False",
                    "c25_k' : nat",
                    "c25_Hle : le (S k') (S (S r'))",
                    "c25_Hne1 : not (eq (S k') 1)",
                    "c25_q : nat",
                    "c25_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c25_goal : False",
                    "c25_Hle : le (S k') (S (S r'))"
                ],
                "tactic_res": [
                    "c26_goal : False",
                    "c26_H0 : eq k' (S r')",
                    "c27_goal : False",
                    "c27_H : eq m (S r')",
                    "c27_H0 : le (S k') (S r')",
                    "c27_m : nat"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "c18_H1 : eq (Z.of_nat (S (S r'))) rz",
                    "c26_H2 : eq (check_range v (S r') rz) true"
                ],
                "tactic_res": [
                    "c26_H2 : eq (check_range v (S r') (Z.of_nat (S (S r')))) true"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) in _i .",
                "tactic_args": [
                    "c26_goal : False",
                    "_global_Z_to_nat_and_back : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x",
                    "c2_v : Z",
                    "c26_H2 : eq (check_range v (S r') (Z.of_nat (S (S r')))) true"
                ],
                "tactic_res": [
                    "c28_goal : False",
                    "c28_H2 : eq (check_range (Z.of_nat (Z.abs_nat v)) (S r') (Z.of_nat (S (S r'))))\n  true",
                    "c29_goal : Z.le 0 v"
                ]
            },
            {
                "tactic_sig": "assert ( Hmod : ( Z_of_nat ( Z.abs_nat _i ) mod Z.of_nat ( S ( S _i ) ) = 0 ) % Z ) .",
                "tactic_sig_no_out_arg": "assert ( Hmod : ( Z_of_nat ( Z.abs_nat _i ) mod Z.of_nat ( S ( S _i ) ) = 0 ) % Z ) .",
                "tactic_args": [
                    "c28_goal : False",
                    "c2_v : Z",
                    "c18_r' : nat"
                ],
                "tactic_res": [
                    "c30_goal : eq (Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r')))) 0%Z",
                    "c31_goal : False",
                    "c31_Hmod : eq (Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r')))) 0%Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : eq (Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r')))) 0%Z",
                    "_global_verif_divide : forall (m p : nat) (_ : lt 0 m) (_ : lt 0 p)\n         (_ : ex (fun q : nat => eq m (Init.Nat.mul q p))),\n       eq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0%Z"
                ],
                "tactic_res": [
                    "c32_goal : lt 0 (Z.abs_nat v)",
                    "c33_goal : lt 0 (S (S r'))",
                    "c34_goal : ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S (S r'))))"
                ]
            },
            {
                "tactic_sig": "replace 0 with ( Z.abs_nat 0 % Z ) .",
                "tactic_sig_no_out_arg": "replace 0 with ( Z.abs_nat 0 % Z ) .",
                "tactic_args": [
                    "c32_goal : lt 0 (Z.abs_nat v)"
                ],
                "tactic_res": [
                    "c35_goal : lt (Z.abs_nat 0%Z) (Z.abs_nat v)",
                    "c36_goal : eq (Z.abs_nat 0%Z) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c35_goal : lt (Z.abs_nat 0%Z) (Z.abs_nat v)",
                    "_global_Zabs_nat_lt : forall (n m : Z) (_ : and (Z.le 0 n) (Z.lt n m)),\n       lt (Z.abs_nat n) (Z.abs_nat m)"
                ],
                "tactic_res": [
                    "c37_goal : and (Z.le 0 0) (Z.lt 0 v)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c37_goal : and (Z.le 0 0) (Z.lt 0 v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c36_goal : eq (Z.abs_nat 0%Z) 0"
                ],
                "tactic_res": [
                    "c38_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c33_goal : lt 0 (S (S r'))",
                    "c18_r' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c34_goal : ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S (S r'))))",
                    "c25_q : nat"
                ],
                "tactic_res": [
                    "c39_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S (S r')))"
                ]
            },
            {
                "tactic_sig": "assert ( H' : _i = S _i ) by assumption .",
                "tactic_sig_no_out_arg": "assert ( H' : _i = S _i ) by assumption .",
                "tactic_args": [
                    "c25_k' : nat",
                    "c18_r' : nat",
                    "c26_H0 : eq k' (S r')",
                    "c25_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c25_q : nat",
                    "c25_Hne1 : not (eq (S k') 1)",
                    "c25_Hle : le (S k') (S (S r'))",
                    "c20_k : nat",
                    "c18_Hex : ex\n  (fun k : nat =>\n   and (le k (S (S r')))\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))",
                    "c28_H2 : eq (check_range (Z.of_nat (Z.abs_nat v)) (S r') (Z.of_nat (S (S r'))))\n  true",
                    "c18_H1 : eq (Z.of_nat (S (S r'))) rz",
                    "c18_Hlt : Z.lt 0 v",
                    "c18_Hrec : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r')) rz)\n  (_ : eq (check_range v r' rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r'))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c2_r : nat",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c39_H' : eq k' (S r')"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c39_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S (S r')))",
                    "c39_H' : eq k' (S r')"
                ],
                "tactic_res": [
                    "c40_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c25_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c25_q : nat",
                    "c25_k' : nat",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_check_range : forall (_ : Z) (_ : nat) (_ : Z), bool",
                    "c31_H2 : eq (check_range (Z.of_nat (Z.abs_nat v)) (S r') (Z.of_nat (S (S r'))))\n  true"
                ],
                "tactic_res": [
                    "c31_H2 : eq\n  match Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r'))) with\n  | 0%Z => false\n  | _ =>\n      (fix check_range (v : Z) (r : nat) (sr : Z) {struct r} : bool :=\n         match r with\n         | 0 => true\n         | S r' =>\n             match Z.modulo v sr with\n             | 0%Z => false\n             | _ => check_range v r' (Z.pred sr)\n             end\n         end) (Z.of_nat (Z.abs_nat v)) r'\n        (Z.pred (Z.of_nat (S (S r'))))\n  end true"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c31_Hmod : eq (Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r')))) 0%Z",
                    "c31_H2 : eq\n  match Z.modulo (Z.of_nat (Z.abs_nat v)) (Z.of_nat (S (S r'))) with\n  | 0%Z => false\n  | _ =>\n      (fix check_range (v : Z) (r : nat) (sr : Z) {struct r} : bool :=\n         match r with\n         | 0 => true\n         | S r' =>\n             match Z.modulo v sr with\n             | 0%Z => false\n             | _ => check_range v r' (Z.pred sr)\n             end\n         end) (Z.of_nat (Z.abs_nat v)) r'\n        (Z.pred (Z.of_nat (S (S r'))))\n  end true"
                ],
                "tactic_res": [
                    "c31_H2 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c31_goal : False",
                    "c31_H2 : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c29_goal : Z.le 0 v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_check_range : forall (_ : Z) (_ : nat) (_ : Z), bool",
                    "c27_H2 : eq (check_range v (S r') rz) true"
                ],
                "tactic_res": [
                    "c27_H2 : eq\n  match Z.modulo v rz with\n  | 0%Z => false\n  | _ =>\n      (fix check_range (v : Z) (r : nat) (sr : Z) {struct r} : bool :=\n         match r with\n         | 0 => true\n         | S r' =>\n             match Z.modulo v sr with\n             | 0%Z => false\n             | _ => check_range v r' (Z.pred sr)\n             end\n         end) v r' (Z.pred rz)\n  end true"
                ]
            },
            {
                "tactic_sig": "fold check_range in _i .",
                "tactic_sig_no_out_arg": "fold check_range in _i .",
                "tactic_args": [
                    "c27_H2 : eq\n  match Z.modulo v rz with\n  | 0%Z => false\n  | _ =>\n      (fix check_range (v : Z) (r : nat) (sr : Z) {struct r} : bool :=\n         match r with\n         | 0 => true\n         | S r' =>\n             match Z.modulo v sr with\n             | 0%Z => false\n             | _ => check_range v r' (Z.pred sr)\n             end\n         end) v r' (Z.pred rz)\n  end true"
                ],
                "tactic_res": [
                    "c27_H2 : eq\n  match Z.modulo v rz with\n  | 0%Z => false\n  | _ => check_range v r' (Z.pred rz)\n  end true"
                ]
            },
            {
                "tactic_sig": "case_eq ( ( _i mod _i ) % Z ) .",
                "tactic_sig_no_out_arg": "case_eq ( ( _i mod _i ) % Z ) .",
                "tactic_args": [
                    "c27_goal : False",
                    "c2_v : Z",
                    "c18_rz : Z"
                ],
                "tactic_res": [
                    "c41_goal : forall _ : eq (Z.modulo v rz) 0%Z, False",
                    "c42_goal : forall (p : positive) (_ : eq (Z.modulo v rz) (Zpos p)), False",
                    "c43_goal : forall (p : positive) (_ : eq (Z.modulo v rz) (Zneg p)), False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heqmod .",
                "tactic_args": [
                    "c41_goal : forall _ : eq (Z.modulo v rz) 0%Z, False"
                ],
                "tactic_res": [
                    "c44_goal : False",
                    "c44_Heqmod : eq (Z.modulo v rz) 0%Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c44_Heqmod : eq (Z.modulo v rz) 0%Z",
                    "c44_H2 : eq\n  match Z.modulo v rz with\n  | 0%Z => false\n  | _ => check_range v r' (Z.pred rz)\n  end true"
                ],
                "tactic_res": [
                    "c44_H2 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c44_goal : False",
                    "c44_H2 : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros pmod Heqmod .",
                "tactic_args": [
                    "c42_goal : forall (p : positive) (_ : eq (Z.modulo v rz) (Zpos p)), False"
                ],
                "tactic_res": [
                    "c45_goal : False",
                    "c45_pmod : positive",
                    "c45_Heqmod : eq (Z.modulo v rz) (Zpos pmod)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c45_Heqmod : eq (Z.modulo v rz) (Zpos pmod)",
                    "c45_H2 : eq\n  match Z.modulo v rz with\n  | 0%Z => false\n  | _ => check_range v r' (Z.pred rz)\n  end true"
                ],
                "tactic_res": [
                    "c45_H2 : eq (check_range v r' (Z.pred rz)) true"
                ]
            },
            {
                "tactic_sig": "elim ( _i ( Z.pred _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( _i ( Z.pred _i ) _i ) .",
                "tactic_args": [
                    "c45_goal : False",
                    "c18_Hrec : forall (rz : Z) (_ : Z.lt 0 v) (_ : eq (Z.of_nat (S r')) rz)\n  (_ : eq (check_range v r' rz) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (le k (S r'))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k))))))",
                    "c18_rz : Z",
                    "c18_Hlt : Z.lt 0 v"
                ],
                "tactic_res": [
                    "c46_goal : eq (Z.of_nat (S r')) (Z.pred rz)",
                    "c47_goal : eq (check_range v r' (Z.pred rz)) true",
                    "c48_goal : ex\n  (fun k : nat =>\n   and (le k (S r'))\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c46_goal : eq (Z.of_nat (S r')) (Z.pred rz)",
                    "c18_H1 : eq (Z.of_nat (S (S r'))) rz"
                ],
                "tactic_res": [
                    "c49_goal : eq (Z.of_nat (S r')) (Z.pred (Z.of_nat (S (S r'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c49_goal : eq (Z.of_nat (S r')) (Z.pred (Z.of_nat (S (S r'))))",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c50_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.of_nat (S (S r'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c50_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.of_nat (S (S r'))))",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c51_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.succ (Z.of_nat (S r'))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c51_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.succ (Z.of_nat (S r'))))",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c52_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.succ (Z.succ (Z.of_nat r'))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c52_goal : eq (Z.succ (Z.of_nat r')) (Z.pred (Z.succ (Z.succ (Z.of_nat r'))))",
                    "_global_Zpred_succ : forall n : Z, eq n (Z.pred (Z.succ n))"
                ],
                "tactic_res": [
                    "c53_goal : eq (Z.succ (Z.of_nat r')) (Z.succ (Z.of_nat r'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : eq (Z.succ (Z.of_nat r')) (Z.succ (Z.of_nat r'))",
                    "c18_r' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c47_goal : eq (check_range v r' (Z.pred rz)) true",
                    "c45_H2 : eq (check_range v r' (Z.pred rz)) true",
                    "c18_rz : Z",
                    "c18_r' : nat",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( S _i ) .",
                "tactic_sig_no_out_arg": "exists ( S _i ) .",
                "tactic_args": [
                    "c48_goal : ex\n  (fun k : nat =>\n   and (le k (S r'))\n     (and (not (eq k 1))\n        (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q k)))))",
                    "c25_k' : nat"
                ],
                "tactic_res": [
                    "c54_goal : and (le (S k') (S r'))\n  (and (not (eq (S k') 1))\n     (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S k')))))"
                ]
            },
            {
                "tactic_sig": "repeat split .",
                "tactic_sig_no_out_arg": "repeat split .",
                "tactic_args": [
                    "c54_goal : and (le (S k') (S r'))\n  (and (not (eq (S k') 1))\n     (ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S k')))))"
                ],
                "tactic_res": [
                    "c55_goal : le (S k') (S r')",
                    "c56_goal : not (eq (S k') 1)",
                    "c57_goal : ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S k')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : le (S k') (S r')",
                    "c27_H0 : le (S k') (S r')",
                    "c25_k' : nat",
                    "c18_r' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : not (eq (S k') 1)",
                    "c25_Hne1 : not (eq (S k') 1)",
                    "c25_k' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c57_goal : ex (fun q : nat => eq (Z.abs_nat v) (Init.Nat.mul q (S k')))",
                    "c25_q : nat"
                ],
                "tactic_res": [
                    "c58_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c58_goal : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c25_Heq : eq (Z.abs_nat v) (Init.Nat.mul q (S k'))",
                    "c25_q : nat",
                    "c25_k' : nat",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Hmod .",
                "tactic_args": [
                    "c43_goal : forall (p : positive) (_ : eq (Z.modulo v rz) (Zneg p)), False"
                ],
                "tactic_res": [
                    "c59_goal : False",
                    "c59_p : positive",
                    "c59_Hmod : eq (Z.modulo v rz) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "elim ( Z_mod_lt _i _i ) .",
                "tactic_sig_no_out_arg": "elim ( Z_mod_lt _i _i ) .",
                "tactic_args": [
                    "c59_goal : False",
                    "c2_v : Z",
                    "c18_rz : Z"
                ],
                "tactic_res": [
                    "c60_goal : forall (_ : Z.le 0 (Z.modulo v rz)) (_ : Z.lt (Z.modulo v rz) rz),\nFalse",
                    "c61_goal : Z.gt rz 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c60_goal : forall (_ : Z.le 0 (Z.modulo v rz)) (_ : Z.lt (Z.modulo v rz) rz),\nFalse",
                    "c59_Hmod : eq (Z.modulo v rz) (Zneg p)"
                ],
                "tactic_res": [
                    "c62_goal : forall (_ : Z.le 0 (Zneg p)) (_ : Z.lt (Zneg p) rz), False"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c62_goal : forall (_ : Z.le 0 (Zneg p)) (_ : Z.lt (Zneg p) rz), False",
                    "_global_Z.le : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c63_goal : forall (_ : not (eq (Z.compare 0%Z (Zneg p)) Gt))\n  (_ : Z.lt (Zneg p) rz), False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c63_goal : forall (_ : not (eq (Z.compare 0%Z (Zneg p)) Gt))\n  (_ : Z.lt (Zneg p) rz), False"
                ],
                "tactic_res": [
                    "c64_goal : forall (_ : not (eq Gt Gt)) (_ : Z.lt (Zneg p) rz), False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hle' .",
                "tactic_args": [
                    "c64_goal : forall (_ : not (eq Gt Gt)) (_ : Z.lt (Zneg p) rz), False"
                ],
                "tactic_res": [
                    "c65_goal : forall _ : Z.lt (Zneg p) rz, False",
                    "c65_Hle' : not (eq Gt Gt)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c65_goal : forall _ : Z.lt (Zneg p) rz, False",
                    "c65_Hle' : not (eq Gt Gt)"
                ],
                "tactic_res": [
                    "c66_goal : eq Gt Gt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c66_goal : eq Gt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c61_goal : Z.gt rz 0",
                    "c18_H1 : eq (Z.of_nat (S (S r'))) rz"
                ],
                "tactic_res": [
                    "c67_goal : Z.gt (Z.of_nat (S (S r'))) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c67_goal : Z.gt (Z.of_nat (S (S r'))) 0",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c68_goal : Z.gt (Z.succ (Z.of_nat (S r'))) 0"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c68_goal : Z.gt (Z.succ (Z.of_nat (S r'))) 0",
                    "_global_Z.succ : forall _ : Z, Z"
                ],
                "tactic_res": [
                    "c69_goal : Z.gt (Z.add (Z.of_nat (S r')) 1%Z) 0"
                ]
            },
            {
                "tactic_sig": "generalize ( Zle_0_nat ( S _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Zle_0_nat ( S _i ) ) .",
                "tactic_args": [
                    "c69_goal : Z.gt (Z.add (Z.of_nat (S r')) 1%Z) 0",
                    "c18_r' : nat"
                ],
                "tactic_res": [
                    "c70_goal : forall _ : Z.le 0 (Z.of_nat (S r')),\nZ.gt (Z.add (Z.of_nat (S r')) 1%Z) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c70_goal : forall _ : Z.le 0 (Z.of_nat (S r')),\nZ.gt (Z.add (Z.of_nat (S r')) 1%Z) 0"
                ],
                "tactic_res": [
                    "c71_goal : Z.gt (Z.add (Z.of_nat (S r')) 1%Z) 0",
                    "c71_H3 : Z.le 0 (Z.of_nat (S r'))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c71_goal : Z.gt (Z.add (Z.of_nat (S r')) 1%Z) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nat_of_P_Psucc",
        "proof": [
            {
                "tactic_sig": "Theorem nat_of_P_Psucc : forall p : positive , nat_of_P ( Pos.succ p ) = S ( nat_of_P p ) .",
                "tactic_sig_no_out_arg": "Theorem nat_of_P_Psucc : forall p : positive , nat_of_P ( Pos.succ p ) = S ( nat_of_P p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p : positive, eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall p : positive, eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c2_goal : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (Pos.succ (xI p))) (S (Pos.to_nat (xI p)))",
                    "c4_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (Pos.succ (xO p))) (S (Pos.to_nat (xO p)))",
                    "c5_goal : eq (Pos.to_nat (Pos.succ 1%positive)) (S (Pos.to_nat 1%positive))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (Pos.succ (xI p))) (S (Pos.to_nat (xI p)))"
                ],
                "tactic_res": [
                    "c6_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (xO (Pos.succ p))) (S (Pos.to_nat (xI p)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p' .",
                "tactic_args": [
                    "c6_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (xO (Pos.succ p))) (S (Pos.to_nat (xI p)))"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p')),\neq (Pos.to_nat (xO (Pos.succ p'))) (S (Pos.to_nat (xI p')))",
                    "c7_p' : positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : forall _ : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p')),\neq (Pos.to_nat (xO (Pos.succ p'))) (S (Pos.to_nat (xI p')))",
                    "_global_nat_of_P_xO : forall p : positive,\n       eq (Pos.to_nat (xO p)) (Init.Nat.mul 2 (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p')),\neq (Init.Nat.mul 2 (Pos.to_nat (Pos.succ p'))) (S (Pos.to_nat (xI p')))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c8_goal : forall _ : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p')),\neq (Init.Nat.mul 2 (Pos.to_nat (Pos.succ p'))) (S (Pos.to_nat (xI p')))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Init.Nat.mul 2 (Pos.to_nat (Pos.succ p'))) (S (Pos.to_nat (xI p')))",
                    "c9_Heq : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (Init.Nat.mul 2 (Pos.to_nat (Pos.succ p'))) (S (Pos.to_nat (xI p')))",
                    "c9_Heq : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p'))"
                ],
                "tactic_res": [
                    "c10_goal : eq (Init.Nat.mul 2 (S (Pos.to_nat p'))) (S (Pos.to_nat (xI p')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (Init.Nat.mul 2 (S (Pos.to_nat p'))) (S (Pos.to_nat (xI p')))",
                    "_global_nat_of_P_xI : forall p : positive,\n       eq (Pos.to_nat (xI p)) (S (Init.Nat.mul 2 (Pos.to_nat p)))"
                ],
                "tactic_res": [
                    "c11_goal : eq (Init.Nat.mul 2 (S (Pos.to_nat p')))\n  (S (S (Init.Nat.mul 2 (Pos.to_nat p'))))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c11_goal : eq (Init.Nat.mul 2 (S (Pos.to_nat p')))\n  (S (S (Init.Nat.mul 2 (Pos.to_nat p'))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Heq .",
                "tactic_args": [
                    "c4_goal : forall (p : positive)\n  (_ : eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))),\neq (Pos.to_nat (Pos.succ (xO p))) (S (Pos.to_nat (xO p)))"
                ],
                "tactic_res": [
                    "c12_goal : eq (Pos.to_nat (Pos.succ (xO p'))) (S (Pos.to_nat (xO p')))",
                    "c12_p' : positive",
                    "c12_Heq : eq (Pos.to_nat (Pos.succ p')) (S (Pos.to_nat p'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : eq (Pos.to_nat (Pos.succ (xO p'))) (S (Pos.to_nat (xO p')))"
                ],
                "tactic_res": [
                    "c13_goal : eq (Pos.to_nat (xI p')) (S (Pos.to_nat (xO p')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq (Pos.to_nat (xI p')) (S (Pos.to_nat (xO p')))",
                    "_global_nat_of_P_xI : forall p : positive,\n       eq (Pos.to_nat (xI p)) (S (Init.Nat.mul 2 (Pos.to_nat p)))"
                ],
                "tactic_res": [
                    "c14_goal : eq (S (Init.Nat.mul 2 (Pos.to_nat p'))) (S (Pos.to_nat (xO p')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : eq (S (Init.Nat.mul 2 (Pos.to_nat p'))) (S (Pos.to_nat (xO p')))",
                    "_global_nat_of_P_xO : forall p : positive,\n       eq (Pos.to_nat (xO p)) (Init.Nat.mul 2 (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c15_goal : eq (S (Init.Nat.mul 2 (Pos.to_nat p')))\n  (S (Init.Nat.mul 2 (Pos.to_nat p')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq (S (Init.Nat.mul 2 (Pos.to_nat p')))\n  (S (Init.Nat.mul 2 (Pos.to_nat p')))",
                    "c12_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (Pos.to_nat (Pos.succ 1%positive)) (S (Pos.to_nat 1%positive))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nat_to_Z_and_back",
        "proof": [
            {
                "tactic_sig": "Theorem nat_to_Z_and_back : forall n : nat , Z.abs_nat ( Z.of_nat n ) = n .",
                "tactic_sig_no_out_arg": "Theorem nat_to_Z_and_back : forall n : nat , Z.abs_nat ( Z.of_nat n ) = n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (Z.abs_nat (Z.of_nat n)) n"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (Z.abs_nat (Z.of_nat n)) n"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.abs_nat (Z.of_nat n)) n",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (Z.abs_nat (Z.of_nat n)) n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (Z.abs_nat (Z.of_nat 0)) 0",
                    "c4_goal : forall (n : nat) (_ : eq (Z.abs_nat (Z.of_nat n)) n),\neq (Z.abs_nat (Z.of_nat (S n))) (S n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (Z.abs_nat (Z.of_nat 0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n' .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : eq (Z.abs_nat (Z.of_nat n)) n),\neq (Z.abs_nat (Z.of_nat (S n))) (S n)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq (Z.abs_nat (Z.of_nat n')) n',\neq (Z.abs_nat (Z.of_nat (S n'))) (S n')",
                    "c5_n' : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall _ : eq (Z.abs_nat (Z.of_nat n')) n',\neq (Z.abs_nat (Z.of_nat (S n'))) (S n')"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq (Z.abs_nat (Z.of_nat n')) n',\neq (Pos.to_nat (Pos.of_succ_nat n')) (S n')"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c6_goal : forall _ : eq (Z.abs_nat (Z.of_nat n')) n',\neq (Pos.to_nat (Pos.of_succ_nat n')) (S n')",
                    "c5_n' : nat"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq (Z.abs_nat (Z.of_nat 0)) 0,\neq (Pos.to_nat (Pos.of_succ_nat 0)) 1",
                    "c8_goal : forall (n : nat) (_ : eq (Z.abs_nat (Z.of_nat (S n))) (S n)),\neq (Pos.to_nat (Pos.of_succ_nat (S n))) (S (S n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall _ : eq (Z.abs_nat (Z.of_nat 0)) 0,\neq (Pos.to_nat (Pos.of_succ_nat 0)) 1"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq 0 0, eq (Pos.to_nat 1%positive) 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall _ : eq 0 0, eq (Pos.to_nat 1%positive) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n'' .",
                "tactic_args": [
                    "c8_goal : forall (n : nat) (_ : eq (Z.abs_nat (Z.of_nat (S n))) (S n)),\neq (Pos.to_nat (Pos.of_succ_nat (S n))) (S (S n))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq (Z.abs_nat (Z.of_nat (S n''))) (S n''),\neq (Pos.to_nat (Pos.of_succ_nat (S n''))) (S (S n''))",
                    "c10_n'' : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall _ : eq (Z.abs_nat (Z.of_nat (S n''))) (S n''),\neq (Pos.to_nat (Pos.of_succ_nat (S n''))) (S (S n''))"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n''),\neq (Pos.to_nat (Pos.succ (Pos.of_succ_nat n''))) (S (S n''))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : forall _ : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n''),\neq (Pos.to_nat (Pos.succ (Pos.of_succ_nat n''))) (S (S n''))",
                    "_global_nat_of_P_Psucc : forall p : positive, eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n''),\neq (S (Pos.to_nat (Pos.of_succ_nat n''))) (S (S n''))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c12_goal : forall _ : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n''),\neq (S (Pos.to_nat (Pos.of_succ_nat n''))) (S (S n''))"
                ],
                "tactic_res": [
                    "c13_goal : eq (S (Pos.to_nat (Pos.of_succ_nat n''))) (S (S n''))",
                    "c13_Heq : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n'')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq (S (Pos.to_nat (Pos.of_succ_nat n''))) (S (S n''))",
                    "c13_Heq : eq (Pos.to_nat (Pos.of_succ_nat n'')) (S n'')"
                ],
                "tactic_res": [
                    "c14_goal : eq (S (S n'')) (S (S n''))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : eq (S (S n'')) (S (S n''))",
                    "c10_n'' : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "check_correct",
        "proof": [
            {
                "tactic_sig": "Theorem check_correct : forall p : nat , 0 < p -> check_primality p = true -> ~ ( exists k : nat , k <> 1 /\\ k <> p /\\ ( exists q : nat , p = q * k ) ) .",
                "tactic_sig_no_out_arg": "Theorem check_correct : forall p : nat , 0 < p -> check_primality p = true -> ~ ( exists k : nat , k <> 1 /\\ k <> p /\\ ( exists q : nat , p = q * k ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p : nat) (_ : lt 0 p) (_ : eq (check_primality p) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (p : nat) (_ : lt 0 p) (_ : eq (check_primality p) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))",
                    "_global_lt : forall (_ : nat) (_ : nat), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (p : nat) (_ : le 1 p) (_ : eq (check_primality p) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Hle .",
                "tactic_args": [
                    "c2_goal : forall (p : nat) (_ : le 1 p) (_ : eq (check_primality p) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq (check_primality p) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))",
                    "c3_p : nat",
                    "c3_Hle : le 1 p"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (check_primality p) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p))\n           (ex (fun q : nat => eq p (Init.Nat.mul q k))))))",
                    "c3_Hle : le 1 p"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (check_primality 1) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq 1 (Init.Nat.mul q k))))))",
                    "c5_goal : forall (m : nat) (_ : le 1 m)\n  (_ : forall _ : eq (check_primality m) true,\n       not\n         (ex\n            (fun k : nat =>\n             and (not (eq k 1))\n               (and (not (eq k m))\n                  (ex (fun q : nat => eq m (Init.Nat.mul q k)))))))\n  (_ : eq (check_primality (S m)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S m)))\n           (ex (fun q : nat => eq (S m) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o , ( _o , ( _o , ( _o , _o ) ) ) ) .",
                "tactic_sig_no_out_arg": "intros Hcp ( k , ( Hne1 , ( Hne1bis , ( q , Heq ) ) ) ) .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (check_primality 1) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k 1))\n           (ex (fun q : nat => eq 1 (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_Hcp : eq (check_primality 1) true",
                    "c6_k : nat",
                    "c6_Hne1 : not (eq k 1)",
                    "c6_Hne1bis : not (eq k 1)",
                    "c6_q : nat",
                    "c6_Heq : eq 1 (Init.Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)",
                    "c6_Heq : eq 1 (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c6_Heq : eq 1 (Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "assert ( Hle' : _i < 1 ) .",
                "tactic_sig_no_out_arg": "assert ( Hle' : _i < 1 ) .",
                "tactic_args": [
                    "c6_goal : False",
                    "c6_k : nat"
                ],
                "tactic_res": [
                    "c7_goal : lt k 1",
                    "c8_goal : False",
                    "c8_Hle' : lt k 1"
                ]
            },
            {
                "tactic_sig": "elim ( proj1 ( Nat.lt_eq_cases _i 1 ) ) .",
                "tactic_sig_no_out_arg": "elim ( proj1 ( Nat.lt_eq_cases _i 1 ) ) .",
                "tactic_args": [
                    "c7_goal : lt k 1",
                    "c6_k : nat"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : lt k 1, lt k 1",
                    "c10_goal : forall _ : eq k 1, lt k 1",
                    "c11_goal : le k 1"
                ]
            },
            {
                "tactic_sig": "try ( intuition ; fail ) .",
                "tactic_sig_no_out_arg": "try ( intuition ; fail ) .",
                "tactic_args": [
                    "c9_goal : forall _ : lt k 1, lt k 1",
                    "c6_k : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( intuition ; fail ) .",
                "tactic_sig_no_out_arg": "try ( intuition ; fail ) .",
                "tactic_args": [
                    "c10_goal : forall _ : eq k 1, lt k 1",
                    "c6_k : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c11_goal : le k 1",
                    "_global_divisor_smaller : forall (m p : nat) (_ : lt 0 m) (q : nat)\n         (_ : eq m (Init.Nat.mul q p)), le q m",
                    "c6_Heq : eq 1 (Nat.mul k q)"
                ],
                "tactic_res": [
                    "c12_goal : lt 0 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : lt 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case_eq _i .",
                "tactic_sig_no_out_arg": "case_eq _i .",
                "tactic_args": [
                    "c8_goal : False",
                    "c6_k : nat"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : eq k 0, False",
                    "c14_goal : forall (n : nat) (_ : eq k (S n)), False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq' .",
                "tactic_args": [
                    "c13_goal : forall _ : eq k 0, False"
                ],
                "tactic_res": [
                    "c15_goal : False",
                    "c15_Heq' : eq k 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c15_Heq' : eq k 0",
                    "c15_Heq : eq 1 (Nat.mul k q)"
                ],
                "tactic_res": [
                    "c15_Heq : eq 1 (Nat.mul 0 q)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c15_Heq : eq 1 (Nat.mul 0 q)"
                ],
                "tactic_res": [
                    "c15_Heq : eq 1 0"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c15_goal : False",
                    "c15_Heq : eq 1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (n : nat) (_ : eq k (S n)), False"
                ],
                "tactic_res": [
                    "c16_goal : False",
                    "c16_n : nat",
                    "c16_H : eq k (S n)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c16_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hlep' Hrec .",
                "tactic_args": [
                    "c5_goal : forall (m : nat) (_ : le 1 m)\n  (_ : forall _ : eq (check_primality m) true,\n       not\n         (ex\n            (fun k : nat =>\n             and (not (eq k 1))\n               (and (not (eq k m))\n                  (ex (fun q : nat => eq m (Init.Nat.mul q k)))))))\n  (_ : eq (check_primality (S m)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S m)))\n           (ex (fun q : nat => eq (S m) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : eq (check_primality (S p')) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c17_p' : nat",
                    "c17_Hlep' : le 1 p'",
                    "c17_Hrec : forall _ : eq (check_primality p') true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k p'))\n           (ex (fun q : nat => eq p' (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c17_goal : forall _ : eq (check_primality (S p')) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "_global_check_primality : forall _ : nat, bool"
                ],
                "tactic_res": [
                    "c18_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "assert ( H' : ( exists p'' : nat , _i = ( S p'' ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H' : ( exists p'' : nat , _i = ( S p'' ) ) ) .",
                "tactic_args": [
                    "c18_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c17_p' : nat"
                ],
                "tactic_res": [
                    "c19_goal : ex (fun p'' : nat => eq p' (S p''))",
                    "c20_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c20_H' : ex (fun p'' : nat => eq p' (S p''))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c19_goal : ex (fun p'' : nat => eq p' (S p''))",
                    "c17_Hlep' : le 1 p'"
                ],
                "tactic_res": [
                    "c21_goal : ex (fun p'' : nat => eq 1 (S p''))",
                    "c21_H : eq 1 p'",
                    "c22_goal : ex (fun p'' : nat => eq (S m) (S p''))",
                    "c22_H0 : eq (S m) p'",
                    "c22_H : le 1 m",
                    "c22_m : nat"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c21_goal : ex (fun p'' : nat => eq 1 (S p''))"
                ],
                "tactic_res": [
                    "c23_goal : eq 1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : eq 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c22_goal : ex (fun p'' : nat => eq (S m) (S p''))",
                    "_global_ex_intro : forall (A : Type) (P : forall _ : A, Prop) (x : A) (_ : P x), ex P"
                ],
                "tactic_res": [
                    "c24_goal : eq (S m) (S ?p'')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : eq (S m) (S ?p'')",
                    "c22_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c20_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c20_H' : ex (fun p'' : nat => eq p' (S p''))"
                ],
                "tactic_res": [
                    "c25_goal : forall (x : nat) (_ : eq p' (S x))\n  (_ : eq\n         (check_range (Z.of_nat (S p'))\n            (Init.Nat.pred (Init.Nat.pred (S p')))\n            (Z.of_nat (Init.Nat.pred (S p')))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p'' Hp'' .",
                "tactic_args": [
                    "c25_goal : forall (x : nat) (_ : eq p' (S x))\n  (_ : eq\n         (check_range (Z.of_nat (S p'))\n            (Init.Nat.pred (Init.Nat.pred (S p')))\n            (Z.of_nat (Init.Nat.pred (S p')))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c26_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c26_p'' : nat",
                    "c26_Hp'' : eq p' (S p'')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S p'))\n           (Init.Nat.pred (Init.Nat.pred (S p')))\n           (Z.of_nat (Init.Nat.pred (S p')))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S p')))\n           (ex (fun q : nat => eq (S p') (Init.Nat.mul q k))))))",
                    "c26_Hp'' : eq p' (S p'')"
                ],
                "tactic_res": [
                    "c27_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S (S p'')))\n           (Init.Nat.pred (Init.Nat.pred (S (S p''))))\n           (Z.of_nat (Init.Nat.pred (S (S p''))))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S (S p''))))\n           (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite <- pred_Sn .",
                "tactic_sig_no_out_arg": "repeat rewrite <- pred_Sn .",
                "tactic_args": [
                    "c27_goal : forall\n  _ : eq\n        (check_range (Z.of_nat (S (S p'')))\n           (Init.Nat.pred (Init.Nat.pred (S (S p''))))\n           (Z.of_nat (Init.Nat.pred (S (S p''))))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S (S p''))))\n           (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c28_goal : forall\n  _ : eq (check_range (Z.of_nat (S (S p''))) p'' (Z.of_nat (S p'')))\n        true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S (S p''))))\n           (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hcr Hex .",
                "tactic_args": [
                    "c28_goal : forall\n  _ : eq (check_range (Z.of_nat (S (S p''))) p'' (Z.of_nat (S p'')))\n        true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k (S (S p''))))\n           (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c29_goal : False",
                    "c29_Hcr : eq (check_range (Z.of_nat (S (S p''))) p'' (Z.of_nat (S p''))) true",
                    "c29_Hex : ex\n  (fun k : nat =>\n   and (not (eq k 1))\n     (and (not (eq k (S (S p''))))\n        (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "elim check_range_correct with ( 3 := _i ) .",
                "tactic_sig_no_out_arg": "elim check_range_correct with ( 3 := _i ) .",
                "tactic_args": [
                    "c29_goal : False",
                    "c29_Hcr : eq (check_range (Z.of_nat (S (S p''))) p'' (Z.of_nat (S p''))) true"
                ],
                "tactic_res": [
                    "c30_goal : Z.lt 0 (Z.of_nat (S (S p'')))",
                    "c31_goal : eq (Z.of_nat (S p'')) (Z.of_nat (S p''))",
                    "c32_goal : ex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c30_goal : Z.lt 0 (Z.of_nat (S (S p'')))",
                    "_global_inj_S : forall n : nat, eq (Z.of_nat (S n)) (Z.succ (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c33_goal : Z.lt 0 (Z.succ (Z.of_nat (S p'')))"
                ]
            },
            {
                "tactic_sig": "generalize ( Zle_0_nat ( S _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Zle_0_nat ( S _i ) ) .",
                "tactic_args": [
                    "c33_goal : Z.lt 0 (Z.succ (Z.of_nat (S p'')))",
                    "c26_p'' : nat"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : Z.le 0 (Z.of_nat (S p'')),\nZ.lt 0 (Z.succ (Z.of_nat (S p'')))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c34_goal : forall _ : Z.le 0 (Z.of_nat (S p'')),\nZ.lt 0 (Z.succ (Z.of_nat (S p'')))"
                ],
                "tactic_res": [
                    "c35_goal : Z.lt 0 (Z.succ (Z.of_nat (S p'')))",
                    "c35_H : Z.le 0 (Z.of_nat (S p''))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c35_goal : Z.lt 0 (Z.succ (Z.of_nat (S p'')))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : eq (Z.of_nat (S p'')) (Z.of_nat (S p''))",
                    "c26_p'' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c32_goal : ex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))",
                    "c29_Hex : ex\n  (fun k : nat =>\n   and (not (eq k 1))\n     (and (not (eq k (S (S p''))))\n        (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q k)))))"
                ],
                "tactic_res": [
                    "c36_goal : forall (x : nat)\n  (_ : and (not (eq x 1))\n         (and (not (eq x (S (S p''))))\n            (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q x))))),\nex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o , ( _o , ( _o , _o ) ) ) .",
                "tactic_sig_no_out_arg": "intros k ( Hne1 , ( HneSSp'' , ( q , Heq ) ) ) .",
                "tactic_args": [
                    "c36_goal : forall (x : nat)\n  (_ : and (not (eq x 1))\n         (and (not (eq x (S (S p''))))\n            (ex (fun q : nat => eq (S (S p'')) (Init.Nat.mul q x))))),\nex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))"
                ],
                "tactic_res": [
                    "c37_goal : ex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))",
                    "c37_k : nat",
                    "c37_Hne1 : not (eq k 1)",
                    "c37_HneSSp'' : not (eq k (S (S p'')))",
                    "c37_q : nat",
                    "c37_Heq : eq (S (S p'')) (Init.Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c37_goal : ex\n  (fun k : nat =>\n   and (le k (S p''))\n     (and (not (eq k 1))\n        (ex\n           (fun q : nat =>\n            eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))))",
                    "c37_k : nat"
                ],
                "tactic_res": [
                    "c38_goal : and (le k (S p''))\n  (and (not (eq k 1))\n     (ex\n        (fun q : nat =>\n         eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c38_goal : and (le k (S p''))\n  (and (not (eq k 1))\n     (ex\n        (fun q : nat =>\n         eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k))))"
                ],
                "tactic_res": [
                    "c39_goal : le k (S p'')",
                    "c40_goal : and (not (eq k 1))\n  (ex\n     (fun q : nat =>\n      eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))"
                ]
            },
            {
                "tactic_sig": "assert ( HkleSSp'' : _i <= S ( S _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( HkleSSp'' : _i <= S ( S _i ) ) .",
                "tactic_args": [
                    "c39_goal : le k (S p'')",
                    "c37_k : nat",
                    "c26_p'' : nat"
                ],
                "tactic_res": [
                    "c41_goal : le k (S (S p''))",
                    "c42_goal : le k (S p'')",
                    "c42_HkleSSp'' : le k (S (S p''))"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i ( _i _i ) ) _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i ( _i _i ) ) _i ) .",
                "tactic_args": [
                    "c41_goal : le k (S (S p''))",
                    "_global_divisor_smaller : forall (m p : nat) (_ : lt 0 m) (q : nat)\n         (_ : eq m (Init.Nat.mul q p)), le q m",
                    "_global_S : forall _ : nat, nat",
                    "_global_S : forall _ : nat, nat",
                    "c26_p'' : nat",
                    "c37_q : nat"
                ],
                "tactic_res": [
                    "c43_goal : lt 0 (S (S p''))",
                    "c44_goal : eq (S (S p'')) (Init.Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c43_goal : lt 0 (S (S p''))",
                    "c26_p'' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c44_goal : eq (S (S p'')) (Init.Nat.mul k q)",
                    "_global_Nat.mul_comm : forall n m : nat, eq (Nat.mul n m) (Nat.mul m n)"
                ],
                "tactic_res": [
                    "c45_goal : eq (S (S p'')) (Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c45_goal : eq (S (S p'')) (Nat.mul q k)",
                    "c37_Heq : eq (S (S p'')) (Init.Nat.mul q k)",
                    "c37_q : nat",
                    "c37_k : nat",
                    "c26_p'' : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c42_goal : le k (S p'')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c40_goal : and (not (eq k 1))\n  (ex\n     (fun q : nat =>\n      eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)))"
                ],
                "tactic_res": [
                    "c46_goal : not (eq k 1)",
                    "c47_goal : ex\n  (fun q : nat =>\n   eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c46_goal : not (eq k 1)",
                    "c37_Hne1 : not (eq k 1)",
                    "c37_k : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c47_goal : ex\n  (fun q : nat =>\n   eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k))",
                    "c37_q : nat"
                ],
                "tactic_res": [
                    "c48_goal : eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "now rewrite nat_to_Z_and_back .",
                "tactic_sig_no_out_arg": "now rewrite nat_to_Z_and_back .",
                "tactic_args": [
                    "c48_goal : eq (Z.abs_nat (Z.of_nat (S (S p'')))) (Init.Nat.mul q k)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "prime_2333",
        "proof": [
            {
                "tactic_sig": "Theorem prime_2333 : ~ ( exists k : nat , k <> 1 /\\ k <> 2333 /\\ ( exists q : nat , 2333 = q * k ) ) .",
                "tactic_sig_no_out_arg": "Theorem prime_2333 : ~ ( exists k : nat , k <> 1 /\\ k <> 2333 /\\ ( exists q : nat , 2333 = q * k ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k 2333))\n           (ex (fun q : nat => eq 2333 (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1))\n        (and (not (eq k 2333))\n           (ex (fun q : nat => eq 2333 (Init.Nat.mul q k))))))",
                    "_global_check_correct : forall (p : nat) (_ : lt 0 p) (_ : eq (check_primality p) true),\n       not\n         (ex\n            (fun k : nat =>\n             and (not (eq k 1))\n               (and (not (eq k p))\n                  (ex (fun q : nat => eq p (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c2_goal : lt 0 2333",
                    "c3_goal : eq (check_primality 2333) true"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c2_goal : lt 0 2333"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c3_goal : eq (check_primality 2333) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reflection_test",
        "proof": [
            {
                "tactic_sig": "Theorem reflection_test : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_sig_no_out_arg": "Theorem reflection_test : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ]
            },
            {
                "tactic_sig": "repeat rewrite Nat.add_assoc .",
                "tactic_sig_no_out_arg": "repeat rewrite Nat.add_assoc .",
                "tactic_args": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ],
                "tactic_res": [
                    "c3_goal : eq (Nat.add (Nat.add (Nat.add (Nat.add x y) z) t) u)\n  (Nat.add (Nat.add (Nat.add (Init.Nat.add x y) z) t) u)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (Nat.add (Nat.add (Nat.add (Nat.add x y) z) t) u)\n  (Nat.add (Nat.add (Nat.add (Init.Nat.add x y) z) t) u)",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_aux_valid",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_aux_valid : forall t t' : bin , bin_nat t + bin_nat t' = bin_nat ( flatten_aux t t' ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_aux_valid : forall t t' : bin , bin_nat t + bin_nat t' = bin_nat ( flatten_aux t t' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t t' : bin,\neq (Init.Nat.add (bin_nat t) (bin_nat t')) (bin_nat (flatten_aux t t'))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t .",
                "tactic_args": [
                    "c1_goal : forall t t' : bin,\neq (Init.Nat.add (bin_nat t) (bin_nat t')) (bin_nat (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c2_goal : forall t' : bin,\neq (Init.Nat.add (bin_nat t) (bin_nat t')) (bin_nat (flatten_aux t t'))",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall t' : bin,\neq (Init.Nat.add (bin_nat t) (bin_nat t')) (bin_nat (flatten_aux t t'))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b) (bin_nat t'))\n         (bin_nat (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b0) (bin_nat t'))\n         (bin_nat (flatten_aux b0 t'))) (t' : bin),\neq (Init.Nat.add (bin_nat (node b b0)) (bin_nat t'))\n  (bin_nat (flatten_aux (node b b0) t'))",
                    "c4_goal : forall (n : nat) (t' : bin),\neq (Init.Nat.add (bin_nat (leaf n)) (bin_nat t'))\n  (bin_nat (flatten_aux (leaf n) t'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b) (bin_nat t'))\n         (bin_nat (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b0) (bin_nat t'))\n         (bin_nat (flatten_aux b0 t'))) (t' : bin),\neq (Init.Nat.add (bin_nat (node b b0)) (bin_nat t'))\n  (bin_nat (flatten_aux (node b b0) t'))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b) (bin_nat t'))\n         (bin_nat (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b0) (bin_nat t'))\n         (bin_nat (flatten_aux b0 t'))) (t' : bin),\neq (Init.Nat.add (Init.Nat.add (bin_nat b) (bin_nat b0)) (bin_nat t'))\n  (bin_nat (flatten_aux b (flatten_aux b0 t')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (t' : bin),\neq (Init.Nat.add (bin_nat (leaf n)) (bin_nat t'))\n  (bin_nat (flatten_aux (leaf n) t'))"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (Init.Nat.add n (bin_nat t')) (Init.Nat.add n (bin_nat t'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (Init.Nat.add n (bin_nat t')) (Init.Nat.add n (bin_nat t'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 t' .",
                "tactic_args": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b) (bin_nat t'))\n         (bin_nat (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (Init.Nat.add (bin_nat b0) (bin_nat t'))\n         (bin_nat (flatten_aux b0 t'))) (t' : bin),\neq (Init.Nat.add (Init.Nat.add (bin_nat b) (bin_nat b0)) (bin_nat t'))\n  (bin_nat (flatten_aux b (flatten_aux b0 t')))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (bin_nat (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_t1 : bin",
                    "c7_IHt1 : forall t' : bin,\neq (Init.Nat.add (bin_nat t1) (bin_nat t'))\n  (bin_nat (flatten_aux t1 t'))",
                    "c7_t2 : bin",
                    "c7_IHt2 : forall t' : bin,\neq (Init.Nat.add (bin_nat t2) (bin_nat t'))\n  (bin_nat (flatten_aux t2 t'))",
                    "c7_t' : bin"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (bin_nat (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_IHt1 : forall t' : bin,\neq (Init.Nat.add (bin_nat t1) (bin_nat t'))\n  (bin_nat (flatten_aux t1 t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Init.Nat.add (bin_nat t1) (bin_nat (flatten_aux t2 t')))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Init.Nat.add (bin_nat t1) (bin_nat (flatten_aux t2 t')))",
                    "c7_IHt2 : forall t' : bin,\neq (Init.Nat.add (bin_nat t2) (bin_nat t'))\n  (bin_nat (flatten_aux t2 t'))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Init.Nat.add (bin_nat t1) (Init.Nat.add (bin_nat t2) (bin_nat t')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Init.Nat.add (bin_nat t1) (Init.Nat.add (bin_nat t2) (bin_nat t')))",
                    "_global_Nat.add_assoc : forall n m p : nat,\n       eq (Nat.add n (Nat.add m p)) (Nat.add (Nat.add n m) p)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Nat.add (Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c10_goal : eq (Init.Nat.add (Init.Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))\n  (Nat.add (Nat.add (bin_nat t1) (bin_nat t2)) (bin_nat t'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid : forall t : bin , bin_nat t = bin_nat ( flatten t ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid : forall t : bin , bin_nat t = bin_nat ( flatten t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t : bin, eq (bin_nat t) (bin_nat (flatten t))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t .",
                "tactic_args": [
                    "c1_goal : forall t : bin, eq (bin_nat t) (bin_nat (flatten t))"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_nat t) (bin_nat (flatten t))",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (bin_nat t) (bin_nat (flatten t))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_nat b) (bin_nat (flatten b))) \n  (b0 : bin) (_ : eq (bin_nat b0) (bin_nat (flatten b0))),\neq (bin_nat (node b b0)) (bin_nat (flatten (node b b0)))",
                    "c4_goal : forall n : nat, eq (bin_nat (leaf n)) (bin_nat (flatten (leaf n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_nat b) (bin_nat (flatten b))) \n  (b0 : bin) (_ : eq (bin_nat b0) (bin_nat (flatten b0))),\neq (bin_nat (node b b0)) (bin_nat (flatten (node b b0)))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_nat b) (bin_nat (flatten b))) \n  (b0 : bin) (_ : eq (bin_nat b0) (bin_nat (flatten b0))),\neq (Init.Nat.add (bin_nat b) (bin_nat b0))\n  (bin_nat (flatten_aux b (flatten b0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall n : nat, eq (bin_nat (leaf n)) (bin_nat (flatten (leaf n)))"
                ],
                "tactic_res": [
                    "c6_goal : forall n : nat, eq n n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall n : nat, eq n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_nat b) (bin_nat (flatten b))) \n  (b0 : bin) (_ : eq (bin_nat b0) (bin_nat (flatten b0))),\neq (Init.Nat.add (bin_nat b) (bin_nat b0))\n  (bin_nat (flatten_aux b (flatten b0)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (bin_nat (flatten_aux t1 (flatten t2)))",
                    "c7_t1 : bin",
                    "c7_IHt1 : eq (bin_nat t1) (bin_nat (flatten t1))",
                    "c7_t2 : bin",
                    "c7_IHt2 : eq (bin_nat t2) (bin_nat (flatten t2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (bin_nat (flatten_aux t1 (flatten t2)))",
                    "_global_flatten_aux_valid : forall t t' : bin,\n       eq (Init.Nat.add (bin_nat t) (bin_nat t'))\n         (bin_nat (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (Init.Nat.add (bin_nat t1) (bin_nat (flatten t2)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (Init.Nat.add (bin_nat t1) (bin_nat (flatten t2)))",
                    "c7_IHt2 : eq (bin_nat t2) (bin_nat (flatten t2))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (Init.Nat.add (bin_nat t1) (bin_nat t2))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq (Init.Nat.add (bin_nat t1) (bin_nat t2))\n  (Init.Nat.add (bin_nat t1) (bin_nat t2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid_2",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid_2 : forall t t' : bin , bin_nat ( flatten t ) = bin_nat ( flatten t' ) -> bin_nat t = bin_nat t' .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid_2 : forall t t' : bin , bin_nat ( flatten t ) = bin_nat ( flatten t' ) -> bin_nat t = bin_nat t' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (t t' : bin)\n  (_ : eq (bin_nat (flatten t)) (bin_nat (flatten t'))),\neq (bin_nat t) (bin_nat t')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (t t' : bin)\n  (_ : eq (bin_nat (flatten t)) (bin_nat (flatten t'))),\neq (bin_nat t) (bin_nat t')"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_nat t) (bin_nat t')",
                    "c2_t : bin",
                    "c2_t' : bin",
                    "c2_H : eq (bin_nat (flatten t)) (bin_nat (flatten t'))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (bin_nat t) (bin_nat t')",
                    "_global_flatten_valid : forall t : bin, eq (bin_nat t) (bin_nat (flatten t))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : eq (bin_nat (flatten t)) (bin_nat t')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (bin_nat (flatten t)) (bin_nat t')",
                    "_global_flatten_valid : forall t : bin, eq (bin_nat t) (bin_nat (flatten t))",
                    "c2_t' : bin"
                ],
                "tactic_res": [
                    "c4_goal : eq (bin_nat (flatten t)) (bin_nat (flatten t'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (bin_nat (flatten t)) (bin_nat (flatten t'))",
                    "c2_H : eq (bin_nat (flatten t)) (bin_nat (flatten t'))",
                    "c2_t : bin",
                    "c2_t' : bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reflection_test'",
        "proof": [
            {
                "tactic_sig": "Theorem reflection_test' : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_sig_no_out_arg": "Theorem reflection_test' : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ]
            },
            {
                "tactic_sig": "change ( bin_nat ( node ( leaf _i ) ( node ( node ( leaf _i ) ( leaf _i ) ) ( node ( leaf _i ) ( leaf _i ) ) ) ) = bin_nat ( node ( node ( leaf _i ) ( leaf _i ) ) ( node ( leaf _i ) ( node ( leaf _i ) ( leaf _i ) ) ) ) ) .",
                "tactic_sig_no_out_arg": "change ( bin_nat ( node ( leaf _i ) ( node ( node ( leaf _i ) ( leaf _i ) ) ( node ( leaf _i ) ( leaf _i ) ) ) ) = bin_nat ( node ( node ( leaf _i ) ( leaf _i ) ) ( node ( leaf _i ) ( node ( leaf _i ) ( leaf _i ) ) ) ) ) .",
                "tactic_args": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (bin_nat\n     (node (leaf x)\n        (node (node (leaf y) (leaf z)) (node (leaf t) (leaf u)))))\n  (bin_nat\n     (node (node (leaf x) (leaf y))\n        (node (leaf z) (node (leaf t) (leaf u)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (bin_nat\n     (node (leaf x)\n        (node (node (leaf y) (leaf z)) (node (leaf t) (leaf u)))))\n  (bin_nat\n     (node (node (leaf x) (leaf y))\n        (node (leaf z) (node (leaf t) (leaf u)))))",
                    "_global_flatten_valid_2 : forall (t t' : bin)\n         (_ : eq (bin_nat (flatten t)) (bin_nat (flatten t'))),\n       eq (bin_nat t) (bin_nat t')"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (bin_nat\n     (flatten\n        (node (leaf x)\n           (node (node (leaf y) (leaf z)) (node (leaf t) (leaf u))))))\n  (bin_nat\n     (flatten\n        (node (node (leaf x) (leaf y))\n           (node (leaf z) (node (leaf t) (leaf u))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq\n  (bin_nat\n     (flatten\n        (node (leaf x)\n           (node (node (leaf y) (leaf z)) (node (leaf t) (leaf u))))))\n  (bin_nat\n     (flatten\n        (node (node (leaf x) (leaf y))\n           (node (leaf z) (node (leaf t) (leaf u))))))",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reflection_test''",
        "proof": [
            {
                "tactic_sig": "Theorem reflection_test'' : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_sig_no_out_arg": "Theorem reflection_test'' : forall x y z t u : nat , x + ( y + z + ( t + u ) ) = x + y + ( z + ( t + u ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y z t u : nat,\neq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ],
                "tactic_res": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_z : nat",
                    "c2_t : nat",
                    "c2_u : nat"
                ]
            },
            {
                "tactic_sig": "assoc_eq_nat .",
                "tactic_sig_no_out_arg": "assoc_eq_nat .",
                "tactic_args": [
                    "c2_goal : eq\n  (Init.Nat.add x (Init.Nat.add (Init.Nat.add y z) (Init.Nat.add t u)))\n  (Init.Nat.add (Init.Nat.add x y) (Init.Nat.add z (Init.Nat.add t u)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_aux_valid_A",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_aux_valid_A : forall ( l : list A ) ( def : A ) ( t t' : bin ) , f ( bin_A l def t ) ( bin_A l def t' ) = bin_A l def ( flatten_aux t t' ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_aux_valid_A : forall ( l : list A ) ( def : A ) ( t t' : bin ) , f ( bin_A l def t ) ( bin_A l def t' ) = bin_A l def ( flatten_aux t t' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t t' : bin),\neq (f (bin_A l def t) (bin_A l def t'))\n  (bin_A l def (flatten_aux t t'))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t t' : bin),\neq (f (bin_A l def t) (bin_A l def t'))\n  (bin_A l def (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c2_goal : forall t' : bin,\neq (f (bin_A l def t) (bin_A l def t'))\n  (bin_A l def (flatten_aux t t'))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall t' : bin,\neq (f (bin_A l def t) (bin_A l def t'))\n  (bin_A l def (flatten_aux t t'))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b) (bin_A l def t'))\n         (bin_A l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b0) (bin_A l def t'))\n         (bin_A l def (flatten_aux b0 t'))) (t' : bin),\neq (f (bin_A l def (node b b0)) (bin_A l def t'))\n  (bin_A l def (flatten_aux (node b b0) t'))",
                    "c4_goal : forall (n : nat) (t' : bin),\neq (f (bin_A l def (leaf n)) (bin_A l def t'))\n  (bin_A l def (flatten_aux (leaf n) t'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b) (bin_A l def t'))\n         (bin_A l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b0) (bin_A l def t'))\n         (bin_A l def (flatten_aux b0 t'))) (t' : bin),\neq (f (bin_A l def (node b b0)) (bin_A l def t'))\n  (bin_A l def (flatten_aux (node b b0) t'))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b) (bin_A l def t'))\n         (bin_A l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b0) (bin_A l def t'))\n         (bin_A l def (flatten_aux b0 t'))) (t' : bin),\neq (f (f (bin_A l def b) (bin_A l def b0)) (bin_A l def t'))\n  (bin_A l def (flatten_aux b (flatten_aux b0 t')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (t' : bin),\neq (f (bin_A l def (leaf n)) (bin_A l def t'))\n  (bin_A l def (flatten_aux (leaf n) t'))"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (f (nth n l def) (bin_A l def t'))\n  (f (nth n l def) (bin_A l def t'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (f (nth n l def) (bin_A l def t'))\n  (f (nth n l def) (bin_A l def t'))",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 t' .",
                "tactic_args": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b) (bin_A l def t'))\n         (bin_A l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A l def b0) (bin_A l def t'))\n         (bin_A l def (flatten_aux b0 t'))) (t' : bin),\neq (f (f (bin_A l def b) (bin_A l def b0)) (bin_A l def t'))\n  (bin_A l def (flatten_aux b (flatten_aux b0 t')))"
                ],
                "tactic_res": [
                    "c7_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (bin_A l def (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_t1 : bin",
                    "c7_IHt1 : forall t' : bin,\neq (f (bin_A l def t1) (bin_A l def t'))\n  (bin_A l def (flatten_aux t1 t'))",
                    "c7_t2 : bin",
                    "c7_IHt2 : forall t' : bin,\neq (f (bin_A l def t2) (bin_A l def t'))\n  (bin_A l def (flatten_aux t2 t'))",
                    "c7_t' : bin"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (bin_A l def (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_IHt1 : forall t' : bin,\neq (f (bin_A l def t1) (bin_A l def t'))\n  (bin_A l def (flatten_aux t1 t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (f (bin_A l def t1) (bin_A l def (flatten_aux t2 t')))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (f (bin_A l def t1) (bin_A l def (flatten_aux t2 t')))",
                    "c7_IHt2 : forall t' : bin,\neq (f (bin_A l def t2) (bin_A l def t'))\n  (bin_A l def (flatten_aux t2 t'))"
                ],
                "tactic_res": [
                    "c9_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (f (bin_A l def t1) (f (bin_A l def t2) (bin_A l def t')))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c9_goal : eq (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))\n  (f (bin_A l def t1) (f (bin_A l def t2) (bin_A l def t')))"
                ],
                "tactic_res": [
                    "c10_goal : eq (f (bin_A l def t1) (f (bin_A l def t2) (bin_A l def t')))\n  (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (f (bin_A l def t1) (f (bin_A l def t2) (bin_A l def t')))\n  (f (f (bin_A l def t1) (bin_A l def t2)) (bin_A l def t'))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid_A",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid_A : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A l def t = bin_A l def ( flatten t ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid_A : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A l def t = bin_A l def ( flatten t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A l def t) (bin_A l def (flatten t))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A l def t) (bin_A l def (flatten t))"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A l def t) (bin_A l def (flatten t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (bin_A l def t) (bin_A l def (flatten t))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A l def b) (bin_A l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A l def b0) (bin_A l def (flatten b0))),\neq (bin_A l def (node b b0)) (bin_A l def (flatten (node b b0)))",
                    "c4_goal : forall n : nat,\neq (bin_A l def (leaf n)) (bin_A l def (flatten (leaf n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A l def b) (bin_A l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A l def b0) (bin_A l def (flatten b0))),\neq (bin_A l def (node b b0)) (bin_A l def (flatten (node b b0)))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A l def b) (bin_A l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A l def b0) (bin_A l def (flatten b0))),\neq (f (bin_A l def b) (bin_A l def b0))\n  (bin_A l def (flatten_aux b (flatten b0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall n : nat,\neq (bin_A l def (leaf n)) (bin_A l def (flatten (leaf n)))"
                ],
                "tactic_res": [
                    "c6_goal : forall n : nat, eq (nth n l def) (nth n l def)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : forall n : nat, eq (nth n l def) (nth n l def)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A l def b) (bin_A l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A l def b0) (bin_A l def (flatten b0))),\neq (f (bin_A l def b) (bin_A l def b0))\n  (bin_A l def (flatten_aux b (flatten b0)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (bin_A l def (flatten_aux t1 (flatten t2)))",
                    "c7_t1 : bin",
                    "c7_IHt1 : eq (bin_A l def t1) (bin_A l def (flatten t1))",
                    "c7_t2 : bin",
                    "c7_IHt2 : eq (bin_A l def t2) (bin_A l def (flatten t2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (bin_A l def (flatten_aux t1 (flatten t2)))",
                    "_global_flatten_aux_valid_A : forall (l : list A) (def : A) (t t' : bin),\n       eq (f (bin_A l def t) (bin_A l def t'))\n         (bin_A l def (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (f (bin_A l def t1) (bin_A l def (flatten t2)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (f (bin_A l def t1) (bin_A l def (flatten t2)))",
                    "c7_IHt2 : eq (bin_A l def t2) (bin_A l def (flatten t2))"
                ],
                "tactic_res": [
                    "c9_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (f (bin_A l def t1) (bin_A l def t2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (f (bin_A l def t1) (bin_A l def t2))\n  (f (bin_A l def t1) (bin_A l def t2))",
                    "c7_t2 : bin",
                    "c7_t1 : bin",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid_A_2",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid_A_2 : forall ( t t' : bin ) ( l : list A ) ( def : A ) , bin_A l def ( flatten t ) = bin_A l def ( flatten t' ) -> bin_A l def t = bin_A l def t' .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid_A_2 : forall ( t t' : bin ) ( l : list A ) ( def : A ) , bin_A l def ( flatten t ) = bin_A l def ( flatten t' ) -> bin_A l def t = bin_A l def t' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (t t' : bin) (l : list A) (def : A)\n  (_ : eq (bin_A l def (flatten t)) (bin_A l def (flatten t'))),\neq (bin_A l def t) (bin_A l def t')",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' l def Heq .",
                "tactic_args": [
                    "c1_goal : forall (t t' : bin) (l : list A) (def : A)\n  (_ : eq (bin_A l def (flatten t)) (bin_A l def (flatten t'))),\neq (bin_A l def t) (bin_A l def t')"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A l def t) (bin_A l def t')",
                    "c2_t : bin",
                    "c2_t' : bin",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_Heq : eq (bin_A l def (flatten t)) (bin_A l def (flatten t'))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (bin_A l def t) (bin_A l def t')",
                    "_global_flatten_valid_A : forall (l : list A) (def : A) (t : bin),\n       eq (bin_A l def t) (bin_A l def (flatten t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : eq (bin_A l def (flatten t)) (bin_A l def t')"
                ]
            },
            {
                "tactic_sig": "now rewrite ( flatten_valid_A _i _i _i ) .",
                "tactic_sig_no_out_arg": "now rewrite ( flatten_valid_A _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (bin_A l def (flatten t)) (bin_A l def t')",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t' : bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reflection_test3",
        "proof": [
            {
                "tactic_sig": "Theorem reflection_test3 : forall x y z t u : Z , ( x * ( y * z * ( t * u ) ) = x * y * ( z * ( t * u ) ) ) % Z .",
                "tactic_sig_no_out_arg": "Theorem reflection_test3 : forall x y z t u : Z , ( x * ( y * z * ( t * u ) ) = x * y * ( z * ( t * u ) ) ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y z t u : Z,\neq (Z.mul x (Z.mul (Z.mul y z) (Z.mul t u)))\n  (Z.mul (Z.mul x y) (Z.mul z (Z.mul t u)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y z t u : Z,\neq (Z.mul x (Z.mul (Z.mul y z) (Z.mul t u)))\n  (Z.mul (Z.mul x y) (Z.mul z (Z.mul t u)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.mul x (Z.mul (Z.mul y z) (Z.mul t u)))\n  (Z.mul (Z.mul x y) (Z.mul z (Z.mul t u)))",
                    "c2_x : Z",
                    "c2_y : Z",
                    "c2_z : Z",
                    "c2_t : Z",
                    "c2_u : Z"
                ]
            },
            {
                "tactic_sig": "assoc_eq Z Zmult Zmult_assoc .",
                "tactic_sig_no_out_arg": "assoc_eq Z Zmult Zmult_assoc .",
                "tactic_args": [
                    "c2_goal : eq (Z.mul x (Z.mul (Z.mul y z) (Z.mul t u)))\n  (Z.mul (Z.mul x y) (Z.mul z (Z.mul t u)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_aux_valid_A'",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_aux_valid_A' : forall ( l : list A ) ( def : A ) ( t t' : bin ) , f ( bin_A' l def t ) ( bin_A' l def t' ) = bin_A' l def ( flatten_aux t t' ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_aux_valid_A' : forall ( l : list A ) ( def : A ) ( t t' : bin ) , f ( bin_A' l def t ) ( bin_A' l def t' ) = bin_A' l def ( flatten_aux t t' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t t' : bin),\neq (f (bin_A' l def t) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t t'))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t t' : bin),\neq (f (bin_A' l def t) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c2_goal : forall t' : bin,\neq (f (bin_A' l def t) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t t'))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall t' : bin,\neq (f (bin_A' l def t) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t t'))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b0) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b0 t'))) (t' : bin),\neq (f (bin_A' l def (node b b0)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux (node b b0) t'))",
                    "c4_goal : forall (n : nat) (t' : bin),\neq (f (bin_A' l def (leaf n)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux (leaf n) t'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b0) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b0 t'))) (t' : bin),\neq (f (bin_A' l def (node b b0)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux (node b b0) t'))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b0) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b0 t'))) (t' : bin),\neq (f (f (bin_A' l def b) (bin_A' l def b0)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux b (flatten_aux b0 t')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (t' : bin),\neq (f (bin_A' l def (leaf n)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux (leaf n) t'))"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (f (nth n l def) (bin_A' l def t'))\n  (f (nth n l def) (bin_A' l def t'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (t' : bin),\neq (f (nth n l def) (bin_A' l def t'))\n  (f (nth n l def) (bin_A' l def t'))",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 t' .",
                "tactic_args": [
                    "c5_goal : forall (b : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b t'))) (b0 : bin)\n  (_ : forall t' : bin,\n       eq (f (bin_A' l def b0) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux b0 t'))) (t' : bin),\neq (f (f (bin_A' l def b) (bin_A' l def b0)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux b (flatten_aux b0 t')))"
                ],
                "tactic_res": [
                    "c7_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_t1 : bin",
                    "c7_IHt1 : forall t' : bin,\neq (f (bin_A' l def t1) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t1 t'))",
                    "c7_t2 : bin",
                    "c7_IHt2 : forall t' : bin,\neq (f (bin_A' l def t2) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t2 t'))",
                    "c7_t' : bin"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t1 (flatten_aux t2 t')))",
                    "c7_IHt1 : forall t' : bin,\neq (f (bin_A' l def t1) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t1 t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (f (bin_A' l def t1) (bin_A' l def (flatten_aux t2 t')))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (f (bin_A' l def t1) (bin_A' l def (flatten_aux t2 t')))",
                    "c7_IHt2 : forall t' : bin,\neq (f (bin_A' l def t2) (bin_A' l def t'))\n  (bin_A' l def (flatten_aux t2 t'))"
                ],
                "tactic_res": [
                    "c9_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (f (bin_A' l def t1) (f (bin_A' l def t2) (bin_A' l def t')))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c9_goal : eq (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))\n  (f (bin_A' l def t1) (f (bin_A' l def t2) (bin_A' l def t')))"
                ],
                "tactic_res": [
                    "c10_goal : eq (f (bin_A' l def t1) (f (bin_A' l def t2) (bin_A' l def t')))\n  (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (f (bin_A' l def t1) (f (bin_A' l def t2) (bin_A' l def t')))\n  (f (f (bin_A' l def t1) (bin_A' l def t2)) (bin_A' l def t'))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid_A'",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid_A' : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A' l def t = bin_A' l def ( flatten t ) .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid_A' : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A' l def t = bin_A' l def ( flatten t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A' l def t) (bin_A' l def (flatten t))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A' l def t) (bin_A' l def (flatten t))"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A' l def t) (bin_A' l def (flatten t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (bin_A' l def t) (bin_A' l def (flatten t))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A' l def b) (bin_A' l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A' l def b0) (bin_A' l def (flatten b0))),\neq (bin_A' l def (node b b0)) (bin_A' l def (flatten (node b b0)))",
                    "c4_goal : forall n : nat,\neq (bin_A' l def (leaf n)) (bin_A' l def (flatten (leaf n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A' l def b) (bin_A' l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A' l def b0) (bin_A' l def (flatten b0))),\neq (bin_A' l def (node b b0)) (bin_A' l def (flatten (node b b0)))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A' l def b) (bin_A' l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A' l def b0) (bin_A' l def (flatten b0))),\neq (f (bin_A' l def b) (bin_A' l def b0))\n  (bin_A' l def (flatten_aux b (flatten b0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall n : nat,\neq (bin_A' l def (leaf n)) (bin_A' l def (flatten (leaf n)))"
                ],
                "tactic_res": [
                    "c6_goal : forall n : nat, eq (nth n l def) (nth n l def)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : forall n : nat, eq (nth n l def) (nth n l def)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 t2 IHt2 .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A' l def b) (bin_A' l def (flatten b)))\n  (b0 : bin) (_ : eq (bin_A' l def b0) (bin_A' l def (flatten b0))),\neq (f (bin_A' l def b) (bin_A' l def b0))\n  (bin_A' l def (flatten_aux b (flatten b0)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (bin_A' l def (flatten_aux t1 (flatten t2)))",
                    "c7_t1 : bin",
                    "c7_IHt1 : eq (bin_A' l def t1) (bin_A' l def (flatten t1))",
                    "c7_t2 : bin",
                    "c7_IHt2 : eq (bin_A' l def t2) (bin_A' l def (flatten t2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (bin_A' l def (flatten_aux t1 (flatten t2)))",
                    "_global_flatten_aux_valid_A' : forall (l : list A) (def : A) (t t' : bin),\n       eq (f (bin_A' l def t) (bin_A' l def t'))\n         (bin_A' l def (flatten_aux t t'))"
                ],
                "tactic_res": [
                    "c8_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (f (bin_A' l def t1) (bin_A' l def (flatten t2)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (f (bin_A' l def t1) (bin_A' l def (flatten t2)))",
                    "c7_IHt2 : eq (bin_A' l def t2) (bin_A' l def (flatten t2))"
                ],
                "tactic_res": [
                    "c9_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (f (bin_A' l def t1) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq (f (bin_A' l def t1) (bin_A' l def t2))\n  (f (bin_A' l def t1) (bin_A' l def t2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flatten_valid_A_2'",
        "proof": [
            {
                "tactic_sig": "Theorem flatten_valid_A_2' : forall ( t t' : bin ) ( l : list A ) ( def : A ) , bin_A' l def ( flatten t ) = bin_A' l def ( flatten t' ) -> bin_A' l def t = bin_A' l def t' .",
                "tactic_sig_no_out_arg": "Theorem flatten_valid_A_2' : forall ( t t' : bin ) ( l : list A ) ( def : A ) , bin_A' l def ( flatten t ) = bin_A' l def ( flatten t' ) -> bin_A' l def t = bin_A' l def t' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (t t' : bin) (l : list A) (def : A)\n  (_ : eq (bin_A' l def (flatten t)) (bin_A' l def (flatten t'))),\neq (bin_A' l def t) (bin_A' l def t')",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' l def Heq .",
                "tactic_args": [
                    "c1_goal : forall (t t' : bin) (l : list A) (def : A)\n  (_ : eq (bin_A' l def (flatten t)) (bin_A' l def (flatten t'))),\neq (bin_A' l def t) (bin_A' l def t')"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A' l def t) (bin_A' l def t')",
                    "c2_t : bin",
                    "c2_t' : bin",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_Heq : eq (bin_A' l def (flatten t)) (bin_A' l def (flatten t'))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (bin_A' l def t) (bin_A' l def t')",
                    "_global_flatten_valid_A' : forall (l : list A) (def : A) (t : bin),\n       eq (bin_A' l def t) (bin_A' l def (flatten t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : eq (bin_A' l def (flatten t)) (bin_A' l def t')"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (bin_A' l def (flatten t)) (bin_A' l def t')",
                    "_global_flatten_valid_A' : forall (l : list A) (def : A) (t : bin),\n       eq (bin_A' l def t) (bin_A' l def (flatten t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t' : bin"
                ],
                "tactic_res": [
                    "c4_goal : eq (bin_A' l def (flatten t)) (bin_A' l def (flatten t'))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : eq (bin_A' l def (flatten t)) (bin_A' l def (flatten t'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "insert_is_f",
        "proof": [
            {
                "tactic_sig": "Theorem insert_is_f : forall ( l : list A ) ( def : A ) ( n : nat ) ( t : bin ) , bin_A' l def ( insert_bin n t ) = f ( nth n l def ) ( bin_A' l def t ) .",
                "tactic_sig_no_out_arg": "Theorem insert_is_f : forall ( l : list A ) ( def : A ) ( n : nat ) ( t : bin ) , bin_A' l def ( insert_bin n t ) = f ( nth n l def ) ( bin_A' l def t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (n : nat) (t : bin),\neq (bin_A' l def (insert_bin n t)) (f (nth n l def) (bin_A' l def t))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def n t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (n : nat) (t : bin),\neq (bin_A' l def (insert_bin n t)) (f (nth n l def) (bin_A' l def t))"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A' l def (insert_bin n t)) (f (nth n l def) (bin_A' l def t))",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_n : nat",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (bin_A' l def (insert_bin n t)) (f (nth n l def) (bin_A' l def t))",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))) (b0 : bin)\n  (_ : eq (bin_A' l def (insert_bin n b0))\n         (f (nth n l def) (bin_A' l def b0))),\neq (bin_A' l def (insert_bin n (node b b0)))\n  (f (nth n l def) (bin_A' l def (node b b0)))",
                    "c4_goal : forall n0 : nat,\neq (bin_A' l def (insert_bin n (leaf n0)))\n  (f (nth n l def) (bin_A' l def (leaf n0)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t1 .",
                "tactic_args": [
                    "c3_goal : forall (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))) (b0 : bin)\n  (_ : eq (bin_A' l def (insert_bin n b0))\n         (f (nth n l def) (bin_A' l def b0))),\neq (bin_A' l def (insert_bin n (node b b0)))\n  (f (nth n l def) (bin_A' l def (node b b0)))"
                ],
                "tactic_res": [
                    "c5_goal : forall\n  (_ : eq (bin_A' l def (insert_bin n t1))\n         (f (nth n l def) (bin_A' l def t1))) (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))),\neq (bin_A' l def (insert_bin n (node t1 b)))\n  (f (nth n l def) (bin_A' l def (node t1 b)))",
                    "c5_t1 : bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c5_goal : forall\n  (_ : eq (bin_A' l def (insert_bin n t1))\n         (f (nth n l def) (bin_A' l def t1))) (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))),\neq (bin_A' l def (insert_bin n (node t1 b)))\n  (f (nth n l def) (bin_A' l def (node t1 b)))",
                    "c5_t1 : bin"
                ],
                "tactic_res": [
                    "c6_goal : forall (b b0 : bin)\n  (_ : eq (bin_A' l def (insert_bin n (node b b0)))\n         (f (nth n l def) (bin_A' l def (node b b0)))) \n  (b1 : bin)\n  (_ : eq (bin_A' l def (insert_bin n b1))\n         (f (nth n l def) (bin_A' l def b1))),\neq (bin_A' l def (insert_bin n (node (node b b0) b1)))\n  (f (nth n l def) (bin_A' l def (node (node b b0) b1)))",
                    "c7_goal : forall (n0 : nat)\n  (_ : eq (bin_A' l def (insert_bin n (leaf n0)))\n         (f (nth n l def) (bin_A' l def (leaf n0)))) \n  (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))),\neq (bin_A' l def (insert_bin n (node (leaf n0) b)))\n  (f (nth n l def) (bin_A' l def (node (leaf n0) b)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1' t1'' IHt1 t2 IHt2 .",
                "tactic_args": [
                    "c6_goal : forall (b b0 : bin)\n  (_ : eq (bin_A' l def (insert_bin n (node b b0)))\n         (f (nth n l def) (bin_A' l def (node b b0)))) \n  (b1 : bin)\n  (_ : eq (bin_A' l def (insert_bin n b1))\n         (f (nth n l def) (bin_A' l def b1))),\neq (bin_A' l def (insert_bin n (node (node b b0) b1)))\n  (f (nth n l def) (bin_A' l def (node (node b b0) b1)))"
                ],
                "tactic_res": [
                    "c8_goal : eq (bin_A' l def (insert_bin n (node (node t1' t1'') t2)))\n  (f (nth n l def) (bin_A' l def (node (node t1' t1'') t2)))",
                    "c8_t1' : bin",
                    "c8_t1'' : bin",
                    "c8_IHt1 : eq (bin_A' l def (insert_bin n (node t1' t1'')))\n  (f (nth n l def) (bin_A' l def (node t1' t1'')))",
                    "c8_t2 : bin",
                    "c8_IHt2 : eq (bin_A' l def (insert_bin n t2)) (f (nth n l def) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (bin_A' l def (insert_bin n (node (node t1' t1'') t2)))\n  (f (nth n l def) (bin_A' l def (node (node t1' t1'') t2)))"
                ],
                "tactic_res": [
                    "c9_goal : eq\n  (f (nth n l def)\n     (f (f (bin_A' l def t1') (bin_A' l def t1'')) (bin_A' l def t2)))\n  (f (nth n l def)\n     (f (f (bin_A' l def t1') (bin_A' l def t1'')) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq\n  (f (nth n l def)\n     (f (f (bin_A' l def t1') (bin_A' l def t1'')) (bin_A' l def t2)))\n  (f (nth n l def)\n     (f (f (bin_A' l def t1') (bin_A' l def t1'')) (bin_A' l def t2)))",
                    "c8_t2 : bin",
                    "c8_t1' : bin",
                    "c8_t1'' : bin",
                    "c2_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n0 IHt1 t2 IHt2 .",
                "tactic_args": [
                    "c7_goal : forall (n0 : nat)\n  (_ : eq (bin_A' l def (insert_bin n (leaf n0)))\n         (f (nth n l def) (bin_A' l def (leaf n0)))) \n  (b : bin)\n  (_ : eq (bin_A' l def (insert_bin n b))\n         (f (nth n l def) (bin_A' l def b))),\neq (bin_A' l def (insert_bin n (node (leaf n0) b)))\n  (f (nth n l def) (bin_A' l def (node (leaf n0) b)))"
                ],
                "tactic_res": [
                    "c10_goal : eq (bin_A' l def (insert_bin n (node (leaf n0) t2)))\n  (f (nth n l def) (bin_A' l def (node (leaf n0) t2)))",
                    "c10_n0 : nat",
                    "c10_IHt1 : eq (bin_A' l def (insert_bin n (leaf n0)))\n  (f (nth n l def) (bin_A' l def (leaf n0)))",
                    "c10_t2 : bin",
                    "c10_IHt2 : eq (bin_A' l def (insert_bin n t2)) (f (nth n l def) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : eq (bin_A' l def (insert_bin n (node (leaf n0) t2)))\n  (f (nth n l def) (bin_A' l def (node (leaf n0) t2)))"
                ],
                "tactic_res": [
                    "c11_goal : eq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (node (leaf n0) t2)\n      else node (leaf n0) (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "case ( nat_le_bool _i _i ) .",
                "tactic_sig_no_out_arg": "case ( nat_le_bool _i _i ) .",
                "tactic_args": [
                    "c11_goal : eq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (node (leaf n0) t2)\n      else node (leaf n0) (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))",
                    "c2_n : nat",
                    "c10_n0 : nat"
                ],
                "tactic_res": [
                    "c12_goal : eq (bin_A' l def (node (leaf n) (node (leaf n0) t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))",
                    "c13_goal : eq (bin_A' l def (node (leaf n0) (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : eq (bin_A' l def (node (leaf n) (node (leaf n0) t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ],
                "tactic_res": [
                    "c14_goal : eq (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : eq (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))",
                    "c10_t2 : bin",
                    "c10_n0 : nat",
                    "c2_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : eq (bin_A' l def (node (leaf n0) (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ],
                "tactic_res": [
                    "c15_goal : eq (f (nth n0 l def) (bin_A' l def (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : eq (f (nth n0 l def) (bin_A' l def (insert_bin n t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))",
                    "c10_IHt2 : eq (bin_A' l def (insert_bin n t2)) (f (nth n l def) (bin_A' l def t2))"
                ],
                "tactic_res": [
                    "c16_goal : eq (f (nth n0 l def) (f (nth n l def) (bin_A' l def t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite _i .",
                "tactic_sig_no_out_arg": "repeat rewrite _i .",
                "tactic_args": [
                    "c16_goal : eq (f (nth n0 l def) (f (nth n l def) (bin_A' l def t2)))\n  (f (nth n l def) (f (nth n0 l def) (bin_A' l def t2)))",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)"
                ],
                "tactic_res": [
                    "c17_goal : eq (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))\n  (f (f (nth n l def) (nth n0 l def)) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i _i ) ) .",
                "tactic_args": [
                    "c17_goal : eq (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))\n  (f (f (nth n l def) (nth n0 l def)) (bin_A' l def t2))",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "_global_nth : forall (A : Type) (_ : nat) (_ : list A) (_ : A), A",
                    "c2_n : nat",
                    "c2_l : list A",
                    "c2_def : A"
                ],
                "tactic_res": [
                    "c18_goal : eq (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))\n  (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))\n  (f (f (nth n0 l def) (nth n l def)) (bin_A' l def t2))",
                    "c10_t2 : bin",
                    "c10_n0 : nat",
                    "c2_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall n0 : nat,\neq (bin_A' l def (insert_bin n (leaf n0)))\n  (f (nth n l def) (bin_A' l def (leaf n0)))"
                ],
                "tactic_res": [
                    "c19_goal : forall n0 : nat,\neq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (leaf n0)\n      else node (leaf n0) (leaf n))) (f (nth n l def) (nth n0 l def))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n0 .",
                "tactic_args": [
                    "c19_goal : forall n0 : nat,\neq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (leaf n0)\n      else node (leaf n0) (leaf n))) (f (nth n l def) (nth n0 l def))"
                ],
                "tactic_res": [
                    "c20_goal : eq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (leaf n0)\n      else node (leaf n0) (leaf n))) (f (nth n l def) (nth n0 l def))",
                    "c20_n0 : nat"
                ]
            },
            {
                "tactic_sig": "case ( nat_le_bool _i _i ) .",
                "tactic_sig_no_out_arg": "case ( nat_le_bool _i _i ) .",
                "tactic_args": [
                    "c20_goal : eq\n  (bin_A' l def\n     (if nat_le_bool n n0\n      then node (leaf n) (leaf n0)\n      else node (leaf n0) (leaf n))) (f (nth n l def) (nth n0 l def))",
                    "c2_n : nat",
                    "c20_n0 : nat"
                ],
                "tactic_res": [
                    "c21_goal : eq (bin_A' l def (node (leaf n) (leaf n0)))\n  (f (nth n l def) (nth n0 l def))",
                    "c22_goal : eq (bin_A' l def (node (leaf n0) (leaf n)))\n  (f (nth n l def) (nth n0 l def))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : eq (bin_A' l def (node (leaf n) (leaf n0)))\n  (f (nth n l def) (nth n0 l def))",
                    "c20_n0 : nat",
                    "c2_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try rewrite _i .",
                "tactic_sig_no_out_arg": "try rewrite _i .",
                "tactic_args": [
                    "c22_goal : eq (bin_A' l def (node (leaf n0) (leaf n)))\n  (f (nth n l def) (nth n0 l def))",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)"
                ],
                "tactic_res": [
                    "c23_goal : eq (bin_A' l def (node (leaf n0) (leaf n)))\n  (f (nth n0 l def) (nth n l def))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : eq (bin_A' l def (node (leaf n0) (leaf n)))\n  (f (nth n0 l def) (nth n l def))",
                    "c20_n0 : nat",
                    "c2_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sort_eq",
        "proof": [
            {
                "tactic_sig": "Theorem sort_eq : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A' l def ( sort_bin t ) = bin_A' l def t .",
                "tactic_sig_no_out_arg": "Theorem sort_eq : forall ( l : list A ) ( def : A ) ( t : bin ) , bin_A' l def ( sort_bin t ) = bin_A' l def t .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A' l def (sort_bin t)) (bin_A' l def t)",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t : bin),\neq (bin_A' l def (sort_bin t)) (bin_A' l def t)"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_A' l def (sort_bin t)) (bin_A' l def t)",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t : bin"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (bin_A' l def (sort_bin t)) (bin_A' l def t)",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b))\n  (b0 : bin) (_ : eq (bin_A' l def (sort_bin b0)) (bin_A' l def b0)),\neq (bin_A' l def (sort_bin (node b b0))) (bin_A' l def (node b b0))",
                    "c4_goal : forall n : nat,\neq (bin_A' l def (sort_bin (leaf n))) (bin_A' l def (leaf n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t1 IHt1 .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b))\n  (b0 : bin) (_ : eq (bin_A' l def (sort_bin b0)) (bin_A' l def b0)),\neq (bin_A' l def (sort_bin (node b b0))) (bin_A' l def (node b b0))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b)),\neq (bin_A' l def (sort_bin (node t1 b))) (bin_A' l def (node t1 b))",
                    "c5_t1 : bin",
                    "c5_IHt1 : eq (bin_A' l def (sort_bin t1)) (bin_A' l def t1)"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b)),\neq (bin_A' l def (sort_bin (node t1 b))) (bin_A' l def (node t1 b))",
                    "c5_t1 : bin"
                ],
                "tactic_res": [
                    "c6_goal : forall (b b0 b1 : bin)\n  (_ : eq (bin_A' l def (sort_bin b1)) (bin_A' l def b1)),\neq (bin_A' l def (sort_bin (node (node b b0) b1)))\n  (bin_A' l def (node (node b b0) b1))",
                    "c7_goal : forall (n : nat) (b : bin)\n  (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b)),\neq (bin_A' l def (sort_bin (node (leaf n) b)))\n  (bin_A' l def (node (leaf n) b))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (b b0 b1 : bin)\n  (_ : eq (bin_A' l def (sort_bin b1)) (bin_A' l def b1)),\neq (bin_A' l def (sort_bin (node (node b b0) b1)))\n  (bin_A' l def (node (node b b0) b1))",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n t2 IHt2 .",
                "tactic_args": [
                    "c7_goal : forall (n : nat) (b : bin)\n  (_ : eq (bin_A' l def (sort_bin b)) (bin_A' l def b)),\neq (bin_A' l def (sort_bin (node (leaf n) b)))\n  (bin_A' l def (node (leaf n) b))"
                ],
                "tactic_res": [
                    "c8_goal : eq (bin_A' l def (sort_bin (node (leaf n) t2)))\n  (bin_A' l def (node (leaf n) t2))",
                    "c8_n : nat",
                    "c8_t2 : bin",
                    "c8_IHt2 : eq (bin_A' l def (sort_bin t2)) (bin_A' l def t2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (bin_A' l def (sort_bin (node (leaf n) t2)))\n  (bin_A' l def (node (leaf n) t2))"
                ],
                "tactic_res": [
                    "c9_goal : eq (bin_A' l def (insert_bin n (sort_bin t2)))\n  (f (nth n l def) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (bin_A' l def (insert_bin n (sort_bin t2)))\n  (f (nth n l def) (bin_A' l def t2))",
                    "_global_insert_is_f : forall (l : list A) (def : A) (n : nat) (t : bin),\n       eq (bin_A' l def (insert_bin n t)) (f (nth n l def) (bin_A' l def t))"
                ],
                "tactic_res": [
                    "c10_goal : eq (f (nth n l def) (bin_A' l def (sort_bin t2)))\n  (f (nth n l def) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (f (nth n l def) (bin_A' l def (sort_bin t2)))\n  (f (nth n l def) (bin_A' l def t2))",
                    "c8_IHt2 : eq (bin_A' l def (sort_bin t2)) (bin_A' l def t2)"
                ],
                "tactic_res": [
                    "c11_goal : eq (f (nth n l def) (bin_A' l def t2))\n  (f (nth n l def) (bin_A' l def t2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq (f (nth n l def) (bin_A' l def t2))\n  (f (nth n l def) (bin_A' l def t2))",
                    "c8_t2 : bin",
                    "c8_n : nat",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall n : nat,\neq (bin_A' l def (sort_bin (leaf n))) (bin_A' l def (leaf n))",
                    "c2_def : A",
                    "c2_l : list A",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sort_eq_2",
        "proof": [
            {
                "tactic_sig": "Theorem sort_eq_2 : forall ( l : list A ) ( def : A ) ( t1 t2 : bin ) , bin_A' l def ( sort_bin t1 ) = bin_A' l def ( sort_bin t2 ) -> bin_A' l def t1 = bin_A' l def t2 .",
                "tactic_sig_no_out_arg": "Theorem sort_eq_2 : forall ( l : list A ) ( def : A ) ( t1 t2 : bin ) , bin_A' l def ( sort_bin t1 ) = bin_A' l def ( sort_bin t2 ) -> bin_A' l def t1 = bin_A' l def t2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (def : A) (t1 t2 : bin)\n  (_ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2))),\neq (bin_A' l def t1) (bin_A' l def t2)",
                    "c1_assoc : forall x y z : A, eq (f x (f y z)) (f (f x y) z)",
                    "c1_comm : forall x y : A, eq (f x y) (f y x)",
                    "c1_f : forall (_ : A) (_ : A), A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l def t1 t2 .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (def : A) (t1 t2 : bin)\n  (_ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2))),\neq (bin_A' l def t1) (bin_A' l def t2)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def t1) (bin_A' l def t2)",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t1 : bin",
                    "c2_t2 : bin"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def t1) (bin_A' l def t2)",
                    "_global_sort_eq : forall (l : list A) (def : A) (t : bin),\n       eq (bin_A' l def (sort_bin t)) (bin_A' l def t)",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t1 : bin"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def (sort_bin t1)) (bin_A' l def t2)"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def (sort_bin t1)) (bin_A' l def t2)",
                    "_global_sort_eq : forall (l : list A) (def : A) (t : bin),\n       eq (bin_A' l def (sort_bin t)) (bin_A' l def t)",
                    "c2_l : list A",
                    "c2_def : A",
                    "c2_t2 : bin"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2)),\neq (bin_A' l def (sort_bin t1)) (bin_A' l def (sort_bin t2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reflection_test4",
        "proof": [
            {
                "tactic_sig": "Theorem reflection_test4 : forall x y z : Z , ( x + ( y + z ) = ( z + x ) + y ) % Z .",
                "tactic_sig_no_out_arg": "Theorem reflection_test4 : forall x y z : Z , ( x + ( y + z ) = ( z + x ) + y ) % Z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y z : Z, eq (Z.add x (Z.add y z)) (Z.add (Z.add z x) y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y z .",
                "tactic_args": [
                    "c1_goal : forall x y z : Z, eq (Z.add x (Z.add y z)) (Z.add (Z.add z x) y)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Z.add x (Z.add y z)) (Z.add (Z.add z x) y)",
                    "c2_x : Z",
                    "c2_y : Z",
                    "c2_z : Z"
                ]
            },
            {
                "tactic_sig": "comm_eq' Z Zplus Zplus_assoc Zplus_comm .",
                "tactic_sig_no_out_arg": "comm_eq' Z Zplus Zplus_assoc Zplus_comm .",
                "tactic_args": [
                    "c2_goal : eq (Z.add x (Z.add y z)) (Z.add (Z.add z x) y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_Zsqrt",
        "proof": [
            {
                "tactic_sig": "Theorem div_Zsqrt : forall m n p : Z , 0 < m < n -> n = m * p -> 0 < m <= Z.sqrt n \\/ 0 < p <= Z.sqrt n .",
                "tactic_sig_no_out_arg": "Theorem div_Zsqrt : forall m n p : Z , 0 < m < n -> n = m * p -> 0 < m <= Z.sqrt n \\/ 0 < p <= Z.sqrt n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m n p : Z) (_ : and (Z.lt 0 m) (Z.lt m n))\n  (_ : eq n (Z.mul m p)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros m n p Hint Heq .",
                "tactic_args": [
                    "c1_goal : forall (m n p : Z) (_ : and (Z.lt 0 m) (Z.lt m n))\n  (_ : eq n (Z.mul m p)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c2_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c2_m : Z",
                    "c2_n : Z",
                    "c2_p : Z",
                    "c2_Hint : and (Z.lt 0 m) (Z.lt m n)",
                    "c2_Heq : eq n (Z.mul m p)"
                ]
            },
            {
                "tactic_sig": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_args": [
                    "c2_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c2_n : Z",
                    "c2_m : Z"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Z.lt (Z.sqrt n) m,\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c4_goal : forall _ : Z.le m (Z.sqrt n),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ]
            },
            {
                "tactic_sig": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_args": [
                    "c3_goal : forall _ : Z.lt (Z.sqrt n) m,\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c2_n : Z",
                    "c2_p : Z"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : Z.lt (Z.sqrt n) p) (_ : Z.lt (Z.sqrt n) m),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c6_goal : forall (_ : Z.le p (Z.sqrt n)) (_ : Z.lt (Z.sqrt n) m),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ]
            },
            {
                "tactic_sig": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( Z_lt_le_dec ( Z.sqrt _i ) _i ) .",
                "tactic_args": [
                    "c4_goal : forall _ : Z.le m (Z.sqrt n),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c2_n : Z",
                    "c2_p : Z"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : Z.lt (Z.sqrt n) p) (_ : Z.le m (Z.sqrt n)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c8_goal : forall (_ : Z.le p (Z.sqrt n)) (_ : Z.le m (Z.sqrt n)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hltm Hltp .",
                "tactic_args": [
                    "c5_goal : forall (_ : Z.lt (Z.sqrt n) p) (_ : Z.lt (Z.sqrt n) m),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c9_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c9_Hltm : Z.lt (Z.sqrt n) p",
                    "c9_Hltp : Z.lt (Z.sqrt n) m"
                ]
            },
            {
                "tactic_sig": "assert ( Hlem : ( Z.sqrt _i ) + 1 <= _i ) by lia .",
                "tactic_sig_no_out_arg": "assert ( Hlem : ( Z.sqrt _i ) + 1 <= _i ) by lia .",
                "tactic_args": [
                    "c2_n : Z",
                    "c2_m : Z"
                ],
                "tactic_res": [
                    "c9_Hlem : Z.le (Z.add (Z.sqrt n) 1) m"
                ]
            },
            {
                "tactic_sig": "assert ( Hlep : ( Z.sqrt _i ) + 1 <= _i ) by lia .",
                "tactic_sig_no_out_arg": "assert ( Hlep : ( Z.sqrt _i ) + 1 <= _i ) by lia .",
                "tactic_args": [
                    "c2_n : Z",
                    "c2_p : Z"
                ],
                "tactic_res": [
                    "c9_Hlep : Z.le (Z.add (Z.sqrt n) 1) p"
                ]
            },
            {
                "tactic_sig": "elim ( Z.lt_irrefl _i ) .",
                "tactic_sig_no_out_arg": "elim ( Z.lt_irrefl _i ) .",
                "tactic_args": [
                    "c9_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c10_goal : Z.lt n n"
                ]
            },
            {
                "tactic_sig": "apply _i with ( ( ( _i _i ) + 1 ) * ( ( _i _i ) + 1 ) ) .",
                "tactic_sig_no_out_arg": "apply _i with ( ( ( _i _i ) + 1 ) * ( ( _i _i ) + 1 ) ) .",
                "tactic_args": [
                    "c10_goal : Z.lt n n",
                    "_global_Z.lt_le_trans : forall (n m p : Z) (_ : Z.lt n m) (_ : Z.le m p), Z.lt n p",
                    "_global_Z.sqrt : forall _ : Z, Z",
                    "c2_n : Z",
                    "_global_Z.sqrt : forall _ : Z, Z",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c11_goal : Z.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))",
                    "c12_goal : Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) n"
                ]
            },
            {
                "tactic_sig": "assert ( Hposn : 0 <= _i ) by lia .",
                "tactic_sig_no_out_arg": "assert ( Hposn : 0 <= _i ) by lia .",
                "tactic_args": [
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c11_Hposn : Z.le 0 n"
                ]
            },
            {
                "tactic_sig": "generalize ( Z.sqrt_spec _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.sqrt_spec _i _i ) .",
                "tactic_args": [
                    "c11_goal : Z.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))",
                    "c2_n : Z",
                    "c11_Hposn : Z.le 0 n"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  _ : let s := Z.sqrt n in\n      and (Z.le (Z.mul s s) n) (Z.lt n (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))"
                ]
            },
            {
                "tactic_sig": "cbv zeta .",
                "tactic_sig_no_out_arg": "cbv zeta .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : let s := Z.sqrt n in\n      and (Z.le (Z.mul s s) n) (Z.lt n (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))"
                ],
                "tactic_res": [
                    "c14_goal : forall\n  _ : and (Z.le (Z.mul (Z.sqrt n) (Z.sqrt n)) n)\n        (Z.lt n (Z.mul (Z.succ (Z.sqrt n)) (Z.succ (Z.sqrt n)))),\nZ.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H23 .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : and (Z.le (Z.mul (Z.sqrt n) (Z.sqrt n)) n)\n        (Z.lt n (Z.mul (Z.succ (Z.sqrt n)) (Z.succ (Z.sqrt n)))),\nZ.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))"
                ],
                "tactic_res": [
                    "c15_goal : Z.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))",
                    "c15_H23 : and (Z.le (Z.mul (Z.sqrt n) (Z.sqrt n)) n)\n  (Z.lt n (Z.mul (Z.succ (Z.sqrt n)) (Z.succ (Z.sqrt n))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c15_goal : Z.lt n (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1))",
                    "c15_H23 : and (Z.le (Z.mul (Z.sqrt n) (Z.sqrt n)) n)\n  (Z.lt n (Z.mul (Z.succ (Z.sqrt n)) (Z.succ (Z.sqrt n))))",
                    "c2_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "pattern _i at 3 .",
                "tactic_sig_no_out_arg": "pattern _i at 3 .",
                "tactic_args": [
                    "c12_goal : Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) n",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c16_goal : (fun z : Z => Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) z)\n  n"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : (fun z : Z => Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) z)\n  n",
                    "c2_Heq : eq n (Z.mul m p)"
                ],
                "tactic_res": [
                    "c17_goal : Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) (Z.mul m p)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Z.le (Z.mul (Z.add (Z.sqrt n) 1) (Z.add (Z.sqrt n) 1)) (Z.mul m p)",
                    "_global_Zmult_le_compat : forall (n m p q : Z) (_ : Z.le n p) (_ : Z.le m q) \n         (_ : Z.le 0 n) (_ : Z.le 0 m), Z.le (Z.mul n m) (Z.mul p q)"
                ],
                "tactic_res": [
                    "c18_goal : Z.le (Z.add (Z.sqrt n) 1) m",
                    "c19_goal : Z.le (Z.add (Z.sqrt n) 1) p",
                    "c20_goal : Z.le 0 (Z.add (Z.sqrt n) 1)",
                    "c21_goal : Z.le 0 (Z.add (Z.sqrt n) 1)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c18_goal : Z.le (Z.add (Z.sqrt n) 1) m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c19_goal : Z.le (Z.add (Z.sqrt n) 1) p"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Z.sqrt_nonneg _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.sqrt_nonneg _i ) .",
                "tactic_args": [
                    "c20_goal : Z.le 0 (Z.add (Z.sqrt n) 1)",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : Z.le 0 (Z.sqrt n), Z.le 0 (Z.add (Z.sqrt n) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c22_goal : forall _ : Z.le 0 (Z.sqrt n), Z.le 0 (Z.add (Z.sqrt n) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Z.sqrt_nonneg _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Z.sqrt_nonneg _i ) .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Z.add (Z.sqrt n) 1)",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : Z.le 0 (Z.sqrt n), Z.le 0 (Z.add (Z.sqrt n) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c23_goal : forall _ : Z.le 0 (Z.sqrt n), Z.le 0 (Z.add (Z.sqrt n) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _ .",
                "tactic_sig_no_out_arg": "intros Hple _ .",
                "tactic_args": [
                    "c6_goal : forall (_ : Z.le p (Z.sqrt n)) (_ : Z.lt (Z.sqrt n) m),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c24_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c24_Hple : Z.le p (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c24_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c25_goal : and (Z.lt 0 p) (Z.le p (Z.sqrt n))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c25_goal : and (Z.lt 0 p) (Z.le p (Z.sqrt n))"
                ],
                "tactic_res": [
                    "c26_goal : Z.lt 0 p",
                    "c27_goal : Z.le p (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : Z.le p (Z.sqrt n)",
                    "c24_Hple : Z.le p (Z.sqrt n)",
                    "c2_n : Z",
                    "c2_p : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c26_goal : Z.lt 0 p",
                    "_global_Zmult_lt_0_reg_r : forall (n m : Z) (_ : Z.lt 0 n) (_ : Z.lt 0 (Z.mul m n)), Z.lt 0 m",
                    "c2_m : Z"
                ],
                "tactic_res": [
                    "c28_goal : Z.lt 0 m",
                    "c29_goal : Z.lt 0 (Z.mul p m)"
                ]
            },
            {
                "tactic_sig": "try tauto .",
                "tactic_sig_no_out_arg": "try tauto .",
                "tactic_args": [
                    "c28_goal : Z.lt 0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : Z.lt 0 (Z.mul p m)",
                    "_global_Zmult_comm : forall n m : Z, eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c30_goal : Z.lt 0 (Z.mul m p)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c30_goal : Z.lt 0 (Z.mul m p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ Hmle .",
                "tactic_args": [
                    "c7_goal : forall (_ : Z.lt (Z.sqrt n) p) (_ : Z.le m (Z.sqrt n)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c31_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c31_Hmle : Z.le m (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c31_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c32_goal : and (Z.lt 0 m) (Z.le m (Z.sqrt n))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c32_goal : and (Z.lt 0 m) (Z.le m (Z.sqrt n))"
                ],
                "tactic_res": [
                    "c33_goal : Z.lt 0 m",
                    "c34_goal : Z.le m (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c33_goal : Z.lt 0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c34_goal : Z.le m (Z.sqrt n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _ _o .",
                "tactic_sig_no_out_arg": "intros _ Hmle .",
                "tactic_args": [
                    "c8_goal : forall (_ : Z.le p (Z.sqrt n)) (_ : Z.le m (Z.sqrt n)),\nor (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c35_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))",
                    "c35_Hmle : Z.le m (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c35_goal : or (and (Z.lt 0 m) (Z.le m (Z.sqrt n)))\n  (and (Z.lt 0 p) (Z.le p (Z.sqrt n)))"
                ],
                "tactic_res": [
                    "c36_goal : and (Z.lt 0 m) (Z.le m (Z.sqrt n))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c36_goal : and (Z.lt 0 m) (Z.le m (Z.sqrt n))"
                ],
                "tactic_res": [
                    "c37_goal : Z.lt 0 m",
                    "c38_goal : Z.le m (Z.sqrt n)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c37_goal : Z.lt 0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c38_goal : Z.le m (Z.sqrt n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "test_odds_correct2",
        "proof": [
            {
                "tactic_sig": "Theorem test_odds_correct2 : forall n x : nat , ( 1 < x ) % nat -> forall p : Z , test_odds n p ( Z_of_nat x ) = true -> ~ ( exists y : nat , x = y * 2 ) % nat .",
                "tactic_sig_no_out_arg": "Theorem test_odds_correct2 : forall n x : nat , ( 1 < x ) % nat -> forall p : Z , test_odds n p ( Z_of_nat x ) = true -> ~ ( exists y : nat , x = y * 2 ) % nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall (n x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds 0 p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c4_goal : forall (n : nat)\n  (_ : forall (x : nat) (_ : lt 1 x) (p : Z)\n         (_ : eq (test_odds n p (Z.of_nat x)) true),\n       not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))) \n  (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds (S n) p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c3_goal : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds 0 p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "_global_test_odds : forall (_ : nat) (_ : Z) (_ : Z), bool",
                    "_global_divides_bool : forall (_ : Z) (_ : Z), bool"
                ],
                "tactic_res": [
                    "c5_goal : forall (x : nat) (_ : lt 1 x) (_ : Z)\n  (_ : eq\n         (negb\n            match Z.modulo (Z.of_nat x) 2 with\n            | 0 => true\n            | _ => false\n            end) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _ _o _o .",
                "tactic_sig_no_out_arg": "intros x H1ltx _ Heq Hex .",
                "tactic_args": [
                    "c5_goal : forall (x : nat) (_ : lt 1 x) (_ : Z)\n  (_ : eq\n         (negb\n            match Z.modulo (Z.of_nat x) 2 with\n            | 0 => true\n            | _ => false\n            end) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_x : nat",
                    "c6_H1ltx : lt 1 x",
                    "c6_Heq : eq\n  (negb match Z.modulo (Z.of_nat x) 2 with\n        | 0 => true\n        | _ => false\n        end) true",
                    "c6_Hex : ex (fun y : nat => eq x (Init.Nat.mul y 2))"
                ]
            },
            {
                "tactic_sig": "assert ( Heq' : Z_of_nat _i mod Z_of_nat 2 = 0 ) .",
                "tactic_sig_no_out_arg": "assert ( Heq' : Z_of_nat _i mod Z_of_nat 2 = 0 ) .",
                "tactic_args": [
                    "c6_goal : False",
                    "c6_x : nat"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.modulo (Z.of_nat x) (Z.of_nat 2%nat)) 0",
                    "c8_goal : False",
                    "c8_Heq' : eq (Z.modulo (Z.of_nat x) (Z.of_nat 2%nat)) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : eq (Z.modulo (Z.of_nat x) (Z.of_nat 2%nat)) 0",
                    "_global_verif_divide : forall (m p : nat) (_ : lt 0 m) (_ : lt 0 p)\n         (_ : ex (fun q : nat => eq m (Init.Nat.mul q p))),\n       eq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0"
                ],
                "tactic_res": [
                    "c9_goal : lt 0 x",
                    "c10_goal : lt 0 2",
                    "c11_goal : ex (fun q : nat => eq x (Init.Nat.mul q 2))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c9_goal : lt 0 x",
                    "c6_H1ltx : lt 1 x",
                    "c6_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c10_goal : lt 0 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : ex (fun q : nat => eq x (Init.Nat.mul q 2))",
                    "c6_Hex : ex (fun y : nat => eq x (Init.Nat.mul y 2))",
                    "c6_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl ( Z_of_nat 2 ) in _i .",
                "tactic_sig_no_out_arg": "simpl ( Z_of_nat 2 ) in _i .",
                "tactic_args": [
                    "c8_Heq' : eq (Z.modulo (Z.of_nat x) (Z.of_nat 2%nat)) 0"
                ],
                "tactic_res": [
                    "c8_Heq' : eq (Z.modulo (Z.of_nat x) 2) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c8_Heq' : eq (Z.modulo (Z.of_nat x) 2) 0",
                    "c8_Heq : eq\n  (negb match Z.modulo (Z.of_nat x) 2 with\n        | 0 => true\n        | _ => false\n        end) true"
                ],
                "tactic_res": [
                    "c8_Heq : eq (negb true) true"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c8_Heq : eq (negb true) true"
                ],
                "tactic_res": [
                    "c8_Heq : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c8_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n IHn x H1ltx p .",
                "tactic_args": [
                    "c4_goal : forall (n : nat)\n  (_ : forall (x : nat) (_ : lt 1 x) (p : Z)\n         (_ : eq (test_odds n p (Z.of_nat x)) true),\n       not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))) \n  (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds (S n) p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq (test_odds (S n) p (Z.of_nat x)) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c12_n : nat",
                    "c12_IHn : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c12_x : nat",
                    "c12_H1ltx : lt 1 x",
                    "c12_p : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : forall _ : eq (test_odds (S n) p (Z.of_nat x)) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  _ : eq\n        (if test_odds n (Z.sub p 2) (Z.of_nat x)\n         then negb (divides_bool p (Z.of_nat x))\n         else false) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ]
            },
            {
                "tactic_sig": "case_eq ( test_odds _i ( _i - 2 ) ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "case_eq ( test_odds _i ( _i - 2 ) ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : eq\n        (if test_odds n (Z.sub p 2) (Z.of_nat x)\n         then negb (divides_bool p (Z.of_nat x))\n         else false) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c12_n : nat",
                    "c12_p : Z",
                    "c12_x : nat"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true)\n  (_ : eq (negb (divides_bool p (Z.of_nat x))) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c15_goal : forall (_ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false)\n  (_ : eq false true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _ .",
                "tactic_sig_no_out_arg": "intros Htest' _ .",
                "tactic_args": [
                    "c14_goal : forall (_ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true)\n  (_ : eq (negb (divides_bool p (Z.of_nat x))) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c16_goal : not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c16_Htest' : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i _i ( _i - 2 ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i _i ( _i - 2 ) ) .",
                "tactic_args": [
                    "c16_goal : not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c12_IHn : forall (x : nat) (_ : lt 1 x) (p : Z)\n  (_ : eq (test_odds n p (Z.of_nat x)) true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c12_x : nat",
                    "c12_H1ltx : lt 1 x",
                    "c12_p : Z"
                ],
                "tactic_res": [
                    "c17_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c16_Htest' : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c12_p : Z",
                    "c12_x : nat",
                    "c12_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall (_ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false)\n  (_ : eq false true),\nnot (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": [
                    "c18_goal : not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))",
                    "c18_H : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false",
                    "c18_H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c18_goal : not (ex (fun y : nat => eq x (Init.Nat.mul y 2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Z_of_nat_le",
        "proof": [
            {
                "tactic_sig": "Theorem Z_of_nat_le : forall x y , Z_of_nat x <= Z_of_nat y -> ( x <= y ) % nat .",
                "tactic_sig_no_out_arg": "Theorem Z_of_nat_le : forall x y , Z_of_nat x <= Z_of_nat y -> ( x <= y ) % nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : nat) (_ : Z.le (Z.of_nat x) (Z.of_nat y)), le x y"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y : nat) (_ : Z.le (Z.of_nat x) (Z.of_nat y)), le x y"
                ],
                "tactic_res": [
                    "c2_goal : le x y",
                    "c2_x : nat",
                    "c2_y : nat",
                    "c2_H : Z.le (Z.of_nat x) (Z.of_nat y)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : le x y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "test_odds_correct",
        "proof": [
            {
                "tactic_sig": "Theorem test_odds_correct : forall ( n x : nat ) ( p : Z ) , p = 2 * ( Z_of_nat n ) + 1 -> ( 1 < x ) % nat -> test_odds n p ( Z_of_nat x ) = true -> forall q : nat , ( 1 < q <= 2 * n + 1 ) % nat -> ~ ( exists y : nat , x = q * y ) % nat .",
                "tactic_sig_no_out_arg": "Theorem test_odds_correct : forall ( n x : nat ) ( p : Z ) , p = 2 * ( Z_of_nat n ) + 1 -> ( 1 < x ) % nat -> test_odds n p ( Z_of_nat x ) = true -> forall q : nat , ( 1 < q <= 2 * n + 1 ) % nat -> ~ ( exists y : nat , x = q * y ) % nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n x : nat) (p : Z) (_ : eq p (Z.add (Z.mul 2 (Z.of_nat n)) 1))\n  (_ : lt 1 x) (_ : eq (test_odds n p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ]
            },
            {
                "tactic_sig": "induction n .",
                "tactic_sig_no_out_arg": "induction n .",
                "tactic_args": [
                    "c1_goal : forall (n x : nat) (p : Z) (_ : eq p (Z.add (Z.mul 2 (Z.of_nat n)) 1))\n  (_ : lt 1 x) (_ : eq (test_odds n p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : nat) (p : Z)\n  (_ : eq p (Z.add (Z.mul 2 (Z.of_nat 0%nat)) 1)) \n  (_ : lt 1 x) (_ : eq (test_odds 0 p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 0) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_goal : forall (x : nat) (p : Z)\n  (_ : eq p (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)) \n  (_ : lt 1 x) (_ : eq (test_odds (S n) p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_IHn : forall (x : nat) (p : Z) (_ : eq p (Z.add (Z.mul 2 (Z.of_nat n)) 1))\n  (_ : lt 1 x) (_ : eq (test_odds n p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x p Hp1 H1ltx Hn q Hint .",
                "tactic_args": [
                    "c2_goal : forall (x : nat) (p : Z)\n  (_ : eq p (Z.add (Z.mul 2 (Z.of_nat 0%nat)) 1)) \n  (_ : lt 1 x) (_ : eq (test_odds 0 p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 0) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c4_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c4_x : nat",
                    "c4_p : Z",
                    "c4_Hp1 : eq p (Z.add (Z.mul 2 (Z.of_nat 0%nat)) 1)",
                    "c4_H1ltx : lt 1 x",
                    "c4_Hn : eq (test_odds 0 p (Z.of_nat x)) true",
                    "c4_q : nat",
                    "c4_Hint : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 0) 1))"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "c4_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c5_goal : False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c5_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x p Hp H1ltx .",
                "tactic_args": [
                    "c3_goal : forall (x : nat) (p : Z)\n  (_ : eq p (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)) \n  (_ : lt 1 x) (_ : eq (test_odds (S n) p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c6_goal : forall (_ : eq (test_odds (S n) p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c6_x : nat",
                    "c6_p : Z",
                    "c6_Hp : eq p (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)",
                    "c6_H1ltx : lt 1 x"
                ]
            },
            {
                "tactic_sig": "simpl ( test_odds ( S _i ) _i ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "simpl ( test_odds ( S _i ) _i ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c6_goal : forall (_ : eq (test_odds (S n) p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_n : nat",
                    "c6_p : Z",
                    "c6_x : nat"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  (_ : eq\n         (if test_odds n (Z.sub p 2) (Z.of_nat x)\n          then negb (divides_bool p (Z.of_nat x))\n          else false) true) (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros Htest q ( H1ltq , Hqle ) .",
                "tactic_args": [
                    "c7_goal : forall\n  (_ : eq\n         (if test_odds n (Z.sub p 2) (Z.of_nat x)\n          then negb (divides_bool p (Z.of_nat x))\n          else false) true) (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c8_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c8_Htest : eq\n  (if test_odds n (Z.sub p 2) (Z.of_nat x)\n   then negb (divides_bool p (Z.of_nat x))\n   else false) true",
                    "c8_q : nat",
                    "c8_H1ltq : lt 1 q",
                    "c8_Hqle : le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1)"
                ]
            },
            {
                "tactic_sig": "case_eq ( test_odds _i ( _i - 2 ) ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "case_eq ( test_odds _i ( _i - 2 ) ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c8_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_n : nat",
                    "c6_p : Z",
                    "c6_x : nat"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c10_goal : forall _ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false,\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Htest'true .",
                "tactic_args": [
                    "c9_goal : forall _ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true,\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c11_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c11_Htest'true : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c11_Htest'true : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c11_Htest : eq\n  (if test_odds n (Z.sub p 2) (Z.of_nat x)\n   then negb (divides_bool p (Z.of_nat x))\n   else false) true"
                ],
                "tactic_res": [
                    "c11_Htest : eq (negb (divides_bool p (Z.of_nat x))) true"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_divides_bool : forall (_ : Z) (_ : Z), bool",
                    "c11_Htest : eq (negb (divides_bool p (Z.of_nat x))) true"
                ],
                "tactic_res": [
                    "c11_Htest : eq\n  (negb match Z.modulo (Z.of_nat x) p with\n        | 0 => true\n        | _ => false\n        end) true"
                ]
            },
            {
                "tactic_sig": "elim ( proj1 ( Nat.lt_eq_cases _i ( 2 * S _i + 1 ) % nat ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( proj1 ( Nat.lt_eq_cases _i ( 2 * S _i + 1 ) % nat ) _i ) .",
                "tactic_args": [
                    "c11_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c8_q : nat",
                    "c3_n : nat",
                    "c8_Hqle : le q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1)"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : lt q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c13_goal : forall _ : eq q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hqlt .",
                "tactic_args": [
                    "c12_goal : forall _ : lt q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c14_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c14_Hqlt : lt q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1)"
                ]
            },
            {
                "tactic_sig": "assert ( Hqle' : ( _i <= ( 2 * S _i ) ) % nat ) by lia .",
                "tactic_sig_no_out_arg": "assert ( Hqle' : ( _i <= ( 2 * S _i ) ) % nat ) by lia .",
                "tactic_args": [
                    "c8_q : nat",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c14_Hqle' : le q (Init.Nat.mul 2 (S n))"
                ]
            },
            {
                "tactic_sig": "elim ( proj1 ( Nat.lt_eq_cases _i ( 2 * S _i ) % nat ) _i ) .",
                "tactic_sig_no_out_arg": "elim ( proj1 ( Nat.lt_eq_cases _i ( 2 * S _i ) % nat ) _i ) .",
                "tactic_args": [
                    "c14_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c8_q : nat",
                    "c3_n : nat",
                    "c14_Hqle' : le q (Init.Nat.mul 2 (S n))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : lt q (Init.Nat.mul 2 (S n)),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c16_goal : forall _ : eq q (Init.Nat.mul 2 (S n)),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ]
            },
            {
                "tactic_sig": "replace ( 2 * S _i ) % nat with ( 2 * _i + 2 ) % nat .",
                "tactic_sig_no_out_arg": "replace ( 2 * S _i ) % nat with ( 2 * _i + 2 ) % nat .",
                "tactic_args": [
                    "c15_goal : forall _ : lt q (Init.Nat.mul 2 (S n)),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_n : nat",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : lt q (Init.Nat.add (Init.Nat.mul 2 n) 2),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c18_goal : eq (Init.Nat.add (Init.Nat.mul 2 n) 2) (Init.Nat.mul 2 (S n))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hqlt' .",
                "tactic_args": [
                    "c17_goal : forall _ : lt q (Init.Nat.add (Init.Nat.mul 2 n) 2),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c19_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c19_Hqlt' : lt q (Init.Nat.add (Init.Nat.mul 2 n) 2)"
                ]
            },
            {
                "tactic_sig": "assert ( Hqle'' : ( _i <= 2 * _i + 1 ) % nat ) by lia .",
                "tactic_sig_no_out_arg": "assert ( Hqle'' : ( _i <= 2 * _i + 1 ) % nat ) by lia .",
                "tactic_args": [
                    "c8_q : nat",
                    "c3_n : nat"
                ],
                "tactic_res": [
                    "c19_Hqle'' : le q (Init.Nat.add (Init.Nat.mul 2 n) 1)"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ( _i - 2 ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ( _i - 2 ) ) .",
                "tactic_args": [
                    "c19_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c3_IHn : forall (x : nat) (p : Z) (_ : eq p (Z.add (Z.mul 2 (Z.of_nat n)) 1))\n  (_ : lt 1 x) (_ : eq (test_odds n p (Z.of_nat x)) true) \n  (q : nat)\n  (_ : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c6_x : nat",
                    "c6_p : Z"
                ],
                "tactic_res": [
                    "c20_goal : eq (Z.sub p 2) (Z.add (Z.mul 2 (Z.of_nat n)) 1)",
                    "c21_goal : lt 1 x",
                    "c22_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c23_goal : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))"
                ]
            },
            {
                "tactic_sig": "auto with zarith arith .",
                "tactic_sig_no_out_arg": "auto with zarith arith .",
                "tactic_args": [
                    "c20_goal : eq (Z.sub p 2) (Z.add (Z.mul 2 (Z.of_nat n)) 1)",
                    "c6_Hp : eq p (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)",
                    "c6_p : Z",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith arith .",
                "tactic_sig_no_out_arg": "auto with zarith arith .",
                "tactic_args": [
                    "c21_goal : lt 1 x",
                    "c6_H1ltx : lt 1 x",
                    "c6_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith arith .",
                "tactic_sig_no_out_arg": "auto with zarith arith .",
                "tactic_args": [
                    "c22_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c11_Htest'true : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c6_p : Z",
                    "c6_x : nat",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith arith .",
                "tactic_sig_no_out_arg": "auto with zarith arith .",
                "tactic_args": [
                    "c23_goal : and (lt 1 q) (le q (Init.Nat.add (Init.Nat.mul 2 n) 1))",
                    "c8_H1ltq : lt 1 q",
                    "c8_q : nat",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c18_goal : eq (Init.Nat.add (Init.Nat.mul 2 n) 2) (Init.Nat.mul 2 (S n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o , _o ) .",
                "tactic_sig_no_out_arg": "intros Hq ( y , Hdiv ) .",
                "tactic_args": [
                    "c16_goal : forall _ : eq q (Init.Nat.mul 2 (S n)),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c24_goal : False",
                    "c24_Hq : eq q (Init.Nat.mul 2 (S n))",
                    "c24_y : nat",
                    "c24_Hdiv : eq x (Init.Nat.mul q y)"
                ]
            },
            {
                "tactic_sig": "elim ( test_odds_correct2 _i _i _i ( _i - 2 ) ) .",
                "tactic_sig_no_out_arg": "elim ( test_odds_correct2 _i _i _i ( _i - 2 ) ) .",
                "tactic_args": [
                    "c24_goal : False",
                    "c3_n : nat",
                    "c6_x : nat",
                    "c6_H1ltx : lt 1 x",
                    "c6_p : Z"
                ],
                "tactic_res": [
                    "c25_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c26_goal : ex (fun y : nat => eq x (Init.Nat.mul y 2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c11_Htest'true : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) true",
                    "c6_p : Z",
                    "c6_x : nat",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( S _i * _i ) % nat .",
                "tactic_sig_no_out_arg": "exists ( S _i * _i ) % nat .",
                "tactic_args": [
                    "c26_goal : ex (fun y : nat => eq x (Init.Nat.mul y 2))",
                    "c3_n : nat",
                    "c24_y : nat"
                ],
                "tactic_res": [
                    "c27_goal : eq x (Init.Nat.mul (Init.Nat.mul (S n) y) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : eq x (Init.Nat.mul (Init.Nat.mul (S n) y) 2)",
                    "c24_Hdiv : eq x (Init.Nat.mul q y)"
                ],
                "tactic_res": [
                    "c28_goal : eq (Init.Nat.mul q y) (Init.Nat.mul (Init.Nat.mul (S n) y) 2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : eq (Init.Nat.mul q y) (Init.Nat.mul (Init.Nat.mul (S n) y) 2)",
                    "c24_Hq : eq q (Init.Nat.mul 2 (S n))"
                ],
                "tactic_res": [
                    "c29_goal : eq (Init.Nat.mul (Init.Nat.mul 2 (S n)) y)\n  (Init.Nat.mul (Init.Nat.mul (S n) y) 2)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c29_goal : eq (Init.Nat.mul (Init.Nat.mul 2 (S n)) y)\n  (Init.Nat.mul (Init.Nat.mul (S n) y) 2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hq Hex .",
                "tactic_args": [
                    "c13_goal : forall _ : eq q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1),\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c30_goal : False",
                    "c30_Hq : eq q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1)",
                    "c30_Hex : ex (fun y : nat => eq x (Init.Nat.mul q y))"
                ]
            },
            {
                "tactic_sig": "assert ( Hp' : _i = Z_of_nat _i ) .",
                "tactic_sig_no_out_arg": "assert ( Hp' : _i = Z_of_nat _i ) .",
                "tactic_args": [
                    "c30_goal : False",
                    "c6_p : Z",
                    "c8_q : nat"
                ],
                "tactic_res": [
                    "c31_goal : eq p (Z.of_nat q)",
                    "c32_goal : False",
                    "c32_Hp' : eq p (Z.of_nat q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : eq p (Z.of_nat q)",
                    "c6_Hp : eq p (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)"
                ],
                "tactic_res": [
                    "c33_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1) (Z.of_nat q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c33_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1) (Z.of_nat q)",
                    "c30_Hq : eq q (Init.Nat.add (Init.Nat.mul 2 (S n)) 1)"
                ],
                "tactic_res": [
                    "c34_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c34_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (S n)) 1))",
                    "_global_inj_plus : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.add n m)) (Z.add (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c35_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (S n))) (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c35_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (S n))) (Z.of_nat 1%nat))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c36_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (S n))) (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : eq (Z.add (Z.mul 2 (Z.of_nat (S n))) 1)\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (S n))) (Z.of_nat 1%nat))",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c32_Hp' : eq p (Z.of_nat q)",
                    "c32_Htest : eq\n  (negb match Z.modulo (Z.of_nat x) p with\n        | 0 => true\n        | _ => false\n        end) true"
                ],
                "tactic_res": [
                    "c32_Htest : eq\n  (negb\n     match Z.modulo (Z.of_nat x) (Z.of_nat q) with\n     | 0 => true\n     | _ => false\n     end) true"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i ) in _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i ) in _i .",
                "tactic_args": [
                    "c32_goal : False",
                    "_global_verif_divide : forall (m p : nat) (_ : lt 0 m) (_ : lt 0 p)\n         (_ : ex (fun q : nat => eq m (Init.Nat.mul q p))),\n       eq (Z.modulo (Z.of_nat m) (Z.of_nat p)) 0",
                    "c6_x : nat",
                    "c8_q : nat",
                    "c32_Htest : eq\n  (negb\n     match Z.modulo (Z.of_nat x) (Z.of_nat q) with\n     | 0 => true\n     | _ => false\n     end) true"
                ],
                "tactic_res": [
                    "c37_goal : False",
                    "c37_Htest : eq (negb true) true",
                    "c38_goal : lt 0 x",
                    "c39_goal : lt 0 q",
                    "c40_goal : ex (fun q0 : nat => eq x (Init.Nat.mul q0 q))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c37_Htest : eq (negb true) true"
                ],
                "tactic_res": [
                    "c37_Htest : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c37_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c38_goal : lt 0 x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c39_goal : lt 0 q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c40_goal : ex (fun q0 : nat => eq x (Init.Nat.mul q0 q))",
                    "c30_Hex : ex (fun y : nat => eq x (Init.Nat.mul q y))"
                ],
                "tactic_res": [
                    "c41_goal : forall (x0 : nat) (_ : eq x (Init.Nat.mul q x0)),\nex (fun q0 : nat => eq x (Init.Nat.mul q0 q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros y Hdiv .",
                "tactic_args": [
                    "c41_goal : forall (x0 : nat) (_ : eq x (Init.Nat.mul q x0)),\nex (fun q0 : nat => eq x (Init.Nat.mul q0 q))"
                ],
                "tactic_res": [
                    "c42_goal : ex (fun q0 : nat => eq x (Init.Nat.mul q0 q))",
                    "c42_y : nat",
                    "c42_Hdiv : eq x (Init.Nat.mul q y)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c42_goal : ex (fun q0 : nat => eq x (Init.Nat.mul q0 q))",
                    "c42_y : nat"
                ],
                "tactic_res": [
                    "c43_goal : eq x (Init.Nat.mul y q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c43_goal : eq x (Init.Nat.mul y q)",
                    "c42_Hdiv : eq x (Init.Nat.mul q y)"
                ],
                "tactic_res": [
                    "c44_goal : eq (Init.Nat.mul q y) (Init.Nat.mul y q)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c44_goal : eq (Init.Nat.mul q y) (Init.Nat.mul y q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Htest' .",
                "tactic_args": [
                    "c10_goal : forall _ : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false,\nnot (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": [
                    "c45_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))",
                    "c45_Htest' : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c45_Htest' : eq (test_odds n (Z.sub p 2) (Z.of_nat x)) false",
                    "c45_Htest : eq\n  (if test_odds n (Z.sub p 2) (Z.of_nat x)\n   then negb (divides_bool p (Z.of_nat x))\n   else false) true"
                ],
                "tactic_res": [
                    "c45_Htest : eq false true"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c45_Htest : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c45_goal : not (ex (fun y : nat => eq x (Init.Nat.mul q y)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lt_Zpos",
        "proof": [
            {
                "tactic_sig": "Theorem lt_Zpos : forall p : positive , 0 < Zpos p .",
                "tactic_sig_no_out_arg": "Theorem lt_Zpos : forall p : positive , 0 < Zpos p .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p : positive, Z.lt 0 (Zpos p)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall p : positive, Z.lt 0 (Zpos p)"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt 0 (Zpos p)",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : Z.lt 0 (Zpos p)",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : forall (p : positive) (_ : Z.lt 0 (Zpos p)), Z.lt 0 (Zpos (xI p))",
                    "c4_goal : forall (p : positive) (_ : Z.lt 0 (Zpos p)), Z.lt 0 (Zpos (xO p))",
                    "c5_goal : Z.lt 0 1"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (p : positive) (_ : Z.lt 0 (Zpos p)), Z.lt 0 (Zpos (xI p))"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt 0 (Zpos (xI p0))",
                    "c6_p0 : positive",
                    "c6_H : Z.lt 0 (Zpos p0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Z.lt 0 (Zpos (xI p0))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt 0 (Z.add (Z.mul 2 (Zpos p0)) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : Z.lt 0 (Z.add (Z.mul 2 (Zpos p0)) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (p : positive) (_ : Z.lt 0 (Zpos p)), Z.lt 0 (Zpos (xO p))"
                ],
                "tactic_res": [
                    "c8_goal : Z.lt 0 (Zpos (xO p0))",
                    "c8_p0 : positive",
                    "c8_H : Z.lt 0 (Zpos p0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Z.lt 0 (Zpos (xO p0))",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c9_goal : Z.lt 0 (Z.mul 2 (Zpos p0))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c9_goal : Z.lt 0 (Z.mul 2 (Zpos p0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.lt 0 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zneg_lt",
        "proof": [
            {
                "tactic_sig": "Theorem Zneg_lt : forall p : positive , Zneg p < 0 .",
                "tactic_sig_no_out_arg": "Theorem Zneg_lt : forall p : positive , Zneg p < 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p : positive, Z.lt (Zneg p) 0"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c1_goal : forall p : positive, Z.lt (Zneg p) 0"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (Zneg p) 0",
                    "c2_p : positive"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : Z.lt (Zneg p) 0",
                    "c2_p : positive"
                ],
                "tactic_res": [
                    "c3_goal : forall (p : positive) (_ : Z.lt (Zneg p) 0), Z.lt (Zneg (xI p)) 0",
                    "c4_goal : forall (p : positive) (_ : Z.lt (Zneg p) 0), Z.lt (Zneg (xO p)) 0",
                    "c5_goal : Z.lt (-1) 0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (p : positive) (_ : Z.lt (Zneg p) 0), Z.lt (Zneg (xI p)) 0"
                ],
                "tactic_res": [
                    "c6_goal : Z.lt (Zneg (xI p0)) 0",
                    "c6_p0 : positive",
                    "c6_H : Z.lt (Zneg p0) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : Z.lt (Zneg (xI p0)) 0",
                    "_global_Zneg_xI : forall p : positive, eq (Zneg (xI p)) (Z.sub (Z.mul 2 (Zneg p)) 1)"
                ],
                "tactic_res": [
                    "c7_goal : Z.lt (Z.sub (Z.mul 2 (Zneg p0)) 1) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : Z.lt (Z.sub (Z.mul 2 (Zneg p0)) 1) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (p : positive) (_ : Z.lt (Zneg p) 0), Z.lt (Zneg (xO p)) 0"
                ],
                "tactic_res": [
                    "c8_goal : Z.lt (Zneg (xO p0)) 0",
                    "c8_p0 : positive",
                    "c8_H : Z.lt (Zneg p0) 0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : Z.lt (Zneg (xO p0)) 0",
                    "_global_Zneg_xO : forall p : positive, eq (Zneg (xO p)) (Z.mul 2 (Zneg p))"
                ],
                "tactic_res": [
                    "c9_goal : Z.lt (Z.mul 2 (Zneg p0)) 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c9_goal : Z.lt (Z.mul 2 (Zneg p0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c5_goal : Z.lt (-1) 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "prime_test_correct",
        "proof": [
            {
                "tactic_sig": "Theorem prime_test_correct : forall n : nat , prime_test n = true -> ~ ( exists k : nat , k <> 1 /\\ k <> n /\\ ( exists q : nat , n = q * k ) ) % nat .",
                "tactic_sig_no_out_arg": "Theorem prime_test_correct : forall n : nat , prime_test n = true -> ~ ( exists k : nat , k <> 1 /\\ k <> n /\\ ( exists q : nat , n = q * k ) ) % nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : eq (prime_test n) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : eq (prime_test n) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (prime_test n) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case_eq _i .",
                "tactic_sig_no_out_arg": "case_eq _i .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (prime_test n) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : eq n 0%nat) (_ : eq (prime_test 0) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))",
                    "c4_goal : forall (n0 : nat) (_ : eq n (S n0)) (_ : eq (prime_test (S n0)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S n0)))\n           (ex (fun q : nat => eq (S n0) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (_ : eq n 0%nat) (_ : eq (prime_test 0) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : eq n 0%nat) (_ : eq false true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq Hd .",
                "tactic_args": [
                    "c5_goal : forall (_ : eq n 0%nat) (_ : eq false true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c6_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))",
                    "c6_Heq : eq n 0%nat",
                    "c6_Hd : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 0%nat))\n           (ex (fun q : nat => eq 0%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n0 .",
                "tactic_args": [
                    "c4_goal : forall (n0 : nat) (_ : eq n (S n0)) (_ : eq (prime_test (S n0)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S n0)))\n           (ex (fun q : nat => eq (S n0) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : eq n (S n0)) (_ : eq (prime_test (S n0)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S n0)))\n           (ex (fun q : nat => eq (S n0) (Init.Nat.mul q k))))))",
                    "c7_n0 : nat"
                ]
            },
            {
                "tactic_sig": "case_eq _i .",
                "tactic_sig_no_out_arg": "case_eq _i .",
                "tactic_args": [
                    "c7_goal : forall (_ : eq n (S n0)) (_ : eq (prime_test (S n0)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S n0)))\n           (ex (fun q : nat => eq (S n0) (Init.Nat.mul q k))))))",
                    "c7_n0 : nat"
                ],
                "tactic_res": [
                    "c8_goal : forall (_ : eq n0 0%nat) (_ : eq n 1%nat) (_ : eq (prime_test 1) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))",
                    "c9_goal : forall (n1 : nat) (_ : eq n0 (S n1)) (_ : eq n (S (S n1)))\n  (_ : eq (prime_test (S (S n1))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : forall (_ : eq n0 0%nat) (_ : eq n 1%nat) (_ : eq (prime_test 1) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c10_goal : forall (_ : eq n0 0%nat) (_ : eq n 1%nat) (_ : eq false true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros Heq1 Heq2 Hd .",
                "tactic_args": [
                    "c10_goal : forall (_ : eq n0 0%nat) (_ : eq n 1%nat) (_ : eq false true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c11_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))",
                    "c11_Heq1 : eq n0 0%nat",
                    "c11_Heq2 : eq n 1%nat",
                    "c11_Hd : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c11_goal : not\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k 1%nat))\n           (ex (fun q : nat => eq 1%nat (Init.Nat.mul q k))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : forall (n1 : nat) (_ : eq n0 (S n1)) (_ : eq n (S (S n1)))\n  (_ : eq (prime_test (S (S n1))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))",
                    "_global_prime_test : forall _ : nat, bool"
                ],
                "tactic_res": [
                    "c12_goal : forall (n1 : nat) (_ : eq n0 (S n1)) (_ : eq n (S (S n1)))\n  (_ : eq\n         (let (half_s, even_bit) :=\n            match Z.sqrt (Z.of_nat (S (S n1))) with\n            | Zpos (xI h) => pair (Zpos h) 0\n            | Zpos (xO h) => pair (Zpos h) 1\n            | 1 => pair 0 0\n            | _ => pair 0 1\n            end in\n          test_odds (Z.abs_nat half_s)\n            (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n            (Z.of_nat (S (S n1)))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n1 Heqn0 Heqn .",
                "tactic_args": [
                    "c12_goal : forall (n1 : nat) (_ : eq n0 (S n1)) (_ : eq n (S (S n1)))\n  (_ : eq\n         (let (half_s, even_bit) :=\n            match Z.sqrt (Z.of_nat (S (S n1))) with\n            | Zpos (xI h) => pair (Zpos h) 0\n            | Zpos (xO h) => pair (Zpos h) 1\n            | 1 => pair 0 0\n            | _ => pair 0 1\n            end in\n          test_odds (Z.abs_nat half_s)\n            (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n            (Z.of_nat (S (S n1)))) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c13_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat (S (S n1))) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n           (Z.of_nat (S (S n1)))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))",
                    "c13_n1 : nat",
                    "c13_Heqn0 : eq n0 (S n1)",
                    "c13_Heqn : eq n (S (S n1))"
                ]
            },
            {
                "tactic_sig": "assert ( H1ltn : ( 1 < _i ) % nat ) .",
                "tactic_sig_no_out_arg": "assert ( H1ltn : ( 1 < _i ) % nat ) .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat (S (S n1))) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n           (Z.of_nat (S (S n1)))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c14_goal : lt 1 n",
                    "c15_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat (S (S n1))) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n           (Z.of_nat (S (S n1)))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))",
                    "c15_H1ltn : lt 1 n"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : lt 1 n",
                    "c13_Heqn : eq n (S (S n1))"
                ],
                "tactic_res": [
                    "c16_goal : lt 1 (S (S n1))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c16_goal : lt 1 (S (S n1))",
                    "c13_n1 : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c15_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat (S (S n1))) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat (S (S n1)))) even_bit)\n           (Z.of_nat (S (S n1)))) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k (S (S n1))))\n           (ex (fun q : nat => eq (S (S n1)) (Init.Nat.mul q k))))))",
                    "c13_Heqn : eq n (S (S n1))"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat n) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat n)) even_bit) \n           (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "case_eq ( Z.sqrt ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "case_eq ( Z.sqrt ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : eq\n        (let (half_s, even_bit) :=\n           match Z.sqrt (Z.of_nat n) with\n           | Zpos (xI h) => pair (Zpos h) 0\n           | Zpos (xO h) => pair (Zpos h) 1\n           | 1 => pair 0 0\n           | _ => pair 0 1\n           end in\n         test_odds (Z.abs_nat half_s)\n           (Z.add (Z.sqrt (Z.of_nat n)) even_bit) \n           (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c18_goal : forall (_ : eq (Z.sqrt (Z.of_nat n)) 0)\n  (_ : eq (test_odds (Z.abs_nat 0) (Z.add 0 1) (Z.of_nat n)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c19_goal : forall (p : positive) (_ : eq (Z.sqrt (Z.of_nat n)) (Zpos p))\n  (_ : eq\n         (let (half_s, even_bit) :=\n            match p with\n            | xI h => pair (Zpos h) 0\n            | xO h => pair (Zpos h) 1\n            | 1%positive => pair 0 0\n            end in\n          test_odds (Z.abs_nat half_s) (Z.add (Zpos p) even_bit)\n            (Z.of_nat n)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c20_goal : forall (p : positive) (_ : eq (Z.sqrt (Z.of_nat n)) (Zneg p))\n  (_ : eq (test_odds (Z.abs_nat 0) (Z.add (Zneg p) 1) (Z.of_nat n))\n         true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ]
            },
            {
                "tactic_sig": "intros Hsqrt_eq .",
                "tactic_sig_no_out_arg": "intros Hsqrt_eq .",
                "tactic_args": [
                    "c18_goal : forall (_ : eq (Z.sqrt (Z.of_nat n)) 0)\n  (_ : eq (test_odds (Z.abs_nat 0) (Z.add 0 1) (Z.of_nat n)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : eq (test_odds (Z.abs_nat 0) (Z.add 0 1) (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c21_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) 0"
                ]
            },
            {
                "tactic_sig": "elim ( Zlt_asym 1 ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "elim ( Zlt_asym 1 ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c21_goal : forall _ : eq (test_odds (Z.abs_nat 0) (Z.add 0 1) (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c22_goal : Z.lt 1 (Z.of_nat n)",
                    "c23_goal : Z.lt (Z.of_nat n) 1"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c22_goal : Z.lt 1 (Z.of_nat n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lapply ( Z.sqrt_spec ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "lapply ( Z.sqrt_spec ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c23_goal : Z.lt (Z.of_nat n) 1",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  _ : let s := Z.sqrt (Z.of_nat n) in\n      and (Z.le (Z.mul s s) (Z.of_nat n))\n        (Z.lt (Z.of_nat n) (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt (Z.of_nat n) 1",
                    "c25_goal : Z.le 0 (Z.of_nat n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : forall\n  _ : let s := Z.sqrt (Z.of_nat n) in\n      and (Z.le (Z.mul s s) (Z.of_nat n))\n        (Z.lt (Z.of_nat n) (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt (Z.of_nat n) 1",
                    "c21_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) 0"
                ],
                "tactic_res": [
                    "c26_goal : forall\n  _ : let s := 0 in\n      and (Z.le (Z.mul s s) (Z.of_nat n))\n        (Z.lt (Z.of_nat n) (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt (Z.of_nat n) 1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c26_goal : forall\n  _ : let s := 0 in\n      and (Z.le (Z.mul s s) (Z.of_nat n))\n        (Z.lt (Z.of_nat n) (Z.mul (Z.succ s) (Z.succ s))),\nZ.lt (Z.of_nat n) 1"
                ],
                "tactic_res": [
                    "c27_goal : forall _ : and (Z.le 0 (Z.of_nat n)) (Z.lt (Z.of_nat n) 1),\nZ.lt (Z.of_nat n) 1"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c27_goal : forall _ : and (Z.le 0 (Z.of_nat n)) (Z.lt (Z.of_nat n) 1),\nZ.lt (Z.of_nat n) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c25_goal : Z.le 0 (Z.of_nat n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o Hsqrt_eq Htest_eq ( _o , ( _o , ( _o , ( _o , _o ) ) ) ) .",
                "tactic_sig_no_out_arg": "intros p Hsqrt_eq Htest_eq ( k , ( Hn1 , ( Hnn , ( q , Heq ) ) ) ) .",
                "tactic_args": [
                    "c19_goal : forall (p : positive) (_ : eq (Z.sqrt (Z.of_nat n)) (Zpos p))\n  (_ : eq\n         (let (half_s, even_bit) :=\n            match p with\n            | xI h => pair (Zpos h) 0\n            | xO h => pair (Zpos h) 1\n            | 1%positive => pair 0 0\n            end in\n          test_odds (Z.abs_nat half_s) (Z.add (Zpos p) even_bit)\n            (Z.of_nat n)) true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c28_goal : False",
                    "c28_p : positive",
                    "c28_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) (Zpos p)",
                    "c28_Htest_eq : eq\n  (let (half_s, even_bit) :=\n     match p with\n     | xI h => pair (Zpos h) 0\n     | xO h => pair (Zpos h) 1\n     | 1%positive => pair 0 0\n     end in\n   test_odds (Z.abs_nat half_s) (Z.add (Zpos p) even_bit) (Z.of_nat n))\n  true",
                    "c28_k : nat",
                    "c28_Hn1 : not (eq k 1%nat)",
                    "c28_Hnn : not (eq k n)",
                    "c28_q : nat",
                    "c28_Heq : eq n (Init.Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "assert ( H0ltn : ( 0 < _i ) % nat ) by lia .",
                "tactic_sig_no_out_arg": "assert ( H0ltn : ( 0 < _i ) % nat ) by lia .",
                "tactic_args": [
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c28_H0ltn : lt 0 n"
                ]
            },
            {
                "tactic_sig": "assert ( Hkltn : ( _i < _i ) % nat ) .",
                "tactic_sig_no_out_arg": "assert ( Hkltn : ( _i < _i ) % nat ) .",
                "tactic_args": [
                    "c28_goal : False",
                    "c28_k : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c29_goal : lt k n",
                    "c30_goal : False",
                    "c30_Hkltn : lt k n"
                ]
            },
            {
                "tactic_sig": "assert ( Heq' : _i = ( _i * _i ) % nat ) .",
                "tactic_sig_no_out_arg": "assert ( Heq' : _i = ( _i * _i ) % nat ) .",
                "tactic_args": [
                    "c29_goal : lt k n",
                    "c2_n : nat",
                    "c28_k : nat",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c31_goal : eq n (Init.Nat.mul k q)",
                    "c32_goal : lt k n",
                    "c32_Heq' : eq n (Init.Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : eq n (Init.Nat.mul k q)",
                    "c28_Heq : eq n (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c33_goal : eq (Init.Nat.mul q k) (Init.Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c33_goal : eq (Init.Nat.mul q k) (Init.Nat.mul k q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( divisor_smaller _i _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( divisor_smaller _i _i _i _i _i ) .",
                "tactic_args": [
                    "c32_goal : lt k n",
                    "c2_n : nat",
                    "c28_q : nat",
                    "c28_H0ltn : lt 0 n",
                    "c28_k : nat",
                    "c32_Heq' : eq n (Init.Nat.mul k q)"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : le k n, lt k n"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c34_goal : forall _ : le k n, lt k n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Hex : exists k' : nat , ( 1 < ( Z_of_nat k' ) <= ( Z.sqrt ( Z_of_nat _i ) ) ) /\\ ( exists q' : nat , _i = ( k' * q' ) % nat ) ) .",
                "tactic_sig_no_out_arg": "assert ( Hex : exists k' : nat , ( 1 < ( Z_of_nat k' ) <= ( Z.sqrt ( Z_of_nat _i ) ) ) /\\ ( exists q' : nat , _i = ( k' * q' ) % nat ) ) .",
                "tactic_args": [
                    "c30_goal : False",
                    "c2_n : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c35_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c36_goal : False",
                    "c36_Hex : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))"
                ]
            },
            {
                "tactic_sig": "elim ( div_Zsqrt ( Z_of_nat _i ) ( Z_of_nat _i ) ( Z_of_nat _i ) ) .",
                "tactic_sig_no_out_arg": "elim ( div_Zsqrt ( Z_of_nat _i ) ( Z_of_nat _i ) ( Z_of_nat _i ) ) .",
                "tactic_args": [
                    "c35_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c28_k : nat",
                    "c2_n : nat",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c37_goal : forall\n  _ : and (Z.lt 0 (Z.of_nat k))\n        (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n))),\nex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c38_goal : forall\n  _ : and (Z.lt 0 (Z.of_nat q))\n        (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))),\nex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c39_goal : and (Z.lt 0 (Z.of_nat k)) (Z.lt (Z.of_nat k) (Z.of_nat n))",
                    "c40_goal : eq (Z.of_nat n) (Z.mul (Z.of_nat k) (Z.of_nat q))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hint1 .",
                "tactic_args": [
                    "c37_goal : forall\n  _ : and (Z.lt 0 (Z.of_nat k))\n        (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n))),\nex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))"
                ],
                "tactic_res": [
                    "c41_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c41_Hint1 : and (Z.lt 0 (Z.of_nat k)) (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c41_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c28_k : nat"
                ],
                "tactic_res": [
                    "c42_goal : and\n  (and (Z.lt 1 (Z.of_nat k)) (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n))))\n  (ex (fun q' : nat => eq n (Init.Nat.mul k q')))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c42_goal : and\n  (and (Z.lt 1 (Z.of_nat k)) (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n))))\n  (ex (fun q' : nat => eq n (Init.Nat.mul k q')))"
                ],
                "tactic_res": [
                    "c43_goal : and (Z.lt 1 (Z.of_nat k)) (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n)))",
                    "c44_goal : ex (fun q' : nat => eq n (Init.Nat.mul k q'))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c43_goal : and (Z.lt 1 (Z.of_nat k)) (Z.le (Z.of_nat k) (Z.sqrt (Z.of_nat n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c44_goal : ex (fun q' : nat => eq n (Init.Nat.mul k q'))",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c45_goal : eq n (Init.Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c45_goal : eq n (Init.Nat.mul k q)",
                    "c28_Heq : eq n (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c46_goal : eq (Init.Nat.mul q k) (Init.Nat.mul k q)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c46_goal : eq (Init.Nat.mul q k) (Init.Nat.mul k q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hint2 .",
                "tactic_args": [
                    "c38_goal : forall\n  _ : and (Z.lt 0 (Z.of_nat q))\n        (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))),\nex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))"
                ],
                "tactic_res": [
                    "c47_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c47_Hint2 : and (Z.lt 0 (Z.of_nat q)) (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c47_goal : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c48_goal : and\n  (and (Z.lt 1 (Z.of_nat q)) (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))))\n  (ex (fun q' : nat => eq n (Init.Nat.mul q q')))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c48_goal : and\n  (and (Z.lt 1 (Z.of_nat q)) (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))))\n  (ex (fun q' : nat => eq n (Init.Nat.mul q q')))"
                ],
                "tactic_res": [
                    "c49_goal : and (Z.lt 1 (Z.of_nat q)) (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n)))",
                    "c50_goal : ex (fun q' : nat => eq n (Init.Nat.mul q q'))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c49_goal : and (Z.lt 1 (Z.of_nat q)) (Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n)))"
                ],
                "tactic_res": [
                    "c51_goal : Z.lt 1 (Z.of_nat q)",
                    "c52_goal : Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))"
                ]
            },
            {
                "tactic_sig": "elim ( Zle_or_lt ( Z_of_nat _i ) 1 ) .",
                "tactic_sig_no_out_arg": "elim ( Zle_or_lt ( Z_of_nat _i ) 1 ) .",
                "tactic_args": [
                    "c51_goal : Z.lt 1 (Z.of_nat q)",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c53_goal : forall _ : Z.le (Z.of_nat q) 1, Z.lt 1 (Z.of_nat q)",
                    "c54_goal : forall _ : Z.lt 1 (Z.of_nat q), Z.lt 1 (Z.of_nat q)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : forall _ : Z.lt 1 (Z.of_nat q), Z.lt 1 (Z.of_nat q)",
                    "c28_q : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros hqle1 .",
                "tactic_args": [
                    "c53_goal : forall _ : Z.le (Z.of_nat q) 1, Z.lt 1 (Z.of_nat q)"
                ],
                "tactic_res": [
                    "c55_goal : Z.lt 1 (Z.of_nat q)",
                    "c55_hqle1 : Z.le (Z.of_nat q) 1"
                ]
            },
            {
                "tactic_sig": "assert ( Hq1 : _i = 1 % nat ) .",
                "tactic_sig_no_out_arg": "assert ( Hq1 : _i = 1 % nat ) .",
                "tactic_args": [
                    "c55_goal : Z.lt 1 (Z.of_nat q)",
                    "c28_q : nat"
                ],
                "tactic_res": [
                    "c56_goal : eq q 1%nat",
                    "c57_goal : Z.lt 1 (Z.of_nat q)",
                    "c57_Hq1 : eq q 1%nat"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c56_goal : eq q 1%nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c57_Hq1 : eq q 1%nat",
                    "c57_Heq : eq n (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c57_Heq : eq n (Init.Nat.mul 1 k)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c57_Heq : eq n (Init.Nat.mul 1 k)"
                ],
                "tactic_res": [
                    "c57_Heq : eq n (Init.Nat.add k 0)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c57_goal : Z.lt 1 (Z.of_nat q)",
                    "c28_Hnn : not (eq k n)"
                ],
                "tactic_res": [
                    "c58_goal : eq k n"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c58_goal : eq k n",
                    "c57_Heq : eq n (Init.Nat.add k 0)"
                ],
                "tactic_res": [
                    "c59_goal : eq k (Init.Nat.add k 0)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c59_goal : eq k (Init.Nat.add k 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c52_goal : Z.le (Z.of_nat q) (Z.sqrt (Z.of_nat n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c50_goal : ex (fun q' : nat => eq n (Init.Nat.mul q q'))",
                    "c28_k : nat"
                ],
                "tactic_res": [
                    "c60_goal : eq n (Init.Nat.mul q k)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c60_goal : eq n (Init.Nat.mul q k)",
                    "c28_Heq : eq n (Init.Nat.mul q k)",
                    "c28_q : nat",
                    "c28_k : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c39_goal : and (Z.lt 0 (Z.of_nat k)) (Z.lt (Z.of_nat k) (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c61_goal : Z.lt 0 (Z.of_nat k)",
                    "c62_goal : Z.lt (Z.of_nat k) (Z.of_nat n)"
                ]
            },
            {
                "tactic_sig": "case_eq _i .",
                "tactic_sig_no_out_arg": "case_eq _i .",
                "tactic_args": [
                    "c61_goal : Z.lt 0 (Z.of_nat k)",
                    "c28_k : nat"
                ],
                "tactic_res": [
                    "c63_goal : forall _ : eq k 0%nat, Z.lt 0 (Z.of_nat 0%nat)",
                    "c64_goal : forall (n : nat) (_ : eq k (S n)), Z.lt 0 (Z.of_nat (S n))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hk0 .",
                "tactic_args": [
                    "c63_goal : forall _ : eq k 0%nat, Z.lt 0 (Z.of_nat 0%nat)"
                ],
                "tactic_res": [
                    "c65_goal : Z.lt 0 (Z.of_nat 0%nat)",
                    "c65_Hk0 : eq k 0%nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c65_Hk0 : eq k 0%nat",
                    "c65_Heq : eq n (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c65_Heq : eq n (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c65_Heq : eq n (Init.Nat.mul q 0)",
                    "c65_H1ltn : lt 1 n"
                ],
                "tactic_res": [
                    "c65_H1ltn : lt 1 (Init.Nat.mul q 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_Nat.mul_0_r : forall n : nat, eq (Nat.mul n 0) 0%nat",
                    "c65_H1ltn : lt 1 (Init.Nat.mul q 0)"
                ],
                "tactic_res": [
                    "c65_H1ltn : lt 1 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c65_goal : Z.lt 0 (Z.of_nat 0%nat)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c64_goal : forall (n : nat) (_ : eq k (S n)), Z.lt 0 (Z.of_nat (S n))"
                ],
                "tactic_res": [
                    "c66_goal : Z.lt 0 (Z.of_nat (S n2))",
                    "c66_n2 : nat",
                    "c66_H : eq k (S n2)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c66_goal : Z.lt 0 (Z.of_nat (S n2))",
                    "_global_Z.lt : forall (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c67_goal : eq (Z.compare 0 (Z.of_nat (S n2))) Lt"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c67_goal : eq (Z.compare 0 (Z.of_nat (S n2))) Lt"
                ],
                "tactic_res": [
                    "c68_goal : eq Lt Lt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c68_goal : eq Lt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c62_goal : Z.lt (Z.of_nat k) (Z.of_nat n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c40_goal : eq (Z.of_nat n) (Z.mul (Z.of_nat k) (Z.of_nat q))",
                    "_global_Zmult_comm : forall n m : Z, eq (Z.mul n m) (Z.mul m n)"
                ],
                "tactic_res": [
                    "c69_goal : eq (Z.of_nat n) (Z.mul (Z.of_nat q) (Z.of_nat k))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c69_goal : eq (Z.of_nat n) (Z.mul (Z.of_nat q) (Z.of_nat k))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c70_goal : eq (Z.of_nat n) (Z.of_nat (Init.Nat.mul q k))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c70_goal : eq (Z.of_nat n) (Z.of_nat (Init.Nat.mul q k))",
                    "c28_Heq : eq n (Init.Nat.mul q k)"
                ],
                "tactic_res": [
                    "c71_goal : eq (Z.of_nat (Init.Nat.mul q k)) (Z.of_nat (Init.Nat.mul q k))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c71_goal : eq (Z.of_nat (Init.Nat.mul q k)) (Z.of_nat (Init.Nat.mul q k))",
                    "c28_q : nat",
                    "c28_k : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c36_goal : False",
                    "c36_Hex : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))"
                ],
                "tactic_res": [
                    "c72_goal : forall (x : nat)\n  (_ : and\n         (and (Z.lt 1 (Z.of_nat x))\n            (Z.le (Z.of_nat x) (Z.sqrt (Z.of_nat n))))\n         (ex (fun q' : nat => eq n (Init.Nat.mul x q')))), False"
                ]
            },
            {
                "tactic_sig": "intros _o ( ( _o , _o ) , _o ) .",
                "tactic_sig_no_out_arg": "intros k' ( ( H1ltk' , Hk'ltsqrt ) , Hex' ) .",
                "tactic_args": [
                    "c72_goal : forall (x : nat)\n  (_ : and\n         (and (Z.lt 1 (Z.of_nat x))\n            (Z.le (Z.of_nat x) (Z.sqrt (Z.of_nat n))))\n         (ex (fun q' : nat => eq n (Init.Nat.mul x q')))), False"
                ],
                "tactic_res": [
                    "c73_goal : False",
                    "c73_k' : nat",
                    "c73_H1ltk' : Z.lt 1 (Z.of_nat k')",
                    "c73_Hk'ltsqrt : Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))",
                    "c73_Hex' : ex (fun q' : nat => eq n (Init.Nat.mul k' q'))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c36_Hex : ex\n  (fun k' : nat =>\n   and\n     (and (Z.lt 1 (Z.of_nat k'))\n        (Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))))\n     (ex (fun q' : nat => eq n (Init.Nat.mul k' q'))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case_eq _i .",
                "tactic_sig_no_out_arg": "case_eq _i .",
                "tactic_args": [
                    "c73_goal : False",
                    "c28_p : positive"
                ],
                "tactic_res": [
                    "c74_goal : forall (p0 : positive) (_ : eq p (xI p0)), False",
                    "c75_goal : forall (p0 : positive) (_ : eq p (xO p0)), False",
                    "c76_goal : forall _ : eq p 1%positive, False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hp .",
                "tactic_args": [
                    "c74_goal : forall (p0 : positive) (_ : eq p (xI p0)), False"
                ],
                "tactic_res": [
                    "c77_goal : False",
                    "c77_p' : positive",
                    "c77_Hp : eq p (xI p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c77_Hp : eq p (xI p')",
                    "c77_Htest_eq : eq\n  (let (half_s, even_bit) :=\n     match p with\n     | xI h => pair (Zpos h) 0\n     | xO h => pair (Zpos h) 1\n     | 1%positive => pair 0 0\n     end in\n   test_odds (Z.abs_nat half_s) (Z.add (Zpos p) even_bit) (Z.of_nat n))\n  true"
                ],
                "tactic_res": [
                    "c77_Htest_eq : eq\n  (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos (xI p')) 0)\n     (Z.of_nat n)) true"
                ]
            },
            {
                "tactic_sig": "elim ( test_odds_correct ( Z.abs_nat ( Zpos _i ) ) _i ( Zpos _i ) ) with _i .",
                "tactic_sig_no_out_arg": "elim ( test_odds_correct ( Z.abs_nat ( Zpos _i ) ) _i ( Zpos _i ) ) with _i .",
                "tactic_args": [
                    "c77_goal : False",
                    "c77_p' : positive",
                    "c2_n : nat",
                    "c28_p : positive",
                    "c73_k' : nat"
                ],
                "tactic_res": [
                    "c78_goal : eq (Zpos p) (Z.add (Z.mul 2 (Z.of_nat (Z.abs_nat (Zpos p')))) 1)",
                    "c79_goal : lt 1 n",
                    "c80_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Zpos p) (Z.of_nat n)) true",
                    "c81_goal : and (lt 1 k')\n  (le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))",
                    "c82_goal : ex (fun y : nat => eq n (Init.Nat.mul k' y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c78_goal : eq (Zpos p) (Z.add (Z.mul 2 (Z.of_nat (Z.abs_nat (Zpos p')))) 1)",
                    "_global_Z_to_nat_and_back : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ],
                "tactic_res": [
                    "c83_goal : eq (Zpos p) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "c84_goal : Z.le 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c83_goal : eq (Zpos p) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "c77_Hp : eq p (xI p')"
                ],
                "tactic_res": [
                    "c85_goal : eq (Zpos (xI p')) (Z.add (Z.mul 2 (Zpos p')) 1)"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c85_goal : eq (Zpos (xI p')) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "c77_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c84_goal : Z.le 0 (Zpos p')",
                    "c77_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c79_goal : lt 1 n",
                    "c15_H1ltn : lt 1 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat rewrite Zminus_0_r in _i .",
                "tactic_sig_no_out_arg": "repeat rewrite Zminus_0_r in _i .",
                "tactic_args": [
                    "c77_Htest_eq : eq\n  (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos (xI p')) 0)\n     (Z.of_nat n)) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c80_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Zpos p) (Z.of_nat n)) true",
                    "c77_Hp : eq p (xI p')"
                ],
                "tactic_res": [
                    "c86_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Zpos (xI p')) (Z.of_nat n)) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Zpos (xI p')) (Z.of_nat n)) true",
                    "c77_Htest_eq : eq\n  (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos (xI p')) 0)\n     (Z.of_nat n)) true",
                    "c77_p' : positive",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c81_goal : and (lt 1 k')\n  (le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))"
                ],
                "tactic_res": [
                    "c87_goal : lt 1 k'",
                    "c88_goal : le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c87_goal : lt 1 k'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c88_goal : le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1)",
                    "_global_Z_of_nat_le : forall (x y : nat) (_ : Z.le (Z.of_nat x) (Z.of_nat y)), le x y"
                ],
                "tactic_res": [
                    "c89_goal : Z.le (Z.of_nat k')\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c89_goal : Z.le (Z.of_nat k')\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))",
                    "_global_inj_plus : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.add n m)) (Z.add (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c90_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c90_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c91_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c91_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))",
                    "_global_Z_to_nat_and_back : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ],
                "tactic_res": [
                    "c92_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Zpos p')) (Z.of_nat 1%nat))",
                    "c93_goal : Z.le 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "simpl ( Z_of_nat 2 ) .",
                "tactic_sig_no_out_arg": "simpl ( Z_of_nat 2 ) .",
                "tactic_args": [
                    "c92_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Zpos p')) (Z.of_nat 1%nat))"
                ],
                "tactic_res": [
                    "c94_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "simpl ( Z_of_nat 1 ) .",
                "tactic_sig_no_out_arg": "simpl ( Z_of_nat 1 ) .",
                "tactic_args": [
                    "c94_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) (Z.of_nat 1%nat))"
                ],
                "tactic_res": [
                    "c95_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c95_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)"
                ],
                "tactic_res": [
                    "c96_goal : Z.le (Z.of_nat k') (Zpos (xI p'))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c96_goal : Z.le (Z.of_nat k') (Zpos (xI p'))",
                    "c77_Hp : eq p (xI p')"
                ],
                "tactic_res": [
                    "c97_goal : Z.le (Z.of_nat k') (Zpos p)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c97_goal : Z.le (Z.of_nat k') (Zpos p)",
                    "c28_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) (Zpos p)"
                ],
                "tactic_res": [
                    "c98_goal : Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c98_goal : Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))",
                    "c73_Hk'ltsqrt : Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))",
                    "c73_k' : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c93_goal : Z.le 0 (Zpos p')",
                    "c77_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c82_goal : ex (fun y : nat => eq n (Init.Nat.mul k' y))",
                    "c73_Hex' : ex (fun q' : nat => eq n (Init.Nat.mul k' q'))",
                    "c73_k' : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' Hp .",
                "tactic_args": [
                    "c75_goal : forall (p0 : positive) (_ : eq p (xO p0)), False"
                ],
                "tactic_res": [
                    "c99_goal : False",
                    "c99_p' : positive",
                    "c99_Hp : eq p (xO p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c99_Hp : eq p (xO p')",
                    "c99_Htest_eq : eq\n  (let (half_s, even_bit) :=\n     match p with\n     | xI h => pair (Zpos h) 0\n     | xO h => pair (Zpos h) 1\n     | 1%positive => pair 0 0\n     end in\n   test_odds (Z.abs_nat half_s) (Z.add (Zpos p) even_bit) (Z.of_nat n))\n  true"
                ],
                "tactic_res": [
                    "c99_Htest_eq : eq\n  (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos (xO p')) 1)\n     (Z.of_nat n)) true"
                ]
            },
            {
                "tactic_sig": "elim ( test_odds_correct ( Z.abs_nat ( Zpos _i ) ) _i ( Zpos _i + 1 ) ) with _i .",
                "tactic_sig_no_out_arg": "elim ( test_odds_correct ( Z.abs_nat ( Zpos _i ) ) _i ( Zpos _i + 1 ) ) with _i .",
                "tactic_args": [
                    "c99_goal : False",
                    "c99_p' : positive",
                    "c2_n : nat",
                    "c28_p : positive",
                    "c73_k' : nat"
                ],
                "tactic_res": [
                    "c100_goal : eq (Z.add (Zpos p) 1)\n  (Z.add (Z.mul 2 (Z.of_nat (Z.abs_nat (Zpos p')))) 1)",
                    "c101_goal : lt 1 n",
                    "c102_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos p) 1) (Z.of_nat n))\n  true",
                    "c103_goal : and (lt 1 k')\n  (le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))",
                    "c104_goal : ex (fun y : nat => eq n (Init.Nat.mul k' y))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c100_goal : eq (Z.add (Zpos p) 1)\n  (Z.add (Z.mul 2 (Z.of_nat (Z.abs_nat (Zpos p')))) 1)",
                    "_global_Z_to_nat_and_back : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ],
                "tactic_res": [
                    "c105_goal : eq (Z.add (Zpos p) 1) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "c106_goal : Z.le 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c105_goal : eq (Z.add (Zpos p) 1) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "c99_Hp : eq p (xO p')"
                ],
                "tactic_res": [
                    "c107_goal : eq (Z.add (Zpos (xO p')) 1) (Z.add (Z.mul 2 (Zpos p')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c107_goal : eq (Z.add (Zpos (xO p')) 1) (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c108_goal : eq (Z.add (Z.mul 2 (Zpos p')) 1) (Z.add (Z.mul 2 (Zpos p')) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c108_goal : eq (Z.add (Z.mul 2 (Zpos p')) 1) (Z.add (Z.mul 2 (Zpos p')) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( lt_Zpos _i ) .",
                "tactic_sig_no_out_arg": "generalize ( lt_Zpos _i ) .",
                "tactic_args": [
                    "c106_goal : Z.le 0 (Zpos p')",
                    "c99_p' : positive"
                ],
                "tactic_res": [
                    "c109_goal : forall _ : Z.lt 0 (Zpos p'), Z.le 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c109_goal : forall _ : Z.lt 0 (Zpos p'), Z.le 0 (Zpos p')"
                ],
                "tactic_res": [
                    "c110_goal : Z.le 0 (Zpos p')",
                    "c110_H : Z.lt 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c110_goal : Z.le 0 (Zpos p')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c101_goal : lt 1 n",
                    "c15_H1ltn : lt 1 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "c99_Hp : eq p (xO p')",
                    "c102_Htest_eq : eq\n  (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos (xO p')) 1)\n     (Z.of_nat n)) true"
                ],
                "tactic_res": [
                    "c102_Htest_eq : eq (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos p) 1) (Z.of_nat n))\n  true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c102_goal : eq (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos p) 1) (Z.of_nat n))\n  true",
                    "c102_Htest_eq : eq (test_odds (Z.abs_nat (Zpos p')) (Z.add (Zpos p) 1) (Z.of_nat n))\n  true",
                    "c99_p' : positive",
                    "c28_p : positive",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c103_goal : and (lt 1 k')\n  (le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))"
                ],
                "tactic_res": [
                    "c111_goal : lt 1 k'",
                    "c112_goal : le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c111_goal : lt 1 k'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c112_goal : le k' (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1)",
                    "_global_Z_of_nat_le : forall (x y : nat) (_ : Z.le (Z.of_nat x) (Z.of_nat y)), le x y"
                ],
                "tactic_res": [
                    "c113_goal : Z.le (Z.of_nat k')\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c113_goal : Z.le (Z.of_nat k')\n  (Z.of_nat (Init.Nat.add (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))) 1))",
                    "_global_inj_plus : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.add n m)) (Z.add (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c114_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c114_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.of_nat (Init.Nat.mul 2 (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))",
                    "_global_inj_mult : forall n m : nat,\n       eq (Z.of_nat (Init.Nat.mul n m)) (Z.mul (Z.of_nat n) (Z.of_nat m))"
                ],
                "tactic_res": [
                    "c115_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c115_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Z.of_nat (Z.abs_nat (Zpos p'))))\n     (Z.of_nat 1%nat))",
                    "_global_Z_to_nat_and_back : forall (x : Z) (_ : Z.le 0 x), eq (Z.of_nat (Z.abs_nat x)) x"
                ],
                "tactic_res": [
                    "c116_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Zpos p')) (Z.of_nat 1%nat))",
                    "c117_goal : Z.le 0 (Zpos p')"
                ]
            },
            {
                "tactic_sig": "simpl ( Z_of_nat 2 ) .",
                "tactic_sig_no_out_arg": "simpl ( Z_of_nat 2 ) .",
                "tactic_args": [
                    "c116_goal : Z.le (Z.of_nat k')\n  (Z.add (Z.mul (Z.of_nat 2%nat) (Zpos p')) (Z.of_nat 1%nat))"
                ],
                "tactic_res": [
                    "c118_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) (Z.of_nat 1%nat))"
                ]
            },
            {
                "tactic_sig": "simpl ( Z_of_nat 1 ) .",
                "tactic_sig_no_out_arg": "simpl ( Z_of_nat 1 ) .",
                "tactic_args": [
                    "c118_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) (Z.of_nat 1%nat))"
                ],
                "tactic_res": [
                    "c119_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c119_goal : Z.le (Z.of_nat k') (Z.add (Z.mul 2 (Zpos p')) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c120_goal : Z.le (Z.of_nat k') (Z.add (Zpos (xO p')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c120_goal : Z.le (Z.of_nat k') (Z.add (Zpos (xO p')) 1)",
                    "c99_Hp : eq p (xO p')"
                ],
                "tactic_res": [
                    "c121_goal : Z.le (Z.of_nat k') (Z.add (Zpos p) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c121_goal : Z.le (Z.of_nat k') (Z.add (Zpos p) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c117_goal : Z.le 0 (Zpos p')",
                    "c99_p' : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c104_goal : ex (fun y : nat => eq n (Init.Nat.mul k' y))",
                    "c73_Hex' : ex (fun q' : nat => eq n (Init.Nat.mul k' q'))",
                    "c73_k' : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hp .",
                "tactic_args": [
                    "c76_goal : forall _ : eq p 1%positive, False"
                ],
                "tactic_res": [
                    "c122_goal : False",
                    "c122_Hp : eq p 1%positive"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c122_Hp : eq p 1%positive",
                    "c122_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) (Zpos p)"
                ],
                "tactic_res": [
                    "c122_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) 1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c122_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) 1",
                    "c122_Hk'ltsqrt : Z.le (Z.of_nat k') (Z.sqrt (Z.of_nat n))"
                ],
                "tactic_res": [
                    "c122_Hk'ltsqrt : Z.le (Z.of_nat k') 1"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c122_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o Hsqrt_eq .",
                "tactic_sig_no_out_arg": "intros p Hsqrt_eq .",
                "tactic_args": [
                    "c20_goal : forall (p : positive) (_ : eq (Z.sqrt (Z.of_nat n)) (Zneg p))\n  (_ : eq (test_odds (Z.abs_nat 0) (Z.add (Zneg p) 1) (Z.of_nat n))\n         true),\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))"
                ],
                "tactic_res": [
                    "c123_goal : forall\n  _ : eq (test_odds (Z.abs_nat 0) (Z.add (Zneg p) 1) (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c123_p : positive",
                    "c123_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "elim ( Zle_not_lt 0 ( Z.sqrt ( Z_of_nat _i ) ) ) .",
                "tactic_sig_no_out_arg": "elim ( Zle_not_lt 0 ( Z.sqrt ( Z_of_nat _i ) ) ) .",
                "tactic_args": [
                    "c123_goal : forall\n  _ : eq (test_odds (Z.abs_nat 0) (Z.add (Zneg p) 1) (Z.of_nat n)) true,\nnot\n  (ex\n     (fun k : nat =>\n      and (not (eq k 1%nat))\n        (and (not (eq k n))\n           (ex (fun q : nat => eq n (Init.Nat.mul q k))))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c124_goal : Z.le 0 (Z.sqrt (Z.of_nat n))",
                    "c125_goal : Z.lt (Z.sqrt (Z.of_nat n)) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c124_goal : Z.le 0 (Z.sqrt (Z.of_nat n))",
                    "_global_Z.sqrt_nonneg : forall a : Z, Z.le 0 (Z.sqrt a)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c125_goal : Z.lt (Z.sqrt (Z.of_nat n)) 0",
                    "c123_Hsqrt_eq : eq (Z.sqrt (Z.of_nat n)) (Zneg p)"
                ],
                "tactic_res": [
                    "c126_goal : Z.lt (Zneg p) 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c126_goal : Z.lt (Zneg p) 0",
                    "_global_Zneg_lt : forall p : positive, Z.lt (Zneg p) 0"
                ],
                "tactic_res": []
            }
        ]
    }
]