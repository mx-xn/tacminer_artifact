[
    {
        "lemma_name": "pred''",
        "proof": [
            {
                "tactic_sig": "Definition pred'' : forall n : nat , { p : nat | n = S p } + { n = 0 } .",
                "tactic_sig_no_out_arg": "Definition pred'' : forall n : nat , { p : nat | n = S p } + { n = 0 } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, sumor (sig (fun p : nat => eq n (S p))) (eq n 0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, sumor (sig (fun p : nat => eq n (S p))) (eq n 0)"
                ],
                "tactic_res": [
                    "c2_goal : sumor (sig (fun p : nat => eq n (S p))) (eq n 0)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : sumor (sig (fun p : nat => eq n (S p))) (eq n 0)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : sumor (sig (fun p : nat => eq 0 (S p))) (eq 0 0)",
                    "c4_goal : forall n : nat,\nsumor (sig (fun p : nat => eq (S n) (S p))) (eq (S n) 0)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c3_goal : sumor (sig (fun p : nat => eq 0 (S p))) (eq 0 0)"
                ],
                "tactic_res": [
                    "c5_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq 0 0",
                    "_global_refl_equal : eq ?x ?x\nwhere\n?A : [n : nat |- Type]\n?x : [n : nat |- ?A]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros p .",
                "tactic_args": [
                    "c4_goal : forall n : nat,\nsumor (sig (fun p : nat => eq (S n) (S p))) (eq (S n) 0)"
                ],
                "tactic_res": [
                    "c6_goal : sumor (sig (fun p0 : nat => eq (S p) (S p0))) (eq (S p) 0)",
                    "c6_p : nat"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c6_goal : sumor (sig (fun p0 : nat => eq (S p) (S p0))) (eq (S p) 0)"
                ],
                "tactic_res": [
                    "c7_goal : sig (fun p0 : nat => eq (S p) (S p0))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : sig (fun p0 : nat => eq (S p) (S p0))",
                    "c6_p : nat"
                ],
                "tactic_res": [
                    "c8_goal : eq (S p) (S p)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c8_goal : eq (S p) (S p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_partial",
        "proof": [
            {
                "tactic_sig": "Definition pred_partial : forall n : nat , n <> 0 -> nat .",
                "tactic_sig_no_out_arg": "Definition pred_partial : forall n : nat , n <> 0 -> nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), nat"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), nat"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : not (eq n 0), nat",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall _ : not (eq n 0), nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : not (eq 0 0), nat",
                    "c4_goal : forall (n : nat) (_ : not (eq (S n) 0)), nat"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros h .",
                "tactic_args": [
                    "c3_goal : forall _ : not (eq 0 0), nat"
                ],
                "tactic_res": [
                    "c5_goal : nat",
                    "c5_h : not (eq 0 0)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c5_goal : nat",
                    "c5_h : not (eq 0 0)"
                ],
                "tactic_res": [
                    "c6_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c6_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p h' .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : not (eq (S n) 0)), nat"
                ],
                "tactic_res": [
                    "c7_goal : nat",
                    "c7_p : nat",
                    "c7_h' : not (eq (S p) 0)"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c7_goal : nat",
                    "c7_p : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "le_2_n_not_zero",
        "proof": [
            {
                "tactic_sig": "Theorem le_2_n_not_zero : forall n : nat , 2 <= n -> n <> 0 .",
                "tactic_sig_no_out_arg": "Theorem le_2_n_not_zero : forall n : nat , 2 <= n -> n <> 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n Hle .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq n 0)",
                    "c2_n : nat",
                    "c2_Hle : le 2 n"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : not (eq n 0)",
                    "c2_Hle : le 2 n"
                ],
                "tactic_res": [
                    "c3_goal : not (eq 2 0)",
                    "c4_goal : forall (m : nat) (_ : le 2 m) (_ : not (eq m 0)), not (eq (S m) 0)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c3_goal : not (eq 2 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (m : nat) (_ : le 2 m) (_ : not (eq m 0)), not (eq (S m) 0)"
                ],
                "tactic_res": [
                    "c5_goal : not (eq (S m) 0)",
                    "c5_m : nat",
                    "c5_H : le 2 m",
                    "c5_H0 : not (eq m 0)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : not (eq (S m) 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "le_2_n_pred'",
        "proof": [
            {
                "tactic_sig": "Theorem le_2_n_pred' : forall n : nat , 2 <= n -> forall h : n <> 0 , pred_partial n h <> 0 .",
                "tactic_sig_no_out_arg": "Theorem le_2_n_pred' : forall n : nat , 2 <= n -> forall h : n <> 0 , pred_partial n h <> 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le 2 n) (h : not (eq n 0)),\nnot (eq (pred_partial n h) 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n Hle .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le 2 n) (h : not (eq n 0)),\nnot (eq (pred_partial n h) 0)"
                ],
                "tactic_res": [
                    "c2_goal : forall h : not (eq n 0), not (eq (pred_partial n h) 0)",
                    "c2_n : nat",
                    "c2_Hle : le 2 n"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall h : not (eq n 0), not (eq (pred_partial n h) 0)",
                    "c2_Hle : le 2 n"
                ],
                "tactic_res": [
                    "c3_goal : forall h : not (eq 2 0), not (eq (pred_partial 2 h) 0)",
                    "c4_goal : forall (m : nat) (_ : le 2 m)\n  (_ : forall h : not (eq m 0), not (eq (pred_partial m h) 0))\n  (h : not (eq (S m) 0)), not (eq (pred_partial (S m) h) 0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall h : not (eq 2 0), not (eq (pred_partial 2 h) 0)"
                ],
                "tactic_res": [
                    "c5_goal : not (eq (pred_partial 2 h) 0)",
                    "c5_h : not (eq 2 0)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : not (eq (pred_partial 2 h) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (m : nat) (_ : le 2 m)\n  (_ : forall h : not (eq m 0), not (eq (pred_partial m h) 0))\n  (h : not (eq (S m) 0)), not (eq (pred_partial (S m) h) 0)"
                ],
                "tactic_res": [
                    "c6_goal : forall (m : nat) (_ : le 2 m)\n  (_ : forall h : not (eq m 0), not (eq (pred_partial m h) 0))\n  (_ : not (eq (S m) 0)), not (eq m 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (m : nat) (_ : le 2 m)\n  (_ : forall h : not (eq m 0), not (eq (pred_partial m h) 0))\n  (_ : not (eq (S m) 0)), not (eq m 0)"
                ],
                "tactic_res": [
                    "c7_goal : not (eq m 0)",
                    "c7_m : nat",
                    "c7_H : le 2 m",
                    "c7_H0 : forall h : not (eq m 0), not (eq (pred_partial m h) 0)",
                    "c7_h : not (eq (S m) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : not (eq m 0)",
                    "_global_le_2_n_not_zero : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ],
                "tactic_res": [
                    "c8_goal : le 2 m"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c8_goal : le 2 m",
                    "c7_H : le 2 m",
                    "c7_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "le_2_n_pred",
        "proof": [
            {
                "tactic_sig": "Theorem le_2_n_pred : forall ( n : nat ) ( h : 2 <= n ) , pred_partial n ( le_2_n_not_zero n h ) <> 0 .",
                "tactic_sig_no_out_arg": "Theorem le_2_n_pred : forall ( n : nat ) ( h : 2 <= n ) , pred_partial n ( le_2_n_not_zero n h ) <> 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (h : le 2 n),\nnot (eq (pred_partial n (le_2_n_not_zero n h)) 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n h .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (h : le 2 n),\nnot (eq (pred_partial n (le_2_n_not_zero n h)) 0)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq (pred_partial n (le_2_n_not_zero n h)) 0)",
                    "c2_n : nat",
                    "c2_h : le 2 n"
                ]
            },
            {
                "tactic_sig": "exact ( le_2_n_pred' _i _i ( le_2_n_not_zero _i _i ) ) .",
                "tactic_sig_no_out_arg": "exact ( le_2_n_pred' _i _i ( le_2_n_not_zero _i _i ) ) .",
                "tactic_args": [
                    "c2_goal : not (eq (pred_partial n (le_2_n_not_zero n h)) 0)",
                    "c2_n : nat",
                    "c2_h : le 2 n",
                    "c2_n : nat",
                    "c2_h : le 2 n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_strong",
        "proof": [
            {
                "tactic_sig": "Definition pred_strong : forall n : nat , n <> 0 -> { v : nat | n = S v } .",
                "tactic_sig_no_out_arg": "Definition pred_strong : forall n : nat , n <> 0 -> { v : nat | n = S v } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), sig (fun v : nat => eq n (S v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), sig (fun v : nat => eq n (S v))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : not (eq n 0), sig (fun v : nat => eq n (S v))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall _ : not (eq n 0), sig (fun v : nat => eq n (S v))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : not (eq 0 0), sig (fun v : nat => eq 0 (S v))",
                    "c4_goal : forall (n : nat) (_ : not (eq (S n) 0)),\nsig (fun v : nat => eq (S n) (S v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c3_goal : forall _ : not (eq 0 0), sig (fun v : nat => eq 0 (S v))"
                ],
                "tactic_res": [
                    "c5_goal : sig (fun v : nat => eq 0 (S v))",
                    "c5_H : not (eq 0 0)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c5_goal : sig (fun v : nat => eq 0 (S v))",
                    "c5_H : not (eq 0 0)"
                ],
                "tactic_res": [
                    "c6_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p H' .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : not (eq (S n) 0)),\nsig (fun v : nat => eq (S n) (S v))"
                ],
                "tactic_res": [
                    "c7_goal : sig (fun v : nat => eq (S p) (S v))",
                    "c7_p : nat",
                    "c7_H' : not (eq (S p) 0)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : sig (fun v : nat => eq (S p) (S v))",
                    "c7_p : nat"
                ],
                "tactic_res": [
                    "c8_goal : eq (S p) (S p)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c8_goal : eq (S p) (S p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_strong2_th1",
        "proof": [
            {
                "tactic_sig": "Theorem pred_strong2_th1 : forall n p : nat , 2 <= n -> n = S p -> p <> 0 .",
                "tactic_sig_no_out_arg": "Theorem pred_strong2_th1 : forall n p : nat , 2 <= n -> n = S p -> p <> 0 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n p : nat) (_ : le 2 n) (_ : eq n (S p)), not (eq p 0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n p : nat) (_ : le 2 n) (_ : eq n (S p)), not (eq p 0)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq p 0)",
                    "c2_n : nat",
                    "c2_p : nat",
                    "c2_H : le 2 n",
                    "c2_H0 : eq n (S p)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : not (eq p 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_th1",
        "proof": [
            {
                "tactic_sig": "Theorem pred_th1 : forall n p q : nat , n = S p -> p = S q -> n = S ( S q ) .",
                "tactic_sig_no_out_arg": "Theorem pred_th1 : forall n p q : nat , n = S p -> p = S q -> n = S ( S q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n p q : nat) (_ : eq n (S p)) (_ : eq p (S q)), eq n (S (S q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n p q : nat) (_ : eq n (S p)) (_ : eq p (S q)), eq n (S (S q))"
                ],
                "tactic_res": [
                    "c2_goal : eq n (S (S q))",
                    "c2_n : nat",
                    "c2_p : nat",
                    "c2_q : nat",
                    "c2_H : eq n (S p)",
                    "c2_H0 : eq p (S q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_goal : eq n (S (S q))",
                    "c2_n : nat",
                    "c2_H : eq n (S p)"
                ],
                "tactic_res": [
                    "c3_goal : eq (S p) (S (S q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (S p) (S (S q))",
                    "c2_H0 : eq p (S q)",
                    "c2_p : nat",
                    "c2_q : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_strong2'",
        "proof": [
            {
                "tactic_sig": "Definition pred_strong2' : forall n : nat , 2 <= n -> { v : nat | n = S ( S v ) } .",
                "tactic_sig_no_out_arg": "Definition pred_strong2' : forall n : nat , 2 <= n -> { v : nat | n = S ( S v ) } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), sig (fun v : nat => eq n (S (S v)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n h .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), sig (fun v : nat => eq n (S (S v)))"
                ],
                "tactic_res": [
                    "c2_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c2_n : nat",
                    "c2_h : le 2 n"
                ]
            },
            {
                "tactic_sig": "case ( pred_strong _i ) .",
                "tactic_sig_no_out_arg": "case ( pred_strong _i ) .",
                "tactic_args": [
                    "c2_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : not (eq n 0)",
                    "c4_goal : forall (x : nat) (_ : eq n (S x)), sig (fun v : nat => eq n (S (S v)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : not (eq n 0)",
                    "_global_le_2_n_not_zero : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ],
                "tactic_res": [
                    "c5_goal : le 2 n"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c5_goal : le 2 n",
                    "c2_h : le 2 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p h' .",
                "tactic_args": [
                    "c4_goal : forall (x : nat) (_ : eq n (S x)), sig (fun v : nat => eq n (S (S v)))"
                ],
                "tactic_res": [
                    "c6_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c6_p : nat",
                    "c6_h' : eq n (S p)"
                ]
            },
            {
                "tactic_sig": "case ( pred_strong _i ) .",
                "tactic_sig_no_out_arg": "case ( pred_strong _i ) .",
                "tactic_args": [
                    "c6_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c6_p : nat"
                ],
                "tactic_res": [
                    "c7_goal : not (eq p 0)",
                    "c8_goal : forall (x : nat) (_ : eq p (S x)), sig (fun v : nat => eq n (S (S v)))"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c7_goal : not (eq p 0)",
                    "_global_pred_strong2_th1 : forall (n p : nat) (_ : le 2 n) (_ : eq n (S p)), not (eq p 0)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c9_goal : le 2 n",
                    "c10_goal : eq n (S p)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c9_goal : le 2 n",
                    "c2_h : le 2 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c10_goal : eq n (S p)",
                    "c6_h' : eq n (S p)",
                    "c6_p : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p' h'' .",
                "tactic_args": [
                    "c8_goal : forall (x : nat) (_ : eq p (S x)), sig (fun v : nat => eq n (S (S v)))"
                ],
                "tactic_res": [
                    "c11_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c11_p' : nat",
                    "c11_h'' : eq p (S p')"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : sig (fun v : nat => eq n (S (S v)))",
                    "c11_p' : nat"
                ],
                "tactic_res": [
                    "c12_goal : eq n (S (S p'))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c12_goal : eq n (S (S p'))",
                    "_global_pred_th1 : forall (n p q : nat) (_ : eq n (S p)) (_ : eq p (S q)), eq n (S (S q))"
                ],
                "tactic_res": [
                    "c13_goal : eq n (S ?p)",
                    "c14_goal : eq p (S p')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : eq n (S ?p)",
                    "c6_h' : eq n (S p)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq p (S p')",
                    "c11_h'' : eq p (S p')",
                    "c11_p' : nat",
                    "c6_p : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "divides_refl",
        "proof": [
            {
                "tactic_sig": "Lemma divides_refl : forall n : nat , divides n n .",
                "tactic_sig_no_out_arg": "Lemma divides_refl : forall n : nat , divides n n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, divides n n",
                    "c1_get_primediv_weak_ok : forall (n : nat) (H : not (prime n)) (_ : lt 1 n),\nprime_divisor n (get_primediv_weak n H)",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime_test_t : forall (n : nat) (_ : eq (prime_test n) true), prime n",
                    "c1_prime_test : forall _ : nat, bool",
                    "c1_prime : forall _ : nat, Prop"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, divides n n"
                ],
                "tactic_res": [
                    "c2_goal : divides n n",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "exists 1 .",
                "tactic_sig_no_out_arg": "exists 1 .",
                "tactic_args": [
                    "c2_goal : divides n n"
                ],
                "tactic_res": [
                    "c3_goal : eq (Init.Nat.mul 1 n) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (Init.Nat.mul 1 n) n"
                ],
                "tactic_res": [
                    "c4_goal : eq (Init.Nat.add n 0) n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (Init.Nat.add n 0) n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bad_get_prime",
        "proof": [
            {
                "tactic_sig": "Definition bad_get_prime : nat -> nat .",
                "tactic_sig_no_out_arg": "Definition bad_get_prime : nat -> nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall _ : nat, nat",
                    "c1_get_primediv_weak_ok : forall (n : nat) (H : not (prime n)) (_ : lt 1 n),\nprime_divisor n (get_primediv_weak n H)",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime_test_t : forall (n : nat) (_ : eq (prime_test n) true), prime n",
                    "c1_prime_test : forall _ : nat, bool",
                    "c1_prime : forall _ : nat, Prop"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall _ : nat, nat"
                ],
                "tactic_res": [
                    "c2_goal : nat",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case_eq ( _i _i ) .",
                "tactic_sig_no_out_arg": "case_eq ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : nat",
                    "c1_prime_test : forall _ : nat, bool",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq (prime_test n) true, nat",
                    "c4_goal : forall _ : eq (prime_test n) false, nat"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (prime_test n) true, nat"
                ],
                "tactic_res": [
                    "c5_goal : nat",
                    "c5_H : eq (prime_test n) true"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "c5_goal : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro Hfalse .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (prime_test n) false, nat"
                ],
                "tactic_res": [
                    "c6_goal : nat",
                    "c6_Hfalse : eq (prime_test n) false"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c6_goal : nat",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c7_goal : not (prime n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : not (prime n)",
                    "c6_Hfalse : eq (prime_test n) false",
                    "c2_n : nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime : forall _ : nat, Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "stronger_prime_test",
        "proof": [
            {
                "tactic_sig": "Definition stronger_prime_test : forall n : nat , { ( prime_test n ) = true } + { ( prime_test n ) = false } .",
                "tactic_sig_no_out_arg": "Definition stronger_prime_test : forall n : nat , { ( prime_test n ) = true } + { ( prime_test n ) = false } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat,\nsumbool (eq (prime_test n) true) (eq (prime_test n) false)",
                    "c1_get_primediv_weak_ok : forall (n : nat) (H : not (prime n)) (_ : lt 1 n),\nprime_divisor n (get_primediv_weak n H)",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime_test_t : forall (n : nat) (_ : eq (prime_test n) true), prime n",
                    "c1_prime_test : forall _ : nat, bool",
                    "c1_prime : forall _ : nat, Prop"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall n : nat,\nsumbool (eq (prime_test n) true) (eq (prime_test n) false)"
                ],
                "tactic_res": [
                    "c2_goal : sumbool (eq (prime_test n) true) (eq (prime_test n) false)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "case ( _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : sumbool (eq (prime_test n) true) (eq (prime_test n) false)",
                    "c1_prime_test : forall _ : nat, bool",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : sumbool (eq true true) (eq true false)",
                    "c4_goal : sumbool (eq false true) (eq false false)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c3_goal : sumbool (eq true true) (eq true false)"
                ],
                "tactic_res": [
                    "c5_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c4_goal : sumbool (eq false true) (eq false false)"
                ],
                "tactic_res": [
                    "c6_goal : eq false false"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c6_goal : eq false false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "get_primediv_ok",
        "proof": [
            {
                "tactic_sig": "Theorem get_primediv_ok : forall n : nat , 1 < n -> prime_divisor n ( get_prime n ) .",
                "tactic_sig_no_out_arg": "Theorem get_primediv_ok : forall n : nat , 1 < n -> prime_divisor n ( get_prime n ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : lt 1 n), prime_divisor n (get_prime n)",
                    "c1_get_primediv_weak_ok : forall (n : nat) (H : not (prime n)) (_ : lt 1 n),\nprime_divisor n (get_primediv_weak n H)",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime_test_t : forall (n : nat) (_ : eq (prime_test n) true), prime n",
                    "c1_prime_test : forall _ : nat, bool",
                    "c1_prime : forall _ : nat, Prop"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : lt 1 n), prime_divisor n (get_prime n)"
                ],
                "tactic_res": [
                    "c2_goal : prime_divisor n (get_prime n)",
                    "c2_n : nat",
                    "c2_H : lt 1 n"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : prime_divisor n (get_prime n)",
                    "_global_get_prime : forall _ : nat, nat"
                ],
                "tactic_res": [
                    "c3_goal : prime_divisor n\n  match stronger_prime_test n with\n  | left _ => n\n  | right H => get_primediv_weak n (prime_test_f n H)\n  end"
                ]
            },
            {
                "tactic_sig": "case ( stronger_prime_test _i ) .",
                "tactic_sig_no_out_arg": "case ( stronger_prime_test _i ) .",
                "tactic_args": [
                    "c3_goal : prime_divisor n\n  match stronger_prime_test n with\n  | left _ => n\n  | right H => get_primediv_weak n (prime_test_f n H)\n  end",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (prime_test n) true, prime_divisor n n",
                    "c5_goal : forall e : eq (prime_test n) false,\nprime_divisor n (get_primediv_weak n (prime_test_f n e))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall e : eq (prime_test n) false,\nprime_divisor n (get_primediv_weak n (prime_test_f n e))",
                    "c2_H : lt 1 n",
                    "c2_n : nat",
                    "c1_get_primediv_weak_ok : forall (n : nat) (H : not (prime n)) (_ : lt 1 n),\nprime_divisor n (get_primediv_weak n H)",
                    "c1_get_primediv_weak : forall (n : nat) (_ : not (prime n)), nat",
                    "c1_prime_test_f : forall (n : nat) (_ : eq (prime_test n) false), not (prime n)",
                    "c1_prime_test : forall _ : nat, bool",
                    "c1_prime : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (prime_test n) true, prime_divisor n n"
                ],
                "tactic_res": [
                    "c6_goal : prime n",
                    "c6_e : eq (prime_test n) true",
                    "c7_goal : divides n n",
                    "c7_e : eq (prime_test n) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : prime n",
                    "c6_e : eq (prime_test n) true",
                    "c2_n : nat",
                    "c1_prime_test_t : forall (n : nat) (_ : eq (prime_test n) true), prime n",
                    "c1_prime : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : divides n n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_partial'",
        "proof": [
            {
                "tactic_sig": "Definition pred_partial' : forall n : nat , n <> 0 -> nat .",
                "tactic_sig_no_out_arg": "Definition pred_partial' : forall n : nat , n <> 0 -> nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), nat"
                ]
            },
            {
                "tactic_sig": "refine ( fun n => match n as x return x <> 0 -> nat with | O => fun h : 0 <> 0 => _ | S p => fun h : S p <> 0 => p end ) .",
                "tactic_sig_no_out_arg": "refine ( fun n => match n as x return x <> 0 -> nat with | O => fun h : 0 <> 0 => _ | S p => fun h : S p <> 0 => p end ) .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : not (eq n 0)), nat"
                ],
                "tactic_res": [
                    "c2_goal : nat",
                    "c2_h : not (eq 0 0)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : nat",
                    "c2_h : not (eq 0 0)"
                ],
                "tactic_res": [
                    "c3_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c3_goal : eq 0 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_partial_2'",
        "proof": [
            {
                "tactic_sig": "Definition pred_partial_2' : forall n : nat , le 2 n -> nat .",
                "tactic_sig_no_out_arg": "Definition pred_partial_2' : forall n : nat , le 2 n -> nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), nat"
                ]
            },
            {
                "tactic_sig": "refine ( fun n h=> ( fun h' : n <> 0 => pred_partial ( pred_partial n h' ) _ ) _ ) .",
                "tactic_sig_no_out_arg": "refine ( fun n h=> ( fun h' : n <> 0 => pred_partial ( pred_partial n h' ) _ ) _ ) .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), nat"
                ],
                "tactic_res": [
                    "c2_goal : not (eq (pred_partial n h') 0)",
                    "c2_h' : not (eq n 0)",
                    "c2_h : le 2 n",
                    "c2_n : nat",
                    "c3_goal : not (eq n 0)",
                    "c3_h : le 2 n",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : not (eq (pred_partial n h') 0)",
                    "_global_le_2_n_pred' : forall (n : nat) (_ : le 2 n) (h : not (eq n 0)),\n       not (eq (pred_partial n h) 0)"
                ],
                "tactic_res": [
                    "c4_goal : le 2 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : le 2 n",
                    "c2_h : le 2 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : not (eq n 0)",
                    "_global_le_2_n_not_zero : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ],
                "tactic_res": [
                    "c5_goal : le 2 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : le 2 n",
                    "c3_h : le 2 n",
                    "c3_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pred_strong2''",
        "proof": [
            {
                "tactic_sig": "Definition pred_strong2'' : forall n : nat , 2 <= n -> { v : nat | n = S ( S v ) } .",
                "tactic_sig_no_out_arg": "Definition pred_strong2'' : forall n : nat , 2 <= n -> { v : nat | n = S ( S v ) } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), sig (fun v : nat => eq n (S (S v)))"
                ]
            },
            {
                "tactic_sig": "refine ( fun n h => match pred_strong n _ with | exist _ p h' => match pred_strong p _ with exist _ p' h'' => exist _ p' _ end end ) .",
                "tactic_sig_no_out_arg": "refine ( fun n h => match pred_strong n _ with | exist _ p h' => match pred_strong p _ with exist _ p' h'' => exist _ p' _ end end ) .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le 2 n), sig (fun v : nat => eq n (S (S v)))"
                ],
                "tactic_res": [
                    "c2_goal : not (eq n 0)",
                    "c2_h : le 2 n",
                    "c2_n : nat",
                    "c3_goal : not (eq p 0)",
                    "c3_h' : eq n (S p)",
                    "c3_p : nat",
                    "c3_h : le 2 n",
                    "c3_n : nat",
                    "c4_goal : eq n (S (S p'))",
                    "c4_h'' : eq p (S p')",
                    "c4_p' : nat",
                    "c4_h' : eq n (S p)",
                    "c4_p : nat",
                    "c4_h : le 2 n",
                    "c4_n : nat"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : not (eq n 0)",
                    "_global_le_2_n_not_zero : forall (n : nat) (_ : le 2 n), not (eq n 0)"
                ],
                "tactic_res": [
                    "c5_goal : le 2 n"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c5_goal : le 2 n",
                    "c2_h : le 2 n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c3_goal : not (eq p 0)",
                    "_global_pred_strong2_th1 : forall (n p : nat) (_ : le 2 n) (_ : eq n (S p)), not (eq p 0)"
                ],
                "tactic_res": [
                    "c6_goal : le 2 ?n",
                    "c7_goal : eq n (S p)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : le 2 ?n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq n (S p)",
                    "c3_h' : eq n (S p)",
                    "c3_p : nat",
                    "c3_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : eq n (S (S p'))",
                    "c4_h'' : eq p (S p')"
                ],
                "tactic_res": [
                    "c8_goal : eq n (S p)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c8_goal : eq n (S p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div2_rect",
        "proof": [
            {
                "tactic_sig": "Theorem div2_rect ( P : nat -> Type ) : P 0 -> P 1 -> ( forall n , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n : nat , P n .",
                "tactic_sig_no_out_arg": "Theorem div2_rect ( P : nat -> Type ) : P 0 -> P 1 -> ( forall n , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n : nat , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n",
                    "c1_P : forall _ : nat, Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros H0 H1 H n .",
                "tactic_args": [
                    "c1_goal : forall (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n"
                ],
                "tactic_res": [
                    "c2_goal : P n",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_H : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "assert ( X : ( _i _i * _i ( S _i ) ) % type ) .",
                "tactic_sig_no_out_arg": "assert ( X : ( _i _i * _i ( S _i ) ) % type ) .",
                "tactic_args": [
                    "c2_goal : P n",
                    "c1_P : forall _ : nat, Type",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Type",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : prod (P n) (P (S n))",
                    "c4_goal : P n",
                    "c4_X : prod (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c3_goal : prod (P n) (P (S n))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : prod (P 0) (P 1)",
                    "c6_goal : prod (P (S n)) (P (S (S n)))",
                    "c6_IHn : prod (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c5_goal : prod (P 0) (P 1)",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c1_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c6_goal : prod (P (S n)) (P (S (S n)))",
                    "c6_IHn : prod (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_H : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c1_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now destruct _i .",
                "tactic_sig_no_out_arg": "now destruct _i .",
                "tactic_args": [
                    "c4_goal : P n",
                    "c4_X : prod (P n) (P (S n))",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div2_le",
        "proof": [
            {
                "tactic_sig": "Theorem div2_le : forall n : nat , div2 n <= n .",
                "tactic_sig_no_out_arg": "Theorem div2_le : forall n : nat , div2 n <= n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, le (div2 n) n"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, le (div2 n) n"
                ],
                "tactic_res": [
                    "c2_goal : le (div2 n) n",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i using div2_rect .",
                "tactic_sig_no_out_arg": "induction _i using div2_rect .",
                "tactic_args": [
                    "c2_goal : le (div2 n) n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : le (div2 0) 0",
                    "c4_goal : le (div2 1) 1",
                    "c5_goal : le (div2 (S (S n))) (S (S n))",
                    "c5_IHn0 : le (div2 (S n)) (S n)",
                    "c5_IHn : le (div2 n) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : le (div2 0) 0"
                ],
                "tactic_res": [
                    "c6_goal : le 0 0"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c6_goal : le 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : le (div2 1) 1"
                ],
                "tactic_res": [
                    "c7_goal : le 0 1"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c7_goal : le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : le (div2 (S (S n))) (S (S n))"
                ],
                "tactic_res": [
                    "c8_goal : le (S (div2 n)) (S (S n))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c8_goal : le (S (div2 n)) (S (S n))",
                    "c5_IHn : le (div2 n) n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "double_div2_le",
        "proof": [
            {
                "tactic_sig": "Lemma double_div2_le : forall x : nat , div2 x + div2 x <= x .",
                "tactic_sig_no_out_arg": "Lemma double_div2_le : forall x : nat , div2 x + div2 x <= x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : nat, le (Init.Nat.add (div2 x) (div2 x)) x"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall x : nat, le (Init.Nat.add (div2 x) (div2 x)) x"
                ],
                "tactic_res": [
                    "c2_goal : le (Init.Nat.add (div2 n) (div2 n)) n",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i using div2_rect .",
                "tactic_sig_no_out_arg": "induction _i using div2_rect .",
                "tactic_args": [
                    "c2_goal : le (Init.Nat.add (div2 n) (div2 n)) n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : le (Init.Nat.add (div2 0) (div2 0)) 0",
                    "c4_goal : le (Init.Nat.add (div2 1) (div2 1)) 1",
                    "c5_goal : le (Init.Nat.add (div2 (S (S n))) (div2 (S (S n)))) (S (S n))",
                    "c5_IHn0 : le (Init.Nat.add (div2 (S n)) (div2 (S n))) (S n)",
                    "c5_IHn : le (Init.Nat.add (div2 n) (div2 n)) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : le (Init.Nat.add (div2 0) (div2 0)) 0"
                ],
                "tactic_res": [
                    "c6_goal : le 0 0"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c6_goal : le 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : le (Init.Nat.add (div2 1) (div2 1)) 1"
                ],
                "tactic_res": [
                    "c7_goal : le 0 1"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c7_goal : le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : le (Init.Nat.add (div2 (S (S n))) (div2 (S (S n)))) (S (S n))"
                ],
                "tactic_res": [
                    "c8_goal : le (S (Init.Nat.add (div2 n) (S (div2 n)))) (S (S n))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c8_goal : le (S (Init.Nat.add (div2 n) (S (div2 n)))) (S (S n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus'_O_n",
        "proof": [
            {
                "tactic_sig": "Theorem plus'_O_n : forall n : nat , n = ( plus' O n ) .",
                "tactic_sig_no_out_arg": "Theorem plus'_O_n : forall n : nat , n = ( plus' O n ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq n (plus' 0 n)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq n (plus' 0 n)"
                ],
                "tactic_res": [
                    "c2_goal : eq n (plus' 0 n)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq n (plus' 0 n)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq 0 (plus' 0 0)",
                    "c4_goal : forall (n : nat) (_ : eq n (plus' 0 n)), eq (S n) (plus' 0 (S n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq 0 (plus' 0 0)"
                ],
                "tactic_res": [
                    "c5_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : eq n (plus' 0 n)), eq (S n) (plus' 0 (S n))"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (_ : eq n (plus' 0 n)), eq (S n) (S (plus' 0 n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (_ : eq n (plus' 0 n)), eq (S n) (S (plus' 0 n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus'_Sn_m",
        "proof": [
            {
                "tactic_sig": "Theorem plus'_Sn_m : forall n m : nat , S ( plus' n m ) = plus' ( S n ) m .",
                "tactic_sig_no_out_arg": "Theorem plus'_Sn_m : forall n m : nat , S ( plus' n m ) = plus' ( S n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : nat, eq (S (plus' n m)) (plus' (S n) m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : nat, eq (S (plus' n m)) (plus' (S n) m)"
                ],
                "tactic_res": [
                    "c2_goal : eq (S (plus' n m)) (plus' (S n) m)",
                    "c2_n : nat",
                    "c2_m : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (S (plus' n m)) (plus' (S n) m)",
                    "c2_m : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (S (plus' n 0)) (plus' (S n) 0)",
                    "c4_goal : forall (n0 : nat) (_ : eq (S (plus' n n0)) (plus' (S n) n0)),\neq (S (plus' n (S n0))) (plus' (S n) (S n0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (S (plus' n 0)) (plus' (S n) 0)"
                ],
                "tactic_res": [
                    "c5_goal : eq (S n) (S n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (S n) (S n)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n0 : nat) (_ : eq (S (plus' n n0)) (plus' (S n) n0)),\neq (S (plus' n (S n0))) (plus' (S n) (S n0))"
                ],
                "tactic_res": [
                    "c6_goal : forall (n0 : nat) (_ : eq (S (plus' n n0)) (plus' (S n) n0)),\neq (S (S (plus' n n0))) (S (plus' (S n) n0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n0 : nat) (_ : eq (S (plus' n n0)) (plus' (S n) n0)),\neq (S (S (plus' n n0))) (S (plus' (S n) n0))",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus'_comm",
        "proof": [
            {
                "tactic_sig": "Theorem plus'_comm : forall n m : nat , plus' n m = plus' m n .",
                "tactic_sig_no_out_arg": "Theorem plus'_comm : forall n m : nat , plus' n m = plus' m n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : nat, eq (plus' n m) (plus' m n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : nat, eq (plus' n m) (plus' m n)"
                ],
                "tactic_res": [
                    "c2_goal : eq (plus' n m) (plus' m n)",
                    "c2_n : nat",
                    "c2_m : nat"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq (plus' n m) (plus' m n)",
                    "c2_m : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (plus' n 0) (plus' 0 n)",
                    "c4_goal : forall (n0 : nat) (_ : eq (plus' n n0) (plus' n0 n)),\neq (plus' n (S n0)) (plus' (S n0) n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (plus' n 0) (plus' 0 n)"
                ],
                "tactic_res": [
                    "c5_goal : eq n (plus' 0 n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (n0 : nat) (_ : eq (plus' n n0) (plus' n0 n)),\neq (plus' n (S n0)) (plus' (S n0) n)"
                ],
                "tactic_res": [
                    "c6_goal : forall (n0 : nat) (_ : eq (plus' n n0) (plus' n0 n)),\neq (S (plus' n n0)) (plus' (S n0) n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq n (plus' 0 n)",
                    "_global_plus'_O_n : forall n : nat, eq n (plus' 0 n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p Hrec .",
                "tactic_args": [
                    "c6_goal : forall (n0 : nat) (_ : eq (plus' n n0) (plus' n0 n)),\neq (S (plus' n n0)) (plus' (S n0) n)"
                ],
                "tactic_res": [
                    "c7_goal : eq (S (plus' n p)) (plus' (S p) n)",
                    "c7_p : nat",
                    "c7_Hrec : eq (plus' n p) (plus' p n)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (S (plus' n p)) (plus' (S p) n)",
                    "_global_plus'_Sn_m : forall n m : nat, eq (S (plus' n m)) (plus' (S n) m)"
                ],
                "tactic_res": [
                    "c8_goal : eq (S (plus' n p)) (S (plus' p n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (S (plus' n p)) (S (plus' p n))",
                    "c7_Hrec : eq (plus' n p) (plus' p n)",
                    "c2_n : nat",
                    "c7_p : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus_plus'",
        "proof": [
            {
                "tactic_sig": "Theorem plus_plus' : forall n m : nat , n + m = plus' n m .",
                "tactic_sig_no_out_arg": "Theorem plus_plus' : forall n m : nat , n + m = plus' n m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : nat, eq (Init.Nat.add n m) (plus' n m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : nat, eq (Init.Nat.add n m) (plus' n m)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Init.Nat.add n m) (plus' n m)",
                    "c2_n : nat",
                    "c2_m : nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Init.Nat.add n m) (plus' n m)",
                    "_global_plus'_comm : forall n m : nat, eq (plus' n m) (plus' m n)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Init.Nat.add n m) (plus' m n)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : eq (Init.Nat.add n m) (plus' m n)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c4_goal : eq (Init.Nat.add 0 m) (plus' m 0)",
                    "c5_goal : forall (n : nat) (_ : eq (Init.Nat.add n m) (plus' m n)),\neq (Init.Nat.add (S n) m) (plus' m (S n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (Init.Nat.add 0 m) (plus' m 0)"
                ],
                "tactic_res": [
                    "c6_goal : eq m m"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq m m",
                    "c2_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (n : nat) (_ : eq (Init.Nat.add n m) (plus' m n)),\neq (Init.Nat.add (S n) m) (plus' m (S n))"
                ],
                "tactic_res": [
                    "c7_goal : forall (n : nat) (_ : eq (Init.Nat.add n m) (plus' m n)),\neq (S (Init.Nat.add n m)) (S (plus' m n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (n : nat) (_ : eq (Init.Nat.add n m) (plus' m n)),\neq (S (Init.Nat.add n m)) (S (plus' m n))",
                    "c2_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus''_Sn_m",
        "proof": [
            {
                "tactic_sig": "Theorem plus''_Sn_m : forall n m : nat , S ( plus'' n m ) = plus'' ( S n ) m .",
                "tactic_sig_no_out_arg": "Theorem plus''_Sn_m : forall n m : nat , S ( plus'' n m ) = plus'' ( S n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : nat, eq (S (plus'' n m)) (plus'' (S n) m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : nat, eq (S (plus'' n m)) (plus'' (S n) m)"
                ],
                "tactic_res": [
                    "c2_goal : eq (S (plus'' n m)) (plus'' (S n) m)",
                    "c2_n : nat",
                    "c2_m : nat"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c2_goal : eq (S (plus'' n m)) (plus'' (S n) m)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall n : nat, eq (S (plus'' n m)) (plus'' (S n) m)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall n : nat, eq (S (plus'' n m)) (plus'' (S n) m)",
                    "c2_m : nat"
                ],
                "tactic_res": [
                    "c4_goal : forall n : nat, eq (S (plus'' n 0)) (plus'' (S n) 0)",
                    "c5_goal : forall (n : nat)\n  (_ : forall n0 : nat, eq (S (plus'' n0 n)) (plus'' (S n0) n))\n  (n0 : nat), eq (S (plus'' n0 (S n))) (plus'' (S n0) (S n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall n : nat, eq (S (plus'' n 0)) (plus'' (S n) 0)"
                ],
                "tactic_res": [
                    "c6_goal : forall n : nat, eq (S n) (S n)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (n : nat)\n  (_ : forall n0 : nat, eq (S (plus'' n0 n)) (plus'' (S n0) n))\n  (n0 : nat), eq (S (plus'' n0 (S n))) (plus'' (S n0) (S n))"
                ],
                "tactic_res": [
                    "c7_goal : forall (n : nat)\n  (_ : forall n0 : nat, eq (S (plus'' n0 n)) (plus'' (S n0) n))\n  (n0 : nat), eq (S (plus'' (S n0) n)) (plus'' (S (S n0)) n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall n : nat, eq (S n) (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now intros p Hrec n0 .",
                "tactic_sig_no_out_arg": "now intros p Hrec n0 .",
                "tactic_args": [
                    "c7_goal : forall (n : nat)\n  (_ : forall n0 : nat, eq (S (plus'' n0 n)) (plus'' (S n0) n))\n  (n0 : nat), eq (S (plus'' (S n0) n)) (plus'' (S (S n0)) n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_1_1_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_1_1_interval : 0 <= 0 < 1 .",
                "tactic_sig_no_out_arg": "Theorem rem_1_1_interval : 0 <= 0 < 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : and (Z.le 0 0) (Z.lt 0 1)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c1_goal : and (Z.le 0 0) (Z.lt 0 1)"
                ],
                "tactic_res": [
                    "c2_goal : Z.le 0 0",
                    "c3_goal : Z.lt 0 1"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : Z.le 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c3_goal : Z.lt 0 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_1_even_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_1_even_interval : forall m : positive , 0 <= 1 < Zpos ( xO m ) .",
                "tactic_sig_no_out_arg": "Theorem rem_1_even_interval : forall m : positive , 0 <= 1 < Zpos ( xO m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall m : positive, and (Z.le 0 1) (Z.lt 1 (Zpos (xO m)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n' .",
                "tactic_args": [
                    "c1_goal : forall m : positive, and (Z.le 0 1) (Z.lt 1 (Zpos (xO m)))"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xO n')))",
                    "c2_n' : positive"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xO n')))"
                ],
                "tactic_res": [
                    "c3_goal : Z.le 0 1",
                    "c4_goal : Z.lt 1 (Zpos (xO n'))"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : Z.le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : Z.lt 1 (Zpos (xO n'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_1_odd_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_1_odd_interval : forall m : positive , 0 <= 1 < Zpos ( xI m ) .",
                "tactic_sig_no_out_arg": "Theorem rem_1_odd_interval : forall m : positive , 0 <= 1 < Zpos ( xI m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall m : positive, and (Z.le 0 1) (Z.lt 1 (Zpos (xI m)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c1_goal : forall m : positive, and (Z.le 0 1) (Z.lt 1 (Zpos (xI m)))"
                ],
                "tactic_res": [
                    "c2_goal : Z.le 0 1",
                    "c2_m : positive",
                    "c3_goal : Z.lt 1 (Zpos (xI m))",
                    "c3_m : positive"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c2_goal : Z.le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "compute .",
                "tactic_sig_no_out_arg": "compute .",
                "tactic_args": [
                    "c3_goal : Z.lt 1 (Zpos (xI m))"
                ],
                "tactic_res": [
                    "c4_goal : eq Lt Lt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq Lt Lt"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_even_ge_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_even_ge_interval : forall m r : Z , 0 <= r < m -> 2 * r >= m -> 0 <= 2 * r - m < m .",
                "tactic_sig_no_out_arg": "Theorem rem_even_ge_interval : forall m r : Z , 0 <= r < m -> 2 * r >= m -> 0 <= 2 * r - m < m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.ge (Z.mul 2 r) m),\nand (Z.le 0 (Z.sub (Z.mul 2 r) m)) (Z.lt (Z.sub (Z.mul 2 r) m) m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.ge (Z.mul 2 r) m),\nand (Z.le 0 (Z.sub (Z.mul 2 r) m)) (Z.lt (Z.sub (Z.mul 2 r) m) m)"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (Z.sub (Z.mul 2 r) m)) (Z.lt (Z.sub (Z.mul 2 r) m) m)",
                    "c2_m : Z",
                    "c2_r : Z",
                    "c2_H : and (Z.le 0 r) (Z.lt r m)",
                    "c2_H0 : Z.ge (Z.mul 2 r) m"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (Z.sub (Z.mul 2 r) m)) (Z.lt (Z.sub (Z.mul 2 r) m) m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_even_lt_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_even_lt_interval : forall m r : Z , 0 <= r < m -> 2 * r < m -> 0 <= 2 * r < m .",
                "tactic_sig_no_out_arg": "Theorem rem_even_lt_interval : forall m r : Z , 0 <= r < m -> 2 * r < m -> 0 <= 2 * r < m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.lt (Z.mul 2 r) m),\nand (Z.le 0 (Z.mul 2 r)) (Z.lt (Z.mul 2 r) m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.lt (Z.mul 2 r) m),\nand (Z.le 0 (Z.mul 2 r)) (Z.lt (Z.mul 2 r) m)"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (Z.mul 2 r)) (Z.lt (Z.mul 2 r) m)",
                    "c2_m : Z",
                    "c2_r : Z",
                    "c2_H : and (Z.le 0 r) (Z.lt r m)",
                    "c2_H0 : Z.lt (Z.mul 2 r) m"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (Z.mul 2 r)) (Z.lt (Z.mul 2 r) m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_odd_ge_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_odd_ge_interval : forall m r : Z , 0 <= r < m -> 2 * r + 1 >= m -> 2 * r + 1 - m < m .",
                "tactic_sig_no_out_arg": "Theorem rem_odd_ge_interval : forall m r : Z , 0 <= r < m -> 2 * r + 1 >= m -> 2 * r + 1 - m < m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.ge (Z.add (Z.mul 2 r) 1) m),\nZ.lt (Z.sub (Z.add (Z.mul 2 r) 1) m) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.ge (Z.add (Z.mul 2 r) 1) m),\nZ.lt (Z.sub (Z.add (Z.mul 2 r) 1) m) m"
                ],
                "tactic_res": [
                    "c2_goal : Z.lt (Z.sub (Z.add (Z.mul 2 r) 1) m) m",
                    "c2_m : Z",
                    "c2_r : Z",
                    "c2_H : and (Z.le 0 r) (Z.lt r m)",
                    "c2_H0 : Z.ge (Z.add (Z.mul 2 r) 1) m"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : Z.lt (Z.sub (Z.add (Z.mul 2 r) 1) m) m"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rem_odd_lt_interval",
        "proof": [
            {
                "tactic_sig": "Theorem rem_odd_lt_interval : forall m r : Z , 0 <= r < m -> 2 * r + 1 < m -> 0 <= 2 * r + 1 < m .",
                "tactic_sig_no_out_arg": "Theorem rem_odd_lt_interval : forall m r : Z , 0 <= r < m -> 2 * r + 1 < m -> 0 <= 2 * r + 1 < m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.lt (Z.add (Z.mul 2 r) 1) m),\nand (Z.le 0 (Z.add (Z.mul 2 r) 1)) (Z.lt (Z.add (Z.mul 2 r) 1) m)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (m r : Z) (_ : and (Z.le 0 r) (Z.lt r m))\n  (_ : Z.lt (Z.add (Z.mul 2 r) 1) m),\nand (Z.le 0 (Z.add (Z.mul 2 r) 1)) (Z.lt (Z.add (Z.mul 2 r) 1) m)"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (Z.add (Z.mul 2 r) 1)) (Z.lt (Z.add (Z.mul 2 r) 1) m)",
                    "c2_m : Z",
                    "c2_r : Z",
                    "c2_H : and (Z.le 0 r) (Z.lt r m)",
                    "c2_H0 : Z.lt (Z.add (Z.mul 2 r) 1) m"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (Z.add (Z.mul 2 r) 1)) (Z.lt (Z.add (Z.mul 2 r) 1) m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_bin_rem_lt",
        "proof": [
            {
                "tactic_sig": "Theorem div_bin_rem_lt : forall n m : positive , 0 <= snd ( div_bin n m ) < Zpos m .",
                "tactic_sig_no_out_arg": "Theorem div_bin_rem_lt : forall n m : positive , 0 <= snd ( div_bin n m ) < Zpos m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : positive,\nand (Z.le 0 (snd (div_bin n m))) (Z.lt (snd (div_bin n m)) (Zpos m))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : positive,\nand (Z.le 0 (snd (div_bin n m))) (Z.lt (snd (div_bin n m)) (Zpos m))"
                ],
                "tactic_res": [
                    "c2_goal : and (Z.le 0 (snd (div_bin n m))) (Z.lt (snd (div_bin n m)) (Zpos m))",
                    "c2_n : positive",
                    "c2_m : positive"
                ]
            },
            {
                "tactic_sig": "div_bin_tac _i _i .",
                "tactic_sig_no_out_arg": "div_bin_tac _i _i .",
                "tactic_args": [
                    "c2_goal : and (Z.le 0 (snd (div_bin n m))) (Z.lt (snd (div_bin n m)) (Zpos m))",
                    "c2_n : positive",
                    "c2_m : positive"
                ],
                "tactic_res": [
                    "c3_goal : and (Z.le 0 (Z.add (Z.mul 2 r') 1))\n  (Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m))",
                    "c3_H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m)",
                    "c3_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c3_r' : Z",
                    "c3_q' : Z",
                    "c3_p : positive",
                    "c4_goal : and (Z.le 0 (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))\n  (Z.lt (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)) (Zpos m))",
                    "c4_H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m)",
                    "c4_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c4_r' : Z",
                    "c4_q' : Z",
                    "c4_p : positive",
                    "c5_goal : and (Z.le 0 (Z.mul 2 r')) (Z.lt (Z.mul 2 r') (Zpos m))",
                    "c5_H : Z.lt (Z.mul 2 r') (Zpos m)",
                    "c5_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c5_r' : Z",
                    "c5_q' : Z",
                    "c5_p : positive",
                    "c6_goal : and (Z.le 0 (Z.sub (Z.mul 2 r') (Zpos m)))\n  (Z.lt (Z.sub (Z.mul 2 r') (Zpos m)) (Zpos m))",
                    "c6_H : Z.ge (Z.mul 2 r') (Zpos m)",
                    "c6_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c6_r' : Z",
                    "c6_q' : Z",
                    "c6_p : positive",
                    "c7_goal : and (Z.le 0 (snd (pair 0 1))) (Z.lt (snd (pair 0 1)) (Zpos (xI p)))",
                    "c7_p : positive",
                    "c8_goal : and (Z.le 0 (snd (pair 0 1))) (Z.lt (snd (pair 0 1)) (Zpos (xO p)))",
                    "c8_p : positive",
                    "c9_goal : and (Z.le 0 (snd (pair 1 0))) (Z.lt (snd (pair 1 0)) 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : and (Z.le 0 (Z.add (Z.mul 2 r') 1))\n  (Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m))",
                    "c3_H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m)",
                    "c3_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c3_r' : Z",
                    "c2_m : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : and (Z.le 0 (Z.mul 2 r')) (Z.lt (Z.mul 2 r') (Zpos m))",
                    "c5_H : Z.lt (Z.mul 2 r') (Zpos m)",
                    "c5_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c5_r' : Z",
                    "c2_m : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : and (Z.le 0 (Z.sub (Z.mul 2 r') (Zpos m)))\n  (Z.lt (Z.sub (Z.mul 2 r') (Zpos m)) (Zpos m))",
                    "c6_H : Z.ge (Z.mul 2 r') (Zpos m)",
                    "c6_Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))",
                    "c6_r' : Z",
                    "c2_m : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c7_goal : and (Z.le 0 (snd (pair 0 1))) (Z.lt (snd (pair 0 1)) (Zpos (xI p)))",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c10_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xI p)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xI p)))",
                    "c7_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c8_goal : and (Z.le 0 (snd (pair 0 1))) (Z.lt (snd (pair 0 1)) (Zpos (xO p)))",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c11_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xO p)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : and (Z.le 0 1) (Z.lt 1 (Zpos (xO p)))",
                    "c8_p : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 (snd (pair 1 0))) (Z.lt (snd (pair 1 0)) 1)",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : and (Z.le 0 r') (Z.lt r' (Zpos m))\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c12_goal : and (Z.le 0 0) (Z.lt 0 1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : and (Z.le 0 0) (Z.lt 0 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c4_goal : and (Z.le 0 (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))\n  (Z.lt (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)) (Zpos m))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_bin_eq",
        "proof": [
            {
                "tactic_sig": "Theorem div_bin_eq : forall n m : positive , Zpos n = ( fst ( div_bin n m ) ) * ( Zpos m ) + snd ( div_bin n m ) .",
                "tactic_sig_no_out_arg": "Theorem div_bin_eq : forall n m : positive , Zpos n = ( fst ( div_bin n m ) ) * ( Zpos m ) + snd ( div_bin n m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n m : positive,\neq (Zpos n)\n  (Z.add (Z.mul (fst (div_bin n m)) (Zpos m)) (snd (div_bin n m)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n m .",
                "tactic_args": [
                    "c1_goal : forall n m : positive,\neq (Zpos n)\n  (Z.add (Z.mul (fst (div_bin n m)) (Zpos m)) (snd (div_bin n m)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (Zpos n)\n  (Z.add (Z.mul (fst (div_bin n m)) (Zpos m)) (snd (div_bin n m)))",
                    "c2_n : positive",
                    "c2_m : positive"
                ]
            },
            {
                "tactic_sig": "div_bin_tac _i _i .",
                "tactic_sig_no_out_arg": "div_bin_tac _i _i .",
                "tactic_args": [
                    "c2_goal : eq (Zpos n)\n  (Z.add (Z.mul (fst (div_bin n m)) (Zpos m)) (snd (div_bin n m)))",
                    "c2_n : positive",
                    "c2_m : positive"
                ],
                "tactic_res": [
                    "c3_goal : eq (Zpos (xI p))\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))",
                    "c3_H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m)",
                    "c3_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')",
                    "c3_r' : Z",
                    "c3_q' : Z",
                    "c3_p : positive",
                    "c4_goal : eq (Zpos (xI p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))",
                    "c4_H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m)",
                    "c4_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')",
                    "c4_r' : Z",
                    "c4_q' : Z",
                    "c4_p : positive",
                    "c5_goal : eq (Zpos (xO p))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))",
                    "c5_H : Z.lt (Z.mul 2 r') (Zpos m)",
                    "c5_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')",
                    "c5_r' : Z",
                    "c5_q' : Z",
                    "c5_p : positive",
                    "c6_goal : eq (Zpos (xO p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))",
                    "c6_H : Z.ge (Z.mul 2 r') (Zpos m)",
                    "c6_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')",
                    "c6_r' : Z",
                    "c6_q' : Z",
                    "c6_p : positive",
                    "c7_goal : eq 1 (Z.add (Z.mul (fst (pair 0 1)) (Zpos (xI p))) (snd (pair 0 1)))",
                    "c7_p : positive",
                    "c8_goal : eq 1 (Z.add (Z.mul (fst (pair 0 1)) (Zpos (xO p))) (snd (pair 0 1)))",
                    "c8_p : positive",
                    "c9_goal : eq 1 (Z.add (Z.mul (fst (pair 1 0)) 1) (snd (pair 1 0)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c3_goal : eq (Zpos (xI p))\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c10_goal : eq (Z.add (Z.mul 2 (Zpos p)) 1)\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))"
                ]
            },
            {
                "tactic_sig": "try rewrite _i .",
                "tactic_sig_no_out_arg": "try rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (Z.add (Z.mul 2 (Zpos p)) 1)\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))",
                    "c3_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')"
                ],
                "tactic_res": [
                    "c11_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')) 1)\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c11_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')) 1)\n  (Z.add\n     (Z.mul (fst (pair (Z.mul 2 q') (Z.add (Z.mul 2 r') 1))) (Zpos m))\n     (Z.add (Z.mul 2 r') 1))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c12_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r')) 1)\n  (Z.add (Z.mul (Z.mul 2 q') (Zpos m)) (Z.add (Z.mul 2 r') 1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c12_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r')) 1)\n  (Z.add (Z.mul (Z.mul 2 q') (Zpos m)) (Z.add (Z.mul 2 r') 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c4_goal : eq (Zpos (xI p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c13_goal : eq (Z.add (Z.mul 2 (Zpos p)) 1)\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "try rewrite _i .",
                "tactic_sig_no_out_arg": "try rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq (Z.add (Z.mul 2 (Zpos p)) 1)\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))",
                    "c4_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')"
                ],
                "tactic_res": [
                    "c14_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')) 1)\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c14_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')) 1)\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1)\n              (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))) \n        (Zpos m)) (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c15_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r')) 1)\n  (Z.add (Z.mul (Z.add (Z.mul 2 q') 1) (Zpos m))\n     (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.add (Z.mul 2 r') 1) (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c15_goal : eq (Z.add (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r')) 1)\n  (Z.add (Z.mul (Z.add (Z.mul 2 q') 1) (Zpos m))\n     (Z.sub (Z.add (Z.mul 2 r') 1) (Zpos m)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c5_goal : eq (Zpos (xO p))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c16_goal : eq (Z.mul 2 (Zpos p))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))"
                ]
            },
            {
                "tactic_sig": "try rewrite _i .",
                "tactic_sig_no_out_arg": "try rewrite _i .",
                "tactic_args": [
                    "c16_goal : eq (Z.mul 2 (Zpos p))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))",
                    "c5_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')"
                ],
                "tactic_res": [
                    "c17_goal : eq (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r'))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c17_goal : eq (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r'))\n  (Z.add (Z.mul (fst (pair (Z.mul 2 q') (Z.mul 2 r'))) (Zpos m))\n     (Z.mul 2 r'))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.mul 2 r') (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.mul 2 r') (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c18_goal : eq (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r'))\n  (Z.add (Z.mul (Z.mul 2 q') (Zpos m)) (Z.mul 2 r'))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.mul 2 r') (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.lt (Z.mul 2 r') (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c18_goal : eq (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r'))\n  (Z.add (Z.mul (Z.mul 2 q') (Zpos m)) (Z.mul 2 r'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c6_goal : eq (Zpos (xO p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c19_goal : eq (Z.mul 2 (Zpos p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "try rewrite _i .",
                "tactic_sig_no_out_arg": "try rewrite _i .",
                "tactic_args": [
                    "c19_goal : eq (Z.mul 2 (Zpos p))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))",
                    "c6_Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')"
                ],
                "tactic_res": [
                    "c20_goal : eq (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r'))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c20_goal : eq (Z.mul 2 (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r'))\n  (Z.add\n     (Z.mul\n        (fst\n           (pair (Z.add (Z.mul 2 q') 1) (Z.sub (Z.mul 2 r') (Zpos m))))\n        (Zpos m)) (Z.sub (Z.mul 2 r') (Zpos m)))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.mul 2 r') (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.mul 2 r') (Zpos m) |- Type]"
                ],
                "tactic_res": [
                    "c21_goal : eq (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r'))\n  (Z.add (Z.mul (Z.add (Z.mul 2 q') 1) (Zpos m))\n     (Z.sub (Z.mul 2 r') (Zpos m)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.mul 2 r') (Zpos m) |- Type]\n?B : [n : positive\n      m : positive\n      p : positive\n      q' : Z\n      r' : Z\n      Hrec : eq (Zpos p) (Z.add (Z.mul (fst (pair q' r')) (Zpos m)) r')\n      H : Z.ge (Z.mul 2 r') (Zpos m) |- Type]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c21_goal : eq (Z.mul 2 (Z.add (Z.mul q' (Zpos m)) r'))\n  (Z.add (Z.mul (Z.add (Z.mul 2 q') 1) (Zpos m))\n     (Z.sub (Z.mul 2 r') (Zpos m)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c7_goal : eq 1 (Z.add (Z.mul (fst (pair 0 1)) (Zpos (xI p))) (snd (pair 0 1)))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c22_goal : eq 1\n  (Z.add (Z.mul (fst (pair 0 1)) (Z.add (Z.mul 2 (Zpos p)) 1))\n     (snd (pair 0 1)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c22_goal : eq 1\n  (Z.add (Z.mul (fst (pair 0 1)) (Z.add (Z.mul 2 (Zpos p)) 1))\n     (snd (pair 0 1)))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive  m : positive  p : positive |- Type]\n?B : [n : positive  m : positive  p : positive |- Type]"
                ],
                "tactic_res": [
                    "c23_goal : eq 1 (Z.add (Z.mul 0 (Z.add (Z.mul 2 (Zpos p)) 1)) (snd (pair 0 1)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c23_goal : eq 1 (Z.add (Z.mul 0 (Z.add (Z.mul 2 (Zpos p)) 1)) (snd (pair 0 1)))",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive  m : positive  p : positive |- Type]\n?B : [n : positive  m : positive  p : positive |- Type]"
                ],
                "tactic_res": [
                    "c24_goal : eq 1 (Z.add (Z.mul 0 (Z.add (Z.mul 2 (Zpos p)) 1)) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c24_goal : eq 1 (Z.add (Z.mul 0 (Z.add (Z.mul 2 (Zpos p)) 1)) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "c8_goal : eq 1 (Z.add (Z.mul (fst (pair 0 1)) (Zpos (xO p))) (snd (pair 0 1)))",
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": [
                    "c25_goal : eq 1\n  (Z.add (Z.mul (fst (pair 0 1)) (Z.mul 2 (Zpos p))) (snd (pair 0 1)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c25_goal : eq 1\n  (Z.add (Z.mul (fst (pair 0 1)) (Z.mul 2 (Zpos p))) (snd (pair 0 1)))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive  m : positive  p : positive |- Type]\n?B : [n : positive  m : positive  p : positive |- Type]"
                ],
                "tactic_res": [
                    "c26_goal : eq 1 (Z.add (Z.mul 0 (Z.mul 2 (Zpos p))) (snd (pair 0 1)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c26_goal : eq 1 (Z.add (Z.mul 0 (Z.mul 2 (Zpos p))) (snd (pair 0 1)))",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive  m : positive  p : positive |- Type]\n?B : [n : positive  m : positive  p : positive |- Type]"
                ],
                "tactic_res": [
                    "c27_goal : eq 1 (Z.add (Z.mul 0 (Z.mul 2 (Zpos p))) 1)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c27_goal : eq 1 (Z.add (Z.mul 0 (Z.mul 2 (Zpos p))) 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i || ( try rewrite _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i || ( try rewrite _i ) .",
                "tactic_args": [
                    "_global_Zpos_xI : forall p : positive, eq (Zpos (xI p)) (Z.add (Z.mul 2 (Zpos p)) 1)",
                    "_global_Zpos_xO : forall p : positive, eq (Zpos (xO p)) (Z.mul 2 (Zpos p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : eq 1 (Z.add (Z.mul (fst (pair 1 0)) 1) (snd (pair 1 0)))",
                    "_global_fst : forall _ : prod ?A ?B, ?A\nwhere\n?A : [n : positive  m : positive |- Type]\n?B : [n : positive  m : positive |- Type]"
                ],
                "tactic_res": [
                    "c28_goal : eq 1 (Z.add (Z.mul 1 1) (snd (pair 1 0)))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c28_goal : eq 1 (Z.add (Z.mul 1 1) (snd (pair 1 0)))",
                    "_global_snd : forall _ : prod ?A ?B, ?B\nwhere\n?A : [n : positive  m : positive |- Type]\n?B : [n : positive  m : positive |- Type]"
                ],
                "tactic_res": [
                    "c29_goal : eq 1 (Z.add (Z.mul 1 1) 0)"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c29_goal : eq 1 (Z.add (Z.mul 1 1) 0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_eq",
        "proof": [
            {
                "tactic_sig": "Lemma cmp_eq : forall x : A , cmp x x = Eq .",
                "tactic_sig_no_out_arg": "Lemma cmp_eq : forall x : A , cmp x x = Eq .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : A, eq (cmp x x) Eq",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hirr _ ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hirr _ ] .",
                "tactic_args": [
                    "c1_lt_strict : StrictOrder lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c1_Hirr : Irreflexive lt"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro x .",
                "tactic_args": [
                    "c1_goal : forall x : A, eq (cmp x x) Eq"
                ],
                "tactic_res": [
                    "c2_goal : eq (cmp x x) Eq",
                    "c2_x : A"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (cmp x x) Eq",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_x : A",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c3_goal : eq Eq Eq",
                    "c3_H_eq : eq x x",
                    "c4_goal : eq Lt Eq",
                    "c4_H_lt : lt x x",
                    "c5_goal : eq Gt Eq",
                    "c5_H_gt : lt x x"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : eq Eq Eq"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c4_goal : eq Lt Eq",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c4_H_lt : lt x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c5_goal : eq Gt Eq",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c5_H_gt : lt x x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_eq_iff",
        "proof": [
            {
                "tactic_sig": "Lemma cmp_eq_iff : forall x y : A , cmp x y = Eq <- > x = y .",
                "tactic_sig_no_out_arg": "Lemma cmp_eq_iff : forall x y : A , cmp x y = Eq <- > x = y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Eq) (eq x y)",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Eq) (eq x y)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (cmp x y) Eq, eq x y",
                    "c2_y : A",
                    "c2_x : A",
                    "c3_goal : forall _ : eq x y, eq (cmp x y) Eq",
                    "c3_y : A",
                    "c3_x : A"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hirr _ ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hirr _ ] .",
                "tactic_args": [
                    "c1_lt_strict : StrictOrder lt",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c2_Hirr : Irreflexive lt"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (cmp x y) Eq, eq x y",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_y : A",
                    "c2_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq Eq Eq, eq x y",
                    "c4_H_eq : eq x y",
                    "c5_goal : forall _ : eq Lt Eq, eq x y",
                    "c5_H_lt : lt x y",
                    "c6_goal : forall _ : eq Gt Eq, eq x y",
                    "c6_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall _ : eq Eq Eq, eq x y",
                    "c4_H_eq : eq x y",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : forall _ : eq Lt Eq, eq x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : forall _ : eq Gt Eq, eq x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c3_goal : forall _ : eq x y, eq (cmp x y) Eq"
                ],
                "tactic_res": [
                    "c7_goal : eq (cmp x y) Eq",
                    "c7_H : eq x y"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c7_goal : eq (cmp x y) Eq",
                    "c3_y : A",
                    "c7_H : eq x y"
                ],
                "tactic_res": [
                    "c8_goal : eq (cmp x x) Eq"
                ]
            },
            {
                "tactic_sig": "now rewrite cmp_eq .",
                "tactic_sig_no_out_arg": "now rewrite cmp_eq .",
                "tactic_args": [
                    "c8_goal : eq (cmp x x) Eq"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_lt_iff",
        "proof": [
            {
                "tactic_sig": "Lemma cmp_lt_iff : forall x y : A , cmp x y = Lt <- > lt x y .",
                "tactic_sig_no_out_arg": "Lemma cmp_lt_iff : forall x y : A , cmp x y = Lt <- > lt x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Lt) (lt x y)",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hirr Htrans ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hirr Htrans ] .",
                "tactic_args": [
                    "c1_lt_strict : StrictOrder lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Lt) (lt x y)"
                ],
                "tactic_res": [
                    "c2_goal : iff (eq (cmp x y) Lt) (lt x y)",
                    "c2_x : A",
                    "c2_y : A"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : iff (eq (cmp x y) Lt) (lt x y)",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A"
                ],
                "tactic_res": [
                    "c3_goal : iff (eq Eq Lt) (lt x y)",
                    "c3_H_eq : eq x y",
                    "c4_goal : iff (eq Lt Lt) (lt x y)",
                    "c4_H_lt : lt x y",
                    "c5_goal : iff (eq Gt Lt) (lt x y)",
                    "c5_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : iff (eq Eq Lt) (lt x y)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq Eq Lt, lt x y",
                    "c7_goal : forall _ : lt x y, eq Eq Lt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : forall _ : eq Eq Lt, lt x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : iff (eq Lt Lt) (lt x y)"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq Lt Lt, lt x y",
                    "c9_goal : forall _ : lt x y, eq Lt Lt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : forall _ : eq Lt Lt, lt x y",
                    "c4_H_lt : lt x y",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall _ : lt x y, eq Lt Lt",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : iff (eq Gt Lt) (lt x y)"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq Gt Lt, lt x y",
                    "c11_goal : forall _ : lt x y, eq Gt Lt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c10_goal : forall _ : eq Gt Lt, lt x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c7_goal : forall _ : lt x y, eq Eq Lt"
                ],
                "tactic_res": [
                    "c12_goal : eq Eq Lt",
                    "c12_H : lt x y"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_y : A",
                    "c3_H_eq : eq x y"
                ],
                "tactic_res": [
                    "c12_H : lt x x"
                ]
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c12_goal : eq Eq Lt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c12_H : lt x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c11_goal : forall _ : lt x y, eq Gt Lt"
                ],
                "tactic_res": [
                    "c13_goal : eq Gt Lt",
                    "c13_H : lt x y"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c13_goal : eq Gt Lt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c13_H : lt x y",
                    "c5_H_gt : lt y x",
                    "c1_Htrans : Transitive lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c14_goal : lt x x"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c14_goal : lt x x",
                    "c1_Htrans : Transitive lt"
                ],
                "tactic_res": [
                    "c15_goal : lt x ?y",
                    "c16_goal : lt y x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : lt x ?y",
                    "c13_H : lt x y",
                    "c2_x : A",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : lt y x",
                    "c5_H_gt : lt y x",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_sym",
        "proof": [
            {
                "tactic_sig": "Lemma cmp_sym : forall x y , cmp x y = Gt <- > cmp y x = Lt .",
                "tactic_sig_no_out_arg": "Lemma cmp_sym : forall x y , cmp x y = Gt <- > cmp y x = Lt .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Gt) (eq (cmp y x) Lt)",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ Hirr Htrans ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hirr Htrans ] .",
                "tactic_args": [
                    "c1_lt_strict : StrictOrder lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : A, iff (eq (cmp x y) Gt) (eq (cmp y x) Lt)"
                ],
                "tactic_res": [
                    "c2_goal : iff (eq (cmp x y) Gt) (eq (cmp y x) Lt)",
                    "c2_x : A",
                    "c2_y : A"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : iff (eq (cmp x y) Gt) (eq (cmp y x) Lt)",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c3_goal : iff (eq Eq Gt) (eq (cmp y x) Lt)",
                    "c3_H_eq : eq x y",
                    "c4_goal : iff (eq Lt Gt) (eq (cmp y x) Lt)",
                    "c4_H_lt : lt x y",
                    "c5_goal : iff (eq Gt Gt) (eq (cmp y x) Lt)",
                    "c5_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : iff (eq Eq Gt) (eq (cmp y x) Lt)",
                    "c1_cmp_ok : correct cmp",
                    "c2_y : A",
                    "c2_x : A",
                    "c3_H_eq : eq x y",
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c6_goal : iff (eq Eq Gt) (eq Eq Lt)",
                    "c6_H_eq0 : eq y x",
                    "c7_goal : iff (eq Eq Gt) (eq Lt Lt)",
                    "c7_H_lt : lt y x",
                    "c8_goal : iff (eq Eq Gt) (eq Gt Lt)",
                    "c8_H_gt : lt x y"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c6_goal : iff (eq Eq Gt) (eq Eq Lt)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq Eq Gt, eq Eq Lt",
                    "c10_goal : forall _ : eq Eq Lt, eq Eq Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c9_goal : forall _ : eq Eq Gt, eq Eq Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c10_goal : forall _ : eq Eq Lt, eq Eq Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : iff (eq Eq Gt) (eq Lt Lt)"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : eq Eq Gt, eq Lt Lt",
                    "c12_goal : forall _ : eq Lt Lt, eq Eq Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c11_goal : forall _ : eq Eq Gt, eq Lt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : iff (eq Eq Gt) (eq Gt Lt)"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : eq Eq Gt, eq Gt Lt",
                    "c14_goal : forall _ : eq Gt Lt, eq Eq Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c13_goal : forall _ : eq Eq Gt, eq Gt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c14_goal : forall _ : eq Gt Lt, eq Eq Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c4_goal : iff (eq Lt Gt) (eq (cmp y x) Lt)",
                    "c1_cmp_ok : correct cmp",
                    "c2_y : A",
                    "c2_x : A",
                    "c4_H_lt : lt x y",
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c15_goal : iff (eq Lt Gt) (eq Eq Lt)",
                    "c15_H_eq : eq y x",
                    "c16_goal : iff (eq Lt Gt) (eq Lt Lt)",
                    "c16_H_lt0 : lt y x",
                    "c17_goal : iff (eq Lt Gt) (eq Gt Lt)",
                    "c17_H_gt : lt x y"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c15_goal : iff (eq Lt Gt) (eq Eq Lt)"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : eq Lt Gt, eq Eq Lt",
                    "c19_goal : forall _ : eq Eq Lt, eq Lt Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c18_goal : forall _ : eq Lt Gt, eq Eq Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c19_goal : forall _ : eq Eq Lt, eq Lt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : iff (eq Lt Gt) (eq Lt Lt)"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : eq Lt Gt, eq Lt Lt",
                    "c21_goal : forall _ : eq Lt Lt, eq Lt Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c20_goal : forall _ : eq Lt Gt, eq Lt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : iff (eq Lt Gt) (eq Gt Lt)"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : eq Lt Gt, eq Gt Lt",
                    "c23_goal : forall _ : eq Gt Lt, eq Lt Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c22_goal : forall _ : eq Lt Gt, eq Gt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c23_goal : forall _ : eq Gt Lt, eq Lt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c5_goal : iff (eq Gt Gt) (eq (cmp y x) Lt)",
                    "c1_cmp_ok : correct cmp",
                    "c2_y : A",
                    "c2_x : A",
                    "c5_H_gt : lt y x",
                    "c1_Htrans : Transitive lt",
                    "c1_Hirr : Irreflexive lt",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c24_goal : iff (eq Gt Gt) (eq Eq Lt)",
                    "c24_H_eq : eq y x",
                    "c25_goal : iff (eq Gt Gt) (eq Lt Lt)",
                    "c25_H_lt : lt y x",
                    "c26_goal : iff (eq Gt Gt) (eq Gt Lt)",
                    "c26_H_gt0 : lt x y"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c24_goal : iff (eq Gt Gt) (eq Eq Lt)"
                ],
                "tactic_res": [
                    "c27_goal : forall _ : eq Gt Gt, eq Eq Lt",
                    "c28_goal : forall _ : eq Eq Lt, eq Gt Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c28_goal : forall _ : eq Eq Lt, eq Gt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c25_goal : iff (eq Gt Gt) (eq Lt Lt)"
                ],
                "tactic_res": [
                    "c29_goal : forall _ : eq Gt Gt, eq Lt Lt",
                    "c30_goal : forall _ : eq Lt Lt, eq Gt Gt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : forall _ : eq Gt Gt, eq Lt Lt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : forall _ : eq Lt Lt, eq Gt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c26_goal : iff (eq Gt Gt) (eq Gt Lt)"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : eq Gt Gt, eq Gt Lt",
                    "c32_goal : forall _ : eq Gt Lt, eq Gt Gt"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c32_goal : forall _ : eq Gt Lt, eq Gt Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c12_goal : forall _ : eq Lt Lt, eq Eq Gt"
                ],
                "tactic_res": [
                    "c33_goal : eq Eq Gt",
                    "c33_H : eq Lt Lt"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_y : A",
                    "c3_H_eq : eq x y"
                ],
                "tactic_res": [
                    "c33_H_lt : lt x x"
                ]
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c33_goal : eq Eq Gt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c33_H_lt : lt x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c21_goal : forall _ : eq Lt Lt, eq Lt Gt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c16_H_lt0 : lt y x",
                    "c4_H_lt : lt x y",
                    "c1_Htrans : Transitive lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c34_goal : lt x x"
                ]
            },
            {
                "tactic_sig": "transitivity _i .",
                "tactic_sig_no_out_arg": "transitivity _i .",
                "tactic_args": [
                    "c34_goal : lt x x",
                    "c2_y : A"
                ],
                "tactic_res": [
                    "c35_goal : lt x y",
                    "c36_goal : lt y x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : lt x y",
                    "c4_H_lt : lt x y",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : lt y x",
                    "c16_H_lt0 : lt y x",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_y : A",
                    "c24_H_eq : eq y x"
                ],
                "tactic_res": [
                    "c27_H_gt : lt x x"
                ]
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c27_goal : forall _ : eq Gt Gt, eq Eq Lt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c27_H_gt : lt x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c31_goal : forall _ : eq Gt Gt, eq Gt Lt",
                    "c1_Hirr : Irreflexive lt",
                    "c2_x : A",
                    "c26_H_gt0 : lt x y",
                    "c5_H_gt : lt y x",
                    "c1_Htrans : Transitive lt",
                    "c1_cmp_ok : correct cmp",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop"
                ],
                "tactic_res": [
                    "c37_goal : lt x x"
                ]
            },
            {
                "tactic_sig": "transitivity _i .",
                "tactic_sig_no_out_arg": "transitivity _i .",
                "tactic_args": [
                    "c37_goal : lt x x",
                    "c2_y : A"
                ],
                "tactic_res": [
                    "c38_goal : lt x y",
                    "c39_goal : lt y x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : lt x y",
                    "c26_H_gt0 : lt x y",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : lt y x",
                    "c5_H_gt : lt y x",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "max_eq",
        "proof": [
            {
                "tactic_sig": "Lemma max_eq : forall x y : A , let m := max x y in m = x \\/ m = y .",
                "tactic_sig_no_out_arg": "Lemma max_eq : forall x y : A , let m := max x y in m = x \\/ m = y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : A, let m := max x y in or (eq m x) (eq m y)",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : A, let m := max x y in or (eq m x) (eq m y)"
                ],
                "tactic_res": [
                    "c2_goal : let m := max x y in or (eq m x) (eq m y)",
                    "c2_x : A",
                    "c2_y : A"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : let m := max x y in or (eq m x) (eq m y)",
                    "_global_max : forall (_ : A) (_ : A), A"
                ],
                "tactic_res": [
                    "c3_goal : or (eq match cmp x y with\n       | Lt => y\n       | _ => x\n       end x) (eq match cmp x y with\n                  | Lt => y\n                  | _ => x\n                  end y)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : or (eq match cmp x y with\n       | Lt => y\n       | _ => x\n       end x) (eq match cmp x y with\n                  | Lt => y\n                  | _ => x\n                  end y)",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : or (eq x x) (eq x y)",
                    "c4_H_eq : eq x y",
                    "c5_goal : or (eq y x) (eq y y)",
                    "c5_H_lt : lt x y",
                    "c6_goal : or (eq x x) (eq x y)",
                    "c6_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : or (eq x x) (eq x y)",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : or (eq y x) (eq y y)",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : or (eq x x) (eq x y)",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "le_max",
        "proof": [
            {
                "tactic_sig": "Lemma le_max : forall x y : A , le x ( max x y ) .",
                "tactic_sig_no_out_arg": "Lemma le_max : forall x y : A , le x ( max x y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : A, le x (max x y)",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros x y .",
                "tactic_args": [
                    "c1_goal : forall x y : A, le x (max x y)"
                ],
                "tactic_res": [
                    "c2_goal : le x (max x y)",
                    "c2_x : A",
                    "c2_y : A"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : le x (max x y)",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "_global_max : forall (_ : A) (_ : A), A"
                ],
                "tactic_res": [
                    "c3_goal : or (lt x match cmp x y with\n         | Lt => y\n         | _ => x\n         end) (eq x match cmp x y with\n                    | Lt => y\n                    | _ => x\n                    end)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c3_goal : or (lt x match cmp x y with\n         | Lt => y\n         | _ => x\n         end) (eq x match cmp x y with\n                    | Lt => y\n                    | _ => x\n                    end)",
                    "c1_cmp_ok : correct cmp",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : or (lt x x) (eq x x)",
                    "c4_H_eq : eq x y",
                    "c5_goal : or (lt x y) (eq x y)",
                    "c5_H_lt : lt x y",
                    "c6_goal : or (lt x x) (eq x x)",
                    "c6_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : or (lt x x) (eq x x)",
                    "c2_x : A",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : or (lt x y) (eq x y)",
                    "c5_H_lt : lt x y",
                    "c2_x : A",
                    "c2_y : A",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : or (lt x x) (eq x x)",
                    "c2_x : A",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "max_le",
        "proof": [
            {
                "tactic_sig": "Lemma max_le : forall x y z : A , le x z -> le y z -> le ( max x y ) z .",
                "tactic_sig_no_out_arg": "Lemma max_le : forall x y z : A , le x z -> le y z -> le ( max x y ) z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y z : A) (_ : le x z) (_ : le y z), le (max x y) z",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_lt : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y z H H0 .",
                "tactic_args": [
                    "c1_goal : forall (x y z : A) (_ : le x z) (_ : le y z), le (max x y) z"
                ],
                "tactic_res": [
                    "c2_goal : le (max x y) z",
                    "c2_x : A",
                    "c2_y : A",
                    "c2_z : A",
                    "c2_H : le x z",
                    "c2_H0 : le y z"
                ]
            },
            {
                "tactic_sig": "destruct ( max_eq _i _i ) as [ e | e ] .",
                "tactic_sig_no_out_arg": "destruct ( max_eq _i _i ) as [ e | e ] .",
                "tactic_args": [
                    "c2_goal : le (max x y) z",
                    "c2_x : A",
                    "c2_y : A",
                    "c2_H0 : le y z",
                    "c2_H : le x z",
                    "c2_z : A",
                    "c1_cmp_ok : correct cmp",
                    "c1_cmp : forall (_ : A) (_ : A), comparison",
                    "c1_lt_strict : StrictOrder lt",
                    "c1_le : forall (_ : A) (_ : A), Prop",
                    "c1_A : Type"
                ],
                "tactic_res": [
                    "c3_goal : le (max x y) z",
                    "c3_e : eq (max x y) x",
                    "c4_goal : le (max x y) z",
                    "c4_e : eq (max x y) y"
                ]
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c3_goal : le (max x y) z",
                    "c3_e : eq (max x y) x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c4_goal : le (max x y) z",
                    "c4_e : eq (max x y) y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_correct",
        "proof": [
            {
                "tactic_sig": "Lemma cmp_correct : correct nat lt cmp .",
                "tactic_sig_no_out_arg": "Lemma cmp_correct : correct nat lt cmp .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : correct nat lt cmp"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c1_goal : correct nat lt cmp"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : nat, CompSpec nat lt x y (cmp x y)"
                ]
            },
            {
                "tactic_sig": "induction x .",
                "tactic_sig_no_out_arg": "induction x .",
                "tactic_args": [
                    "c2_goal : forall x y : nat, CompSpec nat lt x y (cmp x y)"
                ],
                "tactic_res": [
                    "c3_goal : forall y : nat, CompSpec nat lt 0 y (cmp 0 y)",
                    "c4_goal : forall y : nat, CompSpec nat lt (S x) y (cmp (S x) y)",
                    "c4_IHx : forall y : nat, CompSpec nat lt x y (cmp x y)",
                    "c4_x : nat"
                ]
            },
            {
                "tactic_sig": "destruct y as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct y .",
                "tactic_args": [
                    "c3_goal : forall y : nat, CompSpec nat lt 0 y (cmp 0 y)"
                ],
                "tactic_res": [
                    "c5_goal : CompSpec nat lt 0 0 (cmp 0 0)",
                    "c6_goal : CompSpec nat lt 0 (S y) (cmp 0 (S y))",
                    "c6_y : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : CompSpec nat lt 0 0 (cmp 0 0)"
                ],
                "tactic_res": [
                    "c7_goal : CompSpec nat lt 0 0 Eq"
                ]
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c7_goal : CompSpec nat lt 0 0 Eq"
                ],
                "tactic_res": [
                    "c8_goal : eq 0 0"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c8_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : CompSpec nat lt 0 (S y) (cmp 0 (S y))"
                ],
                "tactic_res": [
                    "c9_goal : CompSpec nat lt 0 (S y) Lt"
                ]
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c9_goal : CompSpec nat lt 0 (S y) Lt"
                ],
                "tactic_res": [
                    "c10_goal : lt 0 (S y)"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c10_goal : lt 0 (S y)",
                    "c6_y : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct y as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct y .",
                "tactic_args": [
                    "c4_goal : forall y : nat, CompSpec nat lt (S x) y (cmp (S x) y)",
                    "c4_IHx : forall y : nat, CompSpec nat lt x y (cmp x y)",
                    "c4_x : nat"
                ],
                "tactic_res": [
                    "c11_goal : CompSpec nat lt (S x) 0 (cmp (S x) 0)",
                    "c12_goal : CompSpec nat lt (S x) (S y) (cmp (S x) (S y))",
                    "c12_y : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : CompSpec nat lt (S x) 0 (cmp (S x) 0)"
                ],
                "tactic_res": [
                    "c13_goal : CompSpec nat lt (S x) 0 Gt"
                ]
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c13_goal : CompSpec nat lt (S x) 0 Gt"
                ],
                "tactic_res": [
                    "c14_goal : lt 0 (S x)"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c14_goal : lt 0 (S x)",
                    "c4_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : CompSpec nat lt (S x) (S y) (cmp (S x) (S y))"
                ],
                "tactic_res": [
                    "c15_goal : CompSpec nat lt (S x) (S y) (cmp x y)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c15_goal : CompSpec nat lt (S x) (S y) (cmp x y)",
                    "c4_IHx : forall y : nat, CompSpec nat lt x y (cmp x y)",
                    "c12_y : nat",
                    "c4_x : nat"
                ],
                "tactic_res": [
                    "c16_goal : CompSpec nat lt (S x) (S y) Eq",
                    "c16_H_eq : eq x y",
                    "c17_goal : CompSpec nat lt (S x) (S y) Lt",
                    "c17_H_lt : lt x y",
                    "c18_goal : CompSpec nat lt (S x) (S y) Gt",
                    "c18_H_gt : lt y x"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c16_goal : CompSpec nat lt (S x) (S y) Eq",
                    "c12_y : nat",
                    "c16_H_eq : eq x y"
                ],
                "tactic_res": [
                    "c19_goal : CompSpec nat lt (S x) (S x) Eq"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c19_goal : CompSpec nat lt (S x) (S x) Eq"
                ],
                "tactic_res": [
                    "c20_goal : eq (S x) (S x)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c20_goal : eq (S x) (S x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c17_goal : CompSpec nat lt (S x) (S y) Lt"
                ],
                "tactic_res": [
                    "c21_goal : lt (S x) (S y)"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c21_goal : lt (S x) (S y)",
                    "c17_H_lt : lt x y",
                    "c12_y : nat",
                    "c4_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c18_goal : CompSpec nat lt (S x) (S y) Gt"
                ],
                "tactic_res": [
                    "c22_goal : lt (S y) (S x)"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c22_goal : lt (S y) (S x)",
                    "c18_H_gt : lt y x",
                    "c12_y : nat",
                    "c4_x : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div2_ind",
        "proof": [
            {
                "tactic_sig": "Theorem div2_ind : forall P : nat -> Prop , P 0 -> P 1 -> ( forall n , P n -> P ( S ( S n ) ) ) -> forall n , P n .",
                "tactic_sig_no_out_arg": "Theorem div2_ind : forall P : nat -> Prop , P 0 -> P 1 -> ( forall n , P n -> P ( S ( S n ) ) ) -> forall n , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : forall _ : nat, Prop) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n), P (S (S n))) (n : nat), \nP n"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P H0 H1 Hstep n .",
                "tactic_args": [
                    "c1_goal : forall (P : forall _ : nat, Prop) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n), P (S (S n))) (n : nat), \nP n"
                ],
                "tactic_res": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Prop",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_Hstep : forall (n : nat) (_ : P n), P (S (S n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "assert ( _i _i /\\ _i ( S _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( _i _i /\\ _i ( S _i ) ) .",
                "tactic_args": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Prop",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Prop",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : and (P n) (P (S n))",
                    "c4_goal : P n",
                    "c4_H : and (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : and (P n) (P (S n))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : and (P 0) (P 1)",
                    "c6_goal : forall (n : nat) (_ : and (P n) (P (S n))), and (P (S n)) (P (S (S n)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c5_goal : and (P 0) (P 1)",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (_ : and (P n) (P (S n))), and (P (S n)) (P (S (S n)))",
                    "c2_Hstep : forall (n : nat) (_ : P n), P (S (S n))",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c4_goal : P n",
                    "c4_H : and (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fib_ind",
        "proof": [
            {
                "tactic_sig": "Theorem fib_ind : forall P : nat -> Prop , P 0 -> P 1 -> ( forall n , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n , P n .",
                "tactic_sig_no_out_arg": "Theorem fib_ind : forall P : nat -> Prop , P 0 -> P 1 -> ( forall n , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : forall _ : nat, Prop) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P H0 H1 Hstep n .",
                "tactic_args": [
                    "c1_goal : forall (P : forall _ : nat, Prop) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n"
                ],
                "tactic_res": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Prop",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_Hstep : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "assert ( _i _i /\\ _i ( S _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( _i _i /\\ _i ( S _i ) ) .",
                "tactic_args": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Prop",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Prop",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : and (P n) (P (S n))",
                    "c4_goal : P n",
                    "c4_H : and (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : and (P n) (P (S n))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : and (P 0) (P 1)",
                    "c6_goal : forall (n : nat) (_ : and (P n) (P (S n))), and (P (S n)) (P (S (S n)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c5_goal : and (P 0) (P 1)",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (_ : and (P n) (P (S n))), and (P (S n)) (P (S (S n)))",
                    "c2_Hstep : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c4_goal : P n",
                    "c4_H : and (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div2_rem2_eq",
        "proof": [
            {
                "tactic_sig": "Theorem div2_rem2_eq : forall n , 2 * div2 n + rem2 n = n .",
                "tactic_sig_no_out_arg": "Theorem div2_rem2_eq : forall n , 2 * div2 n + rem2 n = n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n"
                ],
                "tactic_res": [
                    "c2_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i using div2_ind .",
                "tactic_sig_no_out_arg": "elim _i using div2_ind .",
                "tactic_args": [
                    "c2_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 0)) (rem2 0)) 0",
                    "c4_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 1)) (rem2 1)) 1",
                    "c5_goal : forall (n : nat)\n  (_ : eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n),\neq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S n)))) (rem2 (S (S n))))\n  (S (S n))"
                ]
            },
            {
                "tactic_sig": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_sig_no_out_arg": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_args": [
                    "c3_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 0)) (rem2 0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_sig_no_out_arg": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_args": [
                    "c4_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 1)) (rem2 1)) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros p IHp .",
                "tactic_args": [
                    "c5_goal : forall (n : nat)\n  (_ : eq (Init.Nat.add (Init.Nat.mul 2 (div2 n)) (rem2 n)) n),\neq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S n)))) (rem2 (S (S n))))\n  (S (S n))"
                ],
                "tactic_res": [
                    "c6_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n  (S (S p))",
                    "c6_p : nat",
                    "c6_IHp : eq (Init.Nat.add (Init.Nat.mul 2 (div2 p)) (rem2 p)) p"
                ]
            },
            {
                "tactic_sig": "pattern _i at 3 .",
                "tactic_sig_no_out_arg": "pattern _i at 3 .",
                "tactic_args": [
                    "c6_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n  (S (S p))",
                    "c6_p : nat"
                ],
                "tactic_res": [
                    "c7_goal : (fun n : nat =>\n eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n   (S (S n))) p"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : (fun n : nat =>\n eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n   (S (S n))) p",
                    "c6_IHp : eq (Init.Nat.add (Init.Nat.mul 2 (div2 p)) (rem2 p)) p"
                ],
                "tactic_res": [
                    "c8_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n  (S (S (Init.Nat.add (Init.Nat.mul 2 (div2 p)) (rem2 p))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (Init.Nat.add (Init.Nat.mul 2 (div2 (S (S p)))) (rem2 (S (S p))))\n  (S (S (Init.Nat.add (Init.Nat.mul 2 (div2 p)) (rem2 p))))"
                ],
                "tactic_res": [
                    "c9_goal : eq\n  (S\n     (Init.Nat.add\n        (Init.Nat.add (div2 p) (S (Init.Nat.add (div2 p) 0))) \n        (rem2 p)))\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (div2 p) (Init.Nat.add (div2 p) 0))\n           (rem2 p))))"
                ]
            },
            {
                "tactic_sig": "ring .",
                "tactic_sig_no_out_arg": "ring .",
                "tactic_args": [
                    "c9_goal : eq\n  (S\n     (Init.Nat.add\n        (Init.Nat.add (div2 p) (S (Init.Nat.add (div2 p) 0))) \n        (rem2 p)))\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (div2 p) (Init.Nat.add (div2 p) 0))\n           (rem2 p))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fib_fib2_equiv",
        "proof": [
            {
                "tactic_sig": "Theorem fib_fib2_equiv : forall n , fib n = ( fst ( fib2 n ) ) .",
                "tactic_sig_no_out_arg": "Theorem fib_fib2_equiv : forall n , fib n = ( fst ( fib2 n ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (fib n) (fst (fib2 n))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (fib n) (fst (fib2 n))"
                ],
                "tactic_res": [
                    "c2_goal : eq (fib n) (fst (fib2 n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "elim _i using fib_ind .",
                "tactic_sig_no_out_arg": "elim _i using fib_ind .",
                "tactic_args": [
                    "c2_goal : eq (fib n) (fst (fib2 n))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (fib 0) (fst (fib2 0))",
                    "c4_goal : eq (fib 1) (fst (fib2 1))",
                    "c5_goal : forall (n : nat) (_ : eq (fib n) (fst (fib2 n)))\n  (_ : eq (fib (S n)) (fst (fib2 (S n)))),\neq (fib (S (S n))) (fst (fib2 (S (S n))))"
                ]
            },
            {
                "tactic_sig": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_sig_no_out_arg": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_args": [
                    "c3_goal : eq (fib 0) (fst (fib2 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_sig_no_out_arg": "try ( simpl ; auto with arith ; fail ) .",
                "tactic_args": [
                    "c4_goal : eq (fib 1) (fst (fib2 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros p IHp IHSp .",
                "tactic_args": [
                    "c5_goal : forall (n : nat) (_ : eq (fib n) (fst (fib2 n)))\n  (_ : eq (fib (S n)) (fst (fib2 (S n)))),\neq (fib (S (S n))) (fst (fib2 (S (S n))))"
                ],
                "tactic_res": [
                    "c6_goal : eq (fib (S (S p))) (fst (fib2 (S (S p))))",
                    "c6_p : nat",
                    "c6_IHp : eq (fib p) (fst (fib2 p))",
                    "c6_IHSp : eq (fib (S p)) (fst (fib2 (S p)))"
                ]
            },
            {
                "tactic_sig": "replace ( fib ( S ( S _i ) ) ) with ( fib _i + fib ( S _i ) ) .",
                "tactic_sig_no_out_arg": "replace ( fib ( S ( S _i ) ) ) with ( fib _i + fib ( S _i ) ) .",
                "tactic_args": [
                    "c6_goal : eq (fib (S (S p))) (fst (fib2 (S (S p))))",
                    "c6_p : nat",
                    "c6_p : nat",
                    "c6_p : nat"
                ],
                "tactic_res": [
                    "c7_goal : eq (Init.Nat.add (fib p) (fib (S p))) (fst (fib2 (S (S p))))",
                    "c8_goal : eq (Init.Nat.add (fib p) (fib (S p))) (fib (S (S p)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (Init.Nat.add (fib p) (fib (S p))) (fst (fib2 (S (S p))))",
                    "c6_IHp : eq (fib p) (fst (fib2 p))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Init.Nat.add (fst (fib2 p)) (fib (S p))) (fst (fib2 (S (S p))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (Init.Nat.add (fst (fib2 p)) (fib (S p))) (fst (fib2 (S (S p))))",
                    "c6_IHSp : eq (fib (S p)) (fst (fib2 (S p)))"
                ],
                "tactic_res": [
                    "c10_goal : eq (Init.Nat.add (fst (fib2 p)) (fst (fib2 (S p))))\n  (fst (fib2 (S (S p))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : eq (Init.Nat.add (fst (fib2 p)) (fst (fib2 (S p))))\n  (fst (fib2 (S (S p))))"
                ],
                "tactic_res": [
                    "c11_goal : eq\n  (Init.Nat.add (fst (fib2 p))\n     (fst (let (v1, v2) := fib2 p in pair v2 (Init.Nat.add v1 v2))))\n  (fst\n     (let (v1, v2) :=\n        let (v1, v2) := fib2 p in pair v2 (Init.Nat.add v1 v2) in\n      pair v2 (Init.Nat.add v1 v2)))"
                ]
            },
            {
                "tactic_sig": "case ( fib2 _i ) .",
                "tactic_sig_no_out_arg": "case ( fib2 _i ) .",
                "tactic_args": [
                    "c11_goal : eq\n  (Init.Nat.add (fst (fib2 p))\n     (fst (let (v1, v2) := fib2 p in pair v2 (Init.Nat.add v1 v2))))\n  (fst\n     (let (v1, v2) :=\n        let (v1, v2) := fib2 p in pair v2 (Init.Nat.add v1 v2) in\n      pair v2 (Init.Nat.add v1 v2)))",
                    "c6_p : nat"
                ],
                "tactic_res": [
                    "c12_goal : forall n n0 : nat,\neq (Init.Nat.add (fst (pair n n0)) (fst (pair n0 (Init.Nat.add n n0))))\n  (fst (pair (Init.Nat.add n n0) (Init.Nat.add n0 (Init.Nat.add n n0))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall n n0 : nat,\neq (Init.Nat.add (fst (pair n n0)) (fst (pair n0 (Init.Nat.add n n0))))\n  (fst (pair (Init.Nat.add n n0) (Init.Nat.add n0 (Init.Nat.add n n0))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (Init.Nat.add (fib p) (fib (S p))) (fib (S (S p)))",
                    "c6_p : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nat_ind3",
        "proof": [
            {
                "tactic_sig": "Lemma nat_ind3 ( P : nat -> Prop ) : P 0 -> P 1 -> P 2 -> ( forall i : nat , P i -> P ( 3 + i ) ) -> forall n : nat , P n .",
                "tactic_sig_no_out_arg": "Lemma nat_ind3 ( P : nat -> Prop ) : P 0 -> P 1 -> P 2 -> ( forall i : nat , P i -> P ( 3 + i ) ) -> forall n : nat , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (_ : P 0) (_ : P 1) (_ : P 2)\n  (_ : forall (i : nat) (_ : P i), P (Init.Nat.add 3 i)) \n  (n : nat), P n",
                    "c1_P : forall _ : nat, Prop"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros H0 H1 H2 HS n .",
                "tactic_args": [
                    "c1_goal : forall (_ : P 0) (_ : P 1) (_ : P 2)\n  (_ : forall (i : nat) (_ : P i), P (Init.Nat.add 3 i)) \n  (n : nat), P n"
                ],
                "tactic_res": [
                    "c2_goal : P n",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_H2 : P 2",
                    "c2_HS : forall (i : nat) (_ : P i), P (Init.Nat.add 3 i)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "assert ( H : _i _i /\\ _i ( S _i ) /\\ _i ( S ( S _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( H : _i _i /\\ _i ( S _i ) /\\ _i ( S ( S _i ) ) ) .",
                "tactic_args": [
                    "c2_goal : P n",
                    "c1_P : forall _ : nat, Prop",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Prop",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Prop",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : and (P n) (and (P (S n)) (P (S (S n))))",
                    "c4_goal : P n",
                    "c4_H : and (P n) (and (P (S n)) (P (S (S n))))"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c3_goal : and (P n) (and (P (S n)) (P (S (S n))))",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : and (P 0) (and (P 1) (P 2))",
                    "c6_goal : and (P (S n)) (and (P (S (S n))) (P (S (S (S n)))))",
                    "c6_IHn : and (P n) (and (P (S n)) (P (S (S n))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : and (P 0) (and (P 1) (P 2))"
                ],
                "tactic_res": [
                    "c7_goal : P 0",
                    "c8_goal : and (P 1) (P 2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : P 0",
                    "c2_H0 : P 0",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (P 1) (P 2)",
                    "c2_H2 : P 2",
                    "c2_H1 : P 1",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ Hn [ HSn HSSn ] ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ Hn [ HSn HSSn ] ] .",
                "tactic_args": [
                    "c6_IHn : and (P n) (and (P (S n)) (P (S (S n))))",
                    "c2_n : nat",
                    "c2_HS : forall (i : nat) (_ : P i), P (Init.Nat.add 3 i)",
                    "c2_H2 : P 2",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": [
                    "c6_HSSn : P (S (S n))",
                    "c6_HSn : P (S n)",
                    "c6_Hn : P n"
                ]
            },
            {
                "tactic_sig": "repeat split .",
                "tactic_sig_no_out_arg": "repeat split .",
                "tactic_args": [
                    "c6_goal : and (P (S n)) (and (P (S (S n))) (P (S (S (S n)))))"
                ],
                "tactic_res": [
                    "c9_goal : P (S n)",
                    "c10_goal : P (S (S n))",
                    "c11_goal : P (S (S (S n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P (S n)",
                    "c6_HSn : P (S n)",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : P (S (S n))",
                    "c6_HSSn : P (S (S n))",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : P (S (S (S n)))",
                    "c2_HS : forall (i : nat) (_ : P i), P (Init.Nat.add 3 i)"
                ],
                "tactic_res": [
                    "c12_goal : P n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : P n",
                    "c6_Hn : P n",
                    "c2_n : nat",
                    "c1_P : forall _ : nat, Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c4_goal : P n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div3_le",
        "proof": [
            {
                "tactic_sig": "Lemma div3_le : forall n , div3 n <= n .",
                "tactic_sig_no_out_arg": "Lemma div3_le : forall n , div3 n <= n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, le (div3 n) n"
                ]
            },
            {
                "tactic_sig": "induction n using nat_ind3 .",
                "tactic_sig_no_out_arg": "induction n using nat_ind3 .",
                "tactic_args": [
                    "c1_goal : forall n : nat, le (div3 n) n"
                ],
                "tactic_res": [
                    "c2_goal : le (div3 0) 0",
                    "c3_goal : le (div3 1) 1",
                    "c4_goal : le (div3 2) 2",
                    "c5_goal : le (div3 (Init.Nat.add 3 n)) (Init.Nat.add 3 n)",
                    "c5_IHn : le (div3 n) n",
                    "c5_n : nat"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : le (div3 0) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : le (div3 1) 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : le (div3 2) 2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : le (div3 (Init.Nat.add 3 n)) (Init.Nat.add 3 n)"
                ],
                "tactic_res": [
                    "c6_goal : le (S (div3 n)) (S (S (S n)))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c6_goal : le (S (div3 n)) (S (S (S n)))",
                    "_global_Nat.le_trans : forall (n m p : nat) (_ : le n m) (_ : le m p), le n p",
                    "_global_S : forall _ : nat, nat",
                    "c5_n : nat"
                ],
                "tactic_res": [
                    "c7_goal : le (S (div3 n)) (S n)",
                    "c8_goal : le (S n) (S (S (S n)))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c7_goal : le (S (div3 n)) (S n)",
                    "c5_IHn : le (div3 n) n",
                    "c5_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c8_goal : le (S n) (S (S (S n)))",
                    "c5_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Even_not_Odd",
        "proof": [
            {
                "tactic_sig": "Lemma Even_not_Odd : forall n , Even n -> ~ Odd n .",
                "tactic_sig_no_out_arg": "Lemma Even_not_Odd : forall n , Even n -> ~ Odd n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : Even n), not (Odd n)"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros n [ p Hp ] [ q Hq ] .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : Even n), not (Odd n)"
                ],
                "tactic_res": [
                    "c2_goal : False",
                    "c2_n : nat",
                    "c2_p : nat",
                    "c2_Hp : eq n (Init.Nat.mul 2 p)",
                    "c2_q : nat",
                    "c2_Hq : eq n (S (Init.Nat.mul 2 q))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c2_Hp : eq n (Init.Nat.mul 2 p)",
                    "c2_Hq : eq n (S (Init.Nat.mul 2 q))"
                ],
                "tactic_res": [
                    "c2_Hq : eq (Init.Nat.mul 2 p) (S (Init.Nat.mul 2 q))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c2_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nat_double_rect",
        "proof": [
            {
                "tactic_sig": "Lemma nat_double_rect : forall ( P : nat -> Type ) , P 0 -> P 1 -> ( forall p , P p -> P ( S ( S p ) ) ) -> forall n : nat , P n .",
                "tactic_sig_no_out_arg": "Lemma nat_double_rect : forall ( P : nat -> Type ) , P 0 -> P 1 -> ( forall p , P p -> P ( S ( S p ) ) ) -> forall n : nat , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : forall _ : nat, Type) (_ : P 0) (_ : P 1)\n  (_ : forall (p : nat) (_ : P p), P (S (S p))) (n : nat), \nP n"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P H0 H1 HS .",
                "tactic_args": [
                    "c1_goal : forall (P : forall _ : nat, Type) (_ : P 0) (_ : P 1)\n  (_ : forall (p : nat) (_ : P p), P (S (S p))) (n : nat), \nP n"
                ],
                "tactic_res": [
                    "c2_goal : forall n : nat, P n",
                    "c2_P : forall _ : nat, Type",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_HS : forall (p : nat) (_ : P p), P (S (S p))"
                ]
            },
            {
                "tactic_sig": "assert ( X : forall n , ( _i n * _i ( S n ) % type ) ) .",
                "tactic_sig_no_out_arg": "assert ( X : forall n , ( _i n * _i ( S n ) % type ) ) .",
                "tactic_args": [
                    "c2_goal : forall n : nat, P n",
                    "c2_P : forall _ : nat, Type",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": [
                    "c3_goal : forall n : nat, prod (P n) (P (S n))",
                    "c4_goal : forall n : nat, P n",
                    "c4_X : forall n : nat, prod (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "induction n as [ | p IHp ] .",
                "tactic_sig_no_out_arg": "induction n as [ | p IHp ] .",
                "tactic_args": [
                    "c3_goal : forall n : nat, prod (P n) (P (S n))"
                ],
                "tactic_res": [
                    "c5_goal : prod (P 0) (P 1)",
                    "c6_goal : prod (P (S p)) (P (S (S p)))",
                    "c6_IHp : prod (P p) (P (S p))",
                    "c6_p : nat"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : prod (P 0) (P 1)",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_IHp : prod (P p) (P (S p))",
                    "c6_p : nat",
                    "c2_HS : forall (p : nat) (_ : P p), P (S (S p))",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": [
                    "c6_p1 : P (S p)",
                    "c6_p0 : P p"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : prod (P (S p)) (P (S (S p)))",
                    "c6_p1 : P (S p)",
                    "c6_p0 : P p",
                    "c6_p : nat",
                    "c2_HS : forall (p : nat) (_ : P p), P (S (S p))",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c4_goal : forall n : nat, P n"
                ],
                "tactic_res": [
                    "c7_goal : P n",
                    "c7_n : nat"
                ]
            },
            {
                "tactic_sig": "now destruct ( _i _i ) .",
                "tactic_sig_no_out_arg": "now destruct ( _i _i ) .",
                "tactic_args": [
                    "c7_goal : P n",
                    "c4_X : forall n : nat, prod (P n) (P (S n))",
                    "c7_n : nat",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "even_spec_SS",
        "proof": [
            {
                "tactic_sig": "Lemma even_spec_SS : forall n b , even_spec n b -> even_spec ( S ( S n ) ) b .",
                "tactic_sig_no_out_arg": "Lemma even_spec_SS : forall n b , even_spec n b -> even_spec ( S ( S n ) ) b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (b : bool) (_ : even_spec n b), even_spec (S (S n)) b"
                ]
            },
            {
                "tactic_sig": "intros _o _o [ [ _o _o ] | [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros n p [ [ q Hq ] | [ q Hq ] ] .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (b : bool) (_ : even_spec n b), even_spec (S (S n)) b"
                ],
                "tactic_res": [
                    "c2_goal : even_spec (S (S n)) true",
                    "c3_n : nat",
                    "c3_p : bool",
                    "c3_q : nat",
                    "c3_Hq : eq n (S (Init.Nat.mul 2 q))",
                    "c3_goal : even_spec (S (S n)) false",
                    "c2_n : nat",
                    "c2_p : bool",
                    "c2_q : nat",
                    "c2_Hq : eq n (Init.Nat.mul 2 q)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : even_spec (S (S n)) true"
                ],
                "tactic_res": [
                    "c4_goal : Even (S (S n))"
                ]
            },
            {
                "tactic_sig": "exists ( S _i ) .",
                "tactic_sig_no_out_arg": "exists ( S _i ) .",
                "tactic_args": [
                    "c4_goal : Even (S (S n))",
                    "c2_q : nat"
                ],
                "tactic_res": [
                    "c5_goal : eq (S (S n)) (Init.Nat.mul 2 (S q))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c5_goal : eq (S (S n)) (Init.Nat.mul 2 (S q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : even_spec (S (S n)) false"
                ],
                "tactic_res": [
                    "c6_goal : Odd (S (S n))"
                ]
            },
            {
                "tactic_sig": "exists ( S _i ) .",
                "tactic_sig_no_out_arg": "exists ( S _i ) .",
                "tactic_args": [
                    "c6_goal : Odd (S (S n))",
                    "c3_q : nat"
                ],
                "tactic_res": [
                    "c7_goal : eq (S (S n)) (S (Init.Nat.mul 2 (S q)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : eq (S (S n)) (S (Init.Nat.mul 2 (S q)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "even_bool_correct",
        "proof": [
            {
                "tactic_sig": "Lemma even_bool_correct : even_test_ok even_bool .",
                "tactic_sig_no_out_arg": "Lemma even_bool_correct : even_test_ok even_bool .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : even_test_ok even_bool"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : even_test_ok even_bool"
                ],
                "tactic_res": [
                    "c2_goal : even_spec n (even_bool n)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i using nat_double_rect .",
                "tactic_sig_no_out_arg": "induction _i using nat_double_rect .",
                "tactic_args": [
                    "c2_goal : even_spec n (even_bool n)",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : even_spec 0 (even_bool 0)",
                    "c4_goal : even_spec 1 (even_bool 1)",
                    "c5_goal : even_spec (S (S n)) (even_bool (S (S n)))",
                    "c5_IHn : even_spec n (even_bool n)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : even_spec 0 (even_bool 0)"
                ],
                "tactic_res": [
                    "c6_goal : Even 0"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c6_goal : Even 0"
                ],
                "tactic_res": [
                    "c7_goal : eq 0 (Init.Nat.mul 2 0)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : eq 0 (Init.Nat.mul 2 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : even_spec 1 (even_bool 1)"
                ],
                "tactic_res": [
                    "c8_goal : Odd 1"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c8_goal : Odd 1"
                ],
                "tactic_res": [
                    "c9_goal : eq 1 (S (Init.Nat.mul 2 0))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq 1 (S (Init.Nat.mul 2 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : even_spec (S (S n)) (even_bool (S (S n)))"
                ],
                "tactic_res": [
                    "c10_goal : even_spec (S (S n)) (even_bool n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : even_spec (S (S n)) (even_bool n)",
                    "_global_even_spec_SS : forall (n : nat) (b : bool) (_ : even_spec n b), even_spec (S (S n)) b"
                ],
                "tactic_res": [
                    "c11_goal : even_spec n (even_bool n)"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c11_goal : even_spec n (even_bool n)",
                    "c5_IHn : even_spec n (even_bool n)",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "even_bool_false",
        "proof": [
            {
                "tactic_sig": "Lemma even_bool_false ( f : nat -> bool ) ( H : even_test_ok f ) : forall n , Odd n <- > f n = false .",
                "tactic_sig_no_out_arg": "Lemma even_bool_false ( f : nat -> bool ) ( H : even_test_ok f ) : forall n , Odd n <- > f n = false .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, iff (Odd n) (eq (f n) false)",
                    "c1_H : even_test_ok f",
                    "c1_f : forall _ : nat, bool"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, iff (Odd n) (eq (f n) false)"
                ],
                "tactic_res": [
                    "c2_goal : iff (Odd n) (eq (f n) false)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : iff (Odd n) (eq (f n) false)",
                    "c1_H : even_test_ok f",
                    "c2_n : nat",
                    "c1_f : forall _ : nat, bool"
                ],
                "tactic_res": [
                    "c3_goal : iff (Odd n) (eq true false)",
                    "c3_Heven : Even n",
                    "c4_goal : iff (Odd n) (eq false false)",
                    "c4_Hodd : Odd n"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : iff (Odd n) (eq true false)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Odd n, eq true false",
                    "c6_goal : forall _ : eq true false, Odd n"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c5_goal : forall _ : Odd n, eq true false"
                ],
                "tactic_res": [
                    "c7_goal : eq true false",
                    "c7_H0 : Odd n"
                ]
            },
            {
                "tactic_sig": "destruct ( Even_not_Odd _i ) as [  | ] .",
                "tactic_sig_no_out_arg": "destruct ( Even_not_Odd _i ) .",
                "tactic_args": [
                    "c7_goal : eq true false",
                    "c2_n : nat",
                    "c7_H0 : Odd n",
                    "c3_Heven : Even n",
                    "c1_H : even_test_ok f"
                ],
                "tactic_res": [
                    "c8_goal : Even n",
                    "c9_goal : Odd n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Even n",
                    "c3_Heven : Even n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Odd n",
                    "c7_H0 : Odd n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : forall _ : eq true false, Odd n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c4_goal : iff (Odd n) (eq false false)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nat_eq_dec",
        "proof": [
            {
                "tactic_sig": "Definition nat_eq_dec : eqdec nat .",
                "tactic_sig_no_out_arg": "Definition nat_eq_dec : eqdec nat .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eqdec nat"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c1_goal : eqdec nat"
                ],
                "tactic_res": [
                    "c2_goal : forall a b : nat, sumbool (eq a b) (not (eq a b))"
                ]
            },
            {
                "tactic_sig": "simple induction a .",
                "tactic_sig_no_out_arg": "simple induction a .",
                "tactic_args": [
                    "c2_goal : forall a b : nat, sumbool (eq a b) (not (eq a b))"
                ],
                "tactic_res": [
                    "c3_goal : forall b : nat, sumbool (eq 0 b) (not (eq 0 b))",
                    "c3_a : nat",
                    "c4_goal : forall (n : nat) (_ : forall b : nat, sumbool (eq n b) (not (eq n b)))\n  (b : nat), sumbool (eq (S n) b) (not (eq (S n) b))",
                    "c4_a : nat"
                ]
            },
            {
                "tactic_sig": "simple destruct b .",
                "tactic_sig_no_out_arg": "simple destruct b .",
                "tactic_args": [
                    "c3_goal : forall b : nat, sumbool (eq 0 b) (not (eq 0 b))",
                    "c3_a : nat"
                ],
                "tactic_res": [
                    "c5_goal : sumbool (eq 0 0) (not (eq 0 0))",
                    "c5_b : nat",
                    "c6_goal : forall n : nat, sumbool (eq 0 (S n)) (not (eq 0 (S n)))",
                    "c6_b : nat"
                ]
            },
            {
                "tactic_sig": "simple destruct b .",
                "tactic_sig_no_out_arg": "simple destruct b .",
                "tactic_args": [
                    "c4_goal : forall (n : nat) (_ : forall b : nat, sumbool (eq n b) (not (eq n b)))\n  (b : nat), sumbool (eq (S n) b) (not (eq (S n) b))",
                    "c4_a : nat"
                ],
                "tactic_res": [
                    "c7_goal : sumbool (eq (S n) 0) (not (eq (S n) 0))",
                    "c7_b : nat",
                    "c7_H : forall b : nat, sumbool (eq n b) (not (eq n b))",
                    "c7_n : nat",
                    "c8_goal : forall n0 : nat, sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c8_b : nat",
                    "c8_H : forall b : nat, sumbool (eq n b) (not (eq n b))",
                    "c8_n : nat"
                ]
            },
            {
                "tactic_sig": "now left .",
                "tactic_sig_no_out_arg": "now left .",
                "tactic_args": [
                    "c5_goal : sumbool (eq 0 0) (not (eq 0 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c6_goal : forall n : nat, sumbool (eq 0 (S n)) (not (eq 0 (S n)))"
                ],
                "tactic_res": [
                    "c9_goal : not (eq 0 (S n))",
                    "c9_n : nat"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c9_goal : not (eq 0 (S n))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq 0 (S n), False"
                ]
            },
            {
                "tactic_sig": "discriminate 1 .",
                "tactic_sig_no_out_arg": "discriminate 1 .",
                "tactic_args": [
                    "c10_goal : forall _ : eq 0 (S n), False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c7_goal : sumbool (eq (S n) 0) (not (eq (S n) 0))"
                ],
                "tactic_res": [
                    "c11_goal : not (eq (S n) 0)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : not (eq (S n) 0)"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq (S n) 0, False"
                ]
            },
            {
                "tactic_sig": "discriminate 1 .",
                "tactic_sig_no_out_arg": "discriminate 1 .",
                "tactic_args": [
                    "c12_goal : forall _ : eq (S n) 0, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n0 .",
                "tactic_args": [
                    "c8_goal : forall n0 : nat, sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))"
                ],
                "tactic_res": [
                    "c13_goal : sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c13_n0 : nat"
                ]
            },
            {
                "tactic_sig": "case ( _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i ) .",
                "tactic_args": [
                    "c13_goal : sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c8_H : forall b : nat, sumbool (eq n b) (not (eq n b))",
                    "c13_n0 : nat"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : eq n n0, sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c15_goal : forall _ : not (eq n n0),\nsumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall _ : eq n n0, sumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c13_n0 : nat",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : forall _ : not (eq n n0),\nsumbool (eq (S n) (S n0)) (not (eq (S n) (S n0)))",
                    "c13_n0 : nat",
                    "c8_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fib_rect",
        "proof": [
            {
                "tactic_sig": "Lemma fib_rect : forall P : nat -> Type , P 0 -> P 1 -> ( forall n : nat , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n : nat , P n .",
                "tactic_sig_no_out_arg": "Lemma fib_rect : forall P : nat -> Type , P 0 -> P 1 -> ( forall n : nat , P n -> P ( S n ) -> P ( S ( S n ) ) ) -> forall n : nat , P n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : forall _ : nat, Type) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P H0 H1 HSSn n .",
                "tactic_args": [
                    "c1_goal : forall (P : forall _ : nat, Type) (_ : P 0) (_ : P 1)\n  (_ : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))) \n  (n : nat), P n"
                ],
                "tactic_res": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Type",
                    "c2_H0 : P 0",
                    "c2_H1 : P 1",
                    "c2_HSSn : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "assert ( X : _i _i * _i ( S _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( X : _i _i * _i ( S _i ) ) .",
                "tactic_args": [
                    "c2_goal : P n",
                    "c2_P : forall _ : nat, Type",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Type",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : prod (P n) (P (S n))",
                    "c4_goal : P n",
                    "c4_X : prod (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | _i IHn ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | _i IHn ] .",
                "tactic_args": [
                    "c3_goal : prod (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c5_goal : prod (P 0) (P 1)",
                    "c6_goal : prod (P (S n)) (P (S (S n)))",
                    "c6_IHn : prod (P n) (P (S n))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : prod (P 0) (P 1)"
                ],
                "tactic_res": [
                    "c7_goal : P 0",
                    "c8_goal : P 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : P 0",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : P 1",
                    "c2_H1 : P 1",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_IHn : prod (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_HSSn : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_H1 : P 1",
                    "c2_H0 : P 0",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": [
                    "c6_p0 : P (S n)",
                    "c6_p : P n"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c6_goal : prod (P (S n)) (P (S (S n)))"
                ],
                "tactic_res": [
                    "c9_goal : P (S n)",
                    "c10_goal : P (S (S n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : P (S n)",
                    "c6_p0 : P (S n)",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : P (S (S n))",
                    "c6_p0 : P (S n)",
                    "c6_p : P n",
                    "c2_n : nat",
                    "c2_HSSn : forall (n : nat) (_ : P n) (_ : P (S n)), P (S (S n))",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now destruct _i .",
                "tactic_sig_no_out_arg": "now destruct _i .",
                "tactic_args": [
                    "c4_goal : P n",
                    "c4_X : prod (P n) (P (S n))",
                    "c2_n : nat",
                    "c2_P : forall _ : nat, Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fib_SSn",
        "proof": [
            {
                "tactic_sig": "Lemma fib_SSn : forall n : nat , fib ( S ( S n ) ) = fib n + fib ( S n ) .",
                "tactic_sig_no_out_arg": "Lemma fib_SSn : forall n : nat , fib ( S ( S n ) ) = fib n + fib ( S n ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (fib (S (S n))) (Init.Nat.add (fib n) (fib (S n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (fib (S (S n))) (Init.Nat.add (fib n) (fib (S n)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (fib (S (S n))) (Init.Nat.add (fib n) (fib (S n)))",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : eq (fib (S (S n))) (Init.Nat.add (fib n) (fib (S n)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fib_pair_correct",
        "proof": [
            {
                "tactic_sig": "Lemma fib_pair_correct : forall n : nat , fib_pair n = ( fib n , fib ( S n ) ) .",
                "tactic_sig_no_out_arg": "Lemma fib_pair_correct : forall n : nat , fib_pair n = ( fib n , fib ( S n ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (fib_pair n) (pair (fib n) (fib (S n)))"
                ]
            },
            {
                "tactic_sig": "induction n as [ | n IHn ] .",
                "tactic_sig_no_out_arg": "induction n as [ | n IHn ] .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (fib_pair n) (pair (fib n) (fib (S n)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (fib_pair 0) (pair (fib 0) (fib 1))",
                    "c3_goal : eq (fib_pair (S n)) (pair (fib (S n)) (fib (S (S n))))",
                    "c3_IHn : eq (fib_pair n) (pair (fib n) (fib (S n)))",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c2_goal : eq (fib_pair 0) (pair (fib 0) (fib 1))"
                ],
                "tactic_res": [
                    "c4_goal : eq (pair 1 1) (pair 1 1)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c3_goal : eq (fib_pair (S n)) (pair (fib (S n)) (fib (S (S n))))"
                ],
                "tactic_res": [
                    "c5_goal : eq (let (x, y) := fib_pair n in pair y (Init.Nat.add x y))\n  (pair match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end\n     (Init.Nat.add (fib n)\n        match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : eq (pair 1 1) (pair 1 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq (let (x, y) := fib_pair n in pair y (Init.Nat.add x y))\n  (pair match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end\n     (Init.Nat.add (fib n)\n        match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end))",
                    "c3_IHn : eq (fib_pair n) (pair (fib n) (fib (S n)))"
                ],
                "tactic_res": [
                    "c6_goal : eq (pair (fib (S n)) (Init.Nat.add (fib n) (fib (S n))))\n  (pair match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end\n     (Init.Nat.add (fib n)\n        match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c6_goal : eq (pair (fib (S n)) (Init.Nat.add (fib n) (fib (S n))))\n  (pair match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end\n     (Init.Nat.add (fib n)\n        match n with\n        | 0 => 1\n        | S p => Init.Nat.add (fib p) (fib n)\n        end))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "linear_fib_correct",
        "proof": [
            {
                "tactic_sig": "Theorem linear_fib_correct : forall n : nat , linear_fib n = fib n .",
                "tactic_sig_no_out_arg": "Theorem linear_fib_correct : forall n : nat , linear_fib n = fib n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (linear_fib n) (fib n)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (linear_fib n) (fib n)",
                    "_global_linear_fib : forall _ : nat, nat"
                ],
                "tactic_res": [
                    "c2_goal : forall n : nat, eq (fst (fib_pair n)) (fib n)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c2_goal : forall n : nat, eq (fst (fib_pair n)) (fib n)"
                ],
                "tactic_res": [
                    "c3_goal : eq (fst (fib_pair n)) (fib n)",
                    "c3_n : nat"
                ]
            },
            {
                "tactic_sig": "now rewrite fib_pair_correct .",
                "tactic_sig_no_out_arg": "now rewrite fib_pair_correct .",
                "tactic_args": [
                    "c3_goal : eq (fst (fib_pair n)) (fib n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "general_fib_1",
        "proof": [
            {
                "tactic_sig": "Lemma general_fib_1 : forall a b : nat , general_fib a b 1 = b .",
                "tactic_sig_no_out_arg": "Lemma general_fib_1 : forall a b : nat , general_fib a b 1 = b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall a b : nat, eq (general_fib a b 1) b"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall a b : nat, eq (general_fib a b 1) b"
                ],
                "tactic_res": [
                    "c2_goal : eq (general_fib a b 1) b",
                    "c2_a : nat",
                    "c2_b : nat"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : eq (general_fib a b 1) b"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "general_fib_S",
        "proof": [
            {
                "tactic_sig": "Lemma general_fib_S : forall a b n : nat , general_fib a b ( S n ) = general_fib b ( a + b ) n .",
                "tactic_sig_no_out_arg": "Lemma general_fib_S : forall a b n : nat , general_fib a b ( S n ) = general_fib b ( a + b ) n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall a b n : nat,\neq (general_fib a b (S n)) (general_fib b (Init.Nat.add a b) n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall a b n : nat,\neq (general_fib a b (S n)) (general_fib b (Init.Nat.add a b) n)"
                ],
                "tactic_res": [
                    "c2_goal : eq (general_fib a b (S n)) (general_fib b (Init.Nat.add a b) n)",
                    "c2_a : nat",
                    "c2_b : nat",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c2_goal : eq (general_fib a b (S n)) (general_fib b (Init.Nat.add a b) n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "general_fib_2",
        "proof": [
            {
                "tactic_sig": "Lemma general_fib_2 : forall a b n : nat , general_fib a b ( S ( S n ) ) = general_fib a b n + general_fib a b ( S n ) .",
                "tactic_sig_no_out_arg": "Lemma general_fib_2 : forall a b n : nat , general_fib a b ( S ( S n ) ) = general_fib a b n + general_fib a b ( S n ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall a b n : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b n .",
                "tactic_args": [
                    "c1_goal : forall a b n : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ],
                "tactic_res": [
                    "c2_goal : eq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))",
                    "c2_a : nat",
                    "c2_b : nat",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "generalize _i _i .",
                "tactic_sig_no_out_arg": "generalize _i _i .",
                "tactic_args": [
                    "c2_goal : eq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))",
                    "c2_a : nat",
                    "c2_b : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall a b : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | _i IHn ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | _i IHn ] .",
                "tactic_args": [
                    "c3_goal : forall a b : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))",
                    "c2_n : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c4_goal : forall a b : nat,\neq (general_fib a b 2)\n  (Init.Nat.add (general_fib a b 0) (general_fib a b 1))",
                    "c5_goal : forall a b : nat,\neq (general_fib a b (S (S (S n))))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))",
                    "c5_IHn : forall a b : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : forall a b : nat,\neq (general_fib a b 2)\n  (Init.Nat.add (general_fib a b 0) (general_fib a b 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_a : nat",
                    "c2_b : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros a b .",
                "tactic_args": [
                    "c5_goal : forall a b : nat,\neq (general_fib a b (S (S (S n))))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))"
                ],
                "tactic_res": [
                    "c6_goal : eq (general_fib a b (S (S (S n))))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))",
                    "c6_a : nat",
                    "c6_b : nat"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i _i _i ( _i ( _i _i ) ) ) , _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i ( _i ( _i _i ) ) ) , _i .",
                "tactic_args": [
                    "c6_goal : eq (general_fib a b (S (S (S n))))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))",
                    "_global_general_fib_S : forall a b n : nat,\n       eq (general_fib a b (S n)) (general_fib b (Init.Nat.add a b) n)",
                    "_global__ : ?T\nwhere\n?T : [n : nat\n      IHn : forall a b : nat,\n            eq (general_fib a b (S (S n)))\n              (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))\n      a : nat\n      b : nat |- Type]\n?y : [n : nat\n      IHn : forall a b : nat,\n            eq (general_fib a b (S (S n)))\n              (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))\n      a : nat\n      b : nat |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [n : nat\n      IHn : forall a b : nat,\n            eq (general_fib a b (S (S n)))\n              (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))\n      a : nat\n      b : nat |- Type]\n?y : [n : nat\n      IHn : forall a b : nat,\n            eq (general_fib a b (S (S n)))\n              (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))\n      a : nat\n      b : nat |- ?T]",
                    "_global_S : forall _ : nat, nat",
                    "_global_S : forall _ : nat, nat",
                    "c2_n : nat",
                    "c5_IHn : forall a b : nat,\neq (general_fib a b (S (S n)))\n  (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (Init.Nat.add (general_fib b (Init.Nat.add a b) n)\n     (general_fib b (Init.Nat.add a b) (S n)))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))"
                ]
            },
            {
                "tactic_sig": "now rewrite ( general_fib_S _ _ ( S _i ) ) .",
                "tactic_sig_no_out_arg": "now rewrite ( general_fib_S _ _ ( S _i ) ) .",
                "tactic_args": [
                    "c7_goal : eq\n  (Init.Nat.add (general_fib b (Init.Nat.add a b) n)\n     (general_fib b (Init.Nat.add a b) (S n)))\n  (Init.Nat.add (general_fib a b (S n)) (general_fib a b (S (S n))))",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "linear_fibo_equiv",
        "proof": [
            {
                "tactic_sig": "Lemma linear_fibo_equiv : forall n : nat , fib_tail n = fib n .",
                "tactic_sig_no_out_arg": "Lemma linear_fibo_equiv : forall n : nat , fib_tail n = fib n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : nat, eq (fib_tail n) (fib n)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro n .",
                "tactic_args": [
                    "c1_goal : forall n : nat, eq (fib_tail n) (fib n)"
                ],
                "tactic_res": [
                    "c2_goal : eq (fib_tail n) (fib n)",
                    "c2_n : nat"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | | _i IHn IHSn ] using fib_ind .",
                "tactic_sig_no_out_arg": "induction _i as [ | | _i IHn IHSn ] using fib_ind .",
                "tactic_args": [
                    "c2_goal : eq (fib_tail n) (fib n)",
                    "c2_n : nat",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : eq (fib_tail 0) (fib 0)",
                    "c4_goal : eq (fib_tail 1) (fib 1)",
                    "c5_goal : eq (fib_tail (S (S n))) (fib (S (S n)))",
                    "c5_IHSn : eq (fib_tail (S n)) (fib (S n))",
                    "c5_IHn : eq (fib_tail n) (fib n)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : eq (fib_tail 0) (fib 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : eq (fib_tail 1) (fib 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i in * .",
                "tactic_sig_no_out_arg": "unfold _i in * .",
                "tactic_args": [
                    "c5_goal : eq (fib_tail (S (S n))) (fib (S (S n)))",
                    "_global_fib_tail : forall _ : nat, nat"
                ],
                "tactic_res": [
                    "c6_goal : eq (general_fib 1 1 (S (S n))) (fib (S (S n)))",
                    "c6_IHSn : eq (general_fib 1 1 (S n)) (fib (S n))",
                    "c6_IHn : eq (general_fib 1 1 n) (fib n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (general_fib 1 1 (S (S n))) (fib (S (S n)))",
                    "_global_general_fib_2 : forall a b n : nat,\n       eq (general_fib a b (S (S n)))\n         (Init.Nat.add (general_fib a b n) (general_fib a b (S n)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Init.Nat.add (general_fib 1 1 n) (general_fib 1 1 (S n)))\n  (fib (S (S n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (Init.Nat.add (general_fib 1 1 n) (general_fib 1 1 (S n)))\n  (fib (S (S n)))",
                    "c6_IHn : eq (general_fib 1 1 n) (fib n)"
                ],
                "tactic_res": [
                    "c8_goal : eq (Init.Nat.add (fib n) (general_fib 1 1 (S n))) (fib (S (S n)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : eq (Init.Nat.add (fib n) (general_fib 1 1 (S n))) (fib (S (S n)))",
                    "c6_IHSn : eq (general_fib 1 1 (S n)) (fib (S n))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Init.Nat.add (fib n) (fib (S n))) (fib (S (S n)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c9_goal : eq (Init.Nat.add (fib n) (fib (S n))) (fib (S (S n)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "le_add_sub_r",
        "proof": [
            {
                "tactic_sig": "Lemma le_add_sub_r ( n m : nat ) : n <= m -> n + ( m - n ) = m .",
                "tactic_sig_no_out_arg": "Lemma le_add_sub_r ( n m : nat ) : n <= m -> n + ( m - n ) = m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall _ : le n m, eq (Init.Nat.add n (Init.Nat.sub m n)) m",
                    "c1_m : nat",
                    "c1_n : nat"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H .",
                "tactic_args": [
                    "c1_goal : forall _ : le n m, eq (Init.Nat.add n (Init.Nat.sub m n)) m"
                ],
                "tactic_res": [
                    "c2_goal : eq (Init.Nat.add n (Init.Nat.sub m n)) m",
                    "c2_H : le n m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Init.Nat.add n (Init.Nat.sub m n)) m",
                    "_global_Nat.add_comm : forall n m : nat, eq (Nat.add n m) (Nat.add m n)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Nat.add (Init.Nat.sub m n) n) m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq (Nat.add (Init.Nat.sub m n) n) m",
                    "_global_Nat.sub_add : forall (n m : nat) (_ : le n m), eq (Nat.add (Nat.sub m n) n) m"
                ],
                "tactic_res": [
                    "c4_goal : eq m m",
                    "c5_goal : le n m"
                ]
            },
            {
                "tactic_sig": "try assumption .",
                "tactic_sig_no_out_arg": "try assumption .",
                "tactic_args": [
                    "c5_goal : le n m",
                    "c2_H : le n m",
                    "c1_n : nat",
                    "c1_m : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : eq m m"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sub_add",
        "proof": [
            {
                "tactic_sig": "Lemma sub_add ( n m : nat ) : n + m - n = m .",
                "tactic_sig_no_out_arg": "Lemma sub_add ( n m : nat ) : n + m - n = m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : eq (Init.Nat.sub (Init.Nat.add n m) n) m",
                    "c1_m : nat",
                    "c1_n : nat"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c1_goal : eq (Init.Nat.sub (Init.Nat.add n m) n) m",
                    "_global_Nat.add_comm : forall n m : nat, eq (Nat.add n m) (Nat.add m n)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Init.Nat.sub (Nat.add m n) n) m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : eq (Init.Nat.sub (Nat.add m n) n) m",
                    "_global_Nat.add_sub : forall n m : nat, eq (Nat.sub (Nat.add n m) m) n"
                ],
                "tactic_res": [
                    "c3_goal : eq m m"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : eq m m"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transpose_nb_occ",
        "proof": [
            {
                "tactic_sig": "Lemma transpose_nb_occ : forall ( l l' : list A ) , transpose l l' -> forall ( a : A ) , nb_occ a l = nb_occ a l' .",
                "tactic_sig_no_out_arg": "Lemma transpose_nb_occ : forall ( l l' : list A ) , transpose l l' -> forall ( a : A ) , nb_occ a l = nb_occ a l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l l' : list A) (_ : transpose l l') (a : A),\neq (nb_occ a l) (nb_occ a l')",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l l' H .",
                "tactic_args": [
                    "c1_goal : forall (l l' : list A) (_ : transpose l l') (a : A),\neq (nb_occ a l) (nb_occ a l')"
                ],
                "tactic_res": [
                    "c2_goal : forall a : A, eq (nb_occ a l) (nb_occ a l')",
                    "c2_l : list A",
                    "c2_l' : list A",
                    "c2_H : transpose l l'"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall a : A, eq (nb_occ a l) (nb_occ a l')",
                    "c2_H : transpose l l'"
                ],
                "tactic_res": [
                    "c3_goal : forall (a b : A) (l : list A) (a0 : A),\neq (nb_occ a0 (cons a (cons b l))) (nb_occ a0 (cons b (cons a l)))",
                    "c4_goal : forall (a : A) (l l' : list A) (_ : transpose l l')\n  (_ : forall a0 : A, eq (nb_occ a0 l) (nb_occ a0 l')) \n  (a0 : A), eq (nb_occ a0 (cons a l)) (nb_occ a0 (cons a l'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (a b : A) (l : list A) (a0 : A),\neq (nb_occ a0 (cons a (cons b l))) (nb_occ a0 (cons b (cons a l)))"
                ],
                "tactic_res": [
                    "c5_goal : forall (a b : A) (l : list A) (a0 : A),\neq\n  (if A_eq_dec a0 a\n   then S (if A_eq_dec a0 b then S (nb_occ a0 l) else nb_occ a0 l)\n   else if A_eq_dec a0 b then S (nb_occ a0 l) else nb_occ a0 l)\n  (if A_eq_dec a0 b\n   then S (if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)\n   else if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (a : A) (l l' : list A) (_ : transpose l l')\n  (_ : forall a0 : A, eq (nb_occ a0 l) (nb_occ a0 l')) \n  (a0 : A), eq (nb_occ a0 (cons a l)) (nb_occ a0 (cons a l'))"
                ],
                "tactic_res": [
                    "c6_goal : forall (a : A) (l l' : list A) (_ : transpose l l')\n  (_ : forall a0 : A, eq (nb_occ a0 l) (nb_occ a0 l')) \n  (a0 : A),\neq (if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)\n  (if A_eq_dec a0 a then S (nb_occ a0 l') else nb_occ a0 l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b l0 x .",
                "tactic_args": [
                    "c5_goal : forall (a b : A) (l : list A) (a0 : A),\neq\n  (if A_eq_dec a0 a\n   then S (if A_eq_dec a0 b then S (nb_occ a0 l) else nb_occ a0 l)\n   else if A_eq_dec a0 b then S (nb_occ a0 l) else nb_occ a0 l)\n  (if A_eq_dec a0 b\n   then S (if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)\n   else if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (if A_eq_dec x a\n   then S (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n   else if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x b\n   then S (if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)\n   else if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)",
                    "c7_a : A",
                    "c7_b : A",
                    "c7_l0 : list A",
                    "c7_x : A"
                ]
            },
            {
                "tactic_sig": "case ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i _i ) .",
                "tactic_args": [
                    "c7_goal : eq\n  (if A_eq_dec x a\n   then S (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n   else if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x b\n   then S (if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)\n   else if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c7_x : A",
                    "c7_a : A"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq x a,\neq (S (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0))\n  (if A_eq_dec x b then S (S (nb_occ x l0)) else S (nb_occ x l0))",
                    "c9_goal : forall _ : not (eq x a),\neq (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)"
                ]
            },
            {
                "tactic_sig": "case ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i _i ) .",
                "tactic_args": [
                    "c8_goal : forall _ : eq x a,\neq (S (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0))\n  (if A_eq_dec x b then S (S (nb_occ x l0)) else S (nb_occ x l0))",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c7_x : A",
                    "c7_b : A"
                ],
                "tactic_res": [
                    "c10_goal : forall (_ : eq x b) (_ : eq x a),\neq (S (S (nb_occ x l0))) (S (S (nb_occ x l0)))",
                    "c11_goal : forall (_ : not (eq x b)) (_ : eq x a),\neq (S (nb_occ x l0)) (S (nb_occ x l0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : forall (_ : eq x b) (_ : eq x a),\neq (S (S (nb_occ x l0))) (S (S (nb_occ x l0)))",
                    "c7_x : A",
                    "c7_l0 : list A",
                    "c7_a : A",
                    "c7_b : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : forall (_ : not (eq x b)) (_ : eq x a),\neq (S (nb_occ x l0)) (S (nb_occ x l0))",
                    "c7_x : A",
                    "c7_l0 : list A",
                    "c7_a : A",
                    "c7_b : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i _i ) .",
                "tactic_args": [
                    "c9_goal : forall _ : not (eq x a),\neq (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x b then S (nb_occ x l0) else nb_occ x l0)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c7_x : A",
                    "c7_b : A"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : eq x b) (_ : not (eq x a)),\neq (S (nb_occ x l0)) (S (nb_occ x l0))",
                    "c13_goal : forall (_ : not (eq x b)) (_ : not (eq x a)),\neq (nb_occ x l0) (nb_occ x l0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : forall (_ : eq x b) (_ : not (eq x a)),\neq (S (nb_occ x l0)) (S (nb_occ x l0))",
                    "c7_x : A",
                    "c7_l0 : list A",
                    "c7_a : A",
                    "c7_b : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall (_ : not (eq x b)) (_ : not (eq x a)),\neq (nb_occ x l0) (nb_occ x l0)",
                    "c7_x : A",
                    "c7_l0 : list A",
                    "c7_a : A",
                    "c7_b : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l0 l'0 H0 H1 x .",
                "tactic_args": [
                    "c6_goal : forall (a : A) (l l' : list A) (_ : transpose l l')\n  (_ : forall a0 : A, eq (nb_occ a0 l) (nb_occ a0 l')) \n  (a0 : A),\neq (if A_eq_dec a0 a then S (nb_occ a0 l) else nb_occ a0 l)\n  (if A_eq_dec a0 a then S (nb_occ a0 l') else nb_occ a0 l')"
                ],
                "tactic_res": [
                    "c14_goal : eq (if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x a then S (nb_occ x l'0) else nb_occ x l'0)",
                    "c14_a : A",
                    "c14_l0 : list A",
                    "c14_l'0 : list A",
                    "c14_H0 : transpose l0 l'0",
                    "c14_H1 : forall a : A, eq (nb_occ a l0) (nb_occ a l'0)",
                    "c14_x : A"
                ]
            },
            {
                "tactic_sig": "case ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "case ( _i _i _i ) .",
                "tactic_args": [
                    "c14_goal : eq (if A_eq_dec x a then S (nb_occ x l0) else nb_occ x l0)\n  (if A_eq_dec x a then S (nb_occ x l'0) else nb_occ x l'0)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c14_x : A",
                    "c14_a : A"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq x a, eq (S (nb_occ x l0)) (S (nb_occ x l'0))",
                    "c16_goal : forall _ : not (eq x a), eq (nb_occ x l0) (nb_occ x l'0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : forall _ : eq x a, eq (S (nb_occ x l0)) (S (nb_occ x l'0))",
                    "c14_x : A",
                    "c14_H1 : forall a : A, eq (nb_occ a l0) (nb_occ a l'0)",
                    "c14_l0 : list A",
                    "c14_l'0 : list A",
                    "c14_a : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : forall _ : not (eq x a), eq (nb_occ x l0) (nb_occ x l'0)",
                    "c14_x : A",
                    "c14_H1 : forall a : A, eq (nb_occ a l0) (nb_occ a l'0)",
                    "c14_l0 : list A",
                    "c14_l'0 : list A",
                    "c14_a : A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "perm_nb_occ",
        "proof": [
            {
                "tactic_sig": "Lemma perm_nb_occ : forall ( l l' : list A ) , perm l l' -> forall ( a : A ) , nb_occ a l = nb_occ a l' .",
                "tactic_sig_no_out_arg": "Lemma perm_nb_occ : forall ( l l' : list A ) , perm l l' -> forall ( a : A ) , nb_occ a l = nb_occ a l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l l' : list A) (_ : perm l l') (a : A),\neq (nb_occ a l) (nb_occ a l')",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l l' H .",
                "tactic_args": [
                    "c1_goal : forall (l l' : list A) (_ : perm l l') (a : A),\neq (nb_occ a l) (nb_occ a l')"
                ],
                "tactic_res": [
                    "c2_goal : forall a : A, eq (nb_occ a l) (nb_occ a l')",
                    "c2_l : list A",
                    "c2_l' : list A",
                    "c2_H : perm l l'"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall a : A, eq (nb_occ a l) (nb_occ a l')",
                    "c2_H : perm l l'"
                ],
                "tactic_res": [
                    "c3_goal : forall a : A, eq (nb_occ a l) (nb_occ a l)",
                    "c4_goal : forall (l' l'' : list A) (_ : perm l l')\n  (_ : forall a : A, eq (nb_occ a l) (nb_occ a l'))\n  (_ : transpose l' l'') (a : A), eq (nb_occ a l) (nb_occ a l'')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall a : A, eq (nb_occ a l) (nb_occ a l)",
                    "c2_l : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l'0 .",
                "tactic_args": [
                    "c4_goal : forall (l' l'' : list A) (_ : perm l l')\n  (_ : forall a : A, eq (nb_occ a l) (nb_occ a l'))\n  (_ : transpose l' l'') (a : A), eq (nb_occ a l) (nb_occ a l'')"
                ],
                "tactic_res": [
                    "c5_goal : forall (l'' : list A) (_ : perm l l'0)\n  (_ : forall a : A, eq (nb_occ a l) (nb_occ a l'0))\n  (_ : transpose l'0 l'') (a : A), eq (nb_occ a l) (nb_occ a l'')",
                    "c5_l'0 : list A"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (l'' : list A) (_ : perm l l'0)\n  (_ : forall a : A, eq (nb_occ a l) (nb_occ a l'0))\n  (_ : transpose l'0 l'') (a : A), eq (nb_occ a l) (nb_occ a l'')"
                ],
                "tactic_res": [
                    "c6_goal : eq (nb_occ a l) (nb_occ a l'')",
                    "c6_l'' : list A",
                    "c6_H0 : perm l l'0",
                    "c6_H1 : forall a : A, eq (nb_occ a l) (nb_occ a l'0)",
                    "c6_H2 : transpose l'0 l''",
                    "c6_a : A"
                ]
            },
            {
                "tactic_sig": "transitivity ( nb_occ _i _i ) .",
                "tactic_sig_no_out_arg": "transitivity ( nb_occ _i _i ) .",
                "tactic_args": [
                    "c6_goal : eq (nb_occ a l) (nb_occ a l'')",
                    "c6_a : A",
                    "c5_l'0 : list A"
                ],
                "tactic_res": [
                    "c7_goal : eq (nb_occ a l) (nb_occ a l'0)",
                    "c8_goal : eq (nb_occ a l'0) (nb_occ a l'')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (nb_occ a l) (nb_occ a l'0)",
                    "c6_a : A",
                    "c6_H1 : forall a : A, eq (nb_occ a l) (nb_occ a l'0)",
                    "c5_l'0 : list A",
                    "c2_l : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq (nb_occ a l'0) (nb_occ a l'')",
                    "_global_transpose_nb_occ : forall (l l' : list A) (_ : transpose l l') (a : A),\n       eq (nb_occ a l) (nb_occ a l')"
                ],
                "tactic_res": [
                    "c9_goal : transpose l'0 l''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : transpose l'0 l''",
                    "c6_H2 : transpose l'0 l''",
                    "c5_l'0 : list A",
                    "c6_l'' : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eq_nat_bool_false",
        "proof": [
            {
                "tactic_sig": "Theorem eq_nat_bool_false : forall n1 n2 , Nat.eqb n1 n2 = false -> n1 <> n2 .",
                "tactic_sig_no_out_arg": "Theorem eq_nat_bool_false : forall n1 n2 , Nat.eqb n1 n2 = false -> n1 <> n2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n1 n2 : nat) (_ : eq (Nat.eqb n1 n2) false), not (eq n1 n2)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "induction n1 .",
                "tactic_sig_no_out_arg": "induction n1 .",
                "tactic_args": [
                    "c1_goal : forall (n1 n2 : nat) (_ : eq (Nat.eqb n1 n2) false), not (eq n1 n2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (n2 : nat) (_ : eq (Nat.eqb 0 n2) false), not (eq 0 n2)",
                    "c3_goal : forall (n2 : nat) (_ : eq (Nat.eqb (S n1) n2) false),\nnot (eq (S n1) n2)",
                    "c3_IHn1 : forall (n2 : nat) (_ : eq (Nat.eqb n1 n2) false), not (eq n1 n2)",
                    "c3_n1 : nat"
                ]
            },
            {
                "tactic_sig": "destruct n2 as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct n2 .",
                "tactic_args": [
                    "c2_goal : forall (n2 : nat) (_ : eq (Nat.eqb 0 n2) false), not (eq 0 n2)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (Nat.eqb 0 0) false, not (eq 0 0)",
                    "c5_goal : forall _ : eq (Nat.eqb 0 (S n2)) false, not (eq 0 (S n2))",
                    "c5_n2 : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (Nat.eqb 0 0) false, not (eq 0 0)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq true false, not (eq 0 0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall _ : eq true false, not (eq 0 0)"
                ],
                "tactic_res": [
                    "c7_goal : not (eq 0 0)",
                    "c7_H : eq true false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c7_goal : not (eq 0 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall _ : eq (Nat.eqb 0 (S n2)) false, not (eq 0 (S n2))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq false false, not (eq 0 (S n2))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall _ : eq false false, not (eq 0 (S n2))"
                ],
                "tactic_res": [
                    "c9_goal : not (eq 0 (S n2))",
                    "c9_H : eq false false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c9_goal : not (eq 0 (S n2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct n2 as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct n2 .",
                "tactic_args": [
                    "c3_goal : forall (n2 : nat) (_ : eq (Nat.eqb (S n1) n2) false),\nnot (eq (S n1) n2)",
                    "c3_IHn1 : forall (n2 : nat) (_ : eq (Nat.eqb n1 n2) false), not (eq n1 n2)",
                    "c3_n1 : nat",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq (Nat.eqb (S n1) 0) false, not (eq (S n1) 0)",
                    "c11_goal : forall _ : eq (Nat.eqb (S n1) (S n2)) false, not (eq (S n1) (S n2))",
                    "c11_n2 : nat"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall _ : eq (Nat.eqb (S n1) 0) false, not (eq (S n1) 0)"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq false false, not (eq (S n1) 0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall _ : eq false false, not (eq (S n1) 0)"
                ],
                "tactic_res": [
                    "c13_goal : not (eq (S n1) 0)",
                    "c13_H : eq false false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c13_goal : not (eq (S n1) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : forall _ : eq (Nat.eqb (S n1) (S n2)) false, not (eq (S n1) (S n2))"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : eq (Nat.eqb n1 n2) false, not (eq (S n1) (S n2))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall _ : eq (Nat.eqb n1 n2) false, not (eq (S n1) (S n2))"
                ],
                "tactic_res": [
                    "c15_goal : not (eq (S n1) (S n2))",
                    "c15_H : eq (Nat.eqb n1 n2) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : not (eq (S n1) (S n2))",
                    "c15_H : eq (Nat.eqb n1 n2) false",
                    "c11_n2 : nat",
                    "c3_IHn1 : forall (n2 : nat) (_ : eq (Nat.eqb n1 n2) false), not (eq n1 n2)",
                    "c3_n1 : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "check_all_occs_false",
        "proof": [
            {
                "tactic_sig": "Theorem check_all_occs_false : forall l1 l2 l3 , check_all_occs l1 l2 l3 = false -> ( exists a : A , nb_occ a l1 <> nb_occ a l2 ) .",
                "tactic_sig_no_out_arg": "Theorem check_all_occs_false : forall l1 l2 l3 , check_all_occs l1 l2 l3 = false -> ( exists a : A , nb_occ a l1 <> nb_occ a l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 l3 : list A) (_ : eq (check_all_occs l1 l2 l3) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "simple induction l3 .",
                "tactic_sig_no_out_arg": "simple induction l3 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 l3 : list A) (_ : eq (check_all_occs l1 l2 l3) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (check_all_occs l1 l2 nil) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c2_l3 : list A",
                    "c2_l2 : list A",
                    "c2_l1 : list A",
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall _ : eq (check_all_occs l1 l2 l) false,\n       ex (fun a0 : A => not (eq (nb_occ a0 l1) (nb_occ a0 l2))))\n  (_ : eq (check_all_occs l1 l2 (cons a l)) false),\nex (fun a0 : A => not (eq (nb_occ a0 l1) (nb_occ a0 l2)))",
                    "c3_l3 : list A",
                    "c3_l2 : list A",
                    "c3_l1 : list A"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (check_all_occs l1 l2 nil) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq true false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : eq true false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": [
                    "c5_goal : ex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c5_H : eq true false"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : ex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n l IHl .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall _ : eq (check_all_occs l1 l2 l) false,\n       ex (fun a0 : A => not (eq (nb_occ a0 l1) (nb_occ a0 l2))))\n  (_ : eq (check_all_occs l1 l2 (cons a l)) false),\nex (fun a0 : A => not (eq (nb_occ a0 l1) (nb_occ a0 l2)))"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq (check_all_occs l1 l2 (cons n l)) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_n : A",
                    "c6_l : list A",
                    "c6_IHl : forall _ : eq (check_all_occs l1 l2 l) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall _ : eq (check_all_occs l1 l2 (cons n l)) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : eq\n        (if Nat.eqb (nb_occ n l1) (nb_occ n l2)\n         then check_all_occs l1 l2 l\n         else false) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ]
            },
            {
                "tactic_sig": "generalize ( @eq_nat_bool_false ( nb_occ _i _i ) ( nb_occ _i _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( @eq_nat_bool_false ( nb_occ _i _i ) ( nb_occ _i _i ) ) .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : eq\n        (if Nat.eqb (nb_occ n l1) (nb_occ n l2)\n         then check_all_occs l1 l2 l\n         else false) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_n : A",
                    "c3_l1 : list A",
                    "c6_n : A",
                    "c3_l2 : list A"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  (_ : forall _ : eq (Nat.eqb (nb_occ n l1) (nb_occ n l2)) false,\n       not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq\n         (if Nat.eqb (nb_occ n l1) (nb_occ n l2)\n          then check_all_occs l1 l2 l\n          else false) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ]
            },
            {
                "tactic_sig": "case ( Nat.eqb ( nb_occ _i _i ) ( nb_occ _i _i ) ) .",
                "tactic_sig_no_out_arg": "case ( Nat.eqb ( nb_occ _i _i ) ( nb_occ _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : forall\n  (_ : forall _ : eq (Nat.eqb (nb_occ n l1) (nb_occ n l2)) false,\n       not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq\n         (if Nat.eqb (nb_occ n l1) (nb_occ n l2)\n          then check_all_occs l1 l2 l\n          else false) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_n : A",
                    "c3_l1 : list A",
                    "c6_n : A",
                    "c3_l2 : list A"
                ],
                "tactic_res": [
                    "c9_goal : forall\n  (_ : forall _ : eq true false, not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq (check_all_occs l1 l2 l) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c10_goal : forall\n  (_ : forall _ : eq false false, not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq false false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall\n  (_ : forall _ : eq true false, not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq (check_all_occs l1 l2 l) false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_IHl : forall _ : eq (check_all_occs l1 l2 l) false,\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_l : list A",
                    "c6_n : A",
                    "c3_l1 : list A",
                    "c3_l2 : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall\n  (_ : forall _ : eq false false, not (eq (nb_occ n l1) (nb_occ n l2)))\n  (_ : eq false false),\nex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))"
                ],
                "tactic_res": [
                    "c11_goal : ex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c11_H : forall _ : eq false false, not (eq (nb_occ n l1) (nb_occ n l2))",
                    "c11_H0 : eq false false"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : ex (fun a : A => not (eq (nb_occ a l1) (nb_occ a l2)))",
                    "c6_n : A"
                ],
                "tactic_res": [
                    "c12_goal : not (eq (nb_occ n l1) (nb_occ n l2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : not (eq (nb_occ n l1) (nb_occ n l2))",
                    "c11_H : forall _ : eq false false, not (eq (nb_occ n l1) (nb_occ n l2))",
                    "c6_n : A",
                    "c3_l1 : list A",
                    "c3_l2 : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "check_all_occs_not_perm",
        "proof": [
            {
                "tactic_sig": "Theorem check_all_occs_not_perm : forall l1 l2 , check_all_occs l1 l2 l1 = false -> ~ perm l1 l2 .",
                "tactic_sig_no_out_arg": "Theorem check_all_occs_not_perm : forall l1 l2 , check_all_occs l1 l2 l1 = false -> ~ perm l1 l2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list A) (_ : eq (check_all_occs l1 l2 l1) false),\nnot (perm l1 l2)",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 Heq Hperm .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list A) (_ : eq (check_all_occs l1 l2 l1) false),\nnot (perm l1 l2)"
                ],
                "tactic_res": [
                    "c2_goal : False",
                    "c2_l1 : list A",
                    "c2_l2 : list A",
                    "c2_Heq : eq (check_all_occs l1 l2 l1) false",
                    "c2_Hperm : perm l1 l2"
                ]
            },
            {
                "tactic_sig": "elim ( check_all_occs_false _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "elim ( check_all_occs_false _i _i _i _i ) .",
                "tactic_args": [
                    "c2_goal : False",
                    "c2_l1 : list A",
                    "c2_l2 : list A",
                    "c2_l1 : list A",
                    "c2_Heq : eq (check_all_occs l1 l2 l1) false"
                ],
                "tactic_res": [
                    "c3_goal : forall (x : A) (_ : not (eq (nb_occ x l1) (nb_occ x l2))), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n Hneq .",
                "tactic_args": [
                    "c3_goal : forall (x : A) (_ : not (eq (nb_occ x l1) (nb_occ x l2))), False"
                ],
                "tactic_res": [
                    "c4_goal : False",
                    "c4_n : A",
                    "c4_Hneq : not (eq (nb_occ n l1) (nb_occ n l2))"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c4_goal : False",
                    "c4_Hneq : not (eq (nb_occ n l1) (nb_occ n l2))"
                ],
                "tactic_res": [
                    "c5_goal : eq (nb_occ n l1) (nb_occ n l2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (nb_occ n l1) (nb_occ n l2)",
                    "_global_perm_nb_occ : forall (l l' : list A) (_ : perm l l') (a : A),\n       eq (nb_occ a l) (nb_occ a l')"
                ],
                "tactic_res": [
                    "c6_goal : perm l1 l2"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c6_goal : perm l1 l2",
                    "c2_Hperm : perm l1 l2",
                    "c2_l1 : list A",
                    "c2_l2 : list A",
                    "c1_A_eq_dec : forall a b : A, sumbool (eq a b) (not (eq a b))",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    }
]