[
    {
        "lemma_name": "immsafe_frame",
        "proof": [
            {
                "tactic_sig": "Lemma immsafe_frame : forall h' c h , immsafe ( c , h ) -> hdisjoint h h' -> immsafe ( c , hunion h h' ) .",
                "tactic_sig_no_out_arg": "Lemma immsafe_frame : forall h' c h , immsafe ( c , h ) -> hdisjoint h h' -> immsafe ( c , hunion h h' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h' : heap) (c : com) (h : heap) (_ : immsafe (pair c h))\n  (_ : hdisjoint h h'), immsafe (pair c (hunion h h'))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros h' c h IMM .",
                "tactic_args": [
                    "c1_goal : forall (h' : heap) (c : com) (h : heap) (_ : immsafe (pair c h))\n  (_ : hdisjoint h h'), immsafe (pair c (hunion h h'))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : hdisjoint h h', immsafe (pair c (hunion h h'))",
                    "c2_h' : heap",
                    "c2_c : com",
                    "c2_h : heap",
                    "c2_IMM : immsafe (pair c h)"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c2_goal : forall _ : hdisjoint h h', immsafe (pair c (hunion h h'))",
                    "c2_IMM : immsafe (pair c h)"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : hdisjoint h h', immsafe (pair (PURE v) (hunion h h'))",
                    "c3_v : Z",
                    "c4_goal : forall _ : hdisjoint h h', immsafe (pair (LET c0 f) (hunion h h'))",
                    "c4_IHIMM : forall (c : com) (h0 : heap) (_ : eq (pair c0 h) (pair c h0))\n  (_ : hdisjoint h0 h'), immsafe (pair c (hunion h0 h'))",
                    "c4_IMM : immsafe (pair c0 h)",
                    "c4_f : forall _ : Z, com",
                    "c4_c0 : com",
                    "c5_goal : forall _ : hdisjoint h h',\nimmsafe (pair (IFTHENELSE b c1 c2) (hunion h h'))",
                    "c5_c2 : com",
                    "c5_c1 : com",
                    "c5_b : Z",
                    "c6_goal : forall _ : hdisjoint h h', immsafe (pair (ALLOC sz) (hunion h h'))",
                    "c6_H0 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None",
                    "c6_H : not (eq l 0)",
                    "c6_l : Z",
                    "c6_sz : nat",
                    "c7_goal : forall _ : hdisjoint h h', immsafe (pair (GET l) (hunion h h'))",
                    "c7_H : not (eq (h l) None)",
                    "c7_l : addr",
                    "c8_goal : forall _ : hdisjoint h h', immsafe (pair (SET l v) (hunion h h'))",
                    "c8_H : not (eq (h l) None)",
                    "c8_v : Z",
                    "c8_l : addr",
                    "c9_goal : forall _ : hdisjoint h h', immsafe (pair (FREE l) (hunion h h'))",
                    "c9_H : not (eq (h l) None)",
                    "c9_l : addr",
                    "c10_goal : forall _ : hdisjoint h h', immsafe (pair (PICK n) (hunion h h'))",
                    "c10_n : Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c3_goal : forall _ : hdisjoint h h', immsafe (pair (PURE v) (hunion h h'))"
                ],
                "tactic_res": [
                    "c11_goal : immsafe (pair (PURE v) (hunion h h'))",
                    "c11_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c4_goal : forall _ : hdisjoint h h', immsafe (pair (LET c0 f) (hunion h h'))"
                ],
                "tactic_res": [
                    "c12_goal : immsafe (pair (LET c0 f) (hunion h h'))",
                    "c12_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c5_goal : forall _ : hdisjoint h h',\nimmsafe (pair (IFTHENELSE b c1 c2) (hunion h h'))"
                ],
                "tactic_res": [
                    "c13_goal : immsafe (pair (IFTHENELSE b c1 c2) (hunion h h'))",
                    "c13_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c6_goal : forall _ : hdisjoint h h', immsafe (pair (ALLOC sz) (hunion h h'))"
                ],
                "tactic_res": [
                    "c14_goal : immsafe (pair (ALLOC sz) (hunion h h'))",
                    "c14_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c7_goal : forall _ : hdisjoint h h', immsafe (pair (GET l) (hunion h h'))"
                ],
                "tactic_res": [
                    "c15_goal : immsafe (pair (GET l) (hunion h h'))",
                    "c15_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c8_goal : forall _ : hdisjoint h h', immsafe (pair (SET l v) (hunion h h'))"
                ],
                "tactic_res": [
                    "c16_goal : immsafe (pair (SET l v) (hunion h h'))",
                    "c16_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c9_goal : forall _ : hdisjoint h h', immsafe (pair (FREE l) (hunion h h'))"
                ],
                "tactic_res": [
                    "c17_goal : immsafe (pair (FREE l) (hunion h h'))",
                    "c17_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c10_goal : forall _ : hdisjoint h h', immsafe (pair (PICK n) (hunion h h'))"
                ],
                "tactic_res": [
                    "c18_goal : immsafe (pair (PICK n) (hunion h h'))",
                    "c18_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : immsafe (pair (PURE v) (hunion h h'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : immsafe (pair (LET c0 f) (hunion h h'))"
                ],
                "tactic_res": [
                    "c19_goal : immsafe (pair c0 (hunion h h'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : immsafe (pair c0 (hunion h h'))",
                    "c12_DISJ : hdisjoint h h'",
                    "c4_IHIMM : forall (c : com) (h0 : heap) (_ : eq (pair c0 h) (pair c h0))\n  (_ : hdisjoint h0 h'), immsafe (pair c (hunion h0 h'))",
                    "c2_h : heap",
                    "c4_c0 : com",
                    "c2_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c13_goal : immsafe (pair (IFTHENELSE b c1 c2) (hunion h h'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( isfinite ( hunion _i _i ) ) as [ l' FIN ] .",
                "tactic_sig_no_out_arg": "destruct ( isfinite ( hunion _i _i ) ) as [ l' FIN ] .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_h' : heap",
                    "c14_DISJ : hdisjoint h h'",
                    "c6_H0 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None",
                    "c6_H : not (eq l 0)",
                    "c6_sz : nat"
                ],
                "tactic_res": [
                    "c14_FIN : forall (j : Z) (_ : Z.le l' j), eq (hunion h h' j) None",
                    "c14_l' : Z"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i 1 _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i 1 _i ) .",
                "tactic_args": [
                    "c14_goal : immsafe (pair (ALLOC sz) (hunion h h'))",
                    "_global_immsafe_alloc : forall (sz : nat) (h : heap) (l : Z) (_ : not (eq l 0))\n         (_ : forall (i : Z)\n                (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n              eq (h i) None), immsafe (pair (ALLOC sz) h)",
                    "_global_Z.max : forall (_ : Z) (_ : Z), Z",
                    "c14_l' : Z"
                ],
                "tactic_res": [
                    "c20_goal : not (eq (Z.max 1 l') 0)",
                    "c21_goal : forall (i : Z)\n  (_ : and (Z.le (Z.max 1 l') i)\n         (Z.lt i (Z.add (Z.max 1 l') (Z.of_nat sz)))),\neq (hunion h h' i) None"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c20_goal : not (eq (Z.max 1 l') 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (i : Z)\n  (_ : and (Z.le (Z.max 1 l') i)\n         (Z.lt i (Z.add (Z.max 1 l') (Z.of_nat sz)))),\neq (hunion h h' i) None"
                ],
                "tactic_res": [
                    "c22_goal : eq (hunion h h' i) None",
                    "c22_i : Z",
                    "c22_H1 : and (Z.le (Z.max 1 l') i) (Z.lt i (Z.add (Z.max 1 l') (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : eq (hunion h h' i) None",
                    "c14_FIN : forall (j : Z) (_ : Z.le l' j), eq (hunion h h' j) None"
                ],
                "tactic_res": [
                    "c23_goal : Z.le l' i"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c23_goal : Z.le l' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c15_goal : immsafe (pair (GET l) (hunion h h'))"
                ],
                "tactic_res": [
                    "c24_goal : not (eq (hunion h h' l) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c24_goal : not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c25_goal : not (eq (if h l then h l else h' l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c25_goal : not (eq (if h l then h l else h' l) None)",
                    "c2_h : heap",
                    "c7_l : addr",
                    "c15_DISJ : hdisjoint h h'",
                    "c7_H : not (eq (h l) None)",
                    "c2_h' : heap"
                ],
                "tactic_res": [
                    "c26_goal : not (eq (Some z) None)",
                    "c26_H : not (eq (Some z) None)",
                    "c26_z : Z",
                    "c27_goal : not (eq (h' l) None)",
                    "c27_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c26_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c27_goal : not (eq (h' l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : immsafe (pair (SET l v) (hunion h h'))"
                ],
                "tactic_res": [
                    "c28_goal : not (eq (hunion h h' l) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c28_goal : not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c29_goal : not (eq (if h l then h l else h' l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c29_goal : not (eq (if h l then h l else h' l) None)",
                    "c2_h : heap",
                    "c8_l : addr",
                    "c16_DISJ : hdisjoint h h'",
                    "c8_H : not (eq (h l) None)",
                    "c8_v : Z",
                    "c2_h' : heap"
                ],
                "tactic_res": [
                    "c30_goal : not (eq (Some z) None)",
                    "c30_H : not (eq (Some z) None)",
                    "c30_z : Z",
                    "c31_goal : not (eq (h' l) None)",
                    "c31_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c30_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c31_goal : not (eq (h' l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c17_goal : immsafe (pair (FREE l) (hunion h h'))"
                ],
                "tactic_res": [
                    "c32_goal : not (eq (hunion h h' l) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c32_goal : not (eq (hunion h h' l) None)"
                ],
                "tactic_res": [
                    "c33_goal : not (eq (if h l then h l else h' l) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c33_goal : not (eq (if h l then h l else h' l) None)",
                    "c2_h : heap",
                    "c9_l : addr",
                    "c17_DISJ : hdisjoint h h'",
                    "c9_H : not (eq (h l) None)",
                    "c2_h' : heap"
                ],
                "tactic_res": [
                    "c34_goal : not (eq (Some z) None)",
                    "c34_H : not (eq (Some z) None)",
                    "c34_z : Z",
                    "c35_goal : not (eq (h' l) None)",
                    "c35_H : not (eq None None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c34_goal : not (eq (Some z) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c35_goal : not (eq (h' l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c18_goal : immsafe (pair (PICK n) (hunion h h'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "red_frame",
        "proof": [
            {
                "tactic_sig": "Lemma red_frame : forall h2 c h1 c' h' , red ( c , hunion h1 h2 ) ( c' , h' ) -> immsafe ( c , h1 ) -> hdisjoint h1 h2 -> exists h1' , red ( c , h1 ) ( c' , h1' ) /\\ hdisjoint h1' h2 /\\ h' = hunion h1' h2 .",
                "tactic_sig_no_out_arg": "Lemma red_frame : forall h2 c h1 c' h' , red ( c , hunion h1 h2 ) ( c' , h' ) -> immsafe ( c , h1 ) -> hdisjoint h1 h2 -> exists h1' , red ( c , h1 ) ( c' , h1' ) /\\ hdisjoint h1' h2 /\\ h' = hunion h1' h2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (h2 : heap) (c : com) (h1 : heap) (c' : com) \n  (h' : heap) (_ : red (pair c (hunion h1 h2)) (pair c' h'))\n  (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until h' .",
                "tactic_args": [
                    "c1_goal : forall (h2 : heap) (c : com) (h1 : heap) (c' : com) \n  (h' : heap) (_ : red (pair c (hunion h1 h2)) (pair c' h'))\n  (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : red (pair c (hunion h1 h2)) (pair c' h'))\n  (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c2_h' : heap",
                    "c2_c' : com",
                    "c2_h1 : heap",
                    "c2_c : com",
                    "c2_h2 : heap"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros RED .",
                "tactic_args": [
                    "c2_goal : forall (_ : red (pair c (hunion h1 h2)) (pair c' h'))\n  (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c3_RED : red (pair c (hunion h1 h2)) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "dependent induction _i .",
                "tactic_sig_no_out_arg": "dependent induction _i .",
                "tactic_args": [
                    "c3_goal : forall (_ : immsafe (pair c h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair c h1) (pair c' h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c3_RED : red (pair c (hunion h1 h2)) (pair c' h')"
                ],
                "tactic_res": [
                    "c4_goal : forall (_ : immsafe (pair (PICK n) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (PICK n) h1) (pair (PURE i) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c4_H : and (Z.le 0 i) (Z.lt i n)",
                    "c4_i : Z",
                    "c4_n : Z",
                    "c5_goal : forall (_ : immsafe (pair (LET (PURE x) f) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (LET (PURE x) f) h1) (pair (f x) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c5_f : forall _ : Z, com",
                    "c5_x : Z",
                    "c6_goal : forall (_ : immsafe (pair (LET c0 f) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c6_IHRED : forall (h3 : heap) (c : com) (h4 : heap) (c' : com) \n  (h'0 : heap)\n  (_ : eq (pair c0 (hunion h1 h2)) (pair c (hunion h4 h3)))\n  (_ : eq (pair c'0 h') (pair c' h'0)) (_ : immsafe (pair c h4))\n  (_ : hdisjoint h4 h3),\nex\n  (fun h1' : heap =>\n   and (red (pair c h4) (pair c' h1'))\n     (and (hdisjoint h1' h3) (eq h'0 (hunion h1' h3))))",
                    "c6_RED : red (pair c0 (hunion h1 h2)) (pair c'0 h')",
                    "c6_c'0 : com",
                    "c6_f : forall _ : Z, com",
                    "c6_c0 : com",
                    "c7_goal : forall (_ : immsafe (pair (IFTHENELSE b c1 c2) h1))\n  (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and\n     (red (pair (IFTHENELSE b c1 c2) h1)\n        (pair (if Z.eqb b 0 then c2 else c1) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c7_c2 : com",
                    "c7_c1 : com",
                    "c7_b : Z",
                    "c8_goal : forall (_ : immsafe (pair (ALLOC sz) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (ALLOC sz) h1) (pair (PURE l) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hinit l sz (hunion h1 h2)) (hunion h1' h2))))",
                    "c8_H0 : not (eq l 0)",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c9_goal : forall (_ : immsafe (pair (GET l) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (GET l) h1) (pair (PURE v) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c9_H : eq (hunion h1 h2 l) (Some v)",
                    "c9_v : Z",
                    "c9_l : addr",
                    "c10_goal : forall (_ : immsafe (pair (SET l v) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (SET l v) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hupdate l v (hunion h1 h2)) (hunion h1' h2))))",
                    "c10_H : not (eq (hunion h1 h2 l) None)",
                    "c10_v : Z",
                    "c10_l : addr",
                    "c11_goal : forall (_ : immsafe (pair (FREE l) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (FREE l) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hfree l (hunion h1 h2)) (hunion h1' h2))))",
                    "c11_H : not (eq (hunion h1 h2 l) None)",
                    "c11_l : addr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c4_goal : forall (_ : immsafe (pair (PICK n) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (PICK n) h1) (pair (PURE i) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c12_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (PICK n) h1) (pair (PURE i) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c12_IMM : immsafe (pair (PICK n) h1)",
                    "c12_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_IMM : immsafe (pair (PICK n) h1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c5_goal : forall (_ : immsafe (pair (LET (PURE x) f) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (LET (PURE x) f) h1) (pair (f x) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET (PURE x) f) h1) (pair (f x) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c13_IMM : immsafe (pair (LET (PURE x) f) h1)",
                    "c13_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_IMM : immsafe (pair (LET (PURE x) f) h1)"
                ],
                "tactic_res": [
                    "c13_H0 : immsafe (pair (PURE x) h1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c6_goal : forall (_ : immsafe (pair (LET c0 f) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c14_IMM : immsafe (pair (LET c0 f) h1)",
                    "c14_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_IMM : immsafe (pair (LET c0 f) h1)"
                ],
                "tactic_res": [
                    "c14_H0 : immsafe (pair c0 h1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c7_goal : forall (_ : immsafe (pair (IFTHENELSE b c1 c2) h1))\n  (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and\n     (red (pair (IFTHENELSE b c1 c2) h1)\n        (pair (if Z.eqb b 0 then c2 else c1) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   and\n     (red (pair (IFTHENELSE b c1 c2) h1)\n        (pair (if Z.eqb b 0 then c2 else c1) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c15_IMM : immsafe (pair (IFTHENELSE b c1 c2) h1)",
                    "c15_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_IMM : immsafe (pair (IFTHENELSE b c1 c2) h1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c8_goal : forall (_ : immsafe (pair (ALLOC sz) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (ALLOC sz) h1) (pair (PURE l) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hinit l sz (hunion h1 h2)) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c16_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (ALLOC sz) h1) (pair (PURE l) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hinit l sz (hunion h1 h2)) (hunion h1' h2))))",
                    "c16_IMM : immsafe (pair (ALLOC sz) h1)",
                    "c16_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_IMM : immsafe (pair (ALLOC sz) h1)"
                ],
                "tactic_res": [
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c16_H3 : not (eq l0 0)",
                    "c16_l0 : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c9_goal : forall (_ : immsafe (pair (GET l) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (GET l) h1) (pair (PURE v) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c17_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (GET l) h1) (pair (PURE v) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c17_IMM : immsafe (pair (GET l) h1)",
                    "c17_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c17_IMM : immsafe (pair (GET l) h1)"
                ],
                "tactic_res": [
                    "c17_H1 : not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c10_goal : forall (_ : immsafe (pair (SET l v) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (SET l v) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hupdate l v (hunion h1 h2)) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c18_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (SET l v) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hupdate l v (hunion h1 h2)) (hunion h1' h2))))",
                    "c18_IMM : immsafe (pair (SET l v) h1)",
                    "c18_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_IMM : immsafe (pair (SET l v) h1)"
                ],
                "tactic_res": [
                    "c18_H1 : not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros IMM DISJ .",
                "tactic_args": [
                    "c11_goal : forall (_ : immsafe (pair (FREE l) h1)) (_ : hdisjoint h1 h2),\nex\n  (fun h1' : heap =>\n   and (red (pair (FREE l) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hfree l (hunion h1 h2)) (hunion h1' h2))))"
                ],
                "tactic_res": [
                    "c19_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (FREE l) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hfree l (hunion h1 h2)) (hunion h1' h2))))",
                    "c19_IMM : immsafe (pair (FREE l) h1)",
                    "c19_DISJ : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_IMM : immsafe (pair (FREE l) h1)"
                ],
                "tactic_res": [
                    "c19_H1 : not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (PICK n) h1) (pair (PURE i) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c20_goal : and (red (pair (PICK n) h1) (pair (PURE i) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c20_goal : and (red (pair (PICK n) h1) (pair (PURE i) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))",
                    "c12_DISJ : hdisjoint h1 h2",
                    "c4_H : and (Z.le 0 i) (Z.lt i n)",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c4_n : Z",
                    "c4_i : Z"
                ],
                "tactic_res": [
                    "c21_goal : red (pair (PICK n) h1) (pair (PURE i) h1)",
                    "c21_H1 : Z.lt i n",
                    "c21_H0 : Z.le 0 i"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c21_goal : red (pair (PICK n) h1) (pair (PURE i) h1)"
                ],
                "tactic_res": [
                    "c22_goal : and (Z.le 0 i) (Z.lt i n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : and (Z.le 0 i) (Z.lt i n)",
                    "c21_H1 : Z.lt i n",
                    "c21_H0 : Z.le 0 i",
                    "c4_n : Z",
                    "c4_i : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET (PURE x) f) h1) (pair (f x) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c23_goal : and (red (pair (LET (PURE x) f) h1) (pair (f x) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c23_goal : and (red (pair (LET (PURE x) f) h1) (pair (f x) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))",
                    "c13_H0 : immsafe (pair (PURE x) h1)",
                    "c13_DISJ : hdisjoint h1 h2",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c5_f : forall _ : Z, com",
                    "c5_x : Z"
                ],
                "tactic_res": [
                    "c24_goal : red (pair (LET (PURE x) f) h1) (pair (f x) h1)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c24_goal : red (pair (LET (PURE x) f) h1) (pair (f x) h1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct _i as ( h1' & R & D & U ) .",
                "tactic_sig_no_out_arg": "edestruct _i as ( h1' & R & D & U ) .",
                "tactic_args": [
                    "c14_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c6_IHRED : forall (h3 : heap) (c : com) (h4 : heap) (c' : com) \n  (h'0 : heap)\n  (_ : eq (pair c0 (hunion h1 h2)) (pair c (hunion h4 h3)))\n  (_ : eq (pair c'0 h') (pair c' h'0)) (_ : immsafe (pair c h4))\n  (_ : hdisjoint h4 h3),\nex\n  (fun h1' : heap =>\n   and (red (pair c h4) (pair c' h1'))\n     (and (hdisjoint h1' h3) (eq h'0 (hunion h1' h3))))"
                ],
                "tactic_res": [
                    "c25_goal : eq (pair c0 (hunion h1 h2)) (pair ?c (hunion ?h1 ?h2))",
                    "c26_goal : eq (pair c'0 h') (pair ?c' ?h')",
                    "c27_goal : immsafe (pair c0 h1)",
                    "c28_goal : hdisjoint h1 h2",
                    "c29_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c29_U : eq ?h' (hunion h1' ?h2)",
                    "c29_D : hdisjoint h1' ?h2",
                    "c29_R : red (pair ?c ?h1) (pair ?c' h1')",
                    "c29_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : eq (pair c0 (hunion h1 h2)) (pair ?c (hunion ?h1 ?h2))",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : eq (pair c'0 h') (pair ?c' ?h')",
                    "c2_h' : heap",
                    "c6_c'0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : immsafe (pair c0 h1)",
                    "c14_H0 : immsafe (pair c0 h1)",
                    "c2_h1 : heap",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : hdisjoint h1 h2",
                    "c14_DISJ : hdisjoint h1 h2",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c29_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n     (and (hdisjoint h1' h2) (eq h' (hunion h1' h2))))",
                    "c29_h1' : heap"
                ],
                "tactic_res": [
                    "c30_goal : and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n  (and (hdisjoint h1' h2) (eq h' (hunion h1' h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c30_goal : and (red (pair (LET c0 f) h1) (pair (LET c'0 f) h1'))\n  (and (hdisjoint h1' h2) (eq h' (hunion h1' h2)))",
                    "c29_U : eq ?h' (hunion h1' ?h2)",
                    "c29_D : hdisjoint h1' ?h2",
                    "c29_R : red (pair ?c ?h1) (pair ?c' h1')",
                    "c29_h1' : heap",
                    "c14_H0 : immsafe (pair c0 h1)",
                    "c14_DISJ : hdisjoint h1 h2",
                    "c6_IHRED : forall (h3 : heap) (c : com) (h4 : heap) (c' : com) \n  (h'0 : heap)\n  (_ : eq (pair c0 (hunion h1 h2)) (pair c (hunion h4 h3)))\n  (_ : eq (pair c'0 h') (pair c' h'0)) (_ : immsafe (pair c h4))\n  (_ : hdisjoint h4 h3),\nex\n  (fun h1' : heap =>\n   and (red (pair c h4) (pair c' h1'))\n     (and (hdisjoint h1' h3) (eq h'0 (hunion h1' h3))))",
                    "c6_RED : red (pair c0 (hunion h1 h2)) (pair c'0 h')",
                    "c2_h' : heap",
                    "c6_c'0 : com",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c6_f : forall _ : Z, com",
                    "c6_c0 : com"
                ],
                "tactic_res": [
                    "c31_goal : red (pair (LET c0 f) h1) (pair (LET c'0 f) h1')"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c31_goal : red (pair (LET c0 f) h1) (pair (LET c'0 f) h1')"
                ],
                "tactic_res": [
                    "c32_goal : red (pair c0 h1) (pair c'0 h1')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : red (pair c0 h1) (pair c'0 h1')",
                    "c29_R : red (pair ?c ?h1) (pair ?c' h1')",
                    "c29_h1' : heap",
                    "c6_c'0 : com",
                    "c2_h1 : heap",
                    "c6_c0 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c15_goal : ex\n  (fun h1' : heap =>\n   and\n     (red (pair (IFTHENELSE b c1 c2) h1)\n        (pair (if Z.eqb b 0 then c2 else c1) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c33_goal : and\n  (red (pair (IFTHENELSE b c1 c2) h1)\n     (pair (if Z.eqb b 0 then c2 else c1) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c33_goal : and\n  (red (pair (IFTHENELSE b c1 c2) h1)\n     (pair (if Z.eqb b 0 then c2 else c1) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))",
                    "c15_DISJ : hdisjoint h1 h2",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c7_c1 : com",
                    "c7_c2 : com",
                    "c7_b : Z"
                ],
                "tactic_res": [
                    "c34_goal : red (pair (IFTHENELSE b c1 c2) h1)\n  (pair (if Z.eqb b 0 then c2 else c1) h1)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c34_goal : red (pair (IFTHENELSE b c1 c2) h1)\n  (pair (if Z.eqb b 0 then c2 else c1) h1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hinit _i _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( hinit _i _i _i ) .",
                "tactic_args": [
                    "c16_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (ALLOC sz) h1) (pair (PURE l) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hinit l sz (hunion h1 h2)) (hunion h1' h2))))",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c35_goal : and (red (pair (ALLOC sz) h1) (pair (PURE l) (hinit l sz h1)))\n  (and (hdisjoint (hinit l sz h1) h2)\n     (eq (hinit l sz (hunion h1 h2)) (hunion (hinit l sz h1) h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c35_goal : and (red (pair (ALLOC sz) h1) (pair (PURE l) (hinit l sz h1)))\n  (and (hdisjoint (hinit l sz h1) h2)\n     (eq (hinit l sz (hunion h1 h2)) (hunion (hinit l sz h1) h2)))",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c16_H3 : not (eq l0 0)",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c8_H0 : not (eq l 0)",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c36_goal : red (pair (ALLOC sz) h1) (pair (PURE l) (hinit l sz h1))",
                    "c36_H3 : forall _ : eq l0 0, False",
                    "c36_H0 : forall _ : eq l 0, False",
                    "c37_goal : hdisjoint (hinit l sz h1) h2",
                    "c37_H3 : forall _ : eq l0 0, False",
                    "c37_H0 : forall _ : eq l 0, False",
                    "c38_goal : eq (hinit l sz (hunion h1 h2)) (hunion (hinit l sz h1) h2)",
                    "c38_H3 : forall _ : eq l0 0, False",
                    "c38_H0 : forall _ : eq l 0, False"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c36_goal : red (pair (ALLOC sz) h1) (pair (PURE l) (hinit l sz h1))"
                ],
                "tactic_res": [
                    "c39_goal : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h1 i) None",
                    "c40_goal : not (eq l 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : not (eq l 0)",
                    "c36_H0 : forall _ : eq l 0, False",
                    "c8_l : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c39_goal : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h1 i) None"
                ],
                "tactic_res": [
                    "c41_goal : eq (h1 i) None",
                    "c41_i : Z",
                    "c41_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c41_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))"
                ],
                "tactic_res": [
                    "c41_H1 : eq (hunion h1 h2 i) None"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c41_H1 : eq (hunion h1 h2 i) None"
                ],
                "tactic_res": [
                    "c41_H1 : eq (if h1 i then h1 i else h2 i) None"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c41_goal : eq (h1 i) None",
                    "c2_h1 : heap",
                    "c41_i : Z",
                    "c41_H1 : eq (if h1 i then h1 i else h2 i) None",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c36_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c36_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None"
                ],
                "tactic_res": [
                    "c42_goal : eq (Some z) None",
                    "c42_H1 : eq (Some z) None",
                    "c42_z : Z",
                    "c43_goal : eq None None",
                    "c43_H1 : eq (h2 i) None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c42_goal : eq (Some z) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c43_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c37_goal : hdisjoint (hinit l sz h1) h2"
                ],
                "tactic_res": [
                    "c44_goal : forall l0 : addr, or (eq (hinit l sz h1 l0) None) (eq (h2 l0) None)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c44_goal : forall l0 : addr, or (eq (hinit l sz h1 l0) None) (eq (h2 l0) None)"
                ],
                "tactic_res": [
                    "c45_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)",
                    "c45_i : addr"
                ]
            },
            {
                "tactic_sig": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ ( _i < _i \\/ _i + Z.of_nat _i <= _i ) ) by lia .",
                "tactic_sig_no_out_arg": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ ( _i < _i \\/ _i + Z.of_nat _i <= _i ) ) by lia .",
                "tactic_args": [
                    "c8_l : Z",
                    "c45_i : addr",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c45_i : addr",
                    "c8_l : Z",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c45_i : addr"
                ],
                "tactic_res": [
                    "c45_EITHER : or (and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz))))\n  (or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c45_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)",
                    "c45_EITHER : or (and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz))))\n  (or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i))",
                    "c45_i : addr",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c37_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c37_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c46_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)",
                    "c46_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))",
                    "c47_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)",
                    "c47_H1 : or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c46_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)"
                ],
                "tactic_res": [
                    "c48_goal : eq (h2 i) None"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c48_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))"
                ],
                "tactic_res": [
                    "c48_H1 : eq (hunion h1 h2 i) None"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c48_H1 : eq (hunion h1 h2 i) None"
                ],
                "tactic_res": [
                    "c48_H1 : eq (if h1 i then h1 i else h2 i) None"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] , ( _i _i ) as [ z'| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] , ( _i _i ) as [ z'| ] .",
                "tactic_args": [
                    "c48_goal : eq (h2 i) None",
                    "c2_h1 : heap",
                    "c45_i : addr",
                    "c2_h2 : heap",
                    "c45_i : addr",
                    "c48_H1 : eq (if h1 i then h1 i else h2 i) None",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c37_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c37_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None"
                ],
                "tactic_res": [
                    "c49_goal : eq (Some z') None",
                    "c49_z' : Z",
                    "c49_H1 : eq (Some z) None",
                    "c49_z : Z",
                    "c50_goal : eq None None",
                    "c50_H1 : eq (Some z) None",
                    "c50_z : Z",
                    "c51_goal : eq (Some z') None",
                    "c51_H1 : eq (Some z') None",
                    "c51_z' : Z",
                    "c52_goal : eq None None",
                    "c52_H1 : eq None None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c49_goal : eq (Some z') None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c50_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c51_goal : eq (Some z') None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c52_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i by auto .",
                "tactic_args": [
                    "c47_goal : or (eq (hinit l sz h1 i) None) (eq (h2 i) None)",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')",
                    "c47_H1 : or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i)",
                    "c45_i : addr",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c37_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c37_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c53_goal : or (eq (h1 i) None) (eq (h2 i) None)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c53_goal : or (eq (h1 i) None) (eq (h2 i) None)",
                    "c16_DISJ : hdisjoint h1 h2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : eq (hinit l sz (hunion h1 h2)) (hunion (hinit l sz h1) h2)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c54_goal : forall l0 : addr,\neq (hinit l sz (hunion h1 h2) l0) (hunion (hinit l sz h1) h2 l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c54_goal : forall l0 : addr,\neq (hinit l sz (hunion h1 h2) l0) (hunion (hinit l sz h1) h2 l0)"
                ],
                "tactic_res": [
                    "c55_goal : eq (hinit l sz (hunion h1 h2) i) (hunion (hinit l sz h1) h2 i)",
                    "c55_i : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c55_goal : eq (hinit l sz (hunion h1 h2) i) (hunion (hinit l sz h1) h2 i)"
                ],
                "tactic_res": [
                    "c56_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)"
                ]
            },
            {
                "tactic_sig": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ ( _i < _i \\/ _i + Z.of_nat _i <= _i ) ) by lia .",
                "tactic_sig_no_out_arg": "assert ( EITHER : _i <= _i < _i + Z.of_nat _i \\/ ( _i < _i \\/ _i + Z.of_nat _i <= _i ) ) by lia .",
                "tactic_args": [
                    "c8_l : Z",
                    "c55_i : addr",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c55_i : addr",
                    "c8_l : Z",
                    "c8_l : Z",
                    "c8_sz : nat",
                    "c55_i : addr"
                ],
                "tactic_res": [
                    "c56_EITHER : or (and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz))))\n  (or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c56_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)",
                    "c56_EITHER : or (and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz))))\n  (or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i))",
                    "c55_i : addr",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c38_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c38_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c57_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)",
                    "c57_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))",
                    "c58_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)",
                    "c58_H1 : or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i by auto .",
                "tactic_sig_no_out_arg": "rewrite ! _i by auto .",
                "tactic_args": [
                    "c57_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)",
                    "_global_hinit_inside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : and (Z.le l l') (Z.lt l' (Z.add l (Z.of_nat sz)))),\n       eq (hinit l sz h l') (Some 0)",
                    "c57_H1 : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))",
                    "c55_i : addr",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c38_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c38_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c59_goal : eq (Some 0) (Some 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! _i by auto .",
                "tactic_sig_no_out_arg": "rewrite ! _i by auto .",
                "tactic_args": [
                    "c58_goal : eq (hinit l sz (hunion h1 h2) i)\n  (if hinit l sz h1 i then hinit l sz h1 i else h2 i)",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')",
                    "c58_H1 : or (Z.lt i l) (Z.le (Z.add l (Z.of_nat sz)) i)",
                    "c55_i : addr",
                    "c16_H4 : forall (i : Z) (_ : and (Z.le l0 i) (Z.lt i (Z.add l0 (Z.of_nat sz)))),\neq (h1 i) None",
                    "c38_H3 : forall _ : eq l0 0, False",
                    "c16_DISJ : hdisjoint h1 h2",
                    "c38_H0 : forall _ : eq l 0, False",
                    "c8_H : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hunion h1 h2 i) None",
                    "c8_l : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c8_sz : nat"
                ],
                "tactic_res": [
                    "c60_goal : eq (hunion h1 h2 i) (if h1 i then h1 i else h2 i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c60_goal : eq (hunion h1 h2 i) (if h1 i then h1 i else h2 i)",
                    "c55_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c17_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (GET l) h1) (pair (PURE v) h1'))\n     (and (hdisjoint h1' h2) (eq (hunion h1 h2) (hunion h1' h2))))",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c61_goal : and (red (pair (GET l) h1) (pair (PURE v) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c61_goal : and (red (pair (GET l) h1) (pair (PURE v) h1))\n  (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2)))",
                    "c17_H1 : not (eq (h1 l) None)",
                    "c17_DISJ : hdisjoint h1 h2",
                    "c9_H : eq (hunion h1 h2 l) (Some v)",
                    "c9_v : Z",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c9_l : addr"
                ],
                "tactic_res": [
                    "c62_goal : red (pair (GET l) h1) (pair (PURE v) h1)",
                    "c62_H1 : forall _ : eq (h1 l) None, False"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c62_goal : red (pair (GET l) h1) (pair (PURE v) h1)"
                ],
                "tactic_res": [
                    "c63_goal : eq (h1 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "cbn in _i .",
                "tactic_sig_no_out_arg": "cbn in _i .",
                "tactic_args": [
                    "c63_H : eq (hunion h1 h2 l) (Some v)"
                ],
                "tactic_res": [
                    "c63_H : eq (if h1 l then h1 l else h2 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ z| ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ z| ] .",
                "tactic_args": [
                    "c63_goal : eq (h1 l) (Some v)",
                    "c2_h1 : heap",
                    "c9_l : addr",
                    "c62_H1 : forall _ : eq (h1 l) None, False",
                    "c17_DISJ : hdisjoint h1 h2",
                    "c63_H : eq (if h1 l then h1 l else h2 l) (Some v)",
                    "c9_v : Z"
                ],
                "tactic_res": [
                    "c64_goal : eq (Some z) (Some v)",
                    "c64_H1 : forall _ : eq (Some z) None, False",
                    "c64_H : eq (Some z) (Some v)",
                    "c64_z : Z",
                    "c65_goal : eq None (Some v)",
                    "c65_H1 : forall _ : eq None None, False",
                    "c65_H : eq (h2 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c64_goal : eq (Some z) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c65_goal : eq None (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hupdate _i _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i _i _i ) .",
                "tactic_args": [
                    "c18_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (SET l v) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hupdate l v (hunion h1 h2)) (hunion h1' h2))))",
                    "c10_l : addr",
                    "c10_v : Z",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c66_goal : and (red (pair (SET l v) h1) (pair (PURE 0) (hupdate l v h1)))\n  (and (hdisjoint (hupdate l v h1) h2)\n     (eq (hupdate l v (hunion h1 h2)) (hunion (hupdate l v h1) h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c66_goal : and (red (pair (SET l v) h1) (pair (PURE 0) (hupdate l v h1)))\n  (and (hdisjoint (hupdate l v h1) h2)\n     (eq (hupdate l v (hunion h1 h2)) (hunion (hupdate l v h1) h2)))",
                    "c18_H1 : not (eq (h1 l) None)",
                    "c18_DISJ : hdisjoint h1 h2",
                    "c10_H : not (eq (hunion h1 h2 l) None)",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c10_v : Z",
                    "c10_l : addr"
                ],
                "tactic_res": [
                    "c67_goal : red (pair (SET l v) h1) (pair (PURE 0) (hupdate l v h1))",
                    "c67_H1 : forall _ : eq (h1 l) None, False",
                    "c67_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c68_goal : hdisjoint (hupdate l v h1) h2",
                    "c68_H1 : forall _ : eq (h1 l) None, False",
                    "c68_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c69_goal : eq (hupdate l v (hunion h1 h2)) (hunion (hupdate l v h1) h2)",
                    "c69_H1 : forall _ : eq (h1 l) None, False",
                    "c69_H : forall _ : eq (hunion h1 h2 l) None, False"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c67_goal : red (pair (SET l v) h1) (pair (PURE 0) (hupdate l v h1))"
                ],
                "tactic_res": [
                    "c70_goal : not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c70_goal : not (eq (h1 l) None)",
                    "c67_H1 : forall _ : eq (h1 l) None, False",
                    "c2_h1 : heap",
                    "c10_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c68_goal : hdisjoint (hupdate l v h1) h2"
                ],
                "tactic_res": [
                    "c71_goal : or (eq (hupdate l v h1 i) None) (eq (h2 i) None)",
                    "c71_i : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c71_goal : or (eq (hupdate l v h1 i) None) (eq (h2 i) None)"
                ],
                "tactic_res": [
                    "c72_goal : or (eq (if Z.eq_dec l i then Some v else h1 i) None) (eq (h2 i) None)"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c72_goal : or (eq (if Z.eq_dec l i then Some v else h1 i) None) (eq (h2 i) None)",
                    "c18_DISJ : hdisjoint h1 h2",
                    "c71_i : addr"
                ],
                "tactic_res": [
                    "c73_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (if Z.eq_dec l i then Some v else h1 i) None) (eq (h2 i) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c73_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (if Z.eq_dec l i then Some v else h1 i) None) (eq (h2 i) None)",
                    "c10_l : addr",
                    "c71_i : addr",
                    "c68_H1 : forall _ : eq (h1 l) None, False",
                    "c18_DISJ : hdisjoint h1 h2",
                    "c68_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c10_v : Z"
                ],
                "tactic_res": [
                    "c74_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (Some v) None) (eq (h2 i) None)",
                    "c74_e : eq l i",
                    "c75_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (h1 i) None) (eq (h2 i) None)",
                    "c75_n : not (eq l i)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c74_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (Some v) None) (eq (h2 i) None)",
                    "c74_e : eq l i",
                    "c71_i : addr",
                    "c68_H1 : forall _ : eq (h1 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c10_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c75_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (h1 i) None) (eq (h2 i) None)",
                    "c71_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c69_goal : eq (hupdate l v (hunion h1 h2)) (hunion (hupdate l v h1) h2)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c76_goal : forall l0 : addr,\neq (hupdate l v (hunion h1 h2) l0) (hunion (hupdate l v h1) h2 l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c76_goal : forall l0 : addr,\neq (hupdate l v (hunion h1 h2) l0) (hunion (hupdate l v h1) h2 l0)"
                ],
                "tactic_res": [
                    "c77_goal : eq (hupdate l v (hunion h1 h2) i) (hunion (hupdate l v h1) h2 i)",
                    "c77_i : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c77_goal : eq (hupdate l v (hunion h1 h2) i) (hunion (hupdate l v h1) h2 i)"
                ],
                "tactic_res": [
                    "c78_goal : eq (if Z.eq_dec l i then Some v else if h1 i then h1 i else h2 i)\n  (if if Z.eq_dec l i then Some v else h1 i\n   then if Z.eq_dec l i then Some v else h1 i\n   else h2 i)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c78_goal : eq (if Z.eq_dec l i then Some v else if h1 i then h1 i else h2 i)\n  (if if Z.eq_dec l i then Some v else h1 i\n   then if Z.eq_dec l i then Some v else h1 i\n   else h2 i)",
                    "c10_l : addr",
                    "c77_i : addr",
                    "c69_H1 : forall _ : eq (h1 l) None, False",
                    "c18_DISJ : hdisjoint h1 h2",
                    "c69_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c10_v : Z"
                ],
                "tactic_res": [
                    "c79_goal : eq (Some v) (Some v)",
                    "c79_e : eq l i",
                    "c80_goal : eq (if h1 i then h1 i else h2 i) (if h1 i then h1 i else h2 i)",
                    "c80_n : not (eq l i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c79_goal : eq (Some v) (Some v)",
                    "c10_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c80_goal : eq (if h1 i then h1 i else h2 i) (if h1 i then h1 i else h2 i)",
                    "c77_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hfree _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( hfree _i _i ) .",
                "tactic_args": [
                    "c19_goal : ex\n  (fun h1' : heap =>\n   and (red (pair (FREE l) h1) (pair (PURE 0) h1'))\n     (and (hdisjoint h1' h2)\n        (eq (hfree l (hunion h1 h2)) (hunion h1' h2))))",
                    "c11_l : addr",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c81_goal : and (red (pair (FREE l) h1) (pair (PURE 0) (hfree l h1)))\n  (and (hdisjoint (hfree l h1) h2)\n     (eq (hfree l (hunion h1 h2)) (hunion (hfree l h1) h2)))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c81_goal : and (red (pair (FREE l) h1) (pair (PURE 0) (hfree l h1)))\n  (and (hdisjoint (hfree l h1) h2)\n     (eq (hfree l (hunion h1 h2)) (hunion (hfree l h1) h2)))",
                    "c19_H1 : not (eq (h1 l) None)",
                    "c19_DISJ : hdisjoint h1 h2",
                    "c11_H : not (eq (hunion h1 h2 l) None)",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c11_l : addr"
                ],
                "tactic_res": [
                    "c82_goal : red (pair (FREE l) h1) (pair (PURE 0) (hfree l h1))",
                    "c82_H1 : forall _ : eq (h1 l) None, False",
                    "c82_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c83_goal : hdisjoint (hfree l h1) h2",
                    "c83_H1 : forall _ : eq (h1 l) None, False",
                    "c83_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c84_goal : eq (hfree l (hunion h1 h2)) (hunion (hfree l h1) h2)",
                    "c84_H1 : forall _ : eq (h1 l) None, False",
                    "c84_H : forall _ : eq (hunion h1 h2 l) None, False"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c82_goal : red (pair (FREE l) h1) (pair (PURE 0) (hfree l h1))"
                ],
                "tactic_res": [
                    "c85_goal : not (eq (h1 l) None)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c85_goal : not (eq (h1 l) None)",
                    "c82_H1 : forall _ : eq (h1 l) None, False",
                    "c2_h1 : heap",
                    "c11_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c83_goal : hdisjoint (hfree l h1) h2"
                ],
                "tactic_res": [
                    "c86_goal : or (eq (hfree l h1 i) None) (eq (h2 i) None)",
                    "c86_i : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c86_goal : or (eq (hfree l h1 i) None) (eq (h2 i) None)"
                ],
                "tactic_res": [
                    "c87_goal : or (eq (if Z.eq_dec l i then None else h1 i) None) (eq (h2 i) None)"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c87_goal : or (eq (if Z.eq_dec l i then None else h1 i) None) (eq (h2 i) None)",
                    "c19_DISJ : hdisjoint h1 h2",
                    "c86_i : addr"
                ],
                "tactic_res": [
                    "c88_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (if Z.eq_dec l i then None else h1 i) None) (eq (h2 i) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c88_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (if Z.eq_dec l i then None else h1 i) None) (eq (h2 i) None)",
                    "c11_l : addr",
                    "c86_i : addr",
                    "c83_H1 : forall _ : eq (h1 l) None, False",
                    "c19_DISJ : hdisjoint h1 h2",
                    "c83_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c89_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq None None) (eq (h2 i) None)",
                    "c89_e : eq l i",
                    "c90_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (h1 i) None) (eq (h2 i) None)",
                    "c90_n : not (eq l i)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c89_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq None None) (eq (h2 i) None)",
                    "c86_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c90_goal : forall _ : or (eq (h1 i) None) (eq (h2 i) None),\nor (eq (h1 i) None) (eq (h2 i) None)",
                    "c86_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c84_goal : eq (hfree l (hunion h1 h2)) (hunion (hfree l h1) h2)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c91_goal : forall l0 : addr,\neq (hfree l (hunion h1 h2) l0) (hunion (hfree l h1) h2 l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros i .",
                "tactic_args": [
                    "c91_goal : forall l0 : addr,\neq (hfree l (hunion h1 h2) l0) (hunion (hfree l h1) h2 l0)"
                ],
                "tactic_res": [
                    "c92_goal : eq (hfree l (hunion h1 h2) i) (hunion (hfree l h1) h2 i)",
                    "c92_i : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c92_goal : eq (hfree l (hunion h1 h2) i) (hunion (hfree l h1) h2 i)"
                ],
                "tactic_res": [
                    "c93_goal : eq (if Z.eq_dec l i then None else if h1 i then h1 i else h2 i)\n  (if if Z.eq_dec l i then None else h1 i\n   then if Z.eq_dec l i then None else h1 i\n   else h2 i)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c93_goal : eq (if Z.eq_dec l i then None else if h1 i then h1 i else h2 i)\n  (if if Z.eq_dec l i then None else h1 i\n   then if Z.eq_dec l i then None else h1 i\n   else h2 i)",
                    "c11_l : addr",
                    "c92_i : addr",
                    "c84_H1 : forall _ : eq (h1 l) None, False",
                    "c19_DISJ : hdisjoint h1 h2",
                    "c84_H : forall _ : eq (hunion h1 h2 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": [
                    "c94_goal : eq None (h2 i)",
                    "c94_e : eq l i",
                    "c95_goal : eq (if h1 i then h1 i else h2 i) (if h1 i then h1 i else h2 i)",
                    "c95_n : not (eq l i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c95_goal : eq (if h1 i then h1 i else h2 i) (if h1 i then h1 i else h2 i)",
                    "c92_i : addr",
                    "c2_h2 : heap",
                    "c2_h1 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c94_goal : eq None (h2 i)",
                    "c92_i : addr",
                    "c94_e : eq l i"
                ],
                "tactic_res": [
                    "c96_goal : eq None (h2 l)"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c96_goal : eq None (h2 l)",
                    "c19_DISJ : hdisjoint h1 h2",
                    "c11_l : addr"
                ],
                "tactic_res": [
                    "c97_goal : forall _ : or (eq (h1 l) None) (eq (h2 l) None), eq None (h2 l)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c97_goal : forall _ : or (eq (h1 l) None) (eq (h2 l) None), eq None (h2 l)",
                    "c84_H1 : forall _ : eq (h1 l) None, False",
                    "c2_h2 : heap",
                    "c2_h1 : heap",
                    "c11_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_frame",
        "proof": [
            {
                "tactic_sig": "Lemma safe_frame : forall ( R : assertion ) h' , R h' -> forall c h Q , safe c h Q -> hdisjoint h h' -> safe c ( hunion h h' ) ( fun v => Q v ** R ) .",
                "tactic_sig_no_out_arg": "Lemma safe_frame : forall ( R : assertion ) h' , R h' -> forall c h Q , safe c h Q -> hdisjoint h h' -> safe c ( hunion h h' ) ( fun v => Q v ** R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (h' : heap) (_ : R h') (c : com) \n  (h : heap) (Q : postcond) (_ : safe c h Q) (_ : hdisjoint h h'),\nsafe c (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "induction 2 .",
                "tactic_sig_no_out_arg": "induction 2 .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (h' : heap) (_ : R h') (c : com) \n  (h : heap) (Q : postcond) (_ : safe c h Q) (_ : hdisjoint h h'),\nsafe c (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : hdisjoint h h',\nsafe (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R)",
                    "c2_H0 : Q v h",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z",
                    "c2_H : R h'",
                    "c2_h' : heap",
                    "c2_R : assertion",
                    "c3_goal : forall _ : hdisjoint h h',\nsafe c (hunion h h') (fun v : Z => sepconj (Q v) R)",
                    "c3_H3 : forall (c' : com) (h'0 : heap) (_ : red (pair c h) (pair c' h'0))\n  (_ : hdisjoint h'0 h'),\nsafe c' (hunion h'0 h') (fun v : Z => sepconj (Q v) R)",
                    "c3_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c3_H1 : immsafe (pair c h)",
                    "c3_H0 : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c3_Q : postcond",
                    "c3_h : heap",
                    "c3_c : com",
                    "c3_H : R h'",
                    "c3_h' : heap",
                    "c3_R : assertion"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c2_goal : forall _ : hdisjoint h h',\nsafe (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c4_goal : safe (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R)",
                    "c4_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros DISJ .",
                "tactic_args": [
                    "c3_goal : forall _ : hdisjoint h h',\nsafe c (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c5_goal : safe c (hunion h h') (fun v : Z => sepconj (Q v) R)",
                    "c5_DISJ : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (PURE v) (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c6_goal : sepconj (Q v) R (hunion h h')"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c6_goal : sepconj (Q v) R (hunion h h')",
                    "c2_h : heap",
                    "c2_h' : heap"
                ],
                "tactic_res": [
                    "c7_goal : and (Q v h)\n  (and (R h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : and (Q v h)\n  (and (R h') (and (hdisjoint h h') (eq (hunion h h') (hunion h h'))))",
                    "c4_DISJ : hdisjoint h h'",
                    "c2_H0 : Q v h",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z",
                    "c2_H : R h'",
                    "c2_h' : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : safe c (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c8_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c9_goal : immsafe (pair c (hunion h h'))",
                    "c10_goal : forall (c' : com) (h'0 : heap)\n  (_ : red (pair c (hunion h h')) (pair c' h'0)),\nsafe c' h'0 (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c3_H0 : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : immsafe (pair c (hunion h h'))",
                    "_global_immsafe_frame : forall (h' : heap) (c : com) (h : heap) (_ : immsafe (pair c h))\n         (_ : hdisjoint h h'), immsafe (pair c (hunion h h'))"
                ],
                "tactic_res": [
                    "c11_goal : immsafe (pair c h)",
                    "c12_goal : hdisjoint h h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : immsafe (pair c h)",
                    "c3_H1 : immsafe (pair c h)",
                    "c3_h : heap",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : hdisjoint h h'",
                    "c5_DISJ : hdisjoint h h'",
                    "c3_h : heap",
                    "c3_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (c' : com) (h'0 : heap)\n  (_ : red (pair c (hunion h h')) (pair c' h'0)),\nsafe c' h'0 (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c13_goal : safe c' h'0 (fun v : Z => sepconj (Q v) R)",
                    "c13_c' : com",
                    "c13_h'0 : heap",
                    "c13_H4 : red (pair c (hunion h h')) (pair c' h'0)"
                ]
            },
            {
                "tactic_sig": "edestruct red_frame as ( h1' & RED1 & D & U ) .",
                "tactic_sig_no_out_arg": "edestruct red_frame as ( h1' & RED1 & D & U ) .",
                "tactic_args": [
                    "c13_goal : safe c' h'0 (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c14_goal : red (pair ?c (hunion ?h1 ?h2)) (pair ?c' ?h')",
                    "c15_goal : immsafe (pair c h)",
                    "c16_goal : hdisjoint h h'",
                    "c17_goal : safe c' h'0 (fun v : Z => sepconj (Q v) R)",
                    "c17_U : eq ?h' (hunion h1' ?h2)",
                    "c17_D : hdisjoint h1' ?h2",
                    "c17_RED1 : red (pair ?c ?h1) (pair ?c' h1')",
                    "c17_h1' : heap"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : red (pair ?c (hunion ?h1 ?h2)) (pair ?c' ?h')",
                    "c13_H4 : red (pair c (hunion h h')) (pair c' h'0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : immsafe (pair c h)",
                    "c3_H1 : immsafe (pair c h)",
                    "c3_h : heap",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : hdisjoint h h'",
                    "c5_DISJ : hdisjoint h h'",
                    "c3_h : heap",
                    "c3_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c17_goal : safe c' h'0 (fun v : Z => sepconj (Q v) R)",
                    "c13_h'0 : heap",
                    "c17_U : eq ?h' (hunion h1' ?h2)"
                ],
                "tactic_res": [
                    "c18_goal : safe c' (hunion h1' h') (fun v : Z => sepconj (Q v) R)",
                    "c18_D : hdisjoint h1' h'",
                    "c18_RED1 : red (pair c h) (pair c' h1')",
                    "c18_H4 : red (pair c (hunion h h')) (pair c' (hunion h1' h'))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : safe c' (hunion h1' h') (fun v : Z => sepconj (Q v) R)",
                    "c3_H3 : forall (c' : com) (h'0 : heap) (_ : red (pair c h) (pair c' h'0))\n  (_ : hdisjoint h'0 h'),\nsafe c' (hunion h'0 h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c19_goal : red (pair c h) (pair c' h1')",
                    "c20_goal : hdisjoint h1' h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : red (pair c h) (pair c' h1')",
                    "c18_RED1 : red (pair c h) (pair c' h1')",
                    "c17_h1' : heap",
                    "c13_c' : com",
                    "c3_h : heap",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : hdisjoint h1' h'",
                    "c18_D : hdisjoint h1' h'",
                    "c17_h1' : heap",
                    "c3_h' : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_frame",
        "proof": [
            {
                "tactic_sig": "Lemma triple_frame : forall P c Q R , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_frame : forall P c Q R , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (R : assertion)\n  (_ : triple P c Q),\ntriple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros P c Q R TR h ( h1 & h2 & P1 & R2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (R : assertion)\n  (_ : triple P c Q),\ntriple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c2_goal : safe c h (fun v : Z => sepconj (Q v) R)",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_R : assertion",
                    "c2_TR : triple P c Q",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_P1 : P h1",
                    "c2_R2 : R h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_goal : safe c h (fun v : Z => sepconj (Q v) R)",
                    "c2_h : heap",
                    "c2_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c3_goal : safe c (hunion h1 h2) (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe c (hunion h1 h2) (fun v : Z => sepconj (Q v) R)",
                    "_global_safe_frame : forall (R : assertion) (h' : heap) (_ : R h') \n         (c : com) (h : heap) (Q : postcond) (_ : safe c h Q)\n         (_ : hdisjoint h h'),\n       safe c (hunion h h') (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c4_goal : R h2",
                    "c5_goal : safe c h1 Q",
                    "c6_goal : hdisjoint h1 h2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : R h2",
                    "c2_R2 : R h2",
                    "c2_h2 : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : safe c h1 Q",
                    "c2_P1 : P h1",
                    "c2_h1 : heap",
                    "c2_TR : triple P c Q",
                    "c2_Q : postcond",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : hdisjoint h1 h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_get",
        "proof": [
            {
                "tactic_sig": "Lemma triple_get : forall l v , \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_get : forall l v , \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l v h P .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c2_goal : safe (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_P : contains l v h"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h l) (Some v)",
                    "c4_goal : safe (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c4_L : eq (h l) (Some v)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_P : contains l v h"
                ],
                "tactic_res": [
                    "c3_P : eq h (hupdate l v hempty)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq (h l) (Some v)",
                    "c2_h : heap",
                    "c3_P : eq h (hupdate l v hempty)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v hempty l) (Some v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v hempty l) (Some v)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (GET l) h (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c7_goal : immsafe (pair (GET l) h)",
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (GET l) h) (pair c' h')),\nsafe c' h' (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : immsafe (pair (GET l) h)"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (GET l) h) (pair c' h')),\nsafe c' h' (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c10_goal : safe c' h' (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c10_c' : com",
                    "c10_h' : heap",
                    "c10_RED : red (pair (GET l) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe c' h' (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c10_RED : red (pair (GET l) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_goal : safe (PURE v0) h' (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "c11_H0 : eq (h' l) (Some v0)",
                    "c11_v0 : Z",
                    "c11_P : contains l v h'",
                    "c11_L : eq (h' l) (Some v)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe (PURE v0) h' (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c12_goal : pureconj (eq v0 v) (contains l v) h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : pureconj (eq v0 v) (contains l v) h'"
                ],
                "tactic_res": [
                    "c13_goal : eq v0 v",
                    "c14_goal : contains l v h'"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c13_goal : eq v0 v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : contains l v h'",
                    "c11_P : contains l v h'",
                    "c10_h' : heap",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_set",
        "proof": [
            {
                "tactic_sig": "Lemma triple_set : forall l v , \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_set : forall l v , \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros l v h ( v0 & P ) .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c2_goal : safe (SET l v) h (fun _ : Z => contains l v)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_v0 : Z",
                    "c2_P : contains l v0 h"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (SET l v) h (fun _ : Z => contains l v)",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h l) (Some v0)",
                    "c4_goal : safe (SET l v) h (fun _ : Z => contains l v)",
                    "c4_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_P : contains l v0 h"
                ],
                "tactic_res": [
                    "c3_P : eq h (hupdate l v0 hempty)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq (h l) (Some v0)",
                    "c2_h : heap",
                    "c3_P : eq h (hupdate l v0 hempty)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (SET l v) h (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c7_goal : immsafe (pair (SET l v) h)",
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (SET l v) h) (pair c' h')),\nsafe c' h' (fun _ : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : immsafe (pair (SET l v) h)"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (SET l v) h) (pair c' h')),\nsafe c' h' (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c10_goal : safe c' h' (fun _ : Z => contains l v)",
                    "c10_c' : com",
                    "c10_h' : heap",
                    "c10_RED : red (pair (SET l v) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe c' h' (fun _ : Z => contains l v)",
                    "c10_RED : red (pair (SET l v) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_goal : safe SKIP (hupdate l v h) (fun _ : Z => contains l v)",
                    "c11_H0 : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe SKIP (hupdate l v h) (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c12_goal : contains l v (hupdate l v h)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c12_P : contains l v0 h"
                ],
                "tactic_res": [
                    "c12_P : eq h (hupdate l v0 hempty)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c12_goal : contains l v (hupdate l v h)",
                    "c2_h : heap",
                    "c12_P : eq h (hupdate l v0 hempty)"
                ],
                "tactic_res": [
                    "c13_goal : contains l v (hupdate l v (hupdate l v0 hempty))",
                    "c13_L : eq (hupdate l v0 hempty l) (Some v0)",
                    "c13_H0 : not (eq (hupdate l v0 hempty l) None)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : contains l v (hupdate l v (hupdate l v0 hempty))"
                ],
                "tactic_res": [
                    "c14_goal : eq (hupdate l v (hupdate l v0 hempty)) (hupdate l v hempty)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : eq (hupdate l v (hupdate l v0 hempty)) (hupdate l v hempty)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c15_goal : forall l0 : addr,\neq (hupdate l v (hupdate l v0 hempty) l0) (hupdate l v hempty l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l' .",
                "tactic_args": [
                    "c15_goal : forall l0 : addr,\neq (hupdate l v (hupdate l v0 hempty) l0) (hupdate l v hempty l0)"
                ],
                "tactic_res": [
                    "c16_goal : eq (hupdate l v (hupdate l v0 hempty) l') (hupdate l v hempty l')",
                    "c16_l' : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c16_goal : eq (hupdate l v (hupdate l v0 hempty) l') (hupdate l v hempty l')"
                ],
                "tactic_res": [
                    "c17_goal : eq\n  (if Z.eq_dec l l'\n   then Some v\n   else if Z.eq_dec l l' then Some v0 else None)\n  (if Z.eq_dec l l' then Some v else None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c17_goal : eq\n  (if Z.eq_dec l l'\n   then Some v\n   else if Z.eq_dec l l' then Some v0 else None)\n  (if Z.eq_dec l l' then Some v else None)",
                    "c2_l : addr",
                    "c16_l' : addr",
                    "c13_L : eq (hupdate l v0 hempty l) (Some v0)",
                    "c13_H0 : not (eq (hupdate l v0 hempty l) None)",
                    "c2_v : Z",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c18_goal : eq (Some v) (Some v)",
                    "c18_e : eq l l'",
                    "c19_goal : eq None None",
                    "c19_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq (Some v) (Some v)",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_N_init",
        "proof": [
            {
                "tactic_sig": "Remark valid_N_init : forall sz l , ( valid_N l sz ) ( hinit l sz hempty ) .",
                "tactic_sig_no_out_arg": "Remark valid_N_init : forall sz l , ( valid_N l sz ) ( hinit l sz hempty ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro sz .",
                "tactic_args": [
                    "c1_goal : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ],
                "tactic_res": [
                    "c2_goal : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | _i ] .",
                "tactic_args": [
                    "c2_goal : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall l : addr, valid_N l 0 (hinit l 0 hempty)",
                    "c4_goal : forall l : addr, valid_N l (S sz) (hinit l (S sz) hempty)",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c3_goal : forall l : addr, valid_N l 0 (hinit l 0 hempty)"
                ],
                "tactic_res": [
                    "c5_goal : valid_N l 0 (hinit l 0 hempty)",
                    "c5_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : valid_N l 0 (hinit l 0 hempty)"
                ],
                "tactic_res": [
                    "c6_goal : emp hempty"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l .",
                "tactic_args": [
                    "c4_goal : forall l : addr, valid_N l (S sz) (hinit l (S sz) hempty)"
                ],
                "tactic_res": [
                    "c7_goal : valid_N l (S sz) (hinit l (S sz) hempty)",
                    "c7_l : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : valid_N l (S sz) (hinit l (S sz) hempty)"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (valid l) (valid_N (Z.add l 1) sz)\n  (hupdate l 0 (hinit (Z.add l 1) sz hempty))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : emp hempty"
                ],
                "tactic_res": [
                    "c9_goal : eq hempty hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq hempty hempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i hempty ) .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i hempty ) .",
                "tactic_args": [
                    "c8_goal : sepconj (valid l) (valid_N (Z.add l 1) sz)\n  (hupdate l 0 (hinit (Z.add l 1) sz hempty))",
                    "c7_l : addr",
                    "c7_l : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c10_goal : and (valid l (hupdate l 0 hempty))\n  (and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n     (and\n        (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))))"
                ]
            },
            {
                "tactic_sig": "intuition auto .",
                "tactic_sig_no_out_arg": "intuition auto .",
                "tactic_args": [
                    "c10_goal : and (valid l (hupdate l 0 hempty))\n  (and (valid_N (Z.add l 1) sz (hinit (Z.add l 1) sz hempty))\n     (and\n        (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)))))",
                    "c7_l : addr",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c11_goal : valid l (hupdate l 0 hempty)",
                    "c12_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)",
                    "c13_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c11_goal : valid l (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c14_goal : contains l 0 (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c14_goal : contains l 0 (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c15_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)",
                    "c7_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c12_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty)"
                ],
                "tactic_res": [
                    "c16_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "c16_x : addr"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c16_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz hempty x) None)",
                    "_global_hupdate : forall (_ : addr) (_ : Z) (_ : heap), heap",
                    "_global_hempty : heap"
                ],
                "tactic_res": [
                    "c17_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite :=\n          Separation.hupdate_obligation_1 l 0\n            {|\n              contents := fun _ : addr => None;\n              isfinite := Separation.hempty_obligation_1\n            |}\n      |} x) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c17_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite :=\n          Separation.hupdate_obligation_1 l 0\n            {|\n              contents := fun _ : addr => None;\n              isfinite := Separation.hempty_obligation_1\n            |}\n      |} x) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)"
                ],
                "tactic_res": [
                    "c18_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c18_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)",
                    "c7_l : addr",
                    "c16_x : addr",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c19_goal : or (eq (Some 0) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)",
                    "c19_e : eq l x",
                    "c20_goal : or (eq None None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)",
                    "c20_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : or (eq None None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)",
                    "c7_l : addr",
                    "c16_x : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c19_goal : or (eq (Some 0) None)\n  (eq\n     (hinit (Z.add l 1) sz\n        {|\n          contents := fun _ : addr => None;\n          isfinite := Separation.hempty_obligation_1\n        |} x) None)"
                ],
                "tactic_res": [
                    "c21_goal : eq\n  (hinit (Z.add l 1) sz\n     {|\n       contents := fun _ : addr => None;\n       isfinite := Separation.hempty_obligation_1\n     |} x) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c21_goal : eq\n  (hinit (Z.add l 1) sz\n     {|\n       contents := fun _ : addr => None;\n       isfinite := Separation.hempty_obligation_1\n     |} x) None",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c22_goal : eq\n  ({|\n     contents := fun _ : addr => None;\n     isfinite := Separation.hempty_obligation_1\n   |} x) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : eq\n  ({|\n     contents := fun _ : addr => None;\n     isfinite := Separation.hempty_obligation_1\n   |} x) None",
                    "c16_x : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c23_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz hempty) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c23_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz hempty) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) l0)"
                ],
                "tactic_res": [
                    "c24_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) x)",
                    "c24_x : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c24_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz hempty) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz hempty) x)"
                ],
                "tactic_res": [
                    "c25_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz hempty x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz hempty x)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c25_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz hempty x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz hempty x)",
                    "c7_l : addr",
                    "c24_x : addr",
                    "c4_IHsz : forall l : addr, valid_N l sz (hinit l sz hempty)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c26_goal : eq (Some 0) (Some 0)",
                    "c26_e : eq l x",
                    "c27_goal : eq (hinit (Z.add l 1) sz hempty x) (hinit (Z.add l 1) sz hempty x)",
                    "c27_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : eq (hinit (Z.add l 1) sz hempty x) (hinit (Z.add l 1) sz hempty x)",
                    "c7_l : addr",
                    "c24_x : addr",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_alloc",
        "proof": [
            {
                "tactic_sig": "Lemma triple_alloc : forall sz , \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_alloc : forall sz , \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall sz : nat,\ntriple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros sz h P .",
                "tactic_args": [
                    "c1_goal : forall sz : nat,\ntriple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c2_goal : safe (ALLOC sz) h (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "c2_sz : nat",
                    "c2_h : heap",
                    "c2_P : emp h"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c2_P : emp h"
                ],
                "tactic_res": [
                    "c2_P : eq h hempty"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_goal : safe (ALLOC sz) h (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "c2_h : heap",
                    "c2_P : eq h hempty"
                ],
                "tactic_res": [
                    "c3_goal : safe (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (ALLOC sz) hempty\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c4_goal : True",
                    "c5_goal : immsafe (pair (ALLOC sz) hempty)",
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (ALLOC sz) hempty) (pair c' h')),\nsafe c' h' (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with 1 .",
                "tactic_sig_no_out_arg": "apply _i with 1 .",
                "tactic_args": [
                    "c5_goal : immsafe (pair (ALLOC sz) hempty)",
                    "_global_immsafe_alloc : forall (sz : nat) (h : heap) (l : Z) (_ : not (eq l 0))\n         (_ : forall (i : Z)\n                (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n              eq (h i) None), immsafe (pair (ALLOC sz) h)"
                ],
                "tactic_res": [
                    "c7_goal : not (eq 1 0)",
                    "c8_goal : forall (i : Z) (_ : and (Z.le 1 i) (Z.lt i (Z.add 1 (Z.of_nat sz)))),\neq (hempty i) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (i : Z) (_ : and (Z.le 1 i) (Z.lt i (Z.add 1 (Z.of_nat sz)))),\neq (hempty i) None"
                ],
                "tactic_res": [
                    "c9_goal : eq (hempty i) None",
                    "c9_i : Z",
                    "c9_H : and (Z.le 1 i) (Z.lt i (Z.add 1 (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : not (eq 1 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (hempty i) None",
                    "c9_i : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (ALLOC sz) hempty) (pair c' h')),\nsafe c' h' (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c10_goal : safe c' h' (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "c10_c' : com",
                    "c10_h' : heap",
                    "c10_RED : red (pair (ALLOC sz) hempty) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe c' h' (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "c10_RED : red (pair (ALLOC sz) hempty) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_goal : safe (PURE l) (hinit l sz hempty)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "c11_H4 : not (eq l 0)",
                    "c11_H2 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (hempty i) None",
                    "c11_l : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe (PURE l) (hinit l sz hempty)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c12_goal : pureconj (not (eq l 0)) (valid_N l sz) (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : pureconj (not (eq l 0)) (valid_N l sz) (hinit l sz hempty)"
                ],
                "tactic_res": [
                    "c13_goal : not (eq l 0)",
                    "c14_goal : valid_N l sz (hinit l sz hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : not (eq l 0)",
                    "c11_H4 : not (eq l 0)",
                    "c11_l : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : valid_N l sz (hinit l sz hempty)",
                    "_global_valid_N_init : forall (sz : nat) (l : addr), valid_N l sz (hinit l sz hempty)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_free",
        "proof": [
            {
                "tactic_sig": "Lemma triple_free : forall l , \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_free : forall l , \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall l : addr, triple (valid l) (FREE l) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros l h ( v0 & P ) .",
                "tactic_args": [
                    "c1_goal : forall l : addr, triple (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : safe (FREE l) h (fun _ : Z => emp)",
                    "c2_l : addr",
                    "c2_h : heap",
                    "c2_v0 : Z",
                    "c2_P : contains l v0 h"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c2_P : contains l v0 h"
                ],
                "tactic_res": [
                    "c2_P : eq h (hupdate l v0 hempty)"
                ]
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (FREE l) h (fun _ : Z => emp)",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h l) (Some v0)",
                    "c4_goal : safe (FREE l) h (fun _ : Z => emp)",
                    "c4_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq (h l) (Some v0)",
                    "c2_h : heap",
                    "c2_P : eq h (hupdate l v0 hempty)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (FREE l) h (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c7_goal : immsafe (pair (FREE l) h)",
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (FREE l) h) (pair c' h')),\nsafe c' h' (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : immsafe (pair (FREE l) h)"
                ],
                "tactic_res": [
                    "c9_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c8_goal : forall (c' : com) (h' : heap) (_ : red (pair (FREE l) h) (pair c' h')),\nsafe c' h' (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c10_goal : safe c' h' (fun _ : Z => emp)",
                    "c10_c' : com",
                    "c10_h' : heap",
                    "c10_RED : red (pair (FREE l) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe c' h' (fun _ : Z => emp)",
                    "c10_RED : red (pair (FREE l) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_goal : safe SKIP (hfree l (hupdate l v0 hempty)) (fun _ : Z => emp)",
                    "c11_H0 : not (eq (hupdate l v0 hempty l) None)",
                    "c11_L : eq (hupdate l v0 hempty l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe SKIP (hfree l (hupdate l v0 hempty)) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c12_goal : emp (hfree l (hupdate l v0 hempty))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c12_goal : emp (hfree l (hupdate l v0 hempty))"
                ],
                "tactic_res": [
                    "c13_goal : eq (hfree l (hupdate l v0 hempty)) hempty"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eq (hfree l (hupdate l v0 hempty)) hempty",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c14_goal : forall l0 : addr, eq (hfree l (hupdate l v0 hempty) l0) (hempty l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c14_goal : forall l0 : addr, eq (hfree l (hupdate l v0 hempty) l0) (hempty l0)"
                ],
                "tactic_res": [
                    "c15_goal : eq (hfree l (hupdate l v0 hempty) x) (hempty x)",
                    "c15_x : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c15_goal : eq (hfree l (hupdate l v0 hempty) x) (hempty x)"
                ],
                "tactic_res": [
                    "c16_goal : eq\n  (if Z.eq_dec l x\n   then None\n   else if Z.eq_dec l x then Some v0 else None) None"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c16_goal : eq\n  (if Z.eq_dec l x\n   then None\n   else if Z.eq_dec l x then Some v0 else None) None",
                    "c2_l : addr",
                    "c15_x : addr",
                    "c11_H0 : not (eq (hupdate l v0 hempty l) None)",
                    "c11_L : eq (hupdate l v0 hempty l) (Some v0)",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c17_goal : eq None None",
                    "c17_e : eq l x",
                    "c18_goal : eq None None",
                    "c18_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq None None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_pure",
        "proof": [
            {
                "tactic_sig": "Lemma safe_pure : forall v h Q , safe ( PURE v ) h Q -> Q v h .",
                "tactic_sig_no_out_arg": "Lemma safe_pure : forall v h Q , safe ( PURE v ) h Q -> Q v h .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : Z) (h : heap) (Q : postcond) (_ : safe (PURE v) h Q), Q v h"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v : Z) (h : heap) (Q : postcond) (_ : safe (PURE v) h Q), Q v h"
                ],
                "tactic_res": [
                    "c2_goal : Q v h",
                    "c2_v : Z",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_H : safe (PURE v) h Q"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : Q v h",
                    "c2_H : safe (PURE v) h Q"
                ],
                "tactic_res": [
                    "c3_goal : Q v h",
                    "c3_H1 : Q v h",
                    "c4_goal : Q v h",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair (PURE v) h) (pair c' h')),\nsafe c' h' Q",
                    "c4_H1 : immsafe (pair (PURE v) h)",
                    "c4_H0 : False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : Q v h",
                    "c3_H1 : Q v h",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c4_goal : Q v h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_red",
        "proof": [
            {
                "tactic_sig": "Lemma safe_red : forall c h Q c' h' , safe c h Q -> red ( c , h ) ( c' , h' ) -> safe c' h' Q .",
                "tactic_sig_no_out_arg": "Lemma safe_red : forall c h Q c' h' , safe c h Q -> red ( c , h ) ( c' , h' ) -> safe c' h' Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (h : heap) (Q : postcond) (c' : com) \n  (h' : heap) (_ : safe c h Q) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (h : heap) (Q : postcond) (c' : com) \n  (h' : heap) (_ : safe c h Q) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q"
                ],
                "tactic_res": [
                    "c2_goal : safe c' h' Q",
                    "c2_c : com",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_c' : com",
                    "c2_h' : heap",
                    "c2_H : safe c h Q",
                    "c2_H0 : red (pair c h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : safe c' h' Q",
                    "c2_H : safe c h Q"
                ],
                "tactic_res": [
                    "c3_goal : safe c' h' Q",
                    "c3_H1 : Q v h",
                    "c3_H0 : red (pair (PURE v) h) (pair c' h')",
                    "c3_v : Z",
                    "c4_goal : safe c' h' Q",
                    "c4_H3 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c4_H2 : immsafe (pair c h)",
                    "c4_H1 : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : safe c' h' Q",
                    "c3_H0 : red (pair (PURE v) h) (pair c' h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : safe c' h' Q",
                    "c4_H3 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c2_H0 : red (pair c h) (pair c' h')",
                    "c2_h' : heap",
                    "c2_c' : com",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_immsafe",
        "proof": [
            {
                "tactic_sig": "Lemma safe_immsafe : forall c h Q , safe c h Q -> immsafe ( c , h ) .",
                "tactic_sig_no_out_arg": "Lemma safe_immsafe : forall c h Q , safe c h Q -> immsafe ( c , h ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (h : heap) (Q : postcond) (_ : safe c h Q),\nimmsafe (pair c h)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (h : heap) (Q : postcond) (_ : safe c h Q),\nimmsafe (pair c h)"
                ],
                "tactic_res": [
                    "c2_goal : immsafe (pair c h)",
                    "c2_c : com",
                    "c2_h : heap",
                    "c2_Q : postcond",
                    "c2_H : safe c h Q"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : immsafe (pair c h)",
                    "c2_H : safe c h Q"
                ],
                "tactic_res": [
                    "c3_goal : immsafe (pair (PURE v) h)",
                    "c3_H0 : Q v h",
                    "c3_v : Z",
                    "c4_goal : immsafe (pair c h)",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c4_H1 : immsafe (pair c h)",
                    "c4_H0 : match c with\n| PURE _ => False\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : immsafe (pair (PURE v) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : immsafe (pair c h)",
                    "c4_H1 : immsafe (pair c h)",
                    "c2_h : heap",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_let",
        "proof": [
            {
                "tactic_sig": "Lemma safe_let : forall ( Q R : postcond ) f , ( forall v h' , Q v h' -> safe ( f v ) h' R ) -> forall c h , safe c h Q -> safe ( LET c f ) h R .",
                "tactic_sig_no_out_arg": "Lemma safe_let : forall ( Q R : postcond ) f , ( forall v h' , Q v h' -> safe ( f v ) h' R ) -> forall c h , safe c h Q -> safe ( LET c f ) h R .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q R : postcond) (f : forall _ : Z, com)\n  (_ : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R)\n  (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q R f POST .",
                "tactic_args": [
                    "c1_goal : forall (Q R : postcond) (f : forall _ : Z, com)\n  (_ : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R)\n  (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R",
                    "c2_Q : postcond",
                    "c2_R : postcond",
                    "c2_f : forall _ : Z, com",
                    "c2_POST : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R"
                ],
                "tactic_res": [
                    "c3_goal : safe (LET (PURE v) f) h R",
                    "c3_H : Q v h",
                    "c3_h : heap",
                    "c3_v : Z",
                    "c4_goal : safe (LET c f) h R",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h'))\n  (_ : forall (v : Z) (h'0 : heap) (_ : Q v h'0), safe (f v) h'0 R),\nsafe (LET c' f) h' R",
                    "c4_H1 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c4_H0 : immsafe (pair c h)",
                    "c4_H : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_h : heap",
                    "c4_c : com"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (LET (PURE v) f) h R"
                ],
                "tactic_res": [
                    "c5_goal : True",
                    "c6_goal : immsafe (pair (LET (PURE v) f) h)",
                    "c7_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (LET (PURE v) f) h) (pair c' h')), \nsafe c' h' R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : immsafe (pair (LET (PURE v) f) h)"
                ],
                "tactic_res": [
                    "c8_goal : immsafe (pair (PURE v) h)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : immsafe (pair (PURE v) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c7_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (LET (PURE v) f) h) (pair c' h')), \nsafe c' h' R"
                ],
                "tactic_res": [
                    "c9_goal : safe c' h' R",
                    "c9_c' : com",
                    "c9_h' : heap",
                    "c9_RED : red (pair (LET (PURE v) f) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : safe c' h' R",
                    "c9_RED : red (pair (LET (PURE v) f) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c10_goal : safe (f v) h' R",
                    "c10_H : Q v h'",
                    "c11_goal : safe (LET c'0 f) h' R",
                    "c11_H1 : red (pair (PURE v) h) (pair c'0 h')",
                    "c11_c'0 : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe (f v) h' R",
                    "c2_POST : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R"
                ],
                "tactic_res": [
                    "c12_goal : Q v h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Q v h'",
                    "c10_H : Q v h'",
                    "c9_h' : heap",
                    "c3_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : safe (LET c'0 f) h' R",
                    "c11_H1 : red (pair (PURE v) h) (pair c'0 h')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : safe (LET c f) h R"
                ],
                "tactic_res": [
                    "c13_goal : True",
                    "c14_goal : immsafe (pair (LET c f) h)",
                    "c15_goal : forall (c' : com) (h' : heap) (_ : red (pair (LET c f) h) (pair c' h')),\nsafe c' h' R"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c14_goal : immsafe (pair (LET c f) h)"
                ],
                "tactic_res": [
                    "c16_goal : immsafe (pair c h)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : immsafe (pair c h)",
                    "c4_H0 : immsafe (pair c h)",
                    "c4_h : heap",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c15_goal : forall (c' : com) (h' : heap) (_ : red (pair (LET c f) h) (pair c' h')),\nsafe c' h' R"
                ],
                "tactic_res": [
                    "c17_goal : safe c' h' R",
                    "c17_c' : com",
                    "c17_h' : heap",
                    "c17_RED : red (pair (LET c f) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c17_goal : safe c' h' R",
                    "c17_RED : red (pair (LET c f) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c18_goal : safe (f x) h' R",
                    "c18_H : False",
                    "c18_H2 : forall (c' : com) (h'0 : heap)\n  (_ : red (pair (PURE x) h') (pair c' h'0))\n  (_ : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R),\nsafe (LET c' f) h'0 R",
                    "c18_H1 : forall (c' : com) (h'0 : heap)\n  (_ : red (pair (PURE x) h') (pair c' h'0)), safe c' h'0 Q",
                    "c18_H0 : immsafe (pair (PURE x) h')",
                    "c18_x : Z",
                    "c19_goal : safe (LET c'0 f) h' R",
                    "c19_H4 : red (pair c h) (pair c'0 h')",
                    "c19_c'0 : com"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c18_goal : safe (f x) h' R"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : safe (LET c'0 f) h' R",
                    "c19_H4 : red (pair c h) (pair c'0 h')",
                    "c19_c'0 : com",
                    "c17_h' : heap",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h'))\n  (_ : forall (v : Z) (h'0 : heap) (_ : Q v h'0), safe (f v) h'0 R),\nsafe (LET c' f) h' R",
                    "c2_POST : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R",
                    "c2_f : forall _ : Z, com",
                    "c2_R : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "safe_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma safe_consequence : forall ( Q Q' : postcond ) , ( forall v , Q v -->> Q' v ) -> forall c h , safe c h Q -> safe c h Q' .",
                "tactic_sig_no_out_arg": "Lemma safe_consequence : forall ( Q Q' : postcond ) , ( forall v , Q v -->> Q' v ) -> forall c h , safe c h Q -> safe c h Q' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q Q' : postcond) (_ : forall v : Z, aimp (Q v) (Q' v))\n  (c : com) (h : heap) (_ : safe c h Q), safe c h Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros Q Q' IMP .",
                "tactic_args": [
                    "c1_goal : forall (Q Q' : postcond) (_ : forall v : Z, aimp (Q v) (Q' v))\n  (c : com) (h : heap) (_ : safe c h Q), safe c h Q'"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe c h Q), safe c h Q'",
                    "c2_Q : postcond",
                    "c2_Q' : postcond",
                    "c2_IMP : forall v : Z, aimp (Q v) (Q' v)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c2_goal : forall (c : com) (h : heap) (_ : safe c h Q), safe c h Q'"
                ],
                "tactic_res": [
                    "c3_goal : safe (PURE v) h Q'",
                    "c3_H : Q v h",
                    "c3_h : heap",
                    "c3_v : Z",
                    "c4_goal : safe c h Q'",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h'))\n  (_ : forall v : Z, aimp (Q v) (Q' v)), safe c' h' Q'",
                    "c4_H1 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q",
                    "c4_H0 : immsafe (pair c h)",
                    "c4_H : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_h : heap",
                    "c4_c : com"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe (PURE v) h Q'",
                    "_global_safe_done : forall (v : Z) (h : heap) (Q : postcond) (_ : Q v h),\n       safe (PURE v) h Q"
                ],
                "tactic_res": [
                    "c5_goal : Q' v h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Q' v h",
                    "c2_IMP : forall v : Z, aimp (Q v) (Q' v)"
                ],
                "tactic_res": [
                    "c6_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c6_goal : Q v h",
                    "c3_H : Q v h",
                    "c3_h : heap",
                    "c3_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : safe c h Q'",
                    "_global_safe_step : forall (c : com) (h : heap) (Q : postcond)\n         (_ : match c with\n              | PURE _ => False\n              | _ => True\n              end) (_ : immsafe (pair c h))\n         (_ : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\n              safe c' h' Q), safe c h Q"
                ],
                "tactic_res": [
                    "c7_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c8_goal : immsafe (pair c h)",
                    "c9_goal : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_H : match c with\n| PURE _ => False\n| _ => True\nend",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : immsafe (pair c h)",
                    "c4_H0 : immsafe (pair c h)",
                    "c4_h : heap",
                    "c4_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h')),\nsafe c' h' Q'",
                    "c4_H2 : forall (c' : com) (h' : heap) (_ : red (pair c h) (pair c' h'))\n  (_ : forall v : Z, aimp (Q v) (Q' v)), safe c' h' Q'",
                    "c4_h : heap",
                    "c4_c : com",
                    "c2_IMP : forall v : Z, aimp (Q v) (Q' v)",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pure",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pure : forall P v ( Q : postcond ) , P -->> Q v -> \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pure : forall P v ( Q : postcond ) , P -->> Q v -> \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\ntriple P (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\ntriple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (PURE v) Q",
                    "c2_P : assertion",
                    "c2_v : Z",
                    "c2_Q : postcond",
                    "c2_H : aimp P (Q v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h Ph .",
                "tactic_args": [
                    "c2_goal : triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe (PURE v) h Q",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (PURE v) h Q"
                ],
                "tactic_res": [
                    "c4_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Q v h",
                    "c2_H : aimp P (Q v)"
                ],
                "tactic_res": [
                    "c5_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_let",
        "proof": [
            {
                "tactic_sig": "Lemma triple_let : forall c f ( P : precond ) ( Q R : postcond ) , \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_let : forall c f ( P : precond ) ( Q R : postcond ) , \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : triple P c Q)\n  (_ : forall v : Z, triple (Q v) (f v) R), triple P (LET c f) R"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until R .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : triple P c Q)\n  (_ : forall v : Z, triple (Q v) (f v) R), triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : triple P c Q) (_ : forall v : Z, triple (Q v) (f v) R),\ntriple P (LET c f) R",
                    "c2_R : postcond",
                    "c2_Q : postcond",
                    "c2_P : precond",
                    "c2_f : forall _ : Z, com",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros HR1 HR2 h Ph .",
                "tactic_args": [
                    "c2_goal : forall (_ : triple P c Q) (_ : forall v : Z, triple (Q v) (f v) R),\ntriple P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : safe (LET c f) h R",
                    "c3_HR1 : triple P c Q",
                    "c3_HR2 : forall v : Z, triple (Q v) (f v) R",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe (LET c f) h R",
                    "_global_safe_let : forall (Q R : postcond) (f : forall _ : Z, com)\n         (_ : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R)\n         (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c4_goal : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R",
                    "c5_goal : safe c h Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R",
                    "c3_HR2 : forall v : Z, triple (Q v) (f v) R"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe c h Q",
                    "c3_HR1 : triple P c Q"
                ],
                "tactic_res": [
                    "c6_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthenelse : forall b c1 c2 P Q , \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthenelse : forall b c1 c2 P Q , \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q",
                    "c2_Q : postcond",
                    "c2_P : assertion",
                    "c2_c2 : com",
                    "c2_c1 : com",
                    "c2_b : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros HR1 HR2 h Ph .",
                "tactic_args": [
                    "c2_goal : forall (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe (IFTHENELSE b c1 c2) h Q",
                    "c3_HR1 : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c3_HR2 : triple (pureconj (eq b 0) P) c2 Q",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (IFTHENELSE b c1 c2) h Q"
                ],
                "tactic_res": [
                    "c4_goal : True",
                    "c5_goal : immsafe (pair (IFTHENELSE b c1 c2) h)",
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')), \nsafe c' h' Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : immsafe (pair (IFTHENELSE b c1 c2) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')), \nsafe c' h' Q"
                ],
                "tactic_res": [
                    "c7_goal : safe c' h' Q",
                    "c7_c' : com",
                    "c7_h' : heap",
                    "c7_RED : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c7_goal : safe c' h' Q",
                    "c7_RED : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c8_goal : safe (if Z.eqb b 0 then c2 else c1) h' Q",
                    "c8_Ph : P h'"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eqb_spec _i 0 ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eqb_spec _i 0 ) .",
                "tactic_args": [
                    "c8_goal : safe (if Z.eqb b 0 then c2 else c1) h' Q",
                    "c2_b : Z",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c3_HR2 : triple (pureconj (eq b 0) P) c2 Q",
                    "c3_HR1 : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_Q : postcond",
                    "c2_c1 : com",
                    "c2_c2 : com"
                ],
                "tactic_res": [
                    "c9_goal : safe c2 h' Q",
                    "c9_e : eq b 0",
                    "c10_goal : safe c1 h' Q",
                    "c10_n : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : safe c2 h' Q",
                    "c3_HR2 : triple (pureconj (eq b 0) P) c2 Q"
                ],
                "tactic_res": [
                    "c11_goal : pureconj (eq b 0) P h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c11_goal : pureconj (eq b 0) P h'"
                ],
                "tactic_res": [
                    "c12_goal : eq b 0",
                    "c13_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq b 0",
                    "c9_e : eq b 0",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : P h'",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe c1 h' Q",
                    "c3_HR1 : triple (pureconj (not (eq b 0)) P) c1 Q"
                ],
                "tactic_res": [
                    "c14_goal : pureconj (not (eq b 0)) P h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : pureconj (not (eq b 0)) P h'"
                ],
                "tactic_res": [
                    "c15_goal : not (eq b 0)",
                    "c16_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : not (eq b 0)",
                    "c10_n : not (eq b 0)",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : P h'",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence : forall P P' c Q' Q , \u2983 P' \u2984 c \u2983 Q' \u2984 -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence : forall P P' c Q' Q , \u2983 P' \u2984 c \u2983 Q' \u2984 -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : triple P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \ntriple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : triple P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \ntriple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P c Q",
                    "c2_P : assertion",
                    "c2_P' : precond",
                    "c2_c : com",
                    "c2_Q' : postcond",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_H : triple P' c Q'",
                    "c2_H0 : aimp P P'",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple P c Q"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap) (_ : P h), safe c h Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap) (_ : P h), safe c h Q"
                ],
                "tactic_res": [
                    "c4_goal : safe c h Q",
                    "c4_h : heap",
                    "c4_H2 : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : safe c h Q",
                    "_global_safe_consequence : forall (Q Q' : postcond) (_ : forall v : Z, aimp (Q v) (Q' v))\n         (c : com) (h : heap) (_ : safe c h Q), safe c h Q'",
                    "c2_Q' : postcond"
                ],
                "tactic_res": [
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c6_goal : safe c h Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : safe c h Q'",
                    "c4_H2 : P h",
                    "c4_h : heap",
                    "c2_H0 : aimp P P'",
                    "c2_H : triple P' c Q'",
                    "c2_Q' : postcond",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pick",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pick : forall n , \u2983 emp \u2984 PICK n \u2983 fun i => pure ( 0 <= i < n ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pick : forall n , \u2983 emp \u2984 PICK n \u2983 fun i => pure ( 0 <= i < n ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : Z,\ntriple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n h Ph .",
                "tactic_args": [
                    "c1_goal : forall n : Z,\ntriple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c2_goal : safe (PICK n) h (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "c2_n : Z",
                    "c2_h : heap",
                    "c2_Ph : emp h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : safe (PICK n) h (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c3_goal : True",
                    "c4_goal : immsafe (pair (PICK n) h)",
                    "c5_goal : forall (c' : com) (h' : heap) (_ : red (pair (PICK n) h) (pair c' h')),\nsafe c' h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : immsafe (pair (PICK n) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c5_goal : forall (c' : com) (h' : heap) (_ : red (pair (PICK n) h) (pair c' h')),\nsafe c' h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c6_goal : safe c' h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "c6_c' : com",
                    "c6_h' : heap",
                    "c6_RED : red (pair (PICK n) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe c' h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "c6_RED : red (pair (PICK n) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c7_goal : safe (PURE i) h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "c7_H0 : and (Z.le 0 i) (Z.lt i n)",
                    "c7_i : Z",
                    "c7_Ph : emp h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (PURE i) h' (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c8_goal : pure (and (Z.le 0 i) (Z.lt i n)) h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : pure (and (Z.le 0 i) (Z.lt i n)) h'"
                ],
                "tactic_res": [
                    "c9_goal : and (Z.le 0 i) (Z.lt i n)",
                    "c10_goal : eq h' hempty"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 i) (Z.lt i n)",
                    "c7_H0 : and (Z.le 0 i) (Z.lt i n)",
                    "c7_i : Z",
                    "c2_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq h' hempty",
                    "c7_Ph : emp h'",
                    "c6_h' : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence_pre",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence_pre : forall P P' c Q , \u2983 P' \u2984 c \u2983 Q \u2984 -> P -->> P' -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence_pre : forall P P' c Q , \u2983 P' \u2984 c \u2983 Q \u2984 -> P -->> P' -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q : postcond)\n  (_ : triple P' c Q) (_ : aimp P P'), triple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q : postcond)\n  (_ : triple P' c Q) (_ : aimp P P'), triple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P c Q",
                    "c2_P : assertion",
                    "c2_P' : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : triple P' c Q",
                    "c2_H0 : aimp P P'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c2_goal : triple P c Q",
                    "_global_triple_consequence : forall (P : assertion) (P' : precond) (c : com) \n         (Q' : postcond) (Q : forall _ : Z, assertion) \n         (_ : triple P' c Q') (_ : aimp P P')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q",
                    "c2_P' : precond",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c3_goal : triple P' c Q",
                    "c4_goal : aimp P P'",
                    "c5_goal : forall v : Z, aimp (Q v) (Q v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : triple P' c Q",
                    "c2_H : triple P' c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P' : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : aimp P P'",
                    "c2_H0 : aimp P P'",
                    "c2_P' : precond",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q v) (Q v)"
                ],
                "tactic_res": [
                    "c6_goal : aimp (Q v) (Q v)",
                    "c6_v : Z"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : aimp (Q v) (Q v)"
                ],
                "tactic_res": [
                    "c7_goal : forall (h : heap) (_ : Q v h), Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (h : heap) (_ : Q v h), Q v h",
                    "c6_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence_post",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence_post : forall P c Q Q' , \u2983 P \u2984 c \u2983 Q' \u2984 -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence_post : forall P c Q Q' , \u2983 P \u2984 c \u2983 Q' \u2984 -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n  (Q' : postcond) (_ : triple P c Q')\n  (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n  (Q' : postcond) (_ : triple P c Q')\n  (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P c Q",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_Q' : postcond",
                    "c2_H : triple P c Q'",
                    "c2_H0 : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c2_goal : triple P c Q",
                    "_global_triple_consequence : forall (P : assertion) (P' : precond) (c : com) \n         (Q' : postcond) (Q : forall _ : Z, assertion) \n         (_ : triple P' c Q') (_ : aimp P P')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q",
                    "c2_P : precond",
                    "c2_Q' : postcond"
                ],
                "tactic_res": [
                    "c3_goal : triple P c Q'",
                    "c4_goal : aimp P P",
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : triple P c Q'",
                    "c2_H : triple P c Q'",
                    "c2_Q' : postcond",
                    "c2_c : com",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_H0 : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_Q' : postcond",
                    "c2_Q : forall _ : Z, assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp P P"
                ],
                "tactic_res": [
                    "c6_goal : forall (h : heap) (_ : P h), P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (h : heap) (_ : P h), P h",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_lift_pure",
        "proof": [
            {
                "tactic_sig": "Lemma triple_lift_pure : forall ( P : Prop ) P' c Q , ( P -> \u2983 P' \u2984 c \u2983 Q \u2984 ) -> \u2983 P //\\\\ P' \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_lift_pure : forall ( P : Prop ) P' c Q , ( P -> \u2983 P' \u2984 c \u2983 Q \u2984 ) -> \u2983 P //\\\\ P' \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : Prop) (P' : precond) (c : com) (Q : postcond)\n  (_ : forall _ : P, triple P' c Q), triple (pureconj P P') c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : Prop) (P' : precond) (c : com) (Q : postcond)\n  (_ : forall _ : P, triple P' c Q), triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (pureconj P P') c Q",
                    "c2_P : Prop",
                    "c2_P' : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : forall _ : P, triple P' c Q"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros h [ P1 P2 ] .",
                "tactic_args": [
                    "c2_goal : triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe c h Q",
                    "c3_h : heap",
                    "c3_P1 : P",
                    "c3_P2 : P' h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : safe c h Q",
                    "c2_H : forall _ : P, triple P' c Q"
                ],
                "tactic_res": [
                    "c4_goal : P",
                    "c5_goal : P' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P",
                    "c3_P1 : P",
                    "c2_P : Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P' h",
                    "c3_P2 : P' h",
                    "c3_h : heap",
                    "c2_P' : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_lift_exists",
        "proof": [
            {
                "tactic_sig": "Lemma triple_lift_exists : forall ( X : Type ) ( P : X -> assertion ) c Q , ( forall x , \u2983 P x \u2984 c \u2983 Q \u2984 ) -> \u2983 aexists P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_lift_exists : forall ( X : Type ) ( P : X -> assertion ) c Q , ( forall x , \u2983 P x \u2984 c \u2983 Q \u2984 ) -> \u2983 aexists P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (c : com)\n  (Q : postcond) (_ : forall x : X, triple (P x) c Q),\ntriple (aexists P) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (X : Type) (P : forall _ : X, assertion) (c : com)\n  (Q : postcond) (_ : forall x : X, triple (P x) c Q),\ntriple (aexists P) c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple (aexists P) c Q",
                    "c2_X : Type",
                    "c2_P : forall _ : X, assertion",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : forall x : X, triple (P x) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( x & Px ) .",
                "tactic_args": [
                    "c2_goal : triple (aexists P) c Q"
                ],
                "tactic_res": [
                    "c3_goal : safe c h Q",
                    "c3_h : heap",
                    "c3_x : X",
                    "c3_Px : P x h"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : safe c h Q",
                    "c2_H : forall x : X, triple (P x) c Q",
                    "c3_x : X"
                ],
                "tactic_res": [
                    "c4_goal : P x h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P x h",
                    "c3_Px : P x h",
                    "c3_x : X",
                    "c3_h : heap",
                    "c2_P : forall _ : X, assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthen",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthen : forall b c1 c2 P Q , b <> 0 -> \u2983 P \u2984 c1 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthen : forall b c1 c2 P Q , b <> 0 -> \u2983 P \u2984 c1 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : precond) (Q : postcond)\n  (_ : not (eq b 0)) (_ : triple P c1 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : precond) (Q : postcond)\n  (_ : not (eq b 0)) (_ : triple P c1 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : precond",
                    "c2_Q : postcond",
                    "c2_H : not (eq b 0)",
                    "c2_H0 : triple P c1 Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "_global_triple_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple (pureconj (eq b 0) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c4_goal : triple (pureconj (eq b 0) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : not (eq b 0), triple P c1 Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall _ : not (eq b 0), triple P c1 Q"
                ],
                "tactic_res": [
                    "c6_goal : triple P c1 Q",
                    "c6_H1 : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple (pureconj (eq b 0) P) c2 Q",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq b 0, triple P c2 Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall _ : eq b 0, triple P c2 Q"
                ],
                "tactic_res": [
                    "c8_goal : triple P c2 Q",
                    "c8_H1 : eq b 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : triple P c1 Q",
                    "c2_H0 : triple P c1 Q",
                    "c2_Q : postcond",
                    "c2_P : precond",
                    "c2_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c8_goal : triple P c2 Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifelse : forall b c1 c2 P Q , b = 0 -> \u2983 P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifelse : forall b c1 c2 P Q , b = 0 -> \u2983 P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : precond) (Q : postcond) \n  (_ : eq b 0) (_ : triple P c2 Q), triple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : precond) (Q : postcond) \n  (_ : eq b 0) (_ : triple P c2 Q), triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : precond",
                    "c2_Q : postcond",
                    "c2_H : eq b 0",
                    "c2_H0 : triple P c2 Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple P (IFTHENELSE b c1 c2) Q",
                    "_global_triple_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple (pureconj (eq b 0) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c4_goal : triple (pureconj (eq b 0) P) c2 Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : not (eq b 0), triple P c1 Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall _ : not (eq b 0), triple P c1 Q"
                ],
                "tactic_res": [
                    "c6_goal : triple P c1 Q",
                    "c6_H1 : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple (pureconj (eq b 0) P) c2 Q",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq b 0, triple P c2 Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall _ : eq b 0, triple P c2 Q"
                ],
                "tactic_res": [
                    "c8_goal : triple P c2 Q",
                    "c8_H1 : eq b 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c6_goal : triple P c1 Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : triple P c2 Q",
                    "c2_H0 : triple P c2 Q",
                    "c2_Q : postcond",
                    "c2_P : precond",
                    "c2_c2 : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "unroll_com",
        "proof": [
            {
                "tactic_sig": "Lemma unroll_com : forall c , c = match c with | PURE x => PURE x | LET c f => LET c f | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2 | ALLOC sz => ALLOC sz | GET l => GET l | SET l v => SET l v | FREE l => FREE l | PICK n => PICK n end .",
                "tactic_sig_no_out_arg": "Lemma unroll_com : forall c , c = match c with | PURE x => PURE x | LET c f => LET c f | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2 | ALLOC sz => ALLOC sz | GET l => GET l | SET l v => SET l v | FREE l => FREE l | PICK n => PICK n end .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall c : com,\neq c\n  match c with\n  | PURE x => PURE x\n  | LET c0 f => LET c0 f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct c as [  _o | _o _o | _o _o _o | _o | _o | _o _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct c .",
                "tactic_args": [
                    "c1_goal : forall c : com,\neq c\n  match c with\n  | PURE x => PURE x\n  | LET c0 f => LET c0 f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end"
                ],
                "tactic_res": [
                    "c2_goal : eq (PURE x) (PURE x)",
                    "c2_x : Z",
                    "c3_goal : eq (LET c f) (LET c f)",
                    "c3_f : forall _ : Z, com",
                    "c3_c : com",
                    "c4_goal : eq (IFTHENELSE b c1 c2) (IFTHENELSE b c1 c2)",
                    "c4_c2 : com",
                    "c4_c1 : com",
                    "c4_b : Z",
                    "c5_goal : eq (ALLOC sz) (ALLOC sz)",
                    "c5_sz : nat",
                    "c6_goal : eq (GET l) (GET l)",
                    "c6_l : addr",
                    "c7_goal : eq (SET l v) (SET l v)",
                    "c7_v : Z",
                    "c7_l : addr",
                    "c8_goal : eq (FREE l) (FREE l)",
                    "c8_l : addr",
                    "c9_goal : eq (PICK n) (PICK n)",
                    "c9_n : Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : eq (PURE x) (PURE x)",
                    "c2_x : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (LET c f) (LET c f)",
                    "c3_f : forall _ : Z, com",
                    "c3_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (IFTHENELSE b c1 c2) (IFTHENELSE b c1 c2)",
                    "c4_c1 : com",
                    "c4_c2 : com",
                    "c4_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (ALLOC sz) (ALLOC sz)",
                    "c5_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (GET l) (GET l)",
                    "c6_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (SET l v) (SET l v)",
                    "c7_v : Z",
                    "c7_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (FREE l) (FREE l)",
                    "c8_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (PICK n) (PICK n)",
                    "c9_n : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_cons_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_cons_correct : forall a n l , \u2983 list_at a l \u2984 list_cons n a \u2983 fun a' => list_at a' ( n :: l ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_cons_correct : forall a n l , \u2983 list_at a l \u2984 list_cons n a \u2983 fun a' => list_at a' ( n :: l ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : addr) (n : Z) (l : list Z),\ntriple (list_at a l) (list_cons n a)\n  (fun a' : Z => list_at a' (cons n l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (a : addr) (n : Z) (l : list Z),\ntriple (list_at a l) (list_cons n a)\n  (fun a' : Z => list_at a' (cons n l))"
                ],
                "tactic_res": [
                    "c2_goal : triple (list_at a l) (list_cons n a)\n  (fun a' : Z => list_at a' (cons n l))",
                    "c2_a : addr",
                    "c2_n : Z",
                    "c2_l : list Z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : triple (list_at a l) (list_cons n a)\n  (fun a' : Z => list_at a' (cons n l))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : triple (list_at a l) (ALLOC 2) ?Q",
                    "c4_goal : forall v : Z,\ntriple (?Q v) (SEQ (SET v n) (SEQ (SET (Z.add v 1) a) (PURE v)))\n  (fun a' : Z => list_at a' (cons n l))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i at 1 .",
                "tactic_sig_no_out_arg": "rewrite <- _i at 1 .",
                "tactic_args": [
                    "c3_goal : triple (list_at a l) (ALLOC 2) ?Q",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c5_goal : triple (sepconj emp (list_at a l)) (ALLOC 2) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (sepconj emp (list_at a l)) (ALLOC 2) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c6_goal : triple emp (ALLOC 2) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple emp (ALLOC 2) ?Q",
                    "_global_triple_alloc : forall sz : nat,\n       triple emp (ALLOC sz)\n         (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros b .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v0)\n      (list_at a l)) v)\n  (SEQ (SET v n) (SEQ (SET (Z.add v 1) a) (PURE v)))\n  (fun a' : Z => list_at a' (cons n l))"
                ],
                "tactic_res": [
                    "c7_goal : triple\n  ((fun v : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v)\n      (list_at a l)) b)\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z => list_at a' (cons n l))",
                    "c7_b : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : triple\n  ((fun v : Z =>\n    sepconj ((fun l : Z => pureconj (not (eq l 0)) (valid_N l 2)) v)\n      (list_at a l)) b)\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z => list_at a' (cons n l))"
                ],
                "tactic_res": [
                    "c8_goal : triple\n  (sepconj\n     (pureconj (not (eq b 0))\n        (sepconj (valid b) (sepconj (valid (Z.add b 1)) emp)))\n     (list_at a l)) (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , ! _i , _i .",
                "tactic_args": [
                    "c8_goal : triple\n  (sepconj\n     (pureconj (not (eq b 0))\n        (sepconj (valid b) (sepconj (valid (Z.add b 1)) emp)))\n     (list_at a l)) (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c9_goal : triple\n  (pureconj (not (eq b 0))\n     (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l))))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple\n  (pureconj (not (eq b 0))\n     (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l))))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : not (eq b 0),\ntriple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c10_goal : forall _ : not (eq b 0),\ntriple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ],
                "tactic_res": [
                    "c11_goal : triple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "c11_H1 : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c11_goal : triple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET b n) (SEQ (SET (Z.add b 1) a) (PURE b)))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c12_goal : triple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SET b n) ?Q",
                    "c13_goal : forall v : Z,\ntriple (?Q v) (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : triple (sepconj (valid b) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SET b n) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c14_goal : triple (valid b) (SET b n) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple (valid b) (SET b n) ?Q",
                    "_global_triple_set : forall (l : addr) (v : Z),\n       triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => contains b n) v0)\n      (sepconj (valid (Z.add b 1)) (list_at a l))) v)\n  (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : Z,\ntriple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c15_goal : forall _ : Z,\ntriple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ],
                "tactic_res": [
                    "c16_goal : triple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c16_goal : triple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SEQ (SET (Z.add b 1) a) (PURE b))\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c17_goal : triple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SET (Z.add b 1) a) ?Q",
                    "c18_goal : forall v : Z,\ntriple (?Q v) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : triple\n  (sepconj (contains b n) (sepconj (valid (Z.add b 1)) (list_at a l)))\n  (SET (Z.add b 1) a) ?Q",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c19_goal : triple\n  (sepconj (valid (Z.add b 1)) (sepconj (contains b n) (list_at a l)))\n  (SET (Z.add b 1) a) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : triple\n  (sepconj (valid (Z.add b 1)) (sepconj (contains b n) (list_at a l)))\n  (SET (Z.add b 1) a) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c20_goal : triple (valid (Z.add b 1)) (SET (Z.add b 1) a) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : triple (valid (Z.add b 1)) (SET (Z.add b 1) a) ?Q",
                    "_global_triple_set : forall (l : addr) (v : Z),\n       triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c18_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => contains (Z.add b 1) a) v0)\n      (sepconj (contains b n) (list_at a l))) v) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : Z,\ntriple\n  (sepconj (contains (Z.add b 1) a)\n     (sepconj (contains b n) (list_at a l))) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c21_goal : forall _ : Z,\ntriple\n  (sepconj (contains (Z.add b 1) a)\n     (sepconj (contains b n) (list_at a l))) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ],
                "tactic_res": [
                    "c22_goal : triple\n  (sepconj (contains (Z.add b 1) a)\n     (sepconj (contains b n) (list_at a l))) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : triple\n  (sepconj (contains (Z.add b 1) a)\n     (sepconj (contains b n) (list_at a l))) (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c23_goal : triple\n  (sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a) (list_at a l))) \n  (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : triple\n  (sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a) (list_at a l))) \n  (PURE b)\n  (fun a' : Z =>\n   pureconj (not (eq a' 0))\n     (aexists\n        (fun a'0 : Z =>\n         sepconj (contains a' n)\n           (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 l)))))",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c24_goal : aimp\n  (sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a) (list_at a l)))\n  (pureconj (not (eq b 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains b n)\n           (sepconj (contains (Z.add b 1) a') (list_at a' l)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c24_goal : aimp\n  (sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a) (list_at a l)))\n  (pureconj (not (eq b 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains b n)\n           (sepconj (contains (Z.add b 1) a') (list_at a' l)))))"
                ],
                "tactic_res": [
                    "c25_goal : pureconj (not (eq b 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains b n)\n        (sepconj (contains (Z.add b 1) a') (list_at a' l)))) h",
                    "c25_h : heap",
                    "c25_A : sepconj (contains b n) (sepconj (contains (Z.add b 1) a) (list_at a l))\n  h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c25_goal : pureconj (not (eq b 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains b n)\n        (sepconj (contains (Z.add b 1) a') (list_at a' l)))) h"
                ],
                "tactic_res": [
                    "c26_goal : not (eq b 0)",
                    "c27_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a') (list_at a' l))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : not (eq b 0)",
                    "c11_H1 : not (eq b 0)",
                    "c7_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c27_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains b n)\n     (sepconj (contains (Z.add b 1) a') (list_at a' l))) h",
                    "c2_a : addr"
                ],
                "tactic_res": [
                    "c28_goal : sepconj (contains b n) (sepconj (contains (Z.add b 1) a) (list_at a l))\n  h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : sepconj (contains b n) (sepconj (contains (Z.add b 1) a) (list_at a l))\n  h",
                    "c25_A : sepconj (contains b n) (sepconj (contains (Z.add b 1) a) (list_at a l))\n  h",
                    "c25_h : heap",
                    "c7_b : Z",
                    "c2_l : list Z",
                    "c2_n : Z",
                    "c2_a : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_length_rec_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_length_rec_correct : forall l a len , \u2983 list_at a l \u2984 list_length_rec a len \u2983 fun len' => ( len' = len + Z.of_nat ( List.length l ) ) //\\\\ list_at a l \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_length_rec_correct : forall l a len , \u2983 list_at a l \u2984 list_length_rec a len \u2983 fun len' => ( len' = len + Z.of_nat ( List.length l ) ) //\\\\ list_at a l \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list Z) (a : addr) (len : Z),\ntriple (list_at a l) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length l)))) (list_at a l))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro l .",
                "tactic_args": [
                    "c1_goal : forall (l : list Z) (a : addr) (len : Z),\ntriple (list_at a l) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length l)))) (list_at a l))"
                ],
                "tactic_res": [
                    "c2_goal : forall (a : addr) (len : Z),\ntriple (list_at a l) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length l)))) (list_at a l))",
                    "c2_l : list Z"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | h t ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | h t ] .",
                "tactic_args": [
                    "c2_goal : forall (a : addr) (len : Z),\ntriple (list_at a l) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length l)))) (list_at a l))",
                    "c2_l : list Z"
                ],
                "tactic_res": [
                    "c3_goal : forall (a : addr) (len : Z),\ntriple (list_at a nil) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))",
                    "c4_goal : forall (a : addr) (len : Z),\ntriple (list_at a (cons h t)) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))",
                    "c4_IHt : forall (a : addr) (len : Z),\ntriple (list_at a t) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length t)))) (list_at a t))",
                    "c4_t : list Z",
                    "c4_h : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (a : addr) (len : Z),\ntriple (list_at a nil) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))"
                ],
                "tactic_res": [
                    "c5_goal : triple (list_at a nil) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))",
                    "c5_a : addr",
                    "c5_len : Z"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c5_goal : triple (list_at a nil) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_length_rec : forall (_ : addr) (_ : Z), com",
                    "c5_a : addr",
                    "c5_len : Z"
                ],
                "tactic_res": [
                    "c6_goal : triple (list_at a nil)\n  match list_length_rec a len with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c6_goal : triple (list_at a nil)\n  match list_length_rec a len with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length nil))))\n     (list_at a nil))"
                ],
                "tactic_res": [
                    "c7_goal : triple (pureconj (eq a 0) emp)\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (a : addr) (len : Z),\ntriple (list_at a (cons h t)) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))"
                ],
                "tactic_res": [
                    "c8_goal : triple (list_at a (cons h t)) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))",
                    "c8_a : addr",
                    "c8_len : Z"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : triple (list_at a (cons h t)) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_length_rec : forall (_ : addr) (_ : Z), com",
                    "c8_a : addr",
                    "c8_len : Z"
                ],
                "tactic_res": [
                    "c9_goal : triple (list_at a (cons h t))\n  match list_length_rec a len with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c9_goal : triple (list_at a (cons h t))\n  match list_length_rec a len with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length (cons h t)))))\n     (list_at a (cons h t)))"
                ],
                "tactic_res": [
                    "c10_goal : triple\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a h)\n           (sepconj (contains (Z.add a 1) a') (list_at a' t)))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : triple (pureconj (eq a 0) emp)\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : eq a 0,\ntriple emp\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H1 .",
                "tactic_args": [
                    "c11_goal : forall _ : eq a 0,\ntriple emp\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))"
                ],
                "tactic_res": [
                    "c12_goal : triple emp\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))",
                    "c12_H1 : eq a 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : triple emp\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))",
                    "_global_triple_ifelse : forall (b : Z) (c1 c2 : com) (P : precond) \n         (Q : postcond) (_ : eq b 0) (_ : triple P c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c13_goal : eq a 0",
                    "c14_goal : triple emp (PURE len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq a 0",
                    "c12_H1 : eq a 0",
                    "c5_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple emp (PURE len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len 0)) (pureconj (eq a 0) emp))",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c15_goal : aimp emp (pureconj (eq len (Z.add len 0)) (pureconj (eq a 0) emp))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h H2 .",
                "tactic_args": [
                    "c15_goal : aimp emp (pureconj (eq len (Z.add len 0)) (pureconj (eq a 0) emp))"
                ],
                "tactic_res": [
                    "c16_goal : pureconj (eq len (Z.add len 0)) (pureconj (eq a 0) emp) h",
                    "c16_h : heap",
                    "c16_H2 : emp h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c16_goal : pureconj (eq len (Z.add len 0)) (pureconj (eq a 0) emp) h"
                ],
                "tactic_res": [
                    "c17_goal : eq len (Z.add len 0)",
                    "c18_goal : pureconj (eq a 0) emp h"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c17_goal : eq len (Z.add len 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c18_goal : pureconj (eq a 0) emp h"
                ],
                "tactic_res": [
                    "c19_goal : eq a 0",
                    "c20_goal : emp h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : eq a 0",
                    "c12_H1 : eq a 0",
                    "c5_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : emp h",
                    "c16_H2 : emp h",
                    "c16_h : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : triple\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a h)\n           (sepconj (contains (Z.add a 1) a') (list_at a' t)))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : not (eq a 0),\ntriple\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H1 .",
                "tactic_args": [
                    "c21_goal : forall _ : not (eq a 0),\ntriple\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c22_goal : triple\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c22_H1 : not (eq a 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : triple\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_lift_exists : forall (X : Type) (P : forall _ : X, assertion) \n         (c : com) (Q : postcond) (_ : forall x : X, triple (P x) c Q),\n       triple (aexists P) c Q"
                ],
                "tactic_res": [
                    "c23_goal : forall x : Z,\ntriple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) x) (list_at x t)))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a' .",
                "tactic_args": [
                    "c23_goal : forall x : Z,\ntriple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) x) (list_at x t)))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c24_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c24_a' : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun t : Z => list_length_rec t (Z.add len 1))) \n     (PURE len))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_ifthen : forall (b : Z) (c1 c2 : com) (P : precond) \n         (Q : postcond) (_ : not (eq b 0)) (_ : triple P c1 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c25_goal : not (eq a 0)",
                    "c26_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (LET (GET (Z.add a 1)) (fun t : Z => list_length_rec t (Z.add len 1)))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : not (eq a 0)",
                    "c22_H1 : not (eq a 0)",
                    "c8_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c26_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (LET (GET (Z.add a 1)) (fun t : Z => list_length_rec t (Z.add len 1)))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c27_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (GET (Z.add a 1)) ?Q",
                    "c28_goal : forall v : Z,\ntriple (?Q v) (list_length_rec v (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c27_goal : triple\n  (sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t)))\n  (GET (Z.add a 1)) ?Q",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c29_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t))) (GET (Z.add a 1)) \n  ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t))) (GET (Z.add a 1)) \n  ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c30_goal : triple (contains (Z.add a 1) a') (GET (Z.add a 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : triple (contains (Z.add a 1) a') (GET (Z.add a 1)) ?Q",
                    "_global_triple_get : forall (l : addr) (v : Z),\n       triple (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a 1) a')) v0)\n      (sepconj (contains a h) (list_at a' t))) v)\n  (list_length_rec v (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c31_goal : forall v : Z,\ntriple\n  (sepconj (pureconj (eq v a') (contains (Z.add a 1) a'))\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec v (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a'' .",
                "tactic_args": [
                    "c31_goal : forall v : Z,\ntriple\n  (sepconj (pureconj (eq v a') (contains (Z.add a 1) a'))\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec v (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c32_goal : triple\n  (sepconj (pureconj (eq a'' a') (contains (Z.add a 1) a'))\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c32_a'' : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c32_goal : triple\n  (sepconj (pureconj (eq a'' a') (contains (Z.add a 1) a'))\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c33_goal : triple\n  (pureconj (eq a'' a')\n     (sepconj (contains (Z.add a 1) a')\n        (sepconj (contains a h) (list_at a' t))))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c33_goal : triple\n  (pureconj (eq a'' a')\n     (sepconj (contains (Z.add a 1) a')\n        (sepconj (contains a h) (list_at a' t))))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : eq a'' a',\ntriple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H3 .",
                "tactic_args": [
                    "c34_goal : forall _ : eq a'' a',\ntriple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c35_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c35_H3 : eq a'' a'"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c35_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a'' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c32_a'' : Z",
                    "c35_H3 : eq a'' a'"
                ],
                "tactic_res": [
                    "c36_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a h) (list_at a' t)))\n  (list_length_rec a' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_sepconj_swap3 : forall R P Q : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))"
                ],
                "tactic_res": [
                    "c37_goal : triple\n  (sepconj (list_at a' t)\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (list_length_rec a' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c37_goal : triple\n  (sepconj (list_at a' t)\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (list_length_rec a' (Z.add len 1))\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_triple_consequence_post : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n         (Q' : postcond) (_ : triple P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q"
                ],
                "tactic_res": [
                    "c38_goal : triple\n  (sepconj (list_at a' t)\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (list_length_rec a' (Z.add len 1)) ?Q'",
                    "c39_goal : forall v : Z,\naimp (?Q' v)\n  (pureconj (eq v (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : triple\n  (sepconj (list_at a' t)\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (list_length_rec a' (Z.add len 1)) ?Q'",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c40_goal : triple (list_at a' t) (list_length_rec a' (Z.add len 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : triple (list_at a' t) (list_length_rec a' (Z.add len 1)) ?Q",
                    "c4_IHt : forall (a : addr) (len : Z),\ntriple (list_at a t) (list_length_rec a len)\n  (fun len' : Z =>\n   pureconj (eq len' (Z.add len (Z.of_nat (length t)))) (list_at a t))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros len' .",
                "tactic_args": [
                    "c39_goal : forall v : Z,\naimp\n  ((fun v0 : Z =>\n    sepconj\n      ((fun len' : Z =>\n        pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n          (list_at a' t)) v0)\n      (sepconj (contains (Z.add a 1) a') (contains a h))) v)\n  (pureconj (eq v (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c41_goal : aimp\n  ((fun v : Z =>\n    sepconj\n      ((fun len' : Z =>\n        pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n          (list_at a' t)) v)\n      (sepconj (contains (Z.add a 1) a') (contains a h))) len')\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "c41_len' : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c41_goal : aimp\n  ((fun v : Z =>\n    sepconj\n      ((fun len' : Z =>\n        pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n          (list_at a' t)) v)\n      (sepconj (contains (Z.add a 1) a') (contains a h))) len')\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c42_goal : aimp\n  (sepconj\n     (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n        (list_at a' t))\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c42_goal : aimp\n  (sepconj\n     (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n        (list_at a' t))\n     (sepconj (contains (Z.add a 1) a') (contains a h)))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c43_goal : aimp\n  (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n     (sepconj (list_at a' t)\n        (sepconj (contains (Z.add a 1) a') (contains a h))))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c43_goal : aimp\n  (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n     (sepconj (list_at a' t)\n        (sepconj (contains (Z.add a 1) a') (contains a h))))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))",
                    "_global_sepconj_swap3 : forall R P Q : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c44_goal : aimp\n  (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n     (sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h1 ( A & B ) .",
                "tactic_args": [
                    "c44_goal : aimp\n  (pureconj (eq len' (Z.add (Z.add len 1) (Z.of_nat (length t))))\n     (sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t))))\n  (pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a h)\n              (sepconj (contains (Z.add a 1) a') (list_at a' t))))))"
                ],
                "tactic_res": [
                    "c45_goal : pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a h)\n           (sepconj (contains (Z.add a 1) a') (list_at a' t))))) h1",
                    "c45_h1 : heap",
                    "c45_A : eq len' (Z.add (Z.add len 1) (Z.of_nat (length t)))",
                    "c45_B : sepconj (contains a h)\n  (sepconj (contains (Z.add a 1) a') (list_at a' t)) h1"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c45_goal : pureconj (eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t)))))\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a h)\n           (sepconj (contains (Z.add a 1) a') (list_at a' t))))) h1"
                ],
                "tactic_res": [
                    "c46_goal : eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t))))",
                    "c47_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t)))) h1"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c46_goal : eq len' (Z.add len (Zpos (Pos.of_succ_nat (length t))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c47_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a h)\n        (sepconj (contains (Z.add a 1) a') (list_at a' t)))) h1"
                ],
                "tactic_res": [
                    "c48_goal : not (eq a 0)",
                    "c49_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t))) h1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : not (eq a 0)",
                    "c22_H1 : not (eq a 0)",
                    "c8_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c49_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a h)\n     (sepconj (contains (Z.add a 1) a') (list_at a' t))) h1",
                    "c24_a' : Z"
                ],
                "tactic_res": [
                    "c50_goal : sepconj (contains a h)\n  (sepconj (contains (Z.add a 1) a') (list_at a' t)) h1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c50_goal : sepconj (contains a h)\n  (sepconj (contains (Z.add a 1) a') (list_at a' t)) h1",
                    "c45_B : sepconj (contains a h)\n  (sepconj (contains (Z.add a 1) a') (list_at a' t)) h1",
                    "c45_h1 : heap",
                    "c24_a' : Z",
                    "c8_a : addr",
                    "c4_t : list Z",
                    "c4_h : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_length_correct",
        "proof": [
            {
                "tactic_sig": "Corollary list_length_correct : forall l a , \u2983 list_at a l \u2984 list_length a \u2983 fun len => ( len = Z.of_nat ( length l ) ) //\\\\ list_at a l \u2984 .",
                "tactic_sig_no_out_arg": "Corollary list_length_correct : forall l a , \u2983 list_at a l \u2984 list_length a \u2983 fun len => ( len = Z.of_nat ( length l ) ) //\\\\ list_at a l \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list Z) (a : addr),\ntriple (list_at a l) (list_length a)\n  (fun len : Z => pureconj (eq len (Z.of_nat (length l))) (list_at a l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : list Z) (a : addr),\ntriple (list_at a l) (list_length a)\n  (fun len : Z => pureconj (eq len (Z.of_nat (length l))) (list_at a l))"
                ],
                "tactic_res": [
                    "c2_goal : triple (list_at a l) (list_length a)\n  (fun len : Z => pureconj (eq len (Z.of_nat (length l))) (list_at a l))",
                    "c2_l : list Z",
                    "c2_a : addr"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : triple (list_at a l) (list_length a)\n  (fun len : Z => pureconj (eq len (Z.of_nat (length l))) (list_at a l))",
                    "_global_list_length_rec_correct : forall (l : list Z) (a : addr) (len : Z),\n       triple (list_at a l) (list_length_rec a len)\n         (fun len' : Z =>\n          pureconj (eq len' (Z.add len (Z.of_nat (length l)))) (list_at a l))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_concat_rec_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_concat_rec_correct : forall l2 a2 l1 a1 , a1 <> 0 -> \u2983 list_at a1 l1 ** list_at a2 l2 \u2984 list_concat_rec a1 a2 \u2983 fun _ => list_at a1 ( l1 ++ l2 ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_concat_rec_correct : forall l2 a2 l1 a1 , a1 <> 0 -> \u2983 list_at a1 l1 ** list_at a2 l2 \u2984 list_concat_rec a1 a2 \u2983 fun _ => list_at a1 ( l1 ++ l2 ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l2 : list Z) (a2 : addr) (l1 : list Z) (a1 : Z)\n  (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l2 a2 l1 .",
                "tactic_args": [
                    "c1_goal : forall (l2 : list Z) (a2 : addr) (l1 : list Z) (a1 : Z)\n  (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app l1 l2))"
                ],
                "tactic_res": [
                    "c2_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app l1 l2))",
                    "c2_l2 : list Z",
                    "c2_a2 : addr",
                    "c2_l1 : list Z"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | h1 t1 ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | h1 t1 ] .",
                "tactic_args": [
                    "c2_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app l1 l2))",
                    "c2_l1 : list Z"
                ],
                "tactic_res": [
                    "c3_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 nil) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app nil l2))",
                    "c4_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  (list_concat_rec a1 a2)\n  (fun _ : Z => list_at a1 (app (cons h1 t1) l2))",
                    "c4_IHt1 : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 t1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app t1 l2))",
                    "c4_t1 : list Z",
                    "c4_h1 : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 nil) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app nil l2))"
                ],
                "tactic_res": [
                    "c5_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app nil l2))",
                    "c5_a1 : Z",
                    "c5_H : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c5_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app nil l2))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_concat_rec : forall (_ : addr) (_ : addr), com",
                    "c5_a1 : Z",
                    "c2_a2 : addr"
                ],
                "tactic_res": [
                    "c6_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2))\n  match list_concat_rec a1 a2 with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun _ : Z => list_at a1 (app nil l2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2))\n  match list_concat_rec a1 a2 with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun _ : Z => list_at a1 (app nil l2))"
                ],
                "tactic_res": [
                    "c7_goal : triple (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  (list_concat_rec a1 a2)\n  (fun _ : Z => list_at a1 (app (cons h1 t1) l2))"
                ],
                "tactic_res": [
                    "c8_goal : triple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  (list_concat_rec a1 a2)\n  (fun _ : Z => list_at a1 (app (cons h1 t1) l2))",
                    "c8_a1 : Z",
                    "c8_H : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : triple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  (list_concat_rec a1 a2)\n  (fun _ : Z => list_at a1 (app (cons h1 t1) l2))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_concat_rec : forall (_ : addr) (_ : addr), com",
                    "c8_a1 : Z",
                    "c2_a2 : addr"
                ],
                "tactic_res": [
                    "c9_goal : triple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  match list_concat_rec a1 a2 with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun _ : Z => list_at a1 (app (cons h1 t1) l2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : triple (sepconj (list_at a1 (cons h1 t1)) (list_at a2 l2))\n  match list_concat_rec a1 a2 with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun _ : Z => list_at a1 (app (cons h1 t1) l2))"
                ],
                "tactic_res": [
                    "c10_goal : triple\n  (sepconj\n     (pureconj (not (eq a1 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 h1)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' t1)))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : triple (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c11_goal : triple (pureconj (eq a1 0) (sepconj emp (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : triple (pureconj (eq a1 0) (sepconj emp (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq a1 0,\ntriple (sepconj emp (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall _ : eq a1 0,\ntriple (sepconj emp (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)"
                ],
                "tactic_res": [
                    "c13_goal : triple (sepconj emp (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)",
                    "c13_H0 : eq a1 0"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : triple (sepconj emp (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z => list_at a1 l2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : triple\n  (sepconj\n     (pureconj (not (eq a1 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 h1)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' t1)))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c14_goal : triple\n  (pureconj (not (eq a1 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 h1)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : triple\n  (pureconj (not (eq a1 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 h1)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : not (eq a1 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c15_goal : forall _ : not (eq a1 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c16_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c16_H1 : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' t1))))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c17_goal : triple\n  (aexists\n     (fun x : Z =>\n      sepconj\n        (sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) x) (list_at x t1)))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : triple\n  (aexists\n     (fun x : Z =>\n      sepconj\n        (sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) x) (list_at x t1)))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_lift_exists : forall (X : Type) (P : forall _ : X, assertion) \n         (c : com) (Q : postcond) (_ : forall x : X, triple (P x) c Q),\n       triple (aexists P) c Q"
                ],
                "tactic_res": [
                    "c18_goal : forall x : Z,\ntriple\n  (sepconj\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) x) (list_at x t1)))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a' .",
                "tactic_args": [
                    "c18_goal : forall x : Z,\ntriple\n  (sepconj\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) x) (list_at x t1)))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c19_goal : triple\n  (sepconj\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' t1)))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c19_a' : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : triple\n  (sepconj\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' t1)))\n     (list_at a2 l2))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c20_goal : triple\n  (sepconj (contains a1 h1)\n     (sepconj (sepconj (contains (Z.add a1 1) a') (list_at a' t1))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c20_goal : triple\n  (sepconj (contains a1 h1)\n     (sepconj (sepconj (contains (Z.add a1 1) a') (list_at a' t1))\n        (list_at a2 l2)))\n  (LET (GET (Z.add a1 1))\n     (fun t : Z =>\n      IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2)))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c21_goal : triple\n  (sepconj (contains a1 h1)\n     (sepconj (sepconj (contains (Z.add a1 1) a') (list_at a' t1))\n        (list_at a2 l2))) (GET (Z.add a1 1)) ?Q",
                    "c22_goal : forall v : Z,\ntriple (?Q v)\n  (IFTHENELSE v (list_concat_rec v a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c21_goal : triple\n  (sepconj (contains a1 h1)\n     (sepconj (sepconj (contains (Z.add a1 1) a') (list_at a' t1))\n        (list_at a2 l2))) (GET (Z.add a1 1)) ?Q",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c23_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2)))) \n  (GET (Z.add a1 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2)))) \n  (GET (Z.add a1 1)) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c24_goal : triple (contains (Z.add a1 1) a') (GET (Z.add a1 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : triple (contains (Z.add a1 1) a') (GET (Z.add a1 1)) ?Q",
                    "_global_triple_get : forall (l : addr) (v : Z),\n       triple (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros t .",
                "tactic_args": [
                    "c22_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a1 1) a'))\n         v0)\n      (sepconj (contains a1 h1)\n         (sepconj (list_at a' t1) (list_at a2 l2)))) v)\n  (IFTHENELSE v (list_concat_rec v a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c25_goal : triple\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a1 1) a')) v)\n      (sepconj (contains a1 h1)\n         (sepconj (list_at a' t1) (list_at a2 l2)))) t)\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c25_t : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c25_goal : triple\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a1 1) a')) v)\n      (sepconj (contains a1 h1)\n         (sepconj (list_at a' t1) (list_at a2 l2)))) t)\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c26_goal : triple\n  (sepconj (pureconj (eq t a') (contains (Z.add a1 1) a'))\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c26_goal : triple\n  (sepconj (pureconj (eq t a') (contains (Z.add a1 1) a'))\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c27_goal : triple\n  (pureconj (eq t a')\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c27_goal : triple\n  (pureconj (eq t a')\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c28_goal : forall _ : eq t a',\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H2 .",
                "tactic_args": [
                    "c28_goal : forall _ : eq t a',\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c29_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c29_H2 : eq t a'"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c29_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE t (list_concat_rec t a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c25_t : Z",
                    "c29_H2 : eq t a'"
                ],
                "tactic_res": [
                    "c30_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE a' (list_concat_rec a' a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (IFTHENELSE a' (list_concat_rec a' a2) (SET (Z.add a1 1) a2))\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple (pureconj (eq b 0) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c31_goal : triple\n  (pureconj (not (eq a' 0))\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c32_goal : triple\n  (pureconj (eq a' 0)\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c31_goal : triple\n  (pureconj (not (eq a' 0))\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c33_goal : forall _ : not (eq a' 0),\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H2 .",
                "tactic_args": [
                    "c33_goal : forall _ : not (eq a' 0),\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c34_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c34_H2 : not (eq a' 0)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c34_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)"
                ],
                "tactic_res": [
                    "c35_goal : triple\n  (sepconj (sepconj (list_at a' t1) (list_at a2 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c35_goal : triple\n  (sepconj (sepconj (list_at a' t1) (list_at a2 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (list_concat_rec a' a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_consequence_post : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n         (Q' : postcond) (_ : triple P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q"
                ],
                "tactic_res": [
                    "c36_goal : triple\n  (sepconj (sepconj (list_at a' t1) (list_at a2 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (list_concat_rec a' a2) ?Q'",
                    "c37_goal : forall v : Z,\naimp (?Q' v)\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : triple\n  (sepconj (sepconj (list_at a' t1) (list_at a2 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (list_concat_rec a' a2) ?Q'",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c38_goal : triple (sepconj (list_at a' t1) (list_at a2 l2))\n  (list_concat_rec a' a2) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c38_goal : triple (sepconj (list_at a' t1) (list_at a2 l2))\n  (list_concat_rec a' a2) ?Q",
                    "c4_IHt1 : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 t1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app t1 l2))"
                ],
                "tactic_res": [
                    "c39_goal : not (eq a' 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : not (eq a' 0)",
                    "c34_H2 : not (eq a' 0)",
                    "c19_a' : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c37_goal : forall v : Z,\naimp\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => list_at a' (app t1 l2)) v0)\n      (sepconj (contains (Z.add a1 1) a') (contains a1 h1))) v)\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c40_goal : forall _ : Z,\naimp\n  (sepconj (list_at a' (app t1 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c40_goal : forall _ : Z,\naimp\n  (sepconj (list_at a' (app t1 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c41_goal : aimp\n  (sepconj (list_at a' (app t1 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c41_goal : aimp\n  (sepconj (list_at a' (app t1 l2))\n     (sepconj (contains (Z.add a1 1) a') (contains a1 h1)))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_sepconj_swap3 : forall R P Q : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj R (sepconj P Q))"
                ],
                "tactic_res": [
                    "c42_goal : aimp\n  (sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h P .",
                "tactic_args": [
                    "c42_goal : aimp\n  (sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c43_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2)))))\n  h",
                    "c43_h : heap",
                    "c43_P : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c43_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2)))))\n  h"
                ],
                "tactic_res": [
                    "c44_goal : not (eq a1 0)",
                    "c45_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2)))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c44_goal : not (eq a1 0)",
                    "c8_a1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c45_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2)))) h",
                    "c19_a' : Z"
                ],
                "tactic_res": [
                    "c46_goal : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))) h",
                    "c43_P : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))) h",
                    "c43_h : heap",
                    "c19_a' : Z",
                    "c8_a1 : Z",
                    "c4_t1 : list Z",
                    "c4_h1 : Z",
                    "c2_l2 : list Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : triple\n  (pureconj (eq a' 0)\n     (sepconj (contains (Z.add a1 1) a')\n        (sepconj (contains a1 h1)\n           (sepconj (list_at a' t1) (list_at a2 l2)))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c47_goal : forall _ : eq a' 0,\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H2 .",
                "tactic_args": [
                    "c47_goal : forall _ : eq a' 0,\ntriple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c48_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c48_H2 : eq a' 0"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c48_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2)\n  (fun _ : Z =>\n   pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_triple_consequence_post : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n         (Q' : postcond) (_ : triple P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q"
                ],
                "tactic_res": [
                    "c49_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2) ?Q'",
                    "c50_goal : forall v : Z,\naimp (?Q' v)\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c49_goal : triple\n  (sepconj (contains (Z.add a1 1) a')\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (SET (Z.add a1 1) a2) ?Q'",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c51_goal : triple (contains (Z.add a1 1) a') (SET (Z.add a1 1) a2) ?Q"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c51_goal : triple (contains (Z.add a1 1) a') (SET (Z.add a1 1) a2) ?Q",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q"
                ],
                "tactic_res": [
                    "c52_goal : triple ?P' (SET (Z.add a1 1) a2) ?Q",
                    "c53_goal : aimp (contains (Z.add a1 1) a') (valid (Z.add a1 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c52_goal : triple ?P' (SET (Z.add a1 1) a2) ?Q",
                    "_global_triple_set : forall (l : addr) (v : Z),\n       triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h P .",
                "tactic_args": [
                    "c53_goal : aimp (contains (Z.add a1 1) a') (valid (Z.add a1 1))"
                ],
                "tactic_res": [
                    "c54_goal : valid (Z.add a1 1) h",
                    "c54_h : heap",
                    "c54_P : contains (Z.add a1 1) a' h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c54_goal : valid (Z.add a1 1) h",
                    "c19_a' : Z"
                ],
                "tactic_res": [
                    "c55_goal : contains (Z.add a1 1) a' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : contains (Z.add a1 1) a' h",
                    "c54_P : contains (Z.add a1 1) a' h",
                    "c54_h : heap",
                    "c19_a' : Z",
                    "c8_a1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c50_goal : forall v : Z,\naimp\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => contains (Z.add a1 1) a2) v0)\n      (sepconj (contains a1 h1)\n         (sepconj (list_at a' t1) (list_at a2 l2)))) v)\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c56_goal : forall _ : Z,\naimp\n  (sepconj (contains (Z.add a1 1) a2)\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c56_goal : forall _ : Z,\naimp\n  (sepconj (contains (Z.add a1 1) a2)\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ],
                "tactic_res": [
                    "c57_goal : aimp\n  (sepconj (contains (Z.add a1 1) a2)\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c57_goal : aimp\n  (sepconj (contains (Z.add a1 1) a2)\n     (sepconj (contains a1 h1)\n        (sepconj (list_at a' t1) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_sepconj_pick3 : forall R P Q S : assertion,\n       eq (sepconj P (sepconj Q (sepconj R S)))\n         (sepconj R (sepconj P (sepconj Q S)))"
                ],
                "tactic_res": [
                    "c58_goal : aimp\n  (sepconj (list_at a' t1)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c58_goal : aimp\n  (sepconj (list_at a' t1)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' (app t1 l2))))))",
                    "c4_t1 : list Z",
                    "c48_H2 : eq a' 0",
                    "c19_a' : Z",
                    "c16_H1 : not (eq a1 0)",
                    "c8_H : not (eq a1 0)",
                    "c8_a1 : Z",
                    "c4_IHt1 : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 t1) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app t1 l2))",
                    "c4_h1 : Z",
                    "c2_a2 : addr",
                    "c2_l2 : list Z"
                ],
                "tactic_res": [
                    "c59_goal : aimp\n  (sepconj (list_at a' nil)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (list_at a' (app nil l2))))))",
                    "c59_IHt1 : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 nil) (list_at a2 l2))\n  (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app nil l2))",
                    "c60_goal : aimp\n  (sepconj (list_at a' (cons z t1))\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (list_at a' (app (cons z t1) l2))))))",
                    "c60_IHt1 : forall (a1 : Z) (_ : not (eq a1 0)),\ntriple (sepconj (list_at a1 (cons z t1)) (list_at a2 l2))\n  (list_concat_rec a1 a2)\n  (fun _ : Z => list_at a1 (app (cons z t1) l2))",
                    "c60_z : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c59_goal : aimp\n  (sepconj (list_at a' nil)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (list_at a' (app nil l2))))))"
                ],
                "tactic_res": [
                    "c61_goal : aimp\n  (sepconj (pureconj (eq a' 0) emp)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c60_goal : aimp\n  (sepconj (list_at a' (cons z t1))\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (list_at a' (app (cons z t1) l2))))))"
                ],
                "tactic_res": [
                    "c62_goal : aimp\n  (sepconj\n     (pureconj (not (eq a' 0))\n        (aexists\n           (fun a'0 : Z =>\n            sepconj (contains a' z)\n              (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 t1)))))\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (pureconj (not (eq a' 0))\n                 (aexists\n                    (fun a'0 : Z =>\n                     sepconj (contains a' z)\n                       (sepconj (contains (Z.add a' 1) a'0)\n                          (list_at a'0 (app t1 l2))))))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c61_goal : aimp\n  (sepconj (pureconj (eq a' 0) emp)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c63_goal : aimp\n  (pureconj (eq a' 0)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( A & B ) .",
                "tactic_args": [
                    "c63_goal : aimp\n  (pureconj (eq a' 0)\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))))"
                ],
                "tactic_res": [
                    "c64_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))) h",
                    "c64_h : heap",
                    "c64_A : eq a' 0",
                    "c64_B : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c64_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a') (list_at a' l2)))) h"
                ],
                "tactic_res": [
                    "c65_goal : not (eq a1 0)",
                    "c66_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' l2))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c65_goal : not (eq a1 0)",
                    "c8_a1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c66_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a') (list_at a' l2))) h",
                    "c2_a2 : addr"
                ],
                "tactic_res": [
                    "c67_goal : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c67_goal : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)) h",
                    "c64_B : sepconj (contains a1 h1)\n  (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)) h",
                    "c64_h : heap",
                    "c8_a1 : Z",
                    "c4_h1 : Z",
                    "c2_a2 : addr",
                    "c2_l2 : list Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c62_goal : aimp\n  (sepconj\n     (pureconj (not (eq a' 0))\n        (aexists\n           (fun a'0 : Z =>\n            sepconj (contains a' z)\n              (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 t1)))))\n     (sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (pureconj (not (eq a' 0))\n                 (aexists\n                    (fun a'0 : Z =>\n                     sepconj (contains a' z)\n                       (sepconj (contains (Z.add a' 1) a'0)\n                          (list_at a'0 (app t1 l2))))))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c68_goal : aimp\n  (pureconj (not (eq a' 0))\n     (sepconj\n        (aexists\n           (fun a'0 : Z =>\n            sepconj (contains a' z)\n              (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 t1))))\n        (sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (pureconj (not (eq a' 0))\n                 (aexists\n                    (fun a'0 : Z =>\n                     sepconj (contains a' z)\n                       (sepconj (contains (Z.add a' 1) a'0)\n                          (list_at a'0 (app t1 l2))))))))))"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( A & B ) .",
                "tactic_args": [
                    "c68_goal : aimp\n  (pureconj (not (eq a' 0))\n     (sepconj\n        (aexists\n           (fun a'0 : Z =>\n            sepconj (contains a' z)\n              (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 t1))))\n        (sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2)))))\n  (pureconj (not (eq a1 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 h1)\n           (sepconj (contains (Z.add a1 1) a')\n              (pureconj (not (eq a' 0))\n                 (aexists\n                    (fun a'0 : Z =>\n                     sepconj (contains a' z)\n                       (sepconj (contains (Z.add a' 1) a'0)\n                          (list_at a'0 (app t1 l2))))))))))"
                ],
                "tactic_res": [
                    "c69_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a')\n           (pureconj (not (eq a' 0))\n              (aexists\n                 (fun a'0 : Z =>\n                  sepconj (contains a' z)\n                    (sepconj (contains (Z.add a' 1) a'0)\n                       (list_at a'0 (app t1 l2))))))))) h",
                    "c69_h : heap",
                    "c69_A : not (eq a' 0)",
                    "c69_B : sepconj\n  (aexists\n     (fun a'0 : Z =>\n      sepconj (contains a' z)\n        (sepconj (contains (Z.add a' 1) a'0) (list_at a'0 t1))))\n  (sepconj (contains a1 h1)\n     (sepconj (contains (Z.add a1 1) a2) (list_at a2 l2))) h"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c69_goal : pureconj (not (eq a1 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a1 h1)\n        (sepconj (contains (Z.add a1 1) a')\n           (pureconj (not (eq a' 0))\n              (aexists\n                 (fun a'0 : Z =>\n                  sepconj (contains a' z)\n                    (sepconj (contains (Z.add a' 1) a'0)\n                       (list_at a'0 (app t1 l2))))))))) h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_concat_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_concat_correct : forall l1 a1 l2 a2 , \u2983 list_at a1 l1 ** list_at a2 l2 \u2984 list_concat a1 a2 \u2983 fun a => list_at a ( l1 ++ l2 ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_concat_correct : forall l1 a1 l2 a2 , \u2983 list_at a1 l1 ** list_at a2 l2 \u2984 list_concat a1 a2 \u2983 fun a => list_at a ( l1 ++ l2 ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 : list Z) (a1 : addr) (l2 : list Z) (a2 : addr),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2)) (list_concat a1 a2)\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l1 : list Z) (a1 : addr) (l2 : list Z) (a2 : addr),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2)) (list_concat a1 a2)\n  (fun a : Z => list_at a (app l1 l2))"
                ],
                "tactic_res": [
                    "c2_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2)) (list_concat a1 a2)\n  (fun a : Z => list_at a (app l1 l2))",
                    "c2_l1 : list Z",
                    "c2_a1 : addr",
                    "c2_l2 : list Z",
                    "c2_a2 : addr"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2)) (list_concat a1 a2)\n  (fun a : Z => list_at a (app l1 l2))",
                    "_global_list_concat : forall (_ : addr) (_ : addr), com"
                ],
                "tactic_res": [
                    "c3_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (IFTHENELSE a1 (SEQ (list_concat_rec a1 a2) (PURE a1)) (PURE a2))\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (IFTHENELSE a1 (SEQ (list_concat_rec a1 a2) (PURE a1)) (PURE a2))\n  (fun a : Z => list_at a (app l1 l2))",
                    "_global_triple_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple (pureconj (eq b 0) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c4_goal : triple\n  (pureconj (not (eq a1 0)) (sepconj (list_at a1 l1) (list_at a2 l2)))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))",
                    "c5_goal : triple (pureconj (eq a1 0) (sepconj (list_at a1 l1) (list_at a2 l2)))\n  (PURE a2) (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple\n  (pureconj (not (eq a1 0)) (sepconj (list_at a1 l1) (list_at a2 l2)))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : not (eq a1 0),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c6_goal : forall _ : not (eq a1 0),\ntriple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))"
                ],
                "tactic_res": [
                    "c7_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))",
                    "c7_H1 : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (SEQ (list_concat_rec a1 a2) (PURE a1))\n  (fun a : Z => list_at a (app l1 l2))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c8_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) ?Q",
                    "c9_goal : forall v : Z,\ntriple ((fun _ : Z => list_at a1 (app l1 l2)) v) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2))\n  (list_concat_rec a1 a2) ?Q",
                    "_global_list_concat_rec_correct : forall (l2 : list Z) (a2 : addr) (l1 : list Z) \n         (a1 : Z) (_ : not (eq a1 0)),\n       triple (sepconj (list_at a1 l1) (list_at a2 l2))\n         (list_concat_rec a1 a2) (fun _ : Z => list_at a1 (app l1 l2))"
                ],
                "tactic_res": [
                    "c10_goal : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not (eq a1 0)",
                    "c7_H1 : not (eq a1 0)",
                    "c2_a1 : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : forall v : Z,\ntriple ((fun _ : Z => list_at a1 (app l1 l2)) v) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : Z,\ntriple (list_at a1 (app l1 l2)) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c11_goal : forall _ : Z,\ntriple (list_at a1 (app l1 l2)) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))"
                ],
                "tactic_res": [
                    "c12_goal : triple (list_at a1 (app l1 l2)) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : triple (list_at a1 (app l1 l2)) (PURE a1)\n  (fun a : Z => list_at a (app l1 l2))",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c13_goal : aimp (list_at a1 (app l1 l2)) (list_at a1 (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c13_goal : aimp (list_at a1 (app l1 l2)) (list_at a1 (app l1 l2))"
                ],
                "tactic_res": [
                    "c14_goal : forall (h : heap) (_ : list_at a1 (app l1 l2) h),\nlist_at a1 (app l1 l2) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall (h : heap) (_ : list_at a1 (app l1 l2) h),\nlist_at a1 (app l1 l2) h",
                    "c2_l2 : list Z",
                    "c2_a1 : addr",
                    "c2_l1 : list Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (pureconj (eq a1 0) (sepconj (list_at a1 l1) (list_at a2 l2)))\n  (PURE a2) (fun a : Z => list_at a (app l1 l2))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq a1 0,\ntriple (sepconj (list_at a1 l1) (list_at a2 l2)) (PURE a2)\n  (fun a : Z => list_at a (app l1 l2))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c15_goal : forall _ : eq a1 0,\ntriple (sepconj (list_at a1 l1) (list_at a2 l2)) (PURE a2)\n  (fun a : Z => list_at a (app l1 l2))"
                ],
                "tactic_res": [
                    "c16_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2)) (PURE a2)\n  (fun a : Z => list_at a (app l1 l2))",
                    "c16_H1 : eq a1 0"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c16_goal : triple (sepconj (list_at a1 l1) (list_at a2 l2)) (PURE a2)\n  (fun a : Z => list_at a (app l1 l2))",
                    "c2_l1 : list Z",
                    "c16_H1 : eq a1 0",
                    "c2_a2 : addr",
                    "c2_l2 : list Z",
                    "c2_a1 : addr"
                ],
                "tactic_res": [
                    "c17_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a (app nil l2))",
                    "c18_goal : triple (sepconj (list_at a1 (cons z l1)) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a (app (cons z l1) l2))",
                    "c18_z : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : triple (sepconj (list_at a1 nil) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a (app nil l2))"
                ],
                "tactic_res": [
                    "c19_goal : triple (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a l2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c18_goal : triple (sepconj (list_at a1 (cons z l1)) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a (app (cons z l1) l2))"
                ],
                "tactic_res": [
                    "c20_goal : triple\n  (sepconj\n     (pureconj (not (eq a1 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 z)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' l1)))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : triple (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2)) \n  (PURE a2) (fun a : Z => list_at a l2)",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c21_goal : aimp (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2)) (list_at a2 l2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c21_goal : aimp (sepconj (pureconj (eq a1 0) emp) (list_at a2 l2)) (list_at a2 l2)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c22_goal : aimp (pureconj (eq a1 0) (list_at a2 l2)) (list_at a2 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( A & B ) .",
                "tactic_args": [
                    "c22_goal : aimp (pureconj (eq a1 0) (list_at a2 l2)) (list_at a2 l2)"
                ],
                "tactic_res": [
                    "c23_goal : list_at a2 l2 h",
                    "c23_h : heap",
                    "c23_A : eq a1 0",
                    "c23_B : list_at a2 l2 h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : list_at a2 l2 h",
                    "c23_B : list_at a2 l2 h",
                    "c23_h : heap",
                    "c2_a2 : addr",
                    "c2_l2 : list Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : triple\n  (sepconj\n     (pureconj (not (eq a1 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 z)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' l1)))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c24_goal : triple\n  (pureconj (not (eq a1 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 z)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n        (list_at a2 l2))) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : triple\n  (pureconj (not (eq a1 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a1 z)\n              (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n        (list_at a2 l2))) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c25_goal : forall _ : not (eq a1 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 z)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c25_goal : forall _ : not (eq a1 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 z)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))"
                ],
                "tactic_res": [
                    "c26_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 z)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))",
                    "c26_H : not (eq a1 0)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a1 z)\n           (sepconj (contains (Z.add a1 1) a') (list_at a' l1))))\n     (list_at a2 l2)) (PURE a2)\n  (fun a : Z =>\n   pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a z)\n           (sepconj (contains (Z.add a 1) a') (list_at a' (app l1 l2))))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_rev_rec_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_rev_rec_correct : forall l a l' p , \u2983 list_at a l ** list_at p l' \u2984 list_rev_rec a p \u2983 fun x => list_at x ( List.rev_append l l' ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_rev_rec_correct : forall l a l' p , \u2983 list_at a l ** list_at p l' \u2984 list_rev_rec a p \u2983 fun x => list_at x ( List.rev_append l l' ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list Z) (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro l .",
                "tactic_args": [
                    "c1_goal : forall (l : list Z) (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))"
                ],
                "tactic_res": [
                    "c2_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))",
                    "c2_l : list Z"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | hd _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | hd _i ] .",
                "tactic_args": [
                    "c2_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))",
                    "c2_l : list Z",
                    "c2_l : list Z"
                ],
                "tactic_res": [
                    "c3_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a nil) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append nil l'))",
                    "c4_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append (cons hd l) l'))",
                    "c4_IHl : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))",
                    "c4_hd : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a nil) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append nil l'))"
                ],
                "tactic_res": [
                    "c5_goal : triple (sepconj (list_at a nil) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append nil l'))",
                    "c5_a : addr",
                    "c5_l' : list Z",
                    "c5_p : addr"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c5_goal : triple (sepconj (list_at a nil) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append nil l'))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_rev_rec : forall (_ : addr) (_ : addr), com",
                    "c5_a : addr",
                    "c5_p : addr"
                ],
                "tactic_res": [
                    "c6_goal : triple (sepconj (list_at a nil) (list_at p l'))\n  match list_rev_rec a p with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun x : Z => list_at x (rev_append nil l'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : triple (sepconj (list_at a nil) (list_at p l'))\n  match list_rev_rec a p with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun x : Z => list_at x (rev_append nil l'))"
                ],
                "tactic_res": [
                    "c7_goal : triple (sepconj (pureconj (eq a 0) emp) (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append (cons hd l) l'))"
                ],
                "tactic_res": [
                    "c8_goal : triple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append (cons hd l) l'))",
                    "c8_a : addr",
                    "c8_l' : list Z",
                    "c8_p : addr"
                ]
            },
            {
                "tactic_sig": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i ( _i _i _i ) ) .",
                "tactic_args": [
                    "c8_goal : triple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append (cons hd l) l'))",
                    "_global_unroll_com : forall c : com,\n       eq c\n         match c with\n         | PURE x => PURE x\n         | LET c0 f => LET c0 f\n         | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n         | ALLOC sz => ALLOC sz\n         | GET l => GET l\n         | SET l v => SET l v\n         | FREE l => FREE l\n         | PICK n => PICK n\n         end",
                    "_global_list_rev_rec : forall (_ : addr) (_ : addr), com",
                    "c8_a : addr",
                    "c8_p : addr"
                ],
                "tactic_res": [
                    "c9_goal : triple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  match list_rev_rec a p with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun x : Z => list_at x (rev_append (cons hd l) l'))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : triple (sepconj (list_at a (cons hd l)) (list_at p l'))\n  match list_rev_rec a p with\n  | PURE x => PURE x\n  | LET c f => LET c f\n  | IFTHENELSE b c1 c2 => IFTHENELSE b c1 c2\n  | ALLOC sz => ALLOC sz\n  | GET l => GET l\n  | SET l v => SET l v\n  | FREE l => FREE l\n  | PICK n => PICK n\n  end (fun x : Z => list_at x (rev_append (cons hd l) l'))"
                ],
                "tactic_res": [
                    "c10_goal : triple\n  (sepconj\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l)))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c7_goal : triple (sepconj (pureconj (eq a 0) emp) (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c11_goal : triple (pureconj (eq a 0) (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : triple (pureconj (eq a 0) (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : eq a 0,\ntriple (list_at p l')\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c12_goal : forall _ : eq a 0,\ntriple (list_at p l')\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')"
                ],
                "tactic_res": [
                    "c13_goal : triple (list_at p l')\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')",
                    "c13_H1 : eq a 0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : triple (list_at p l')\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x l')",
                    "_global_triple_ifelse : forall (b : Z) (c1 c2 : com) (P : precond) \n         (Q : postcond) (_ : eq b 0) (_ : triple P c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c14_goal : eq a 0",
                    "c15_goal : triple (list_at p l') (PURE p) (fun x : Z => list_at x l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : eq a 0",
                    "c13_H1 : eq a 0",
                    "c5_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : triple (list_at p l') (PURE p) (fun x : Z => list_at x l')",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c16_goal : aimp (list_at p l') (list_at p l')"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c16_goal : aimp (list_at p l') (list_at p l')"
                ],
                "tactic_res": [
                    "c17_goal : forall (h : heap) (_ : list_at p l' h), list_at p l' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : forall (h : heap) (_ : list_at p l' h), list_at p l' h",
                    "c5_p : addr",
                    "c5_l' : list Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : triple\n  (sepconj\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l)))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c18_goal : triple\n  (pureconj (not (eq a 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n        (list_at p l')))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : triple\n  (pureconj (not (eq a 0))\n     (sepconj\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n        (list_at p l')))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : not (eq a 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H1 .",
                "tactic_args": [
                    "c19_goal : forall _ : not (eq a 0),\ntriple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c20_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c20_H1 : not (eq a 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : triple\n  (sepconj\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l))))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_lift_aexists : forall (A : Type) (P : forall _ : A, assertion) (Q : assertion),\n       eq (sepconj (aexists P) Q) (aexists (fun x : A => sepconj (P x) Q))"
                ],
                "tactic_res": [
                    "c21_goal : triple\n  (aexists\n     (fun x : Z =>\n      sepconj\n        (sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) x) (list_at x l)))\n        (list_at p l')))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : triple\n  (aexists\n     (fun x : Z =>\n      sepconj\n        (sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) x) (list_at x l)))\n        (list_at p l')))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_lift_exists : forall (X : Type) (P : forall _ : X, assertion) \n         (c : com) (Q : postcond) (_ : forall x : X, triple (P x) c Q),\n       triple (aexists P) c Q"
                ],
                "tactic_res": [
                    "c22_goal : forall x : Z,\ntriple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) x) (list_at x l)))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x0 : Z => list_at x0 (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a' .",
                "tactic_args": [
                    "c22_goal : forall x : Z,\ntriple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) x) (list_at x l)))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x0 : Z => list_at x0 (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c23_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c23_a' : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l'))\n  (IFTHENELSE a\n     (LET (GET (Z.add a 1))\n        (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n     (PURE p)) (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_ifthen : forall (b : Z) (c1 c2 : com) (P : precond) \n         (Q : postcond) (_ : not (eq b 0)) (_ : triple P c1 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c24_goal : not (eq a 0)",
                    "c25_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l'))\n  (LET (GET (Z.add a 1))\n     (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : not (eq a 0)",
                    "c20_H1 : not (eq a 0)",
                    "c8_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c25_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l'))\n  (LET (GET (Z.add a 1))\n     (fun n : Z => SEQ (SET (Z.add a 1) p) (list_rev_rec n a)))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c26_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l')) (GET (Z.add a 1)) ?Q",
                    "c27_goal : forall v : Z,\ntriple (?Q v) (SEQ (SET (Z.add a 1) p) (list_rev_rec v a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i , _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i , _i .",
                "tactic_args": [
                    "c26_goal : triple\n  (sepconj\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l)))\n     (list_at p l')) (GET (Z.add a 1)) ?Q",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))"
                ],
                "tactic_res": [
                    "c28_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (GET (Z.add a 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (GET (Z.add a 1)) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c29_goal : triple (contains (Z.add a 1) a') (GET (Z.add a 1)) ?Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c29_goal : triple (contains (Z.add a 1) a') (GET (Z.add a 1)) ?Q",
                    "_global_triple_get : forall (l : addr) (v : Z),\n       triple (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a'' .",
                "tactic_args": [
                    "c27_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a 1) a')) v0)\n      (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n     v) (SEQ (SET (Z.add a 1) p) (list_rev_rec v a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c30_goal : triple\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a 1) a')) v)\n      (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n     a'') (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c30_a'' : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c30_goal : triple\n  ((fun v : Z =>\n    sepconj\n      ((fun v' : Z => pureconj (eq v' a') (contains (Z.add a 1) a')) v)\n      (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n     a'') (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c31_goal : triple\n  (sepconj (pureconj (eq a'' a') (contains (Z.add a 1) a'))\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : triple\n  (sepconj (pureconj (eq a'' a') (contains (Z.add a 1) a'))\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c32_goal : triple\n  (pureconj (eq a'' a')\n     (sepconj (contains (Z.add a 1) a')\n        (sepconj (contains a hd)\n           (sepconj (list_at a' l) (list_at p l')))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : triple\n  (pureconj (eq a'' a')\n     (sepconj (contains (Z.add a 1) a')\n        (sepconj (contains a hd)\n           (sepconj (list_at a' l) (list_at p l')))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_lift_pure : forall (P : Prop) (P' : precond) (c : com) \n         (Q : postcond) (_ : forall _ : P, triple P' c Q),\n       triple (pureconj P P') c Q"
                ],
                "tactic_res": [
                    "c33_goal : forall _ : eq a'' a',\ntriple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H3 .",
                "tactic_args": [
                    "c33_goal : forall _ : eq a'' a',\ntriple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c34_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c34_H3 : eq a'' a'"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c34_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a'' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c30_a'' : Z",
                    "c34_H3 : eq a'' a'"
                ],
                "tactic_res": [
                    "c35_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c35_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SEQ (SET (Z.add a 1) p) (list_rev_rec a' a))\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c36_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SET (Z.add a 1) p) ?Q",
                    "c37_goal : forall v : Z,\ntriple (?Q v) (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : triple\n  (sepconj (contains (Z.add a 1) a')\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (SET (Z.add a 1) p) ?Q",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c38_goal : triple (contains (Z.add a 1) a') (SET (Z.add a 1) p) ?Q"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c38_goal : triple (contains (Z.add a 1) a') (SET (Z.add a 1) p) ?Q",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q"
                ],
                "tactic_res": [
                    "c39_goal : triple ?P' (SET (Z.add a 1) p) ?Q",
                    "c40_goal : aimp (contains (Z.add a 1) a') (valid (Z.add a 1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c39_goal : triple ?P' (SET (Z.add a 1) p) ?Q",
                    "_global_triple_set : forall (l : addr) (v : Z),\n       triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h P .",
                "tactic_args": [
                    "c40_goal : aimp (contains (Z.add a 1) a') (valid (Z.add a 1))"
                ],
                "tactic_res": [
                    "c41_goal : valid (Z.add a 1) h",
                    "c41_h : heap",
                    "c41_P : contains (Z.add a 1) a' h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c41_goal : valid (Z.add a 1) h",
                    "c23_a' : Z"
                ],
                "tactic_res": [
                    "c42_goal : contains (Z.add a 1) a' h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : contains (Z.add a 1) a' h",
                    "c41_P : contains (Z.add a 1) a' h",
                    "c41_h : heap",
                    "c23_a' : Z",
                    "c8_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c37_goal : forall v : Z,\ntriple\n  ((fun v0 : Z =>\n    sepconj ((fun _ : Z => contains (Z.add a 1) p) v0)\n      (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n     v) (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c43_goal : forall _ : Z,\ntriple\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "intros _ .",
                "tactic_sig_no_out_arg": "intros _ .",
                "tactic_args": [
                    "c43_goal : forall _ : Z,\ntriple\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ],
                "tactic_res": [
                    "c44_goal : triple\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c44_goal : triple\n  (sepconj (contains (Z.add a 1) p)\n     (sepconj (contains a hd) (sepconj (list_at a' l) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_sepconj_pick2 : forall Q P R : assertion,\n       eq (sepconj P (sepconj Q R)) (sepconj Q (sepconj P R))",
                    "_global_sepconj_pick3 : forall R P Q S : assertion,\n       eq (sepconj P (sepconj Q (sepconj R S)))\n         (sepconj R (sepconj P (sepconj Q S)))"
                ],
                "tactic_res": [
                    "c45_goal : triple\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c45_goal : triple\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l'))))\n  (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q"
                ],
                "tactic_res": [
                    "c46_goal : triple ?P' (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c47_goal : aimp\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l')))) \n  ?P'"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c46_goal : triple ?P' (list_rev_rec a' a)\n  (fun x : Z => list_at x (rev_append l (cons hd l')))",
                    "c4_IHl : forall (a : addr) (l' : list Z) (p : addr),\ntriple (sepconj (list_at a l) (list_at p l')) (list_rev_rec a p)\n  (fun x : Z => list_at x (rev_append l l'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c47_goal : aimp\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l'))))\n  (sepconj (list_at a' l) (list_at a (cons hd l')))"
                ],
                "tactic_res": [
                    "c48_goal : aimp\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l'))))\n  (sepconj (list_at a' l)\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l'))))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c48_goal : aimp\n  (sepconj (list_at a' l)\n     (sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) p) (list_at p l'))))\n  (sepconj (list_at a' l)\n     (pureconj (not (eq a 0))\n        (aexists\n           (fun a' : Z =>\n            sepconj (contains a hd)\n              (sepconj (contains (Z.add a 1) a') (list_at a' l'))))))",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c49_goal : aimp\n  (sepconj (contains a hd)\n     (sepconj (contains (Z.add a 1) p) (list_at p l')))\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l')))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c49_goal : aimp\n  (sepconj (contains a hd)\n     (sepconj (contains (Z.add a 1) p) (list_at p l')))\n  (pureconj (not (eq a 0))\n     (aexists\n        (fun a' : Z =>\n         sepconj (contains a hd)\n           (sepconj (contains (Z.add a 1) a') (list_at a' l')))))"
                ],
                "tactic_res": [
                    "c50_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l')))) h",
                    "c50_h : heap",
                    "c50_A : sepconj (contains a hd)\n  (sepconj (contains (Z.add a 1) p) (list_at p l')) h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c50_goal : pureconj (not (eq a 0))\n  (aexists\n     (fun a' : Z =>\n      sepconj (contains a hd)\n        (sepconj (contains (Z.add a 1) a') (list_at a' l')))) h"
                ],
                "tactic_res": [
                    "c51_goal : not (eq a 0)",
                    "c52_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a hd)\n     (sepconj (contains (Z.add a 1) a') (list_at a' l'))) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : not (eq a 0)",
                    "c20_H1 : not (eq a 0)",
                    "c8_a : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c52_goal : aexists\n  (fun a' : Z =>\n   sepconj (contains a hd)\n     (sepconj (contains (Z.add a 1) a') (list_at a' l'))) h",
                    "c8_p : addr"
                ],
                "tactic_res": [
                    "c53_goal : sepconj (contains a hd)\n  (sepconj (contains (Z.add a 1) p) (list_at p l')) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : sepconj (contains a hd)\n  (sepconj (contains (Z.add a 1) p) (list_at p l')) h",
                    "c50_A : sepconj (contains a hd)\n  (sepconj (contains (Z.add a 1) p) (list_at p l')) h",
                    "c50_h : heap",
                    "c8_p : addr",
                    "c8_l' : list Z",
                    "c8_a : addr",
                    "c4_hd : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "list_rev_correct",
        "proof": [
            {
                "tactic_sig": "Lemma list_rev_correct : forall a l , \u2983 list_at a l \u2984 list_rev a \u2983 fun x => list_at x ( List.rev l ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma list_rev_correct : forall a l , \u2983 list_at a l \u2984 list_rev a \u2983 fun x => list_at x ( List.rev l ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : addr) (l : list Z),\ntriple (list_at a l) (list_rev a) (fun x : Z => list_at x (rev l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (a : addr) (l : list Z),\ntriple (list_at a l) (list_rev a) (fun x : Z => list_at x (rev l))"
                ],
                "tactic_res": [
                    "c2_goal : triple (list_at a l) (list_rev a) (fun x : Z => list_at x (rev l))",
                    "c2_a : addr",
                    "c2_l : list Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : triple (list_at a l) (list_rev a) (fun x : Z => list_at x (rev l))",
                    "_global_List.rev_alt : forall (A : Type) (l : list A), eq (rev l) (rev_append l nil)"
                ],
                "tactic_res": [
                    "c3_goal : triple (list_at a l) (list_rev a)\n  (fun x : Z => list_at x (rev_append l nil))"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c3_goal : triple (list_at a l) (list_rev a)\n  (fun x : Z => list_at x (rev_append l nil))",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q"
                ],
                "tactic_res": [
                    "c4_goal : triple ?P' (list_rev a) (fun x : Z => list_at x (rev_append l nil))",
                    "c5_goal : aimp (list_at a l) (sepconj (list_at a l) (list_at 0 nil))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple ?P' (list_rev a) (fun x : Z => list_at x (rev_append l nil))",
                    "_global_list_rev_rec_correct : forall (l : list Z) (a : addr) (l' : list Z) (p : addr),\n       triple (sepconj (list_at a l) (list_at p l')) \n         (list_rev_rec a p) (fun x : Z => list_at x (rev_append l l'))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : aimp (list_at a l) (sepconj (list_at a l) (list_at 0 nil))"
                ],
                "tactic_res": [
                    "c6_goal : aimp (list_at a l) (sepconj (list_at a l) (pureconj (eq 0 0) emp))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i , _i .",
                "tactic_args": [
                    "c6_goal : aimp (list_at a l) (sepconj (list_at a l) (pureconj (eq 0 0) emp))",
                    "_global_sepconj_comm : forall P Q : assertion, eq (sepconj P Q) (sepconj Q P)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c7_goal : aimp (list_at a l) (pureconj (eq 0 0) (list_at a l))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h A .",
                "tactic_args": [
                    "c7_goal : aimp (list_at a l) (pureconj (eq 0 0) (list_at a l))"
                ],
                "tactic_res": [
                    "c8_goal : pureconj (eq 0 0) (list_at a l) h",
                    "c8_h : heap",
                    "c8_A : list_at a l h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : pureconj (eq 0 0) (list_at a l) h"
                ],
                "tactic_res": [
                    "c9_goal : eq 0 0",
                    "c10_goal : list_at a l h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : list_at a l h",
                    "c8_A : list_at a l h",
                    "c8_h : heap",
                    "c2_l : list Z",
                    "c2_a : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_frame",
        "proof": [
            {
                "tactic_sig": "Lemma triple_frame : forall P c Q R , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_frame : forall P c Q R , \u2983 P \u2984 c \u2983 Q \u2984 -> \u2983 P ** R \u2984 c \u2983 fun v => Q v ** R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (R : assertion)\n  (_ : triple P c Q),\ntriple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P c Q R TR R' .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (R : assertion)\n  (_ : triple P c Q),\ntriple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c2_goal : Hoare (sepconj (sepconj P R) R') c\n  (fun v : Z => sepconj (sepconj (Q v) R) R')",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_R : assertion",
                    "c2_TR : triple P c Q",
                    "c2_R' : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : Hoare (sepconj (sepconj P R) R') c\n  (fun v : Z => sepconj (sepconj (Q v) R) R')",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (sepconj P (sepconj R R')) c\n  (fun v : Z => sepconj (sepconj (Q v) R) R')"
                ]
            },
            {
                "tactic_sig": "replace ( fun v => ( _i v ** _i ) ** _i ) with ( fun v => _i v ** ( _i ** _i ) ) .",
                "tactic_sig_no_out_arg": "replace ( fun v => ( _i v ** _i ) ** _i ) with ( fun v => _i v ** ( _i ** _i ) ) .",
                "tactic_args": [
                    "c3_goal : Hoare (sepconj P (sepconj R R')) c\n  (fun v : Z => sepconj (sepconj (Q v) R) R')",
                    "c2_Q : postcond",
                    "c2_R : assertion",
                    "c2_R' : assertion",
                    "c2_Q : postcond",
                    "c2_R : assertion",
                    "c2_R' : assertion"
                ],
                "tactic_res": [
                    "c4_goal : Hoare (sepconj P (sepconj R R')) c\n  (fun v : Z => sepconj (Q v) (sepconj R R'))",
                    "c5_goal : eq (fun v : Z => sepconj (Q v) (sepconj R R'))\n  (fun v : Z => sepconj (sepconj (Q v) R) R')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Hoare (sepconj P (sepconj R R')) c\n  (fun v : Z => sepconj (Q v) (sepconj R R'))",
                    "c2_TR : triple P c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (fun v : Z => sepconj (Q v) (sepconj R R'))\n  (fun v : Z => sepconj (sepconj (Q v) R) R')",
                    "_global_functional_extensionality : forall (f g : forall _ : ?A, ?B) (_ : forall x : ?A, eq (f x) (g x)),\n       eq f g\nwhere\n?A : [P : precond\n      c : com\n      Q : postcond\n      R : assertion\n      TR : triple P c Q\n      R' : assertion |- Type]\n?B : [P : precond\n      c : com\n      Q : postcond\n      R : assertion\n      TR : triple P c Q\n      R' : assertion |- Type]"
                ],
                "tactic_res": [
                    "c6_goal : forall x : Z,\neq (sepconj (Q x) (sepconj R R')) (sepconj (sepconj (Q x) R) R')"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall x : Z,\neq (sepconj (Q x) (sepconj R R')) (sepconj (sepconj (Q x) R) R')"
                ],
                "tactic_res": [
                    "c7_goal : eq (sepconj (Q x) (sepconj R R')) (sepconj (sepconj (Q x) R) R')",
                    "c7_x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (sepconj (Q x) (sepconj R R')) (sepconj (sepconj (Q x) R) R')",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c8_goal : eq (sepconj (Q x) (sepconj R R')) (sepconj (Q x) (sepconj R R'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (sepconj (Q x) (sepconj R R')) (sepconj (Q x) (sepconj R R'))",
                    "c7_x : Z",
                    "c2_R' : assertion",
                    "c2_R : assertion",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_get",
        "proof": [
            {
                "tactic_sig": "Lemma triple_get : forall l v , \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_get : forall l v , \u2983 contains l v \u2984 GET l \u2983 fun v' => ( v' = v ) //\\\\ contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros l v R h ( h1 & h2 & H1 & H2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": [
                    "c2_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_R : assertion",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H1 : contains l v h1",
                    "c2_H2 : R h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c2_h1 : heap",
                    "c2_l : addr",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h1 l) (Some v)",
                    "c4_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c4_L1 : eq (h1 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c3_H1 : contains l v h1"
                ],
                "tactic_res": [
                    "c3_H1 : eq h1 (hupdate l v hempty)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq (h1 l) (Some v)",
                    "c2_h1 : heap",
                    "c3_H1 : eq h1 (hupdate l v hempty)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v hempty l) (Some v)",
                    "c5_D : hdisjoint (hupdate l v hempty) h2",
                    "c5_U : eq h (hunion (hupdate l v hempty) h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v hempty l) (Some v)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c4_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c6_goal : eq (h l) (Some v)",
                    "c7_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c7_L : eq (h l) (Some v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (h l) (Some v)",
                    "c2_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v)"
                ],
                "tactic_res": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v)",
                    "c4_L1 : eq (h1 l) (Some v)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Some v) (Some v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Some v) (Some v)",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (GET l) h\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)"
                ],
                "tactic_res": [
                    "c11_goal : True",
                    "c12_goal : immsafe (pair (GET l) h)",
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (GET l) h) (pair c' h')),\nsafe c' h'\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : immsafe (pair (GET l) h)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c14_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (GET l) h) (pair c' h')),\nsafe c' h'\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)"
                ],
                "tactic_res": [
                    "c15_goal : safe c' h'\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_RED : red (pair (GET l) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : safe c' h'\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c15_RED : red (pair (GET l) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c16_goal : safe (PURE v0) (hunion h1 h2)\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)",
                    "c16_H0 : eq (hunion h1 h2 l) (Some v0)",
                    "c16_v0 : Z",
                    "c16_L : eq (hunion h1 h2 l) (Some v)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : safe (PURE v0) (hunion h1 h2)\n  (fun v0 : Z => sepconj (pureconj (eq v0 v) (contains l v)) R)"
                ],
                "tactic_res": [
                    "c17_goal : sepconj (pureconj (eq v0 v) (contains l v)) R (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c17_goal : sepconj (pureconj (eq v0 v) (contains l v)) R (hunion h1 h2)",
                    "c2_h1 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c18_goal : and (pureconj (eq v0 v) (contains l v) h1)\n  (and (R h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c18_goal : and (pureconj (eq v0 v) (contains l v) h1)\n  (and (R h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))",
                    "_global_pureconj : forall (_ : Prop) (_ : assertion), assertion"
                ],
                "tactic_res": [
                    "c19_goal : and (and (eq v0 v) (contains l v h1))\n  (and (R h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c19_goal : and (and (eq v0 v) (contains l v h1))\n  (and (R h2)\n     (and (hdisjoint h1 h2) (eq (hunion h1 h2) (hunion h1 h2))))",
                    "c16_H0 : eq (hunion h1 h2 l) (Some v0)",
                    "c16_v0 : Z",
                    "c16_L : eq (hunion h1 h2 l) (Some v)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_H2 : R h2",
                    "c2_H1 : contains l v h1",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_R : assertion",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_set",
        "proof": [
            {
                "tactic_sig": "Lemma triple_set : forall l v , \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_set : forall l v , \u2983 valid l \u2984 SET l v \u2983 fun _ => contains l v \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros l v R h ( h1 & h2 & H1 & H2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z),\ntriple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": [
                    "c2_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_R : assertion",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H1 : valid l h1",
                    "c2_H2 : R h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( v0 & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( v0 & _i ) .",
                "tactic_args": [
                    "c2_H1 : valid l h1",
                    "c2_H1 : valid l h1",
                    "c2_U : eq h (hunion h1 h2)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_H2 : R h2",
                    "c2_h : heap",
                    "c2_R : assertion",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": [
                    "c2_H1 : contains l v0 h1",
                    "c2_v0 : Z"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "c2_H1 : contains l v0 h1"
                ],
                "tactic_res": [
                    "c2_H1 : eq h1 (hupdate l v0 hempty)"
                ]
            },
            {
                "tactic_sig": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)",
                    "c2_h1 : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h1 l) (Some v0)",
                    "c4_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)",
                    "c4_L1 : eq (h1 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : eq (h1 l) (Some v0)",
                    "c2_h1 : heap",
                    "c2_H1 : eq h1 (hupdate l v0 hempty)"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)",
                    "c5_D : hdisjoint (hupdate l v0 hempty) h2",
                    "c5_U : eq h (hunion (hupdate l v0 hempty) h2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c4_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c6_goal : eq (h l) (Some v0)",
                    "c7_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)",
                    "c7_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (h l) (Some v0)",
                    "c2_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v0)"
                ],
                "tactic_res": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v0)",
                    "c4_L1 : eq (h1 l) (Some v0)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Some v0) (Some v0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Some v0) (Some v0)",
                    "c2_v0 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (SET l v) h (fun _ : Z => sepconj (contains l v) R)"
                ],
                "tactic_res": [
                    "c11_goal : True",
                    "c12_goal : immsafe (pair (SET l v) h)",
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (SET l v) h) (pair c' h')),\nsafe c' h' (fun _ : Z => sepconj (contains l v) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : immsafe (pair (SET l v) h)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c14_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (SET l v) h) (pair c' h')),\nsafe c' h' (fun _ : Z => sepconj (contains l v) R)"
                ],
                "tactic_res": [
                    "c15_goal : safe c' h' (fun _ : Z => sepconj (contains l v) R)",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_RED : red (pair (SET l v) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : safe c' h' (fun _ : Z => sepconj (contains l v) R)",
                    "c15_RED : red (pair (SET l v) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c16_goal : safe SKIP (hupdate l v (hunion (hupdate l v0 hempty) h2))\n  (fun _ : Z => sepconj (contains l v) R)",
                    "c16_H0 : not (eq (hunion (hupdate l v0 hempty) h2 l) None)",
                    "c16_L : eq (hunion (hupdate l v0 hempty) h2 l) (Some v0)",
                    "c16_D : hdisjoint (hupdate l v0 hempty) h2",
                    "c16_L1 : eq (hupdate l v0 hempty l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : safe SKIP (hupdate l v (hunion (hupdate l v0 hempty) h2))\n  (fun _ : Z => sepconj (contains l v) R)"
                ],
                "tactic_res": [
                    "c17_goal : sepconj (contains l v) R\n  (hupdate l v (hunion (hupdate l v0 hempty) h2))"
                ]
            },
            {
                "tactic_sig": "exists ( hupdate _i _i hempty ) , _i .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i _i hempty ) , _i .",
                "tactic_args": [
                    "c17_goal : sepconj (contains l v) R\n  (hupdate l v (hunion (hupdate l v0 hempty) h2))",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c18_goal : and (contains l v (hupdate l v hempty))\n  (and (R h2)\n     (and (hdisjoint (hupdate l v hempty) h2)\n        (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n           (hunion (hupdate l v hempty) h2))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c18_goal : and (contains l v (hupdate l v hempty))\n  (and (R h2)\n     (and (hdisjoint (hupdate l v hempty) h2)\n        (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n           (hunion (hupdate l v hempty) h2))))"
                ],
                "tactic_res": [
                    "c19_goal : contains l v (hupdate l v hempty)",
                    "c20_goal : and (R h2)\n  (and (hdisjoint (hupdate l v hempty) h2)\n     (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n        (hunion (hupdate l v hempty) h2)))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c19_goal : contains l v (hupdate l v hempty)"
                ],
                "tactic_res": [
                    "c21_goal : eq (hupdate l v hempty) (hupdate l v hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : eq (hupdate l v hempty) (hupdate l v hempty)",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c20_goal : and (R h2)\n  (and (hdisjoint (hupdate l v hempty) h2)\n     (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n        (hunion (hupdate l v hempty) h2)))"
                ],
                "tactic_res": [
                    "c22_goal : R h2",
                    "c23_goal : and (hdisjoint (hupdate l v hempty) h2)\n  (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n     (hunion (hupdate l v hempty) h2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : R h2",
                    "c2_H2 : R h2",
                    "c2_h2 : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c23_goal : and (hdisjoint (hupdate l v hempty) h2)\n  (eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n     (hunion (hupdate l v hempty) h2))"
                ],
                "tactic_res": [
                    "c24_goal : hdisjoint (hupdate l v hempty) h2",
                    "c25_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n  (hunion (hupdate l v hempty) h2)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro l' .",
                "tactic_args": [
                    "c24_goal : hdisjoint (hupdate l v hempty) h2"
                ],
                "tactic_res": [
                    "c26_goal : or (eq (hupdate l v hempty l') None) (eq (h2 l') None)",
                    "c26_l' : addr"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c26_D : hdisjoint (hupdate l v0 hempty) h2",
                    "c26_l' : addr"
                ],
                "tactic_res": [
                    "c26_D : or (eq (hupdate l v0 hempty l') None) (eq (h2 l') None)"
                ]
            },
            {
                "tactic_sig": "cbn in * .",
                "tactic_sig_no_out_arg": "cbn in * .",
                "tactic_args": [
                    "c26_goal : or (eq (hupdate l v hempty l') None) (eq (h2 l') None)"
                ],
                "tactic_res": [
                    "c27_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c27_H0 : not\n  (eq\n     (if if Z.eq_dec l l then Some v0 else None\n      then if Z.eq_dec l l then Some v0 else None\n      else h2 l) None)",
                    "c27_L : eq\n  (if if Z.eq_dec l l then Some v0 else None\n   then if Z.eq_dec l l then Some v0 else None\n   else h2 l) (Some v0)",
                    "c27_D : or (eq (if Z.eq_dec l l' then Some v0 else None) None)\n  (eq (h2 l') None)",
                    "c27_L1 : eq (if Z.eq_dec l l then Some v0 else None) (Some v0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c27_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c27_D : or (eq (if Z.eq_dec l l' then Some v0 else None) None)\n  (eq (h2 l') None)",
                    "c27_H0 : not\n  (eq\n     (if if Z.eq_dec l l then Some v0 else None\n      then if Z.eq_dec l l then Some v0 else None\n      else h2 l) None)",
                    "c27_L : eq\n  (if if Z.eq_dec l l then Some v0 else None\n   then if Z.eq_dec l l then Some v0 else None\n   else h2 l) (Some v0)",
                    "c26_l' : addr",
                    "c27_L1 : eq (if Z.eq_dec l l then Some v0 else None) (Some v0)",
                    "c2_H2 : R h2",
                    "c2_h2 : heap",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": [
                    "c28_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c28_H : eq (if Z.eq_dec l l' then Some v0 else None) None",
                    "c29_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c29_H : eq (h2 l') None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c29_H : eq (h2 l') None",
                    "c26_l' : addr",
                    "c2_h2 : heap",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c28_goal : or (eq (if Z.eq_dec l l' then Some v else None) None) (eq (h2 l') None)",
                    "c2_l : addr",
                    "c26_l' : addr",
                    "c27_H0 : not\n  (eq\n     (if if Z.eq_dec l l then Some v0 else None\n      then if Z.eq_dec l l then Some v0 else None\n      else h2 l) None)",
                    "c27_L : eq\n  (if if Z.eq_dec l l then Some v0 else None\n   then if Z.eq_dec l l then Some v0 else None\n   else h2 l) (Some v0)",
                    "c28_H : eq (if Z.eq_dec l l' then Some v0 else None) None",
                    "c27_L1 : eq (if Z.eq_dec l l then Some v0 else None) (Some v0)",
                    "c2_H2 : R h2",
                    "c2_h2 : heap",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c30_goal : or (eq (Some v) None) (eq (h2 l') None)",
                    "c30_H : eq (Some v0) None",
                    "c30_e : eq l l'",
                    "c31_goal : or (eq None None) (eq (h2 l') None)",
                    "c31_H : eq None None",
                    "c31_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : or (eq None None) (eq (h2 l') None)",
                    "c26_l' : addr",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c30_goal : or (eq (Some v) None) (eq (h2 l') None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) h2))\n  (hunion (hupdate l v hempty) h2)",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c32_goal : forall l0 : addr,\neq (hupdate l v (hunion (hupdate l v0 hempty) h2) l0)\n  (hunion (hupdate l v hempty) h2 l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros l' .",
                "tactic_args": [
                    "c32_goal : forall l0 : addr,\neq (hupdate l v (hunion (hupdate l v0 hempty) h2) l0)\n  (hunion (hupdate l v hempty) h2 l0)"
                ],
                "tactic_res": [
                    "c33_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) h2) l')\n  (hunion (hupdate l v hempty) h2 l')",
                    "c33_l' : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c33_goal : eq (hupdate l v (hunion (hupdate l v0 hempty) h2) l')\n  (hunion (hupdate l v hempty) h2 l')"
                ],
                "tactic_res": [
                    "c34_goal : eq\n  (if Z.eq_dec l l'\n   then Some v\n   else\n    if if Z.eq_dec l l' then Some v0 else None\n    then if Z.eq_dec l l' then Some v0 else None\n    else h2 l')\n  (if if Z.eq_dec l l' then Some v else None\n   then if Z.eq_dec l l' then Some v else None\n   else h2 l')"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c34_goal : eq\n  (if Z.eq_dec l l'\n   then Some v\n   else\n    if if Z.eq_dec l l' then Some v0 else None\n    then if Z.eq_dec l l' then Some v0 else None\n    else h2 l')\n  (if if Z.eq_dec l l' then Some v else None\n   then if Z.eq_dec l l' then Some v else None\n   else h2 l')",
                    "c2_l : addr",
                    "c33_l' : addr",
                    "c16_H0 : not (eq (hunion (hupdate l v0 hempty) h2 l) None)",
                    "c16_L : eq (hunion (hupdate l v0 hempty) h2 l) (Some v0)",
                    "c16_D : hdisjoint (hupdate l v0 hempty) h2",
                    "c16_L1 : eq (hupdate l v0 hempty l) (Some v0)",
                    "c2_H2 : R h2",
                    "c2_v0 : Z",
                    "c2_h2 : heap",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c35_goal : eq (Some v) (Some v)",
                    "c35_e : eq l l'",
                    "c36_goal : eq (h2 l') (h2 l')",
                    "c36_n : not (eq l l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq (Some v) (Some v)",
                    "c2_v : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : eq (h2 l') (h2 l')",
                    "c33_l' : addr",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_N_init",
        "proof": [
            {
                "tactic_sig": "Remark valid_N_init : forall ( R : assertion ) sz l h , R h -> ( forall i , l <= i < l + Z.of_nat sz -> h i = None ) -> ( valid_N l sz ** R ) ( hinit l sz h ) .",
                "tactic_sig_no_out_arg": "Remark valid_N_init : forall ( R : assertion ) sz l h , R h -> ( forall i , l <= i < l + Z.of_nat sz -> h i = None ) -> ( valid_N l sz ** R ) ( hinit l sz h ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (sz : nat) (l : Z) (h : heap) \n  (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros R sz .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (sz : nat) (l : Z) (h : heap) \n  (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)"
                ],
                "tactic_res": [
                    "c2_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)",
                    "c2_R : assertion",
                    "c2_sz : nat"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | _i ] .",
                "tactic_args": [
                    "c2_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)",
                    "c2_sz : nat",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat 0%nat)))),\n       eq (h i) None), sepconj (valid_N l 0) R (hinit l 0 h)",
                    "c4_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\n       eq (h i) None), sepconj (valid_N l (S sz)) R (hinit l (S sz) h)",
                    "c4_IHsz : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l h Rh EMPTY .",
                "tactic_args": [
                    "c3_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat 0%nat)))),\n       eq (h i) None), sepconj (valid_N l 0) R (hinit l 0 h)"
                ],
                "tactic_res": [
                    "c5_goal : sepconj (valid_N l 0) R (hinit l 0 h)",
                    "c5_l : Z",
                    "c5_h : heap",
                    "c5_Rh : R h",
                    "c5_EMPTY : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat 0%nat)))),\neq (h i) None"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c5_goal : sepconj (valid_N l 0) R (hinit l 0 h)"
                ],
                "tactic_res": [
                    "c6_goal : sepconj emp R h"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l h Rh EMPTY .",
                "tactic_args": [
                    "c4_goal : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\n       eq (h i) None), sepconj (valid_N l (S sz)) R (hinit l (S sz) h)"
                ],
                "tactic_res": [
                    "c7_goal : sepconj (valid_N l (S sz)) R (hinit l (S sz) h)",
                    "c7_l : Z",
                    "c7_h : heap",
                    "c7_Rh : R h",
                    "c7_EMPTY : forall (i : Z)\n  (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\neq (h i) None"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c7_goal : sepconj (valid_N l (S sz)) R (hinit l (S sz) h)"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (sepconj (valid l) (valid_N (Z.add l 1) sz)) R\n  (hupdate l 0 (hinit (Z.add l 1) sz h))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : sepconj emp R h",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c9_goal : R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : R h",
                    "c5_Rh : R h",
                    "c5_h : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : sepconj (sepconj (valid l) (valid_N (Z.add l 1) sz)) R\n  (hupdate l 0 (hinit (Z.add l 1) sz h))",
                    "_global_sepconj_assoc : forall P Q R : assertion,\n       eq (sepconj (sepconj P Q) R) (sepconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c10_goal : sepconj (valid l) (sepconj (valid_N (Z.add l 1) sz) R)\n  (hupdate l 0 (hinit (Z.add l 1) sz h))"
                ]
            },
            {
                "tactic_sig": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( hupdate _i 0 hempty ) , ( hinit ( _i + 1 ) _i _i ) .",
                "tactic_args": [
                    "c10_goal : sepconj (valid l) (sepconj (valid_N (Z.add l 1) sz) R)\n  (hupdate l 0 (hinit (Z.add l 1) sz h))",
                    "c7_l : Z",
                    "c7_l : Z",
                    "c2_sz : nat",
                    "c7_h : heap"
                ],
                "tactic_res": [
                    "c11_goal : and (valid l (hupdate l 0 hempty))\n  (and (sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h))\n     (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c11_goal : and (valid l (hupdate l 0 hempty))\n  (and (sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h))\n     (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n        (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n           (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)))))"
                ],
                "tactic_res": [
                    "c12_goal : valid l (hupdate l 0 hempty)",
                    "c13_goal : and (sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h))\n  (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n     (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n        (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))))"
                ]
            },
            {
                "tactic_sig": "exists 0 .",
                "tactic_sig_no_out_arg": "exists 0 .",
                "tactic_args": [
                    "c12_goal : valid l (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c14_goal : contains l 0 (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c14_goal : contains l 0 (hupdate l 0 hempty)"
                ],
                "tactic_res": [
                    "c15_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq (hupdate l 0 hempty) (hupdate l 0 hempty)",
                    "c7_l : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : and (sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h))\n  (and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n     (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n        (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))))"
                ],
                "tactic_res": [
                    "c16_goal : sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h)",
                    "c17_goal : and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n  (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n     (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : sepconj (valid_N (Z.add l 1) sz) R (hinit (Z.add l 1) sz h)",
                    "c4_IHsz : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)"
                ],
                "tactic_res": [
                    "c18_goal : R h",
                    "c19_goal : forall (i : Z)\n  (_ : and (Z.le (Z.add l 1) i)\n         (Z.lt i (Z.add (Z.add l 1) (Z.of_nat sz)))), \neq (h i) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : R h",
                    "c7_Rh : R h",
                    "c7_h : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c19_goal : forall (i : Z)\n  (_ : and (Z.le (Z.add l 1) i)\n         (Z.lt i (Z.add (Z.add l 1) (Z.of_nat sz)))), \neq (h i) None"
                ],
                "tactic_res": [
                    "c20_goal : eq (h i) None",
                    "c20_i : Z",
                    "c20_H : and (Z.le (Z.add l 1) i) (Z.lt i (Z.add (Z.add l 1) (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : eq (h i) None",
                    "c7_EMPTY : forall (i : Z)\n  (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\neq (h i) None"
                ],
                "tactic_res": [
                    "c21_goal : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c21_goal : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : and (hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))\n  (eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n     (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)))"
                ],
                "tactic_res": [
                    "c22_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)",
                    "c23_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c22_goal : hdisjoint (hupdate l 0 hempty) (hinit (Z.add l 1) sz h)"
                ],
                "tactic_res": [
                    "c24_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz h x) None)",
                    "c24_x : addr"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c24_goal : or (eq (hupdate l 0 hempty x) None)\n  (eq (hinit (Z.add l 1) sz h x) None)",
                    "_global_hupdate : forall (_ : addr) (_ : Z) (_ : heap), heap",
                    "_global_hempty : heap"
                ],
                "tactic_res": [
                    "c25_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite :=\n          Separation.hupdate_obligation_1 l 0\n            {|\n              contents := fun _ : addr => None;\n              isfinite := Separation.hempty_obligation_1\n            |}\n      |} x) None) (eq (hinit (Z.add l 1) sz h x) None)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c25_goal : or\n  (eq\n     ({|\n        contents :=\n          fun l' : addr =>\n          if Z.eq_dec l l'\n          then Some 0\n          else\n           {|\n             contents := fun _ : addr => None;\n             isfinite := Separation.hempty_obligation_1\n           |} l';\n        isfinite :=\n          Separation.hupdate_obligation_1 l 0\n            {|\n              contents := fun _ : addr => None;\n              isfinite := Separation.hempty_obligation_1\n            |}\n      |} x) None) (eq (hinit (Z.add l 1) sz h x) None)"
                ],
                "tactic_res": [
                    "c26_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq (hinit (Z.add l 1) sz h x) None)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c26_goal : or (eq (if Z.eq_dec l x then Some 0 else None) None)\n  (eq (hinit (Z.add l 1) sz h x) None)",
                    "c7_l : Z",
                    "c24_x : addr",
                    "c7_EMPTY : forall (i : Z)\n  (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\neq (h i) None",
                    "c7_Rh : R h",
                    "c7_h : heap",
                    "c4_IHsz : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c27_goal : or (eq (Some 0) None) (eq (hinit (Z.add l 1) sz h x) None)",
                    "c27_e : eq l x",
                    "c28_goal : or (eq None None) (eq (hinit (Z.add l 1) sz h x) None)",
                    "c28_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : or (eq None None) (eq (hinit (Z.add l 1) sz h x) None)",
                    "c24_x : addr",
                    "c7_h : heap",
                    "c7_l : Z",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c27_goal : or (eq (Some 0) None) (eq (hinit (Z.add l 1) sz h x) None)"
                ],
                "tactic_res": [
                    "c29_goal : eq (hinit (Z.add l 1) sz h x) None"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c29_goal : eq (hinit (Z.add l 1) sz h x) None",
                    "_global_hinit_outside : forall (h : heap) (sz : nat) (l l' : Z)\n         (_ : or (Z.lt l' l) (Z.le (Z.add l (Z.of_nat sz)) l')),\n       eq (hinit l sz h l') (h l')"
                ],
                "tactic_res": [
                    "c30_goal : eq (h x) None"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : eq (h x) None",
                    "c7_EMPTY : forall (i : Z)\n  (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\neq (h i) None"
                ],
                "tactic_res": [
                    "c31_goal : and (Z.le l x) (Z.lt x (Z.add l (Z.of_nat (S sz))))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c31_goal : and (Z.le l x) (Z.lt x (Z.add l (Z.of_nat (S sz))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz h))\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c32_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz h) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c32_goal : forall l0 : addr,\neq (hupdate l 0 (hinit (Z.add l 1) sz h) l0)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h) l0)"
                ],
                "tactic_res": [
                    "c33_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz h) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h) x)",
                    "c33_x : addr"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c33_goal : eq (hupdate l 0 (hinit (Z.add l 1) sz h) x)\n  (hunion (hupdate l 0 hempty) (hinit (Z.add l 1) sz h) x)"
                ],
                "tactic_res": [
                    "c34_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz h x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz h x)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c34_goal : eq (if Z.eq_dec l x then Some 0 else hinit (Z.add l 1) sz h x)\n  (if if Z.eq_dec l x then Some 0 else None\n   then if Z.eq_dec l x then Some 0 else None\n   else hinit (Z.add l 1) sz h x)",
                    "c7_l : Z",
                    "c33_x : addr",
                    "c7_EMPTY : forall (i : Z)\n  (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat (S sz))))),\neq (h i) None",
                    "c7_Rh : R h",
                    "c7_h : heap",
                    "c4_IHsz : forall (l : Z) (h : heap) (_ : R h)\n  (_ : forall (i : Z)\n         (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n       eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c35_goal : eq (Some 0) (Some 0)",
                    "c35_e : eq l x",
                    "c36_goal : eq (hinit (Z.add l 1) sz h x) (hinit (Z.add l 1) sz h x)",
                    "c36_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq (Some 0) (Some 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : eq (hinit (Z.add l 1) sz h x) (hinit (Z.add l 1) sz h x)",
                    "c33_x : addr",
                    "c7_h : heap",
                    "c7_l : Z",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_alloc",
        "proof": [
            {
                "tactic_sig": "Lemma triple_alloc : forall sz , \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_alloc : forall sz , \u2983 emp \u2984 ALLOC sz \u2983 fun l => ( l <> 0 ) //\\\\ valid_N l sz \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall sz : nat,\ntriple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros sz R h H .",
                "tactic_args": [
                    "c1_goal : forall sz : nat,\ntriple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": [
                    "c2_goal : safe (ALLOC sz) h\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)",
                    "c2_sz : nat",
                    "c2_R : assertion",
                    "c2_h : heap",
                    "c2_H : sepconj emp R h"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P",
                    "c2_H : sepconj emp R h"
                ],
                "tactic_res": [
                    "c2_H : R h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : safe (ALLOC sz) h\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)"
                ],
                "tactic_res": [
                    "c3_goal : True",
                    "c4_goal : immsafe (pair (ALLOC sz) h)",
                    "c5_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (ALLOC sz) h) (pair c' h')),\nsafe c' h'\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( isfinite _i ) as ( l0 & FIN ) .",
                "tactic_sig_no_out_arg": "destruct ( isfinite _i ) as ( l0 & FIN ) .",
                "tactic_args": [
                    "c2_h : heap",
                    "c2_H : R h",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c4_FIN : forall (j : Z) (_ : Z.le l0 j), eq (h j) None",
                    "c4_l0 : Z"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i 1 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i 1 ) .",
                "tactic_args": [
                    "c4_goal : immsafe (pair (ALLOC sz) h)",
                    "_global_immsafe_alloc : forall (sz : nat) (h : heap) (l : Z) (_ : not (eq l 0))\n         (_ : forall (i : Z)\n                (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n              eq (h i) None), immsafe (pair (ALLOC sz) h)",
                    "_global_Z.max : forall (_ : Z) (_ : Z), Z",
                    "c4_l0 : Z"
                ],
                "tactic_res": [
                    "c6_goal : not (eq (Z.max l0 1) 0)",
                    "c7_goal : forall (i : Z)\n  (_ : and (Z.le (Z.max l0 1) i)\n         (Z.lt i (Z.add (Z.max l0 1) (Z.of_nat sz)))), \neq (h i) None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (i : Z)\n  (_ : and (Z.le (Z.max l0 1) i)\n         (Z.lt i (Z.add (Z.max l0 1) (Z.of_nat sz)))), \neq (h i) None"
                ],
                "tactic_res": [
                    "c8_goal : eq (h i) None",
                    "c8_i : Z",
                    "c8_H0 : and (Z.le (Z.max l0 1) i) (Z.lt i (Z.add (Z.max l0 1) (Z.of_nat sz)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c6_goal : not (eq (Z.max l0 1) 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq (h i) None",
                    "c4_FIN : forall (j : Z) (_ : Z.le l0 j), eq (h j) None"
                ],
                "tactic_res": [
                    "c9_goal : Z.le l0 i"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c9_goal : Z.le l0 i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c5_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (ALLOC sz) h) (pair c' h')),\nsafe c' h'\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)"
                ],
                "tactic_res": [
                    "c10_goal : safe c' h'\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)",
                    "c10_c' : com",
                    "c10_h' : heap",
                    "c10_RED : red (pair (ALLOC sz) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : safe c' h'\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)",
                    "c10_RED : red (pair (ALLOC sz) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c11_goal : safe (PURE l) (hinit l sz h)\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)",
                    "c11_H5 : not (eq l 0)",
                    "c11_H3 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None",
                    "c11_l : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : safe (PURE l) (hinit l sz h)\n  (fun v : Z => sepconj (pureconj (not (eq v 0)) (valid_N v sz)) R)"
                ],
                "tactic_res": [
                    "c12_goal : sepconj (pureconj (not (eq l 0)) (valid_N l sz)) R (hinit l sz h)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : sepconj (pureconj (not (eq l 0)) (valid_N l sz)) R (hinit l sz h)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c13_goal : pureconj (not (eq l 0)) (sepconj (valid_N l sz) R) (hinit l sz h)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : pureconj (not (eq l 0)) (sepconj (valid_N l sz) R) (hinit l sz h)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq l 0)",
                    "c15_goal : sepconj (valid_N l sz) R (hinit l sz h)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : not (eq l 0)",
                    "c11_H5 : not (eq l 0)",
                    "c11_l : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : sepconj (valid_N l sz) R (hinit l sz h)",
                    "_global_valid_N_init : forall (R : assertion) (sz : nat) (l : Z) (h : heap) \n         (_ : R h)\n         (_ : forall (i : Z)\n                (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\n              eq (h i) None), sepconj (valid_N l sz) R (hinit l sz h)"
                ],
                "tactic_res": [
                    "c16_goal : R h",
                    "c17_goal : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : R h",
                    "c2_H : R h",
                    "c2_h : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None",
                    "c11_H3 : forall (i : Z) (_ : and (Z.le l i) (Z.lt i (Z.add l (Z.of_nat sz)))),\neq (h i) None",
                    "c11_l : Z",
                    "c2_h : heap",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_free",
        "proof": [
            {
                "tactic_sig": "Lemma triple_free : forall l , \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_free : forall l , \u2983 valid l \u2984 FREE l \u2983 fun _ => emp \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall l : addr, triple (valid l) (FREE l) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros l R h ( h1 & h2 & H1 & H2 & D & U ) .",
                "tactic_args": [
                    "c1_goal : forall l : addr, triple (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": [
                    "c2_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)",
                    "c2_l : addr",
                    "c2_R : assertion",
                    "c2_h : heap",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_H1 : valid l h1",
                    "c2_H2 : R h2",
                    "c2_D : hdisjoint h1 h2",
                    "c2_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( v0 & _i ) .",
                "tactic_sig_no_out_arg": "destruct _i as ( v0 & _i ) .",
                "tactic_args": [
                    "c2_H1 : valid l h1",
                    "c2_H1 : valid l h1",
                    "c2_U : eq h (hunion h1 h2)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_H2 : R h2",
                    "c2_h : heap",
                    "c2_R : assertion",
                    "c2_l : addr"
                ],
                "tactic_res": [
                    "c2_H1 : contains l v0 h1",
                    "c2_v0 : Z"
                ]
            },
            {
                "tactic_sig": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L1 : _i _i = Some _i ) .",
                "tactic_args": [
                    "c2_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)",
                    "c2_h1 : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c3_goal : eq (h1 l) (Some v0)",
                    "c4_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)",
                    "c4_L1 : eq (h1 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : eq (h1 l) (Some v0)",
                    "c2_H1 : contains l v0 h1"
                ],
                "tactic_res": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq (hupdate l v0 hempty l) (Some v0)",
                    "_global_hupdate_same : forall (l : addr) (v : Z) (h : heap), eq (hupdate l v h l) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( L : _i _i = Some _i ) .",
                "tactic_sig_no_out_arg": "assert ( L : _i _i = Some _i ) .",
                "tactic_args": [
                    "c4_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)",
                    "c2_h : heap",
                    "c2_l : addr",
                    "c2_v0 : Z"
                ],
                "tactic_res": [
                    "c6_goal : eq (h l) (Some v0)",
                    "c7_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)",
                    "c7_L : eq (h l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (h l) (Some v0)",
                    "c2_U : eq h (hunion h1 h2)"
                ],
                "tactic_res": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c8_goal : eq (hunion h1 h2 l) (Some v0)"
                ],
                "tactic_res": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (if h1 l then h1 l else h2 l) (Some v0)",
                    "c4_L1 : eq (h1 l) (Some v0)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Some v0) (Some v0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Some v0) (Some v0)",
                    "c2_v0 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (FREE l) h (fun _ : Z => sepconj emp R)"
                ],
                "tactic_res": [
                    "c11_goal : True",
                    "c12_goal : immsafe (pair (FREE l) h)",
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (FREE l) h) (pair c' h')),\nsafe c' h' (fun _ : Z => sepconj emp R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : immsafe (pair (FREE l) h)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq (h l) None)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c14_goal : not (eq (h l) None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c13_goal : forall (c' : com) (h' : heap) (_ : red (pair (FREE l) h) (pair c' h')),\nsafe c' h' (fun _ : Z => sepconj emp R)"
                ],
                "tactic_res": [
                    "c15_goal : safe c' h' (fun _ : Z => sepconj emp R)",
                    "c15_c' : com",
                    "c15_h' : heap",
                    "c15_RED : red (pair (FREE l) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : safe c' h' (fun _ : Z => sepconj emp R)",
                    "c15_RED : red (pair (FREE l) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c16_goal : safe SKIP (hfree l (hunion h1 h2)) (fun _ : Z => sepconj emp R)",
                    "c16_H0 : not (eq (hunion h1 h2 l) None)",
                    "c16_L : eq (hunion h1 h2 l) (Some v0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : safe SKIP (hfree l (hunion h1 h2)) (fun _ : Z => sepconj emp R)"
                ],
                "tactic_res": [
                    "c17_goal : sepconj emp R (hfree l (hunion h1 h2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : sepconj emp R (hfree l (hunion h1 h2))",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c18_goal : R (hfree l (hunion h1 h2))"
                ]
            },
            {
                "tactic_sig": "replace ( hfree _i ( hunion _i _i ) ) with _i .",
                "tactic_sig_no_out_arg": "replace ( hfree _i ( hunion _i _i ) ) with _i .",
                "tactic_args": [
                    "c18_goal : R (hfree l (hunion h1 h2))",
                    "c2_l : addr",
                    "c2_h1 : heap",
                    "c2_h2 : heap",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c19_goal : R h2",
                    "c20_goal : eq h2 (hfree l (hunion h1 h2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : R h2",
                    "c2_H2 : R h2",
                    "c2_h2 : heap",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : eq h2 (hfree l (hunion h1 h2))",
                    "_global_heap_extensionality : forall (h1 h2 : heap) (_ : forall l : addr, eq (h1 l) (h2 l)),\n       eq h1 h2"
                ],
                "tactic_res": [
                    "c21_goal : forall l0 : addr, eq (h2 l0) (hfree l (hunion h1 h2) l0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c21_goal : forall l0 : addr, eq (h2 l0) (hfree l (hunion h1 h2) l0)"
                ],
                "tactic_res": [
                    "c22_goal : eq (h2 x) (hfree l (hunion h1 h2) x)",
                    "c22_x : addr"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) .",
                "tactic_args": [
                    "c22_goal : eq (h2 x) (hfree l (hunion h1 h2) x)",
                    "c2_D : hdisjoint h1 h2",
                    "c22_x : addr"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : or (eq (h1 x) None) (eq (h2 x) None),\neq (h2 x) (hfree l (hunion h1 h2) x)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c23_goal : forall _ : or (eq (h1 x) None) (eq (h2 x) None),\neq (h2 x) (hfree l (hunion h1 h2) x)",
                    "c2_H1 : contains l v0 h1"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : or (eq (hupdate l v0 hempty x) None) (eq (h2 x) None),\neq (h2 x) (hfree l (hunion (hupdate l v0 hempty) h2) x)"
                ]
            },
            {
                "tactic_sig": "cbn .",
                "tactic_sig_no_out_arg": "cbn .",
                "tactic_args": [
                    "c24_goal : forall _ : or (eq (hupdate l v0 hempty x) None) (eq (h2 x) None),\neq (h2 x) (hfree l (hunion (hupdate l v0 hempty) h2) x)"
                ],
                "tactic_res": [
                    "c25_goal : forall\n  _ : or (eq (if Z.eq_dec l x then Some v0 else None) None)\n        (eq (h2 x) None),\neq (h2 x)\n  (if Z.eq_dec l x\n   then None\n   else\n    if if Z.eq_dec l x then Some v0 else None\n    then if Z.eq_dec l x then Some v0 else None\n    else h2 x)"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eq_dec _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eq_dec _i _i ) .",
                "tactic_args": [
                    "c25_goal : forall\n  _ : or (eq (if Z.eq_dec l x then Some v0 else None) None)\n        (eq (h2 x) None),\neq (h2 x)\n  (if Z.eq_dec l x\n   then None\n   else\n    if if Z.eq_dec l x then Some v0 else None\n    then if Z.eq_dec l x then Some v0 else None\n    else h2 x)",
                    "c2_l : addr",
                    "c22_x : addr",
                    "c16_H0 : not (eq (hunion h1 h2 l) None)",
                    "c16_L : eq (hunion h1 h2 l) (Some v0)",
                    "c4_L1 : eq (h1 l) (Some v0)",
                    "c2_D : hdisjoint h1 h2",
                    "c2_H2 : R h2",
                    "c2_H1 : contains l v0 h1",
                    "c2_v0 : Z",
                    "c2_h2 : heap"
                ],
                "tactic_res": [
                    "c26_goal : forall _ : or (eq (Some v0) None) (eq (h2 x) None), eq (h2 x) None",
                    "c26_e : eq l x",
                    "c27_goal : forall _ : or (eq None None) (eq (h2 x) None), eq (h2 x) (h2 x)",
                    "c27_n : not (eq l x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : forall _ : or (eq None None) (eq (h2 x) None), eq (h2 x) (h2 x)",
                    "c22_x : addr",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c26_goal : forall _ : or (eq (Some v0) None) (eq (h2 x) None), eq (h2 x) None",
                    "c22_x : addr",
                    "c2_v0 : Z",
                    "c2_h2 : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_pure",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_pure : forall P v ( Q : postcond ) , P -->> Q v -> Hoare P ( PURE v ) Q .",
                "tactic_sig_no_out_arg": "Lemma Hoare_pure : forall P v ( Q : postcond ) , P -->> Q v -> Hoare P ( PURE v ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\nHoare P (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\nHoare P (PURE v) Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P (PURE v) Q",
                    "c2_P : assertion",
                    "c2_v : Z",
                    "c2_Q : postcond",
                    "c2_H : aimp P (Q v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h Ph .",
                "tactic_args": [
                    "c2_goal : Hoare P (PURE v) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe (PURE v) h Q",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (PURE v) h Q"
                ],
                "tactic_res": [
                    "c4_goal : Q v h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : Q v h",
                    "c2_H : aimp P (Q v)"
                ],
                "tactic_res": [
                    "c5_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pure",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pure : forall P v ( Q : postcond ) , P -->> Q v -> \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pure : forall P v ( Q : postcond ) , P -->> Q v -> \u2983 P \u2984 PURE v \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\ntriple P (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\ntriple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P (PURE v) Q",
                    "c2_P : assertion",
                    "c2_v : Z",
                    "c2_Q : postcond",
                    "c2_H : aimp P (Q v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros R .",
                "tactic_args": [
                    "c2_goal : triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (sepconj P R) (PURE v) (fun v : Z => sepconj (Q v) R)",
                    "c3_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Hoare (sepconj P R) (PURE v) (fun v : Z => sepconj (Q v) R)",
                    "_global_Hoare_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       Hoare P (PURE v) Q"
                ],
                "tactic_res": [
                    "c4_goal : aimp (sepconj P R) (sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : aimp (sepconj P R) (sepconj (Q v) R)",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c5_goal : aimp P (Q v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : aimp P (Q v)",
                    "c2_H : aimp P (Q v)",
                    "c2_Q : postcond",
                    "c2_v : Z",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_let",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_let : forall c f ( P : precond ) ( Q R : postcond ) , Hoare P c Q -> ( forall v , Hoare ( Q v ) ( f v ) R ) -> Hoare P ( LET c f ) R .",
                "tactic_sig_no_out_arg": "Lemma Hoare_let : forall c f ( P : precond ) ( Q R : postcond ) , Hoare P c Q -> ( forall v , Hoare ( Q v ) ( f v ) R ) -> Hoare P ( LET c f ) R .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : Hoare P c Q)\n  (_ : forall v : Z, Hoare (Q v) (f v) R), Hoare P (LET c f) R"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until R .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : Hoare P c Q)\n  (_ : forall v : Z, Hoare (Q v) (f v) R), Hoare P (LET c f) R"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : Hoare P c Q) (_ : forall v : Z, Hoare (Q v) (f v) R),\nHoare P (LET c f) R",
                    "c2_R : postcond",
                    "c2_Q : postcond",
                    "c2_P : precond",
                    "c2_f : forall _ : Z, com",
                    "c2_c : com"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros HR1 HR2 h Ph .",
                "tactic_args": [
                    "c2_goal : forall (_ : Hoare P c Q) (_ : forall v : Z, Hoare (Q v) (f v) R),\nHoare P (LET c f) R"
                ],
                "tactic_res": [
                    "c3_goal : safe (LET c f) h R",
                    "c3_HR1 : Hoare P c Q",
                    "c3_HR2 : forall v : Z, Hoare (Q v) (f v) R",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : safe (LET c f) h R",
                    "_global_safe_let : forall (Q R : postcond) (f : forall _ : Z, com)\n         (_ : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R)\n         (c : com) (h : heap) (_ : safe c h Q), safe (LET c f) h R",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c4_goal : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R",
                    "c5_goal : safe c h Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : forall (v : Z) (h' : heap) (_ : Q v h'), safe (f v) h' R",
                    "c3_HR2 : forall v : Z, Hoare (Q v) (f v) R"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : safe c h Q",
                    "c3_HR1 : Hoare P c Q"
                ],
                "tactic_res": [
                    "c6_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_let",
        "proof": [
            {
                "tactic_sig": "Lemma triple_let : forall c f ( P : precond ) ( Q R : postcond ) , \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_let : forall c f ( P : precond ) ( Q R : postcond ) , \u2983 P \u2984 c \u2983 Q \u2984 -> ( forall v , \u2983 Q v \u2984 f v \u2983 R \u2984 ) -> \u2983 P \u2984 LET c f \u2983 R \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : triple P c Q)\n  (_ : forall v : Z, triple (Q v) (f v) R), triple P (LET c f) R"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c f P Q R TR1 TR2 R' .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (P : precond) \n  (Q R : postcond) (_ : triple P c Q)\n  (_ : forall v : Z, triple (Q v) (f v) R), triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c2_goal : Hoare (sepconj P R') (LET c f) (fun v : Z => sepconj (R v) R')",
                    "c2_c : com",
                    "c2_f : forall _ : Z, com",
                    "c2_P : precond",
                    "c2_Q : postcond",
                    "c2_R : postcond",
                    "c2_TR1 : triple P c Q",
                    "c2_TR2 : forall v : Z, triple (Q v) (f v) R",
                    "c2_R' : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( fun v => _i v ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( fun v => _i v ** _i ) .",
                "tactic_args": [
                    "c2_goal : Hoare (sepconj P R') (LET c f) (fun v : Z => sepconj (R v) R')",
                    "_global_Hoare_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : Hoare P c Q)\n         (_ : forall v : Z, Hoare (Q v) (f v) R), \n       Hoare P (LET c f) R",
                    "c2_Q : postcond",
                    "c2_R' : assertion"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (sepconj P R') c (fun v : Z => sepconj (Q v) R')",
                    "c4_goal : forall v : Z,\nHoare (sepconj (Q v) R') (f v) (fun v0 : Z => sepconj (R v0) R')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : Hoare (sepconj P R') c (fun v : Z => sepconj (Q v) R')",
                    "c2_TR1 : triple P c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall v : Z,\nHoare (sepconj (Q v) R') (f v) (fun v0 : Z => sepconj (R v0) R')"
                ],
                "tactic_res": [
                    "c5_goal : Hoare (sepconj (Q v) R') (f v) (fun v : Z => sepconj (R v) R')",
                    "c5_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Hoare (sepconj (Q v) R') (f v) (fun v : Z => sepconj (R v) R')",
                    "c2_TR2 : forall v : Z, triple (Q v) (f v) R"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_ifthenelse : forall b c1 c2 P Q , Hoare ( ( b <> 0 ) //\\\\ P ) c1 Q -> Hoare ( ( b = 0 ) //\\\\ P ) c2 Q -> Hoare P ( IFTHENELSE b c1 c2 ) Q .",
                "tactic_sig_no_out_arg": "Lemma Hoare_ifthenelse : forall b c1 c2 P Q , Hoare ( ( b <> 0 ) //\\\\ P ) c1 Q -> Hoare ( ( b = 0 ) //\\\\ P ) c2 Q -> Hoare P ( IFTHENELSE b c1 c2 ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : Hoare (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : Hoare (pureconj (eq b 0) P) c2 Q),\nHoare P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until Q .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : Hoare (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : Hoare (pureconj (eq b 0) P) c2 Q),\nHoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : Hoare (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : Hoare (pureconj (eq b 0) P) c2 Q),\nHoare P (IFTHENELSE b c1 c2) Q",
                    "c2_Q : postcond",
                    "c2_P : assertion",
                    "c2_c2 : com",
                    "c2_c1 : com",
                    "c2_b : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros HR1 HR2 h Ph .",
                "tactic_args": [
                    "c2_goal : forall (_ : Hoare (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : Hoare (pureconj (eq b 0) P) c2 Q),\nHoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : safe (IFTHENELSE b c1 c2) h Q",
                    "c3_HR1 : Hoare (pureconj (not (eq b 0)) P) c1 Q",
                    "c3_HR2 : Hoare (pureconj (eq b 0) P) c2 Q",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : safe (IFTHENELSE b c1 c2) h Q"
                ],
                "tactic_res": [
                    "c4_goal : True",
                    "c5_goal : immsafe (pair (IFTHENELSE b c1 c2) h)",
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')), \nsafe c' h' Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : immsafe (pair (IFTHENELSE b c1 c2) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c6_goal : forall (c' : com) (h' : heap)\n  (_ : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')), \nsafe c' h' Q"
                ],
                "tactic_res": [
                    "c7_goal : safe c' h' Q",
                    "c7_c' : com",
                    "c7_h' : heap",
                    "c7_RED : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c7_goal : safe c' h' Q",
                    "c7_RED : red (pair (IFTHENELSE b c1 c2) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c8_goal : safe (if Z.eqb b 0 then c2 else c1) h' Q",
                    "c8_Ph : P h'"
                ]
            },
            {
                "tactic_sig": "destruct ( Z.eqb_spec _i 0 ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Z.eqb_spec _i 0 ) .",
                "tactic_args": [
                    "c8_goal : safe (if Z.eqb b 0 then c2 else c1) h' Q",
                    "c2_b : Z",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c3_HR2 : Hoare (pureconj (eq b 0) P) c2 Q",
                    "c3_HR1 : Hoare (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_Q : postcond",
                    "c2_c1 : com",
                    "c2_c2 : com"
                ],
                "tactic_res": [
                    "c9_goal : safe c2 h' Q",
                    "c9_e : eq b 0",
                    "c10_goal : safe c1 h' Q",
                    "c10_n : not (eq b 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : safe c2 h' Q",
                    "c3_HR2 : Hoare (pureconj (eq b 0) P) c2 Q"
                ],
                "tactic_res": [
                    "c11_goal : pureconj (eq b 0) P h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c11_goal : pureconj (eq b 0) P h'"
                ],
                "tactic_res": [
                    "c12_goal : eq b 0",
                    "c13_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq b 0",
                    "c9_e : eq b 0",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : P h'",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : safe c1 h' Q",
                    "c3_HR1 : Hoare (pureconj (not (eq b 0)) P) c1 Q"
                ],
                "tactic_res": [
                    "c14_goal : pureconj (not (eq b 0)) P h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c14_goal : pureconj (not (eq b 0)) P h'"
                ],
                "tactic_res": [
                    "c15_goal : not (eq b 0)",
                    "c16_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : not (eq b 0)",
                    "c10_n : not (eq b 0)",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : P h'",
                    "c8_Ph : P h'",
                    "c7_h' : heap",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ifthenelse : forall b c1 c2 P Q , \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ifthenelse : forall b c1 c2 P Q , \u2983 ( b <> 0 ) //\\\\ P \u2984 c1 \u2983 Q \u2984 -> \u2983 ( b = 0 ) //\\\\ P \u2984 c2 \u2983 Q \u2984 -> \u2983 P \u2984 IFTHENELSE b c1 c2 \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros b c1 c2 P Q TR1 TR2 R .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (P : assertion) (Q : postcond)\n  (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n  (_ : triple (pureconj (eq b 0) P) c2 Q),\ntriple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare (sepconj P R) (IFTHENELSE b c1 c2) (fun v : Z => sepconj (Q v) R)",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_P : assertion",
                    "c2_Q : postcond",
                    "c2_TR1 : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_TR2 : triple (pureconj (eq b 0) P) c2 Q",
                    "c2_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : Hoare (sepconj P R) (IFTHENELSE b c1 c2) (fun v : Z => sepconj (Q v) R)",
                    "_global_Hoare_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : Hoare (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : Hoare (pureconj (eq b 0) P) c2 Q),\n       Hoare P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (pureconj (not (eq b 0)) (sepconj P R)) c1\n  (fun v : Z => sepconj (Q v) R)",
                    "c4_goal : Hoare (pureconj (eq b 0) (sepconj P R)) c2\n  (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c3_goal : Hoare (pureconj (not (eq b 0)) (sepconj P R)) c1\n  (fun v : Z => sepconj (Q v) R)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c5_goal : Hoare (sepconj (pureconj (not (eq b 0)) P) R) c1\n  (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Hoare (sepconj (pureconj (not (eq b 0)) P) R) c1\n  (fun v : Z => sepconj (Q v) R)",
                    "c2_R : assertion",
                    "c2_TR1 : triple (pureconj (not (eq b 0)) P) c1 Q",
                    "c2_Q : postcond",
                    "c2_P : assertion",
                    "c2_c1 : com",
                    "c2_b : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : Hoare (pureconj (eq b 0) (sepconj P R)) c2\n  (fun v : Z => sepconj (Q v) R)",
                    "_global_lift_pureconj : forall (P : Prop) (Q R : assertion),\n       eq (sepconj (pureconj P Q) R) (pureconj P (sepconj Q R))"
                ],
                "tactic_res": [
                    "c6_goal : Hoare (sepconj (pureconj (eq b 0) P) R) c2\n  (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Hoare (sepconj (pureconj (eq b 0) P) R) c2\n  (fun v : Z => sepconj (Q v) R)",
                    "c2_R : assertion",
                    "c2_TR2 : triple (pureconj (eq b 0) P) c2 Q",
                    "c2_Q : postcond",
                    "c2_P : assertion",
                    "c2_c2 : com",
                    "c2_b : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_consequence : forall P P' c Q' Q , Hoare P' c Q' -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> Hoare P c Q .",
                "tactic_sig_no_out_arg": "Lemma Hoare_consequence : forall P P' c Q' Q , Hoare P' c Q' -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> Hoare P c Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : Hoare P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \nHoare P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : Hoare P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \nHoare P c Q"
                ],
                "tactic_res": [
                    "c2_goal : Hoare P c Q",
                    "c2_P : assertion",
                    "c2_P' : precond",
                    "c2_c : com",
                    "c2_Q' : postcond",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_H : Hoare P' c Q'",
                    "c2_H0 : aimp P P'",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : Hoare P c Q"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap) (_ : P h), safe c h Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap) (_ : P h), safe c h Q"
                ],
                "tactic_res": [
                    "c4_goal : safe c h Q",
                    "c4_h : heap",
                    "c4_H2 : P h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c4_goal : safe c h Q",
                    "_global_safe_consequence : forall (Q Q' : postcond) (_ : forall v : Z, aimp (Q v) (Q' v))\n         (c : com) (h : heap) (_ : safe c h Q), safe c h Q'",
                    "c2_Q' : postcond"
                ],
                "tactic_res": [
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c6_goal : safe c h Q'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : safe c h Q'",
                    "c4_H2 : P h",
                    "c4_h : heap",
                    "c2_H0 : aimp P P'",
                    "c2_H : Hoare P' c Q'",
                    "c2_Q' : postcond",
                    "c2_c : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma triple_consequence : forall P P' c Q' Q , \u2983 P' \u2984 c \u2983 Q' \u2984 -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_consequence : forall P P' c Q' Q , \u2983 P' \u2984 c \u2983 Q' \u2984 -> P -->> P' -> ( forall v , Q' v -->> Q v ) -> \u2983 P \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : triple P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \ntriple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : assertion) (P' : precond) (c : com) (Q' : postcond)\n  (Q : forall _ : Z, assertion) (_ : triple P' c Q') \n  (_ : aimp P P') (_ : forall v : Z, aimp (Q' v) (Q v)), \ntriple P c Q"
                ],
                "tactic_res": [
                    "c2_goal : triple P c Q",
                    "c2_P : assertion",
                    "c2_P' : precond",
                    "c2_c : com",
                    "c2_Q' : postcond",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_H : triple P' c Q'",
                    "c2_H0 : aimp P P'",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : triple P c Q"
                ],
                "tactic_res": [
                    "c3_goal : forall R : assertion,\nHoare (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall R : assertion,\nHoare (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c4_goal : Hoare (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "c4_R : assertion"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ** _i ) ( fun v => _i v ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ** _i ) ( fun v => _i v ** _i ) .",
                "tactic_args": [
                    "c4_goal : Hoare (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global_Hoare_consequence : forall (P : assertion) (P' : precond) (c : com) \n         (Q' : postcond) (Q : forall _ : Z, assertion) \n         (_ : Hoare P' c Q') (_ : aimp P P')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), Hoare P c Q",
                    "c2_P' : precond",
                    "c4_R : assertion",
                    "c2_Q' : postcond",
                    "c4_R : assertion"
                ],
                "tactic_res": [
                    "c5_goal : Hoare (sepconj P' R) c (fun v : Z => sepconj (Q' v) R)",
                    "c6_goal : aimp (sepconj P R) (sepconj P' R)",
                    "c7_goal : forall v : Z, aimp (sepconj (Q' v) R) (sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Hoare (sepconj P' R) c (fun v : Z => sepconj (Q' v) R)",
                    "c2_H : triple P' c Q'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : aimp (sepconj P R) (sepconj P' R)",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c8_goal : aimp P P'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : aimp P P'",
                    "c2_H0 : aimp P P'",
                    "c2_P' : precond",
                    "c2_P : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall v : Z, aimp (sepconj (Q' v) R) (sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp (sepconj (Q' v) R) (sepconj (Q v) R)",
                    "c9_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : aimp (sepconj (Q' v) R) (sepconj (Q v) R)",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c10_goal : aimp (Q' v) (Q v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : aimp (Q' v) (Q v)",
                    "c9_v : Z",
                    "c2_H1 : forall v : Z, aimp (Q' v) (Q v)",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Hoare_pick",
        "proof": [
            {
                "tactic_sig": "Lemma Hoare_pick : forall P n , Hoare P ( PICK n ) ( fun i => ( 0 <= i < n ) //\\\\ P ) .",
                "tactic_sig_no_out_arg": "Lemma Hoare_pick : forall P n , Hoare P ( PICK n ) ( fun i => ( 0 <= i < n ) //\\\\ P ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (n : Z),\nHoare P (PICK n) (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P n h Ph .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (n : Z),\nHoare P (PICK n) (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ],
                "tactic_res": [
                    "c2_goal : safe (PICK n) h (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)",
                    "c2_P : precond",
                    "c2_n : Z",
                    "c2_h : heap",
                    "c2_Ph : P h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : safe (PICK n) h (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ],
                "tactic_res": [
                    "c3_goal : True",
                    "c4_goal : immsafe (pair (PICK n) h)",
                    "c5_goal : forall (c' : com) (h' : heap) (_ : red (pair (PICK n) h) (pair c' h')),\nsafe c' h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : immsafe (pair (PICK n) h)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c' h' RED .",
                "tactic_args": [
                    "c5_goal : forall (c' : com) (h' : heap) (_ : red (pair (PICK n) h) (pair c' h')),\nsafe c' h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ],
                "tactic_res": [
                    "c6_goal : safe c' h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)",
                    "c6_c' : com",
                    "c6_h' : heap",
                    "c6_RED : red (pair (PICK n) h) (pair c' h')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : safe c' h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)",
                    "c6_RED : red (pair (PICK n) h) (pair c' h')"
                ],
                "tactic_res": [
                    "c7_goal : safe (PURE i) h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)",
                    "c7_H0 : and (Z.le 0 i) (Z.lt i n)",
                    "c7_i : Z",
                    "c7_Ph : P h'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : safe (PURE i) h' (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ],
                "tactic_res": [
                    "c8_goal : pureconj (and (Z.le 0 i) (Z.lt i n)) P h'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : pureconj (and (Z.le 0 i) (Z.lt i n)) P h'"
                ],
                "tactic_res": [
                    "c9_goal : and (Z.le 0 i) (Z.lt i n)",
                    "c10_goal : P h'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 i) (Z.lt i n)",
                    "c7_H0 : and (Z.le 0 i) (Z.lt i n)",
                    "c7_i : Z",
                    "c2_n : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : P h'",
                    "c7_Ph : P h'",
                    "c6_h' : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_pick",
        "proof": [
            {
                "tactic_sig": "Lemma triple_pick : forall n , \u2983 emp \u2984 PICK n \u2983 fun i => pure ( 0 <= i < n ) \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_pick : forall n , \u2983 emp \u2984 PICK n \u2983 fun i => pure ( 0 <= i < n ) \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall n : Z,\ntriple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall n : Z,\ntriple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c2_goal : triple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "c2_n : Z"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros R .",
                "tactic_args": [
                    "c2_goal : triple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": [
                    "c3_goal : Hoare (sepconj emp R) (PICK n)\n  (fun v : Z => sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)",
                    "c3_R : assertion"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c3_goal : Hoare (sepconj emp R) (PICK n)\n  (fun v : Z => sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c4_goal : Hoare R (PICK n)\n  (fun v : Z => sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( P' := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( P' := _i ) .",
                "tactic_args": [
                    "c4_goal : Hoare R (PICK n)\n  (fun v : Z => sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)",
                    "_global_Hoare_consequence : forall (P : assertion) (P' : precond) (c : com) \n         (Q' : postcond) (Q : forall _ : Z, assertion) \n         (_ : Hoare P' c Q') (_ : aimp P P')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), Hoare P c Q",
                    "c3_R : assertion"
                ],
                "tactic_res": [
                    "c5_goal : Hoare R (PICK n) ?Q'",
                    "c6_goal : aimp R R",
                    "c7_goal : forall v : Z,\naimp ((fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) R) v)\n  (sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Hoare R (PICK n) ?Q'",
                    "_global_Hoare_pick : forall (P : precond) (n : Z),\n       Hoare P (PICK n) (fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) P)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : aimp R R"
                ],
                "tactic_res": [
                    "c8_goal : forall (h : heap) (_ : R h), R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : forall (h : heap) (_ : R h), R h",
                    "c3_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall v : Z,\naimp ((fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) R) v)\n  (sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp ((fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) R) v)\n  (sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)",
                    "c9_v : Z"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c9_goal : aimp ((fun i : Z => pureconj (and (Z.le 0 i) (Z.lt i n)) R) v)\n  (sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R)"
                ],
                "tactic_res": [
                    "c10_goal : forall (h : heap) (_ : pureconj (and (Z.le 0 v) (Z.lt v n)) R h),\nsepconj (pure (and (Z.le 0 v) (Z.lt v n))) R h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (h : heap) (_ : pureconj (and (Z.le 0 v) (Z.lt v n)) R h),\nsepconj (pure (and (Z.le 0 v) (Z.lt v n))) R h"
                ],
                "tactic_res": [
                    "c11_goal : sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R h",
                    "c11_h : heap",
                    "c11_H : pureconj (and (Z.le 0 v) (Z.lt v n)) R h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : sepconj (pure (and (Z.le 0 v) (Z.lt v n))) R h",
                    "_global_pureconj_sepconj : forall (P : Prop) (Q : assertion),\n       eq (sepconj (pure P) Q) (pureconj P Q)"
                ],
                "tactic_res": [
                    "c12_goal : pureconj (and (Z.le 0 v) (Z.lt v n)) R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : pureconj (and (Z.le 0 v) (Z.lt v n)) R h",
                    "c11_H : pureconj (and (Z.le 0 v) (Z.lt v n)) R h",
                    "c11_h : heap",
                    "c9_v : Z",
                    "c3_R : assertion",
                    "c2_n : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_frame_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma triple_frame_consequence : forall R P c Q P' Q' , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P ** R -> ( forall v , Q v ** R -->> Q' v ) -> \u2983 P' \u2984 c \u2983 Q' \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_frame_consequence : forall R P c Q P' Q' , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P ** R -> ( forall v , Q v ** R -->> Q' v ) -> \u2983 P' \u2984 c \u2983 Q' \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (P : precond) (c : com) (Q : postcond)\n  (P' : assertion) (Q' : forall _ : Z, assertion) \n  (_ : triple P c Q) (_ : aimp P' (sepconj P R))\n  (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)), \ntriple P' c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (P : precond) (c : com) (Q : postcond)\n  (P' : assertion) (Q' : forall _ : Z, assertion) \n  (_ : triple P c Q) (_ : aimp P' (sepconj P R))\n  (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)), \ntriple P' c Q'"
                ],
                "tactic_res": [
                    "c2_goal : triple P' c Q'",
                    "c2_R : assertion",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_P' : assertion",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_H : triple P c Q",
                    "c2_H0 : aimp P' (sepconj P R)",
                    "c2_H1 : forall v : Z, aimp (sepconj (Q v) R) (Q' v)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i ** _i ) ( fun v => _i v ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i ** _i ) ( fun v => _i v ** _i ) .",
                "tactic_args": [
                    "c2_goal : triple P' c Q'",
                    "_global_triple_consequence : forall (P : assertion) (P' : precond) (c : com) \n         (Q' : postcond) (Q : forall _ : Z, assertion) \n         (_ : triple P' c Q') (_ : aimp P P')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q",
                    "c2_P : precond",
                    "c2_R : assertion",
                    "c2_Q : postcond",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "c4_goal : aimp P' (sepconj P R)",
                    "c5_goal : forall v : Z, aimp (sepconj (Q v) R) (Q' v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : aimp P' (sepconj P R)",
                    "c2_H0 : aimp P' (sepconj P R)",
                    "c2_P' : assertion",
                    "c2_P : precond",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (sepconj (Q v) R) (Q' v)",
                    "c2_H1 : forall v : Z, aimp (sepconj (Q v) R) (Q' v)",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_Q : postcond",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c6_goal : triple P c Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : triple P c Q",
                    "c2_H : triple P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "triple_ramification",
        "proof": [
            {
                "tactic_sig": "Lemma triple_ramification : forall P c Q P' Q' , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P ** ( aforall ( fun v => Q v --* Q' v ) ) -> \u2983 P' \u2984 c \u2983 Q' \u2984 .",
                "tactic_sig_no_out_arg": "Lemma triple_ramification : forall P c Q P' Q' , \u2983 P \u2984 c \u2983 Q \u2984 -> P' -->> P ** ( aforall ( fun v => Q v --* Q' v ) ) -> \u2983 P' \u2984 c \u2983 Q' \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (P' : assertion)\n  (Q' : forall _ : Z, assertion) (_ : triple P c Q)\n  (_ : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))),\ntriple P' c Q'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (P' : assertion)\n  (Q' : forall _ : Z, assertion) (_ : triple P c Q)\n  (_ : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))),\ntriple P' c Q'"
                ],
                "tactic_res": [
                    "c2_goal : triple P' c Q'",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_P' : assertion",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_H : triple P c Q",
                    "c2_H0 : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( R := _i ( fun v => _i v --* _i v ) ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( R := _i ( fun v => _i v --* _i v ) ) .",
                "tactic_args": [
                    "c2_goal : triple P' c Q'",
                    "_global_triple_frame_consequence : forall (R : assertion) (P : precond) (c : com) \n         (Q : postcond) (P' : assertion) (Q' : forall _ : Z, assertion)\n         (_ : triple P c Q) (_ : aimp P' (sepconj P R))\n         (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)), \n       triple P' c Q'",
                    "_global_aforall : forall _ : forall _ : ?A, assertion, assertion\nwhere\n?A : [P : precond\n      c : com\n      Q : postcond\n      P' : assertion\n      Q' : forall _ : Z, assertion\n      H : triple P c Q\n      H0 : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))\n     |- Type]",
                    "c2_Q : postcond",
                    "c2_Q' : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c3_goal : triple ?P c ?Q",
                    "c4_goal : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))",
                    "c5_goal : forall v : Z,\naimp (sepconj (Q v) (aforall (fun v0 : Z => wand (Q v0) (Q' v0))))\n  (Q' v)"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "c3_goal : triple ?P c ?Q",
                    "c2_H : triple P c Q",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c4_goal : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))",
                    "c2_H0 : aimp P' (sepconj P (aforall (fun v : Z => wand (Q v) (Q' v))))",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_P' : assertion",
                    "c2_Q : postcond",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros v h ( h1 & h2 & Q1 & W2 & D & U ) .",
                "tactic_args": [
                    "c5_goal : forall v : Z,\naimp (sepconj (Q v) (aforall (fun v0 : Z => wand (Q v0) (Q' v0))))\n  (Q' v)"
                ],
                "tactic_res": [
                    "c6_goal : Q' v h",
                    "c6_v : Z",
                    "c6_h : heap",
                    "c6_h1 : heap",
                    "c6_h2 : heap",
                    "c6_Q1 : Q v h1",
                    "c6_W2 : aforall (fun v : Z => wand (Q v) (Q' v)) h2",
                    "c6_D : hdisjoint h1 h2",
                    "c6_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c6_goal : Q' v h",
                    "_global_wand_cancel : forall P Q : assertion, aimp (sepconj P (wand P Q)) Q",
                    "c2_Q : postcond",
                    "c6_v : Z"
                ],
                "tactic_res": [
                    "c7_goal : sepconj (Q v) (wand (Q v) (Q' v)) h"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c7_goal : sepconj (Q v) (wand (Q v) (Q' v)) h",
                    "c6_h1 : heap",
                    "c6_h2 : heap"
                ],
                "tactic_res": [
                    "c8_goal : and (Q v h1)\n  (and (wand (Q v) (Q' v) h2)\n     (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : and (Q v h1)\n  (and (wand (Q v) (Q' v) h2)\n     (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c6_U : eq h (hunion h1 h2)",
                    "c6_D : hdisjoint h1 h2",
                    "c6_W2 : aforall (fun v : Z => wand (Q v) (Q' v)) h2",
                    "c6_Q1 : Q v h1",
                    "c6_h : heap",
                    "c6_h1 : heap",
                    "c6_h2 : heap",
                    "c6_v : Z",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_precond",
        "proof": [
            {
                "tactic_sig": "Lemma wp_precond : forall c Q , \u2983 wp c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma wp_precond : forall c Q , \u2983 wp c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros c Q h ( P & T & C ) .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": [
                    "c2_goal : safe c h Q",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_P : precond",
                    "c2_T : triple P c Q",
                    "c2_C : P h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe c h Q",
                    "c2_T : triple P c Q"
                ],
                "tactic_res": [
                    "c3_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : P h",
                    "c2_C : P h",
                    "c2_P : precond",
                    "c2_h : heap"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_weakest",
        "proof": [
            {
                "tactic_sig": "Lemma wp_weakest : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> P -->> wp c Q .",
                "tactic_sig_no_out_arg": "Lemma wp_weakest : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> P -->> wp c Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\naimp P (wp c Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P c Q T h Ph .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\naimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c2_goal : wp c Q h",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_T : triple P c Q",
                    "c2_h : heap",
                    "c2_Ph : P h"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c2_goal : wp c Q h",
                    "c2_P : precond"
                ],
                "tactic_res": [
                    "c3_goal : pureconj (triple P c Q) P h"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : pureconj (triple P c Q) P h"
                ],
                "tactic_res": [
                    "c4_goal : triple P c Q",
                    "c5_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : triple P c Q",
                    "c2_T : triple P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P h",
                    "c2_Ph : P h",
                    "c2_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_equiv",
        "proof": [
            {
                "tactic_sig": "Corollary wp_equiv : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 <- > ( P -->> wp c Q ) .",
                "tactic_sig_no_out_arg": "Corollary wp_equiv : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 <- > ( P -->> wp c Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond),\niff (triple P c Q) (aimp P (wp c Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond),\niff (triple P c Q) (aimp P (wp c Q))"
                ],
                "tactic_res": [
                    "c2_goal : iff (triple P c Q) (aimp P (wp c Q))",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : iff (triple P c Q) (aimp P (wp c Q))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : triple P c Q, aimp P (wp c Q)",
                    "c4_goal : forall _ : aimp P (wp c Q), triple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall _ : triple P c Q, aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : aimp P (wp c Q)",
                    "c5_H : triple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : aimp P (wp c Q), triple P c Q"
                ],
                "tactic_res": [
                    "c6_goal : triple P c Q",
                    "c6_H : aimp P (wp c Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : aimp P (wp c Q)",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c7_goal : triple P c Q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : triple P c Q",
                    "c5_H : triple P c Q",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c6_goal : triple P c Q",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q",
                    "_global_wp : forall (_ : com) (_ : postcond), precond",
                    "c2_c : com",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c8_goal : triple (wp c Q) c Q",
                    "c9_goal : aimp P (wp c Q)"
                ]
            },
            {
                "tactic_sig": "auto using wp_precond .",
                "tactic_sig_no_out_arg": "auto using wp_precond .",
                "tactic_args": [
                    "c8_goal : triple (wp c Q) c Q",
                    "c2_Q : postcond",
                    "c2_c : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using wp_precond .",
                "tactic_sig_no_out_arg": "auto using wp_precond .",
                "tactic_args": [
                    "c9_goal : aimp P (wp c Q)",
                    "c6_H : aimp P (wp c Q)",
                    "c2_Q : postcond",
                    "c2_c : com",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_precond",
        "proof": [
            {
                "tactic_sig": "Lemma wp'_precond : forall c Q , \u2983 wp' c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_sig_no_out_arg": "Lemma wp'_precond : forall c Q , \u2983 wp' c Q \u2984 c \u2983 Q \u2984 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (Q : postcond), triple (wp' c Q) c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros c Q h SAFE .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (Q : postcond), triple (wp' c Q) c Q"
                ],
                "tactic_res": [
                    "c2_goal : safe c h Q",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_h : heap",
                    "c2_SAFE : wp' c Q h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : safe c h Q",
                    "c2_SAFE : wp' c Q h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_weakest",
        "proof": [
            {
                "tactic_sig": "Lemma wp'_weakest : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> P -->> wp' c Q .",
                "tactic_sig_no_out_arg": "Lemma wp'_weakest : forall P c Q , \u2983 P \u2984 c \u2983 Q \u2984 -> P -->> wp' c Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\naimp P (wp' c Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\naimp P (wp' c Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp P (wp' c Q)",
                    "c2_P : precond",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_H : triple P c Q"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros h Ph .",
                "tactic_args": [
                    "c2_goal : aimp P (wp' c Q)"
                ],
                "tactic_res": [
                    "c3_goal : wp' c Q h",
                    "c3_h : heap",
                    "c3_Ph : P h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp' c Q h",
                    "c2_H : triple P c Q"
                ],
                "tactic_res": [
                    "c4_goal : P h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : P h",
                    "c3_Ph : P h",
                    "c3_h : heap",
                    "c2_P : precond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_consequence",
        "proof": [
            {
                "tactic_sig": "Lemma wp_consequence : forall ( Q Q' : postcond ) c , ( forall v , Q v -->> Q' v ) -> wp c Q -->> wp c Q' .",
                "tactic_sig_no_out_arg": "Lemma wp_consequence : forall ( Q Q' : postcond ) c , ( forall v , Q v -->> Q' v ) -> wp c Q -->> wp c Q' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q Q' : postcond) (c : com)\n  (_ : forall v : Z, aimp (Q v) (Q' v)), aimp (wp c Q) (wp c Q')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q Q' : postcond) (c : com)\n  (_ : forall v : Z, aimp (Q v) (Q' v)), aimp (wp c Q) (wp c Q')"
                ],
                "tactic_res": [
                    "c2_goal : aimp (wp c Q) (wp c Q')",
                    "c2_Q : postcond",
                    "c2_Q' : postcond",
                    "c2_c : com",
                    "c2_H : forall v : Z, aimp (Q v) (Q' v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (wp c Q) (wp c Q')",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c3_goal : triple (wp c Q) c Q'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c3_goal : triple (wp c Q) c Q'",
                    "_global_triple_consequence_post : forall (P : precond) (c : com) (Q : forall _ : Z, assertion)\n         (Q' : postcond) (_ : triple P c Q')\n         (_ : forall v : Z, aimp (Q' v) (Q v)), triple P c Q",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c4_goal : triple (wp c Q) c Q",
                    "c5_goal : forall v : Z, aimp (Q v) (Q' v)"
                ]
            },
            {
                "tactic_sig": "auto using wp_precond .",
                "tactic_sig_no_out_arg": "auto using wp_precond .",
                "tactic_args": [
                    "c4_goal : triple (wp c Q) c Q",
                    "c2_c : com",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using wp_precond .",
                "tactic_sig_no_out_arg": "auto using wp_precond .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (Q v) (Q' v)",
                    "c2_H : forall v : Z, aimp (Q v) (Q' v)",
                    "c2_Q : postcond",
                    "c2_Q' : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_frame",
        "proof": [
            {
                "tactic_sig": "Lemma wp_frame : forall R c Q , wp c Q ** R -->> wp c ( fun v => Q v ** R ) .",
                "tactic_sig_no_out_arg": "Lemma wp_frame : forall R c Q , wp c Q ** R -->> wp c ( fun v => Q v ** R ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (c : com) (Q : postcond),\naimp (sepconj (wp c Q) R) (wp c (fun v : Z => sepconj (Q v) R))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (c : com) (Q : postcond),\naimp (sepconj (wp c Q) R) (wp c (fun v : Z => sepconj (Q v) R))"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (wp c Q) R) (wp c (fun v : Z => sepconj (Q v) R))",
                    "c2_R : assertion",
                    "c2_c : com",
                    "c2_Q : postcond"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (wp c Q) R) (wp c (fun v : Z => sepconj (Q v) R))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c3_goal : triple (sepconj (wp c Q) R) c (fun v : Z => sepconj (Q v) R)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (sepconj (wp c Q) R) c (fun v : Z => sepconj (Q v) R)",
                    "_global_triple_frame : forall (P : precond) (c : com) (Q : postcond) \n         (R : assertion) (_ : triple P c Q),\n       triple (sepconj P R) c (fun v : Z => sepconj (Q v) R)"
                ],
                "tactic_res": [
                    "c4_goal : triple (wp c Q) c Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple (wp c Q) c Q",
                    "_global_wp_precond : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_frame_consequence",
        "proof": [
            {
                "tactic_sig": "Corollary wp_frame_consequence : forall R Q c Q' , ( forall v , Q v ** R -->> Q' v ) -> wp c Q ** R -->> wp c Q' .",
                "tactic_sig_no_out_arg": "Corollary wp_frame_consequence : forall R Q c Q' , ( forall v , Q v ** R -->> Q' v ) -> wp c Q ** R -->> wp c Q' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (R : assertion) (Q : forall _ : Z, assertion) \n  (c : com) (Q' : forall _ : Z, assertion)\n  (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)),\naimp (sepconj (wp c Q) R) (wp c Q')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (R : assertion) (Q : forall _ : Z, assertion) \n  (c : com) (Q' : forall _ : Z, assertion)\n  (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)),\naimp (sepconj (wp c Q) R) (wp c Q')"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (wp c Q) R) (wp c Q')",
                    "c2_R : assertion",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_c : com",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_H : forall v : Z, aimp (sepconj (Q v) R) (Q' v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (wp c Q) R) (wp c Q')"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap) (_ : sepconj (wp c Q) R h), wp c Q' h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap) (_ : sepconj (wp c Q) R h), wp c Q' h"
                ],
                "tactic_res": [
                    "c4_goal : wp c Q' h",
                    "c4_h : heap",
                    "c4_H0 : sepconj (wp c Q) R h"
                ]
            },
            {
                "tactic_sig": "apply _i with ( fun v => _i v ** _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( fun v => _i v ** _i ) .",
                "tactic_args": [
                    "c4_goal : wp c Q' h",
                    "_global_wp_consequence : forall (Q Q' : postcond) (c : com)\n         (_ : forall v : Z, aimp (Q v) (Q' v)), aimp (wp c Q) (wp c Q')",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": [
                    "c5_goal : forall v : Z, aimp (sepconj (Q v) R) (Q' v)",
                    "c6_goal : wp c (fun v : Z => sepconj (Q v) R) h"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c5_goal : forall v : Z, aimp (sepconj (Q v) R) (Q' v)",
                    "c2_H : forall v : Z, aimp (sepconj (Q v) R) (Q' v)",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : wp c (fun v : Z => sepconj (Q v) R) h",
                    "_global_wp_frame : forall (R : assertion) (c : com) (Q : postcond),\n       aimp (sepconj (wp c Q) R) (wp c (fun v : Z => sepconj (Q v) R))"
                ],
                "tactic_res": [
                    "c7_goal : sepconj (wp c Q) R h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : sepconj (wp c Q) R h",
                    "c4_H0 : sepconj (wp c Q) R h",
                    "c4_h : heap",
                    "c2_c : com",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_R : assertion"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_ramification",
        "proof": [
            {
                "tactic_sig": "Corollary wp_ramification : forall c Q Q' , wp c Q ** aforall ( fun v => Q v --* Q' v ) -->> wp c Q' .",
                "tactic_sig_no_out_arg": "Corollary wp_ramification : forall c Q Q' , wp c Q ** aforall ( fun v => Q v --* Q' v ) -->> wp c Q' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\naimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n  (wp c Q')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\naimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n  (wp c Q')"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n  (wp c Q')",
                    "c2_c : com",
                    "c2_Q : postcond",
                    "c2_Q' : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n  (wp c Q')",
                    "_global_wp_frame_consequence : forall (R : assertion) (Q : forall _ : Z, assertion) \n         (c : com) (Q' : forall _ : Z, assertion)\n         (_ : forall v : Z, aimp (sepconj (Q v) R) (Q' v)),\n       aimp (sepconj (wp c Q) R) (wp c Q')"
                ],
                "tactic_res": [
                    "c3_goal : forall v : Z,\naimp (sepconj (Q v) (aforall (fun v0 : Z => wand (Q v0) (Q' v0))))\n  (Q' v)"
                ]
            },
            {
                "tactic_sig": "intros _o _o ( _o & _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros v h ( h1 & h2 & A & B & D & U ) .",
                "tactic_args": [
                    "c3_goal : forall v : Z,\naimp (sepconj (Q v) (aforall (fun v0 : Z => wand (Q v0) (Q' v0))))\n  (Q' v)"
                ],
                "tactic_res": [
                    "c4_goal : Q' v h",
                    "c4_v : Z",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_A : Q v h1",
                    "c4_B : aforall (fun v : Z => wand (Q v) (Q' v)) h2",
                    "c4_D : hdisjoint h1 h2",
                    "c4_U : eq h (hunion h1 h2)"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i _i ) ) .",
                "tactic_args": [
                    "c4_goal : Q' v h",
                    "_global_wand_cancel : forall P Q : assertion, aimp (sepconj P (wand P Q)) Q",
                    "c2_Q : postcond",
                    "c4_v : Z"
                ],
                "tactic_res": [
                    "c5_goal : sepconj (Q v) (wand (Q v) (Q' v)) h"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c5_goal : sepconj (Q v) (wand (Q v) (Q' v)) h",
                    "c4_h1 : heap",
                    "c4_h2 : heap"
                ],
                "tactic_res": [
                    "c6_goal : and (Q v h1)\n  (and (wand (Q v) (Q' v) h2)\n     (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : and (Q v h1)\n  (and (wand (Q v) (Q' v) h2)\n     (and (hdisjoint h1 h2) (eq h (hunion h1 h2))))",
                    "c4_U : eq h (hunion h1 h2)",
                    "c4_D : hdisjoint h1 h2",
                    "c4_B : aforall (fun v : Z => wand (Q v) (Q' v)) h2",
                    "c4_A : Q v h1",
                    "c4_h : heap",
                    "c4_h1 : heap",
                    "c4_h2 : heap",
                    "c4_v : Z",
                    "c2_Q' : forall _ : Z, assertion",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_pure",
        "proof": [
            {
                "tactic_sig": "Lemma wp_pure : forall ( Q : postcond ) v , Q v -->> wp ( PURE v ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_pure : forall ( Q : postcond ) v , Q v -->> wp ( PURE v ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (Q : postcond) (v : Z), aimp (Q v) (wp (PURE v) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (Q : postcond) (v : Z), aimp (Q v) (wp (PURE v) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (Q v) (wp (PURE v) Q)",
                    "c2_Q : postcond",
                    "c2_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (Q v) (wp (PURE v) Q)",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c3_goal : triple (Q v) (PURE v) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (Q v) (PURE v) Q",
                    "_global_triple_pure : forall (P : assertion) (v : Z) (Q : postcond) (_ : aimp P (Q v)),\n       triple P (PURE v) Q"
                ],
                "tactic_res": [
                    "c4_goal : aimp (Q v) (Q v)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp (Q v) (Q v)"
                ],
                "tactic_res": [
                    "c5_goal : forall (h : heap) (_ : Q v h), Q v h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (h : heap) (_ : Q v h), Q v h",
                    "c2_v : Z",
                    "c2_Q : postcond"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_let",
        "proof": [
            {
                "tactic_sig": "Lemma wp_let : forall c f Q , wp c ( fun v => wp ( f v ) Q ) -->> wp ( LET c f ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_let : forall c f Q , wp c ( fun v => wp ( f v ) Q ) -->> wp ( LET c f ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (Q : postcond),\naimp (wp c (fun v : Z => wp (f v) Q)) (wp (LET c f) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (c : com) (f : forall _ : Z, com) (Q : postcond),\naimp (wp c (fun v : Z => wp (f v) Q)) (wp (LET c f) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (wp c (fun v : Z => wp (f v) Q)) (wp (LET c f) Q)",
                    "c2_c : com",
                    "c2_f : forall _ : Z, com",
                    "c2_Q : postcond"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (wp c (fun v : Z => wp (f v) Q)) (wp (LET c f) Q)",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c3_goal : triple (wp c (fun v : Z => wp (f v) Q)) (LET c f) Q"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c3_goal : triple (wp c (fun v : Z => wp (f v) Q)) (LET c f) Q",
                    "_global_triple_let : forall (c : com) (f : forall _ : Z, com) (P : precond)\n         (Q R : postcond) (_ : triple P c Q)\n         (_ : forall v : Z, triple (Q v) (f v) R), \n       triple P (LET c f) R"
                ],
                "tactic_res": [
                    "c4_goal : triple (wp c (fun v : Z => wp (f v) Q)) c ?Q",
                    "c5_goal : forall v : Z, triple ((fun v0 : Z => wp (f v0) Q) v) (f v) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : triple (wp c (fun v : Z => wp (f v) Q)) c ?Q",
                    "_global_wp_precond : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall v : Z, triple ((fun v0 : Z => wp (f v0) Q) v) (f v) Q"
                ],
                "tactic_res": [
                    "c6_goal : triple ((fun v : Z => wp (f v) Q) v) (f v) Q",
                    "c6_v : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple ((fun v : Z => wp (f v) Q) v) (f v) Q",
                    "_global_wp_precond : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_ifthenelse",
        "proof": [
            {
                "tactic_sig": "Lemma wp_ifthenelse : forall b c1 c2 Q , ( if b =? 0 then wp c2 Q else wp c1 Q ) -->> wp ( IFTHENELSE b c1 c2 ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_ifthenelse : forall b c1 c2 Q , ( if b =? 0 then wp c2 Q else wp c1 Q ) -->> wp ( IFTHENELSE b c1 c2 ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (Q : postcond),\naimp (if Z.eqb b 0 then wp c2 Q else wp c1 Q)\n  (wp (IFTHENELSE b c1 c2) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : Z) (c1 c2 : com) (Q : postcond),\naimp (if Z.eqb b 0 then wp c2 Q else wp c1 Q)\n  (wp (IFTHENELSE b c1 c2) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (if Z.eqb b 0 then wp c2 Q else wp c1 Q)\n  (wp (IFTHENELSE b c1 c2) Q)",
                    "c2_b : Z",
                    "c2_c1 : com",
                    "c2_c2 : com",
                    "c2_Q : postcond"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : aimp (if Z.eqb b 0 then wp c2 Q else wp c1 Q)\n  (wp (IFTHENELSE b c1 c2) Q)",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c3_goal : triple (if Z.eqb b 0 then wp c2 Q else wp c1 Q) (IFTHENELSE b c1 c2) Q"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : triple (if Z.eqb b 0 then wp c2 Q else wp c1 Q) (IFTHENELSE b c1 c2) Q",
                    "_global_triple_ifthenelse : forall (b : Z) (c1 c2 : com) (P : assertion) \n         (Q : postcond) (_ : triple (pureconj (not (eq b 0)) P) c1 Q)\n         (_ : triple (pureconj (eq b 0) P) c2 Q),\n       triple P (IFTHENELSE b c1 c2) Q"
                ],
                "tactic_res": [
                    "c4_goal : triple\n  (pureconj (not (eq b 0)) (if Z.eqb b 0 then wp c2 Q else wp c1 Q)) c1\n  Q",
                    "c5_goal : triple (pureconj (eq b 0) (if Z.eqb b 0 then wp c2 Q else wp c1 Q)) c2\n  Q"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c4_goal : triple\n  (pureconj (not (eq b 0)) (if Z.eqb b 0 then wp c2 Q else wp c1 Q)) c1\n  Q",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q",
                    "_global_wp : forall (_ : com) (_ : postcond), precond",
                    "c2_c1 : com",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c6_goal : triple (wp c1 Q) c1 Q",
                    "c7_goal : aimp (pureconj (not (eq b 0)) (if Z.eqb b 0 then wp c2 Q else wp c1 Q))\n  (wp c1 Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : triple (wp c1 Q) c1 Q",
                    "_global_wp_precond : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( A & B ) .",
                "tactic_args": [
                    "c7_goal : aimp (pureconj (not (eq b 0)) (if Z.eqb b 0 then wp c2 Q else wp c1 Q))\n  (wp c1 Q)"
                ],
                "tactic_res": [
                    "c8_goal : wp c1 Q h",
                    "c8_h : heap",
                    "c8_A : not (eq b 0)",
                    "c8_B : (if Z.eqb b 0 then wp c2 Q else wp c1 Q) h"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_Z.eqb_neq : forall x y : Z, iff (eq (Z.eqb x y) false) (not (eq x y))",
                    "c8_A : not (eq b 0)"
                ],
                "tactic_res": [
                    "c8_A : eq (Z.eqb b 0) false"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "c8_A : eq (Z.eqb b 0) false",
                    "c8_B : (if Z.eqb b 0 then wp c2 Q else wp c1 Q) h"
                ],
                "tactic_res": [
                    "c8_B : wp c1 Q h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : wp c1 Q h",
                    "c8_B : wp c1 Q h",
                    "c8_h : heap",
                    "c2_Q : postcond",
                    "c2_c1 : com"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i _i ) .",
                "tactic_args": [
                    "c5_goal : triple (pureconj (eq b 0) (if Z.eqb b 0 then wp c2 Q else wp c1 Q)) c2\n  Q",
                    "_global_triple_consequence_pre : forall (P : assertion) (P' : precond) (c : com) \n         (Q : postcond) (_ : triple P' c Q) (_ : aimp P P'), \n       triple P c Q",
                    "_global_wp : forall (_ : com) (_ : postcond), precond",
                    "c2_c2 : com",
                    "c2_Q : postcond"
                ],
                "tactic_res": [
                    "c9_goal : triple (wp c2 Q) c2 Q",
                    "c10_goal : aimp (pureconj (eq b 0) (if Z.eqb b 0 then wp c2 Q else wp c1 Q))\n  (wp c2 Q)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : triple (wp c2 Q) c2 Q",
                    "_global_wp_precond : forall (c : com) (Q : postcond), triple (wp c Q) c Q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h ( A & B ) .",
                "tactic_args": [
                    "c10_goal : aimp (pureconj (eq b 0) (if Z.eqb b 0 then wp c2 Q else wp c1 Q))\n  (wp c2 Q)"
                ],
                "tactic_res": [
                    "c11_goal : wp c2 Q h",
                    "c11_h : heap",
                    "c11_A : eq b 0",
                    "c11_B : (if Z.eqb b 0 then wp c2 Q else wp c1 Q) h"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_b : Z",
                    "c11_A : eq b 0"
                ],
                "tactic_res": [
                    "c11_B : (if Z.eqb 0 0 then wp c2 Q else wp c1 Q) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : wp c2 Q h",
                    "c11_B : (if Z.eqb 0 0 then wp c2 Q else wp c1 Q) h",
                    "c11_h : heap",
                    "c2_Q : postcond",
                    "c2_c2 : com"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_alloc",
        "proof": [
            {
                "tactic_sig": "Lemma wp_alloc : forall sz Q , aforall ( fun l => ( l <> 0 ) //\\\\ valid_N l sz --* Q l ) -->> wp ( ALLOC sz ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_alloc : forall sz Q , aforall ( fun l => ( l <> 0 ) //\\\\ valid_N l sz --* Q l ) -->> wp ( ALLOC sz ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (sz : nat) (Q : forall _ : Z, assertion),\naimp\n  (aforall\n     (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)))\n  (wp (ALLOC sz) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (sz : nat) (Q : forall _ : Z, assertion),\naimp\n  (aforall\n     (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)))\n  (wp (ALLOC sz) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp\n  (aforall\n     (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)))\n  (wp (ALLOC sz) Q)",
                    "c2_sz : nat",
                    "c2_Q : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : aimp\n  (aforall\n     (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)))\n  (wp (ALLOC sz) Q)"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap)\n  (_ : aforall\n         (fun l : Z =>\n          wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)) h),\nwp (ALLOC sz) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap)\n  (_ : aforall\n         (fun l : Z =>\n          wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)) h),\nwp (ALLOC sz) Q h"
                ],
                "tactic_res": [
                    "c4_goal : wp (ALLOC sz) Q h",
                    "c4_h : heap",
                    "c4_H : aforall\n  (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)) h"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := fun l => ( l <> 0 ) //\\\\ _i l _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := fun l => ( l <> 0 ) //\\\\ _i l _i ) .",
                "tactic_args": [
                    "c4_goal : wp (ALLOC sz) Q h",
                    "_global_wp_ramification : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\n       aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n         (wp c Q')",
                    "c2_Q : forall _ : Z, assertion",
                    "_global_valid_N : forall (_ : addr) (_ : nat), assertion",
                    "c2_sz : nat"
                ],
                "tactic_res": [
                    "c5_goal : sepconj\n  (wp (ALLOC sz) (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)))\n  (aforall\n     (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)))\n  h"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c5_goal : sepconj\n  (wp (ALLOC sz) (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)))\n  (aforall\n     (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)))\n  h",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)",
                    "_global_emp : assertion"
                ],
                "tactic_res": [
                    "c6_goal : aimp emp\n  (wp (ALLOC sz) (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)))",
                    "c7_goal : sepconj emp\n  (aforall\n     (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)))\n  h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : aimp emp\n  (wp (ALLOC sz) (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz)))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c8_goal : triple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : triple emp (ALLOC sz)\n  (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))",
                    "_global_triple_alloc : forall sz : nat,\n       triple emp (ALLOC sz)\n         (fun l : Z => pureconj (not (eq l 0)) (valid_N l sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : sepconj emp\n  (aforall\n     (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)))\n  h",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c9_goal : aforall\n  (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)) h"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c9_goal : aforall\n  (fun v : Z => wand (pureconj (not (eq v 0)) (valid_N v sz)) (Q v)) h",
                    "c4_H : aforall\n  (fun l : Z => wand (pureconj (not (eq l 0)) (valid_N l sz)) (Q l)) h",
                    "c4_h : heap",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_sz : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_get",
        "proof": [
            {
                "tactic_sig": "Lemma wp_get : forall l v Q , contains l v ** ( contains l v --* Q v ) -->> wp ( GET l ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_get : forall l v Q , contains l v ** ( contains l v --* Q v ) -->> wp ( GET l ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : forall _ : Z, assertion),\naimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : forall _ : Z, assertion),\naimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_Q : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "assert ( W : contains _i _i -->> wp ( GET _i ) ( fun v' => ( v' = _i ) //\\\\ contains _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( W : contains _i _i -->> wp ( GET _i ) ( fun v' => ( v' = _i ) //\\\\ contains _i _i ) ) .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c3_goal : aimp (contains l v)\n  (wp (GET l) (fun v' : Z => pureconj (eq v' v) (contains l v)))",
                    "c4_goal : aimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)",
                    "c4_W : aimp (contains l v)\n  (wp (GET l) (fun v' : Z => pureconj (eq v' v) (contains l v)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : aimp (contains l v)\n  (wp (GET l) (fun v' : Z => pureconj (eq v' v) (contains l v)))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : triple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (contains l v) (GET l)\n  (fun v' : Z => pureconj (eq v' v) (contains l v))",
                    "_global_triple_get : forall (l : addr) (v : Z),\n       triple (contains l v) (GET l)\n         (fun v' : Z => pureconj (eq v' v) (contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp (sepconj (contains l v) (wand (contains l v) (Q v)))\n  (wp (GET l) Q)"
                ],
                "tactic_res": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (contains l v) (wand (contains l v) (Q v)) h),\nwp (GET l) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (contains l v) (wand (contains l v) (Q v)) h),\nwp (GET l) Q h"
                ],
                "tactic_res": [
                    "c7_goal : wp (GET l) Q h",
                    "c7_h : heap",
                    "c7_H : sepconj (contains l v) (wand (contains l v) (Q v)) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : wp (GET l) Q h",
                    "_global_wp_ramification : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\n       aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n         (wp c Q')"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (wp (GET l) ?Q) (aforall (fun v0 : Z => wand (?Q v0) (Q v0))) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c8_goal : sepconj (wp (GET l) ?Q) (aforall (fun v0 : Z => wand (?Q v0) (Q v0))) h",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp ?P (wp (GET l) ?Q)",
                    "c10_goal : sepconj (contains l v)\n  (aforall\n     (fun v0 : Z =>\n      wand ((fun v' : Z => pureconj (eq v' v) (contains l v)) v0)\n        (Q v0))) h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c9_goal : aimp ?P (wp (GET l) ?Q)",
                    "c4_W : aimp (contains l v)\n  (wp (GET l) (fun v' : Z => pureconj (eq v' v) (contains l v)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : sepconj (contains l v)\n  (aforall\n     (fun v0 : Z =>\n      wand ((fun v' : Z => pureconj (eq v' v) (contains l v)) v0)\n        (Q v0))) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c11_goal : aimp (wand (contains l v) (Q v))\n  (aforall\n     (fun v0 : Z => wand (pureconj (eq v0 v) (contains l v)) (Q v0)))",
                    "c12_goal : sepconj (contains l v) ?P h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : sepconj (contains l v) ?P h",
                    "c7_H : sepconj (contains l v) (wand (contains l v) (Q v)) h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o ( _o & _o ) .",
                "tactic_sig_no_out_arg": "intros h' H' v' h'' D ( A & B ) .",
                "tactic_args": [
                    "c11_goal : aimp (wand (contains l v) (Q v))\n  (aforall\n     (fun v0 : Z => wand (pureconj (eq v0 v) (contains l v)) (Q v0)))"
                ],
                "tactic_res": [
                    "c13_goal : Q v' (hunion h' h'')",
                    "c13_h' : heap",
                    "c13_H' : wand (contains l v) (Q v) h'",
                    "c13_v' : Z",
                    "c13_h'' : heap",
                    "c13_D : hdisjoint h' h''",
                    "c13_A : eq v' v",
                    "c13_B : contains l v h''"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c13_goal : Q v' (hunion h' h'')",
                    "c13_v' : Z",
                    "c13_A : eq v' v"
                ],
                "tactic_res": [
                    "c14_goal : Q v (hunion h' h'')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Q v (hunion h' h'')",
                    "c13_H' : wand (contains l v) (Q v) h'"
                ],
                "tactic_res": [
                    "c15_goal : hdisjoint h' h''",
                    "c16_goal : contains l v h''"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : hdisjoint h' h''",
                    "c13_D : hdisjoint h' h''",
                    "c13_h'' : heap",
                    "c13_h' : heap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : contains l v h''",
                    "c13_B : contains l v h''",
                    "c13_h'' : heap",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_set",
        "proof": [
            {
                "tactic_sig": "Lemma wp_set : forall l v Q , valid l ** aforall ( fun v' => ( contains l v --* Q v' ) ) -->> wp ( SET l v ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_set : forall l v Q , valid l ** aforall ( fun v' => ( contains l v --* Q v' ) ) -->> wp ( SET l v ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : forall _ : Z, assertion),\naimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : forall _ : Z, assertion),\naimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_Q : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "assert ( W : valid _i -->> wp ( SET _i _i ) ( fun _ => contains _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( W : valid _i -->> wp ( SET _i _i ) ( fun _ => contains _i _i ) ) .",
                "tactic_args": [
                    "c2_goal : aimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)",
                    "c2_l : addr",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_l : addr",
                    "c2_v : Z"
                ],
                "tactic_res": [
                    "c3_goal : aimp (valid l) (wp (SET l v) (fun _ : Z => contains l v))",
                    "c4_goal : aimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)",
                    "c4_W : aimp (valid l) (wp (SET l v) (fun _ : Z => contains l v))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : aimp (valid l) (wp (SET l v) (fun _ : Z => contains l v))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (valid l) (SET l v) (fun _ : Z => contains l v)",
                    "_global_triple_set : forall (l : addr) (v : Z),\n       triple (valid l) (SET l v) (fun _ : Z => contains l v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp\n  (sepconj (valid l)\n     (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n  (wp (SET l v) Q)"
                ],
                "tactic_res": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (valid l)\n         (aforall (fun v' : Z => wand (contains l v) (Q v'))) h),\nwp (SET l v) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (valid l)\n         (aforall (fun v' : Z => wand (contains l v) (Q v'))) h),\nwp (SET l v) Q h"
                ],
                "tactic_res": [
                    "c7_goal : wp (SET l v) Q h",
                    "c7_h : heap",
                    "c7_H : sepconj (valid l) (aforall (fun v' : Z => wand (contains l v) (Q v')))\n  h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : wp (SET l v) Q h",
                    "_global_wp_ramification : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\n       aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n         (wp c Q')"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (wp (SET l v) ?Q) (aforall (fun v0 : Z => wand (?Q v0) (Q v0)))\n  h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c8_goal : sepconj (wp (SET l v) ?Q) (aforall (fun v0 : Z => wand (?Q v0) (Q v0)))\n  h",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp ?P (wp (SET l v) ?Q)",
                    "c10_goal : sepconj (valid l)\n  (aforall (fun v0 : Z => wand ((fun _ : Z => contains l v) v0) (Q v0)))\n  h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c9_goal : aimp ?P (wp (SET l v) ?Q)",
                    "c4_W : aimp (valid l) (wp (SET l v) (fun _ : Z => contains l v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : sepconj (valid l)\n  (aforall (fun v0 : Z => wand ((fun _ : Z => contains l v) v0) (Q v0)))\n  h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c11_goal : aimp (aforall (fun v' : Z => wand (contains l v) (Q v')))\n  (aforall (fun v0 : Z => wand (contains l v) (Q v0)))",
                    "c12_goal : sepconj (valid l) ?P h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : sepconj (valid l) ?P h",
                    "c7_H : sepconj (valid l) (aforall (fun v' : Z => wand (contains l v) (Q v')))\n  h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : aimp (aforall (fun v' : Z => wand (contains l v) (Q v')))\n  (aforall (fun v0 : Z => wand (contains l v) (Q v0)))"
                ],
                "tactic_res": [
                    "c13_goal : forall (h : heap)\n  (_ : aforall (fun v' : Z => wand (contains l v) (Q v')) h),\naforall (fun v0 : Z => wand (contains l v) (Q v0)) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall (h : heap)\n  (_ : aforall (fun v' : Z => wand (contains l v) (Q v')) h),\naforall (fun v0 : Z => wand (contains l v) (Q v0)) h",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_set'",
        "proof": [
            {
                "tactic_sig": "Corollary wp_set' : forall l v Q , valid l ** ( contains l v --* Q ) -->> wp ( SET l v ) ( fun _ => Q ) .",
                "tactic_sig_no_out_arg": "Corollary wp_set' : forall l v Q , valid l ** ( contains l v --* Q ) -->> wp ( SET l v ) ( fun _ => Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : assertion),\naimp (sepconj (valid l) (wand (contains l v) Q))\n  (wp (SET l v) (fun _ : Z => Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (v : Z) (Q : assertion),\naimp (sepconj (valid l) (wand (contains l v) Q))\n  (wp (SET l v) (fun _ : Z => Q))"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (valid l) (wand (contains l v) Q))\n  (wp (SET l v) (fun _ : Z => Q))",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (valid l) (wand (contains l v) Q))\n  (wp (SET l v) (fun _ : Z => Q))"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap) (_ : sepconj (valid l) (wand (contains l v) Q) h),\nwp (SET l v) (fun _ : Z => Q) h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap) (_ : sepconj (valid l) (wand (contains l v) Q) h),\nwp (SET l v) (fun _ : Z => Q) h"
                ],
                "tactic_res": [
                    "c4_goal : wp (SET l v) (fun _ : Z => Q) h",
                    "c4_h : heap",
                    "c4_H : sepconj (valid l) (wand (contains l v) Q) h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : wp (SET l v) (fun _ : Z => Q) h",
                    "_global_wp_set : forall (l : addr) (v : Z) (Q : forall _ : Z, assertion),\n       aimp\n         (sepconj (valid l)\n            (aforall (fun v' : Z => wand (contains l v) (Q v'))))\n         (wp (SET l v) Q)"
                ],
                "tactic_res": [
                    "c5_goal : sepconj (valid l) (aforall (fun _ : Z => wand (contains l v) Q)) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c5_goal : sepconj (valid l) (aforall (fun _ : Z => wand (contains l v) Q)) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c6_goal : aimp ?P (aforall (fun _ : Z => wand (contains l v) Q))",
                    "c7_goal : sepconj (valid l) (wand (contains l v) Q) h"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := contains _i _i --* _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := contains _i _i --* _i ) .",
                "tactic_args": [
                    "c6_goal : aimp ?P (aforall (fun _ : Z => wand (contains l v) Q))",
                    "c2_l : addr",
                    "c2_v : Z",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c8_goal : aimp (wand (contains l v) Q)\n  (aforall (fun _ : Z => wand (contains l v) Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h' H' v' .",
                "tactic_args": [
                    "c8_goal : aimp (wand (contains l v) Q)\n  (aforall (fun _ : Z => wand (contains l v) Q))"
                ],
                "tactic_res": [
                    "c9_goal : wand (contains l v) Q h'",
                    "c9_h' : heap",
                    "c9_H' : wand (contains l v) Q h'",
                    "c9_v' : Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : wand (contains l v) Q h'",
                    "c9_H' : wand (contains l v) Q h'",
                    "c9_h' : heap",
                    "c2_Q : assertion",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : sepconj (valid l) (wand (contains l v) Q) h",
                    "c4_H : sepconj (valid l) (wand (contains l v) Q) h",
                    "c4_h : heap",
                    "c2_Q : assertion",
                    "c2_v : Z",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_free",
        "proof": [
            {
                "tactic_sig": "Lemma wp_free : forall l Q , valid l ** aforall ( fun v' => Q v' ) -->> wp ( FREE l ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_free : forall l Q , valid l ** aforall ( fun v' => Q v' ) -->> wp ( FREE l ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (Q : forall _ : Z, assertion),\naimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (Q : forall _ : Z, assertion),\naimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)",
                    "c2_l : addr",
                    "c2_Q : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "assert ( W : valid _i -->> wp ( FREE _i ) ( fun _ => emp ) ) .",
                "tactic_sig_no_out_arg": "assert ( W : valid _i -->> wp ( FREE _i ) ( fun _ => emp ) ) .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)",
                    "c2_l : addr",
                    "c2_l : addr"
                ],
                "tactic_res": [
                    "c3_goal : aimp (valid l) (wp (FREE l) (fun _ : Z => emp))",
                    "c4_goal : aimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)",
                    "c4_W : aimp (valid l) (wp (FREE l) (fun _ : Z => emp))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : aimp (valid l) (wp (FREE l) (fun _ : Z => emp))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : triple (valid l) (FREE l) (fun _ : Z => emp)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple (valid l) (FREE l) (fun _ : Z => emp)",
                    "_global_triple_free : forall l : addr, triple (valid l) (FREE l) (fun _ : Z => emp)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp (sepconj (valid l) (aforall (fun v' : Z => Q v'))) (wp (FREE l) Q)"
                ],
                "tactic_res": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (valid l) (aforall (fun v' : Z => Q v')) h),\nwp (FREE l) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (h : heap)\n  (_ : sepconj (valid l) (aforall (fun v' : Z => Q v')) h),\nwp (FREE l) Q h"
                ],
                "tactic_res": [
                    "c7_goal : wp (FREE l) Q h",
                    "c7_h : heap",
                    "c7_H : sepconj (valid l) (aforall (fun v' : Z => Q v')) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : wp (FREE l) Q h",
                    "_global_wp_ramification : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\n       aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n         (wp c Q')"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (wp (FREE l) ?Q) (aforall (fun v : Z => wand (?Q v) (Q v))) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c8_goal : sepconj (wp (FREE l) ?Q) (aforall (fun v : Z => wand (?Q v) (Q v))) h",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp ?P (wp (FREE l) ?Q)",
                    "c10_goal : sepconj (valid l)\n  (aforall (fun v : Z => wand ((fun _ : Z => emp) v) (Q v))) h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c9_goal : aimp ?P (wp (FREE l) ?Q)",
                    "c4_W : aimp (valid l) (wp (FREE l) (fun _ : Z => emp))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : sepconj (valid l)\n  (aforall (fun v : Z => wand ((fun _ : Z => emp) v) (Q v))) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c11_goal : aimp (aforall (fun v' : Z => Q v'))\n  (aforall (fun v : Z => wand emp (Q v)))",
                    "c12_goal : sepconj (valid l) ?P h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : sepconj (valid l) ?P h",
                    "c7_H : sepconj (valid l) (aforall (fun v' : Z => Q v')) h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : aimp (aforall (fun v' : Z => Q v'))\n  (aforall (fun v : Z => wand emp (Q v)))"
                ],
                "tactic_res": [
                    "c13_goal : forall (h : heap) (_ : aforall (fun v' : Z => Q v') h),\naforall (fun v : Z => wand emp (Q v)) h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (h : heap) (_ : aforall (fun v' : Z => Q v') h),\naforall (fun v : Z => wand emp (Q v)) h"
                ],
                "tactic_res": [
                    "c14_goal : aforall (fun v : Z => wand emp (Q v)) h0",
                    "c14_h0 : heap",
                    "c14_H0 : aforall (fun v' : Z => Q v') h0"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros v h' D E .",
                "tactic_args": [
                    "c14_goal : aforall (fun v : Z => wand emp (Q v)) h0"
                ],
                "tactic_res": [
                    "c15_goal : Q v (hunion h0 h')",
                    "c15_v : Z",
                    "c15_h' : heap",
                    "c15_D : hdisjoint h0 h'",
                    "c15_E : emp h'"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c15_goal : Q v (hunion h0 h')",
                    "c15_E : emp h'"
                ],
                "tactic_res": [
                    "c16_goal : Q v (hunion h0 hempty)",
                    "c16_D : hdisjoint h0 hempty"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i by HDISJ .",
                "tactic_sig_no_out_arg": "rewrite _i , _i by HDISJ .",
                "tactic_args": [
                    "c16_goal : Q v (hunion h0 hempty)",
                    "_global_hunion_comm : forall (h1 h2 : heap) (_ : hdisjoint h1 h2),\n       eq (hunion h2 h1) (hunion h1 h2)",
                    "_global_hunion_empty : forall h : heap, eq (hunion hempty h) h",
                    "c15_E : emp h'",
                    "c16_D : hdisjoint h0 hempty",
                    "c15_v : Z",
                    "c14_H0 : aforall (fun v' : Z => Q v') h0",
                    "c14_h0 : heap",
                    "c7_H : sepconj (valid l) (aforall (fun v' : Z => Q v')) h",
                    "c4_W : aimp (valid l) (wp (FREE l) (fun _ : Z => emp))",
                    "c2_Q : forall _ : Z, assertion"
                ],
                "tactic_res": [
                    "c17_goal : Q v h0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : Q v h0",
                    "c14_H0 : aforall (fun v' : Z => Q v') h0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_free'",
        "proof": [
            {
                "tactic_sig": "Corollary wp_free' : forall l Q , valid l ** Q -->> wp ( FREE l ) ( fun _ => Q ) .",
                "tactic_sig_no_out_arg": "Corollary wp_free' : forall l Q , valid l ** Q -->> wp ( FREE l ) ( fun _ => Q ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : addr) (Q : assertion),\naimp (sepconj (valid l) Q) (wp (FREE l) (fun _ : Z => Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : addr) (Q : assertion),\naimp (sepconj (valid l) Q) (wp (FREE l) (fun _ : Z => Q))"
                ],
                "tactic_res": [
                    "c2_goal : aimp (sepconj (valid l) Q) (wp (FREE l) (fun _ : Z => Q))",
                    "c2_l : addr",
                    "c2_Q : assertion"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : aimp (sepconj (valid l) Q) (wp (FREE l) (fun _ : Z => Q))"
                ],
                "tactic_res": [
                    "c3_goal : forall (h : heap) (_ : sepconj (valid l) Q h),\nwp (FREE l) (fun _ : Z => Q) h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (h : heap) (_ : sepconj (valid l) Q h),\nwp (FREE l) (fun _ : Z => Q) h"
                ],
                "tactic_res": [
                    "c4_goal : wp (FREE l) (fun _ : Z => Q) h",
                    "c4_h : heap",
                    "c4_H : sepconj (valid l) Q h"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : wp (FREE l) (fun _ : Z => Q) h",
                    "_global_wp_free : forall (l : addr) (Q : forall _ : Z, assertion),\n       aimp (sepconj (valid l) (aforall (fun v' : Z => Q v')))\n         (wp (FREE l) Q)"
                ],
                "tactic_res": [
                    "c5_goal : sepconj (valid l) (aforall (fun _ : Z => Q)) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c5_goal : sepconj (valid l) (aforall (fun _ : Z => Q)) h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c6_goal : aimp ?P (aforall (fun _ : Z => Q))",
                    "c7_goal : sepconj (valid l) Q h"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "c6_goal : aimp ?P (aforall (fun _ : Z => Q))",
                    "c2_Q : assertion"
                ],
                "tactic_res": [
                    "c8_goal : aimp Q (aforall (fun _ : Z => Q))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros h' H' v' .",
                "tactic_args": [
                    "c8_goal : aimp Q (aforall (fun _ : Z => Q))"
                ],
                "tactic_res": [
                    "c9_goal : Q h'",
                    "c9_h' : heap",
                    "c9_H' : Q h'",
                    "c9_v' : Z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : Q h'",
                    "c9_H' : Q h'",
                    "c9_h' : heap",
                    "c2_Q : assertion"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : sepconj (valid l) Q h",
                    "c4_H : sepconj (valid l) Q h",
                    "c4_h : heap",
                    "c2_Q : assertion",
                    "c2_l : addr"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_pick",
        "proof": [
            {
                "tactic_sig": "Lemma wp_pick : forall n Q , aforall ( fun i => pure ( 0 <= i < n ) --* Q i ) -->> wp ( PICK n ) Q .",
                "tactic_sig_no_out_arg": "Lemma wp_pick : forall n Q , aforall ( fun i => pure ( 0 <= i < n ) --* Q i ) -->> wp ( PICK n ) Q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : Z) (Q : forall _ : Z, assertion),\naimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : Z) (Q : forall _ : Z, assertion),\naimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)"
                ],
                "tactic_res": [
                    "c2_goal : aimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)",
                    "c2_n : Z",
                    "c2_Q : forall _ : Z, assertion"
                ]
            },
            {
                "tactic_sig": "assert ( W : emp -->> wp ( PICK _i ) ( fun i => pure ( 0 <= i < _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( W : emp -->> wp ( PICK _i ) ( fun i => pure ( 0 <= i < _i ) ) ) .",
                "tactic_args": [
                    "c2_goal : aimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)",
                    "c2_n : Z",
                    "c2_n : Z"
                ],
                "tactic_res": [
                    "c3_goal : aimp emp (wp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))))",
                    "c4_goal : aimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)",
                    "c4_W : aimp emp (wp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : aimp emp (wp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))))",
                    "_global_wp_weakest : forall (P : precond) (c : com) (Q : postcond) (_ : triple P c Q),\n       aimp P (wp c Q)"
                ],
                "tactic_res": [
                    "c5_goal : triple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : triple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))",
                    "_global_triple_pick : forall n : Z,\n       triple emp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : aimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (wp (PICK n) Q)"
                ],
                "tactic_res": [
                    "c6_goal : forall (h : heap)\n  (_ : aforall\n         (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h),\nwp (PICK n) Q h"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (h : heap)\n  (_ : aforall\n         (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h),\nwp (PICK n) Q h"
                ],
                "tactic_res": [
                    "c7_goal : wp (PICK n) Q h",
                    "c7_h : heap",
                    "c7_H : aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c7_goal : wp (PICK n) Q h",
                    "_global_wp_ramification : forall (c : com) (Q : postcond) (Q' : forall _ : Z, assertion),\n       aimp (sepconj (wp c Q) (aforall (fun v : Z => wand (Q v) (Q' v))))\n         (wp c Q')"
                ],
                "tactic_res": [
                    "c8_goal : sepconj (wp (PICK n) ?Q) (aforall (fun v : Z => wand (?Q v) (Q v))) h"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c8_goal : sepconj (wp (PICK n) ?Q) (aforall (fun v : Z => wand (?Q v) (Q v))) h",
                    "_global_sepconj_imp_l : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj P R) (sepconj Q R)"
                ],
                "tactic_res": [
                    "c9_goal : aimp ?P (wp (PICK n) ?Q)",
                    "c10_goal : sepconj emp\n  (aforall\n     (fun v : Z =>\n      wand ((fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))) v) (Q v)))\n  h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c9_goal : aimp ?P (wp (PICK n) ?Q)",
                    "c4_W : aimp emp (wp (PICK n) (fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : sepconj emp\n  (aforall\n     (fun v : Z =>\n      wand ((fun i : Z => pure (and (Z.le 0 i) (Z.lt i n))) v) (Q v)))\n  h",
                    "_global_sepconj_imp_r : forall (P Q R : assertion) (_ : aimp P Q),\n       aimp (sepconj R P) (sepconj R Q)"
                ],
                "tactic_res": [
                    "c11_goal : aimp ?P\n  (aforall (fun v : Z => wand (pure (and (Z.le 0 v) (Z.lt v n))) (Q v)))",
                    "c12_goal : sepconj emp ?P h"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : sepconj emp ?P h",
                    "_global_sepconj_emp : forall P : assertion, eq (sepconj emp P) P"
                ],
                "tactic_res": [
                    "c13_goal : ?P h"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c13_goal : ?P h",
                    "c7_H : aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : aimp\n  (aforall (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)))\n  (aforall (fun v : Z => wand (pure (and (Z.le 0 v) (Z.lt v n))) (Q v)))"
                ],
                "tactic_res": [
                    "c14_goal : forall (h : heap)\n  (_ : aforall\n         (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h),\naforall (fun v : Z => wand (pure (and (Z.le 0 v) (Z.lt v n))) (Q v)) h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall (h : heap)\n  (_ : aforall\n         (fun i : Z => wand (pure (and (Z.le 0 i) (Z.lt i n))) (Q i)) h),\naforall (fun v : Z => wand (pure (and (Z.le 0 v) (Z.lt v n))) (Q v)) h",
                    "c2_Q : forall _ : Z, assertion",
                    "c2_n : Z"
                ],
                "tactic_res": []
            }
        ]
    }
]