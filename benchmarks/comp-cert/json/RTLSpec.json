[
    {
        "lemma_name": "bind_inversion",
        "proof": [
            {
                "tactic_sig": "Remark bind_inversion : forall ( A B : Type ) ( f : mon A ) ( g : A -> mon B ) ( y : B ) ( s1 s3 : state ) ( i : state_incr s1 s3 ) , bind f g s1 = OK y s3 i -> exists x , exists s2 , exists i1 , exists i2 , f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2 .",
                "tactic_sig_no_out_arg": "Remark bind_inversion : forall ( A B : Type ) ( f : mon A ) ( g : A -> mon B ) ( y : B ) ( s1 s3 : state ) ( i : state_incr s1 s3 ) , bind f g s1 = OK y s3 i -> exists x , exists s2 , exists i1 , exists i2 , f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A B : Type) (f : mon A) (g : forall _ : A, mon B) \n  (y : B) (s1 s3 : state) (i : state_incr s1 s3)\n  (_ : eq (bind f g s1) (OK y s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until i .",
                "tactic_args": [
                    "c1_goal : forall (A B : Type) (f : mon A) (g : forall _ : A, mon B) \n  (y : B) (s1 s3 : state) (i : state_incr s1 s3)\n  (_ : eq (bind f g s1) (OK y s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (bind f g s1) (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))",
                    "c2_i : state_incr s1 s3",
                    "c2_s3 : state",
                    "c2_s1 : state",
                    "c2_y : B",
                    "c2_g : forall _ : A, mon B",
                    "c2_f : mon A",
                    "c2_B : Type",
                    "c2_A : Type"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (bind f g s1) (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))",
                    "_global_bind : forall (_ : mon ?A) (_ : forall _ : ?A, mon ?B), mon ?B\nwhere\n?A : [A : Type\n      B : Type\n      f : mon A\n      g : forall _ : A, mon B\n      y : B\n      s1 : state\n      s3 : state\n      i : state_incr s1 s3 |- Type]\n?B : [A : Type\n      B : Type\n      f : mon A\n      g : forall _ : A, mon B\n      y : B\n      s1 : state\n      s3 : state\n      i : state_incr s1 s3 |- Type]"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : eq\n        match f s1 with\n        | Error msg => Error msg\n        | OK a s' i =>\n            match g a s' with\n            | Error msg => Error msg\n            | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' i i')\n            end\n        end (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : eq\n        match f s1 with\n        | Error msg => Error msg\n        | OK a s' i =>\n            match g a s' with\n            | Error msg => Error msg\n            | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' i i')\n            end\n        end (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))",
                    "c2_f : mon A",
                    "c2_s1 : state",
                    "c2_i : state_incr s1 s3",
                    "c2_s3 : state",
                    "c2_y : B",
                    "c2_g : forall _ : A, mon B",
                    "c2_B : Type",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (Error e) (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (Error e) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))",
                    "c4_e : Errors\\.errmsg",
                    "c5_goal : forall\n  _ : eq\n        match g a s' with\n        | Error msg => Error msg\n        | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\n        end (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (OK a s' s) (OK x s2 i1))\n              (eq (g x s2) (OK y s3 i2))))))",
                    "c5_s : state_incr s1 s'",
                    "c5_s' : state",
                    "c5_a : A"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (Error e) (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (Error e) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))"
                ],
                "tactic_res": [
                    "c6_goal : ex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (Error e) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))",
                    "c6_H : eq (Error e) (OK y s3 i)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : eq\n        match g a s' with\n        | Error msg => Error msg\n        | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\n        end (OK y s3 i),\nex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (OK a s' s) (OK x s2 i1))\n              (eq (g x s2) (OK y s3 i2))))))"
                ],
                "tactic_res": [
                    "c7_goal : ex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (OK a s' s) (OK x s2 i1))\n              (eq (g x s2) (OK y s3 i2))))))",
                    "c7_H : eq\n  match g a s' with\n  | Error msg => Error msg\n  | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\n  end (OK y s3 i)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (Error e) (OK x s2 i1)) (eq (g x s2) (OK y s3 i2))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun x : A =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (OK a s' s) (OK x s2 i1))\n              (eq (g x s2) (OK y s3 i2))))))",
                    "c5_a : A"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun s2 : state =>\n   ex\n     (fun i1 : state_incr s1 s2 =>\n      ex\n        (fun i2 : state_incr s2 s3 =>\n         and (eq (OK a s' s) (OK a s2 i1)) (eq (g a s2) (OK y s3 i2)))))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun s2 : state =>\n   ex\n     (fun i1 : state_incr s1 s2 =>\n      ex\n        (fun i2 : state_incr s2 s3 =>\n         and (eq (OK a s' s) (OK a s2 i1)) (eq (g a s2) (OK y s3 i2)))))",
                    "c5_s' : state"
                ],
                "tactic_res": [
                    "c9_goal : ex\n  (fun i1 : state_incr s1 s' =>\n   ex\n     (fun i2 : state_incr s' s3 =>\n      and (eq (OK a s' s) (OK a s' i1)) (eq (g a s') (OK y s3 i2))))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun i1 : state_incr s1 s' =>\n   ex\n     (fun i2 : state_incr s' s3 =>\n      and (eq (OK a s' s) (OK a s' i1)) (eq (g a s') (OK y s3 i2))))",
                    "c5_s : state_incr s1 s'"
                ],
                "tactic_res": [
                    "c10_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (g a s') (OK y s3 i2)))"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i _i ) as [  _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i _i ) .",
                "tactic_args": [
                    "c10_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (g a s') (OK y s3 i2)))",
                    "c2_g : forall _ : A, mon B",
                    "c5_a : A",
                    "c5_s' : state",
                    "c7_H : eq\n  match g a s' with\n  | Error msg => Error msg\n  | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\n  end (OK y s3 i)",
                    "c5_s : state_incr s1 s'",
                    "c2_s1 : state",
                    "c2_s3 : state",
                    "c2_y : B",
                    "c2_f : mon A",
                    "c2_B : Type",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c11_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (Error e) (OK y s3 i2)))",
                    "c11_H : eq (Error e) (OK y s3 i)",
                    "c11_e : Errors\\.errmsg",
                    "c12_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (OK b s'0 s0) (OK y s3 i2)))",
                    "c12_H : eq (OK b s'0 (state_incr_trans s1 s' s'0 s s0)) (OK y s3 i)",
                    "c12_s0 : state_incr s' s'0",
                    "c12_s'0 : state",
                    "c12_b : B"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (Error e) (OK y s3 i2)))",
                    "c11_H : eq (Error e) (OK y s3 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (OK b s'0 s0) (OK y s3 i2)))",
                    "c12_H : eq (OK b s'0 (state_incr_trans s1 s' s'0 s s0)) (OK y s3 i)"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (OK y s3 s0) (OK y s3 i2)))",
                    "c13_s0 : state_incr s' s3"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun i2 : state_incr s' s3 =>\n   and (eq (OK a s' s) (OK a s' s)) (eq (OK y s3 s0) (OK y s3 i2)))",
                    "c13_s0 : state_incr s' s3"
                ],
                "tactic_res": [
                    "c14_goal : and (eq (OK a s' s) (OK a s' s)) (eq (OK y s3 s0) (OK y s3 s0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : and (eq (OK a s' s) (OK a s' s)) (eq (OK y s3 s0) (OK y s3 s0))",
                    "c13_s0 : state_incr s' s3",
                    "c5_s : state_incr s1 s'",
                    "c5_s' : state",
                    "c5_a : A",
                    "c2_s1 : state",
                    "c2_s3 : state",
                    "c2_y : B",
                    "c2_B : Type",
                    "c2_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bind2_inversion",
        "proof": [
            {
                "tactic_sig": "Remark bind2_inversion : forall ( A B C : Type ) ( f : mon ( A * B ) ) ( g : A -> B -> mon C ) ( z : C ) ( s1 s3 : state ) ( i : state_incr s1 s3 ) , bind2 f g s1 = OK z s3 i -> exists x , exists y , exists s2 , exists i1 , exists i2 , f s1 = OK ( x , y ) s2 i1 /\\ g x y s2 = OK z s3 i2 .",
                "tactic_sig_no_out_arg": "Remark bind2_inversion : forall ( A B C : Type ) ( f : mon ( A * B ) ) ( g : A -> B -> mon C ) ( z : C ) ( s1 s3 : state ) ( i : state_incr s1 s3 ) , bind2 f g s1 = OK z s3 i -> exists x , exists y , exists s2 , exists i1 , exists i2 , f s1 = OK ( x , y ) s2 i1 /\\ g x y s2 = OK z s3 i2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A B C : Type) (f : mon (prod A B))\n  (g : forall (_ : A) (_ : B), mon C) (z : C) (s1 s3 : state)\n  (i : state_incr s1 s3) (_ : eq (bind2 f g s1) (OK z s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (A B C : Type) (f : mon (prod A B))\n  (g : forall (_ : A) (_ : B), mon C) (z : C) (s1 s3 : state)\n  (i : state_incr s1 s3) (_ : eq (bind2 f g s1) (OK z s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))",
                    "_global_bind2 : forall (_ : mon (prod ?A ?B)) (_ : forall (_ : ?A) (_ : ?B), mon ?C),\n       mon ?C\nwhere\n?A : [ |- Type]\n?B : [ |- Type]\n?C : [ |- Type]"
                ],
                "tactic_res": [
                    "c2_goal : forall (A B C : Type) (f : mon (prod A B))\n  (g : forall (_ : A) (_ : B), mon C) (z : C) (s1 s3 : state)\n  (i : state_incr s1 s3)\n  (_ : eq (bind f (fun xy : prod A B => g (fst xy) (snd xy)) s1)\n         (OK z s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (A B C : Type) (f : mon (prod A B))\n  (g : forall (_ : A) (_ : B), mon C) (z : C) (s1 s3 : state)\n  (i : state_incr s1 s3)\n  (_ : eq (bind f (fun xy : prod A B => g (fst xy) (snd xy)) s1)\n         (OK z s3 i)),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))",
                    "c3_A : Type",
                    "c3_B : Type",
                    "c3_C : Type",
                    "c3_f : mon (prod A B)",
                    "c3_g : forall (_ : A) (_ : B), mon C",
                    "c3_z : C",
                    "c3_s1 : state",
                    "c3_s3 : state",
                    "c3_i : state_incr s1 s3",
                    "c3_H : eq (bind f (fun xy : prod A B => g (fst xy) (snd xy)) s1) (OK z s3 i)"
                ]
            },
            {
                "tactic_sig": "exploit bind_inversion .",
                "tactic_sig_no_out_arg": "exploit bind_inversion .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ],
                "tactic_res": [
                    "c4_goal : eq (bind ?Goal1 ?Goal2 ?Goal4) (OK ?Goal3 ?Goal5 ?Goal6)",
                    "c5_goal : forall\n  _ : ex\n        (fun x : prod A B =>\n         ex\n           (fun s2 : state =>\n            ex\n              (fun i1 : state_incr s1 s2 =>\n               ex\n                 (fun i2 : state_incr s2 s3 =>\n                  and (eq (f s1) (OK x s2 i1))\n                    (eq\n                       ((fun xy : prod A B => g (fst xy) (snd xy)) x s2)\n                       (OK z s3 i2)))))),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : eq (bind ?Goal1 ?Goal2 ?Goal4) (OK ?Goal3 ?Goal5 ?Goal6)",
                    "c3_H : eq (bind f (fun xy : prod A B => g (fst xy) (snd xy)) s1) (OK z s3 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ [ _o _o ] [ _o [ _o [ _o [ _o _o ] ] ] ] ] .",
                "tactic_sig_no_out_arg": "intros [ [ x y ] [ s2 [ i1 [ i2 [ P Q ] ] ] ] ] .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : ex\n        (fun x : prod A B =>\n         ex\n           (fun s2 : state =>\n            ex\n              (fun i1 : state_incr s1 s2 =>\n               ex\n                 (fun i2 : state_incr s2 s3 =>\n                  and (eq (f s1) (OK x s2 i1))\n                    (eq\n                       ((fun xy : prod A B => g (fst xy) (snd xy)) x s2)\n                       (OK z s3 i2)))))),\nex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))"
                ],
                "tactic_res": [
                    "c6_goal : ex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))",
                    "c6_x : A",
                    "c6_y : B",
                    "c6_s2 : state",
                    "c6_i1 : state_incr s1 s2",
                    "c6_i2 : state_incr s2 s3",
                    "c6_P : eq (f s1) (OK (pair x y) s2 i1)",
                    "c6_Q : eq (g (fst (pair x y)) (snd (pair x y)) s2) (OK z s3 i2)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c6_Q : eq (g (fst (pair x y)) (snd (pair x y)) s2) (OK z s3 i2)"
                ],
                "tactic_res": [
                    "c6_Q : eq (g x y s2) (OK z s3 i2)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun x : A =>\n   ex\n     (fun y : B =>\n      ex\n        (fun s2 : state =>\n         ex\n           (fun i1 : state_incr s1 s2 =>\n            ex\n              (fun i2 : state_incr s2 s3 =>\n               and (eq (f s1) (OK (pair x y) s2 i1))\n                 (eq (g x y s2) (OK z s3 i2)))))))",
                    "c6_x : A"
                ],
                "tactic_res": [
                    "c7_goal : ex\n  (fun y : B =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK (pair x y) s2 i1))\n              (eq (g x y s2) (OK z s3 i2))))))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun y : B =>\n   ex\n     (fun s2 : state =>\n      ex\n        (fun i1 : state_incr s1 s2 =>\n         ex\n           (fun i2 : state_incr s2 s3 =>\n            and (eq (f s1) (OK (pair x y) s2 i1))\n              (eq (g x y s2) (OK z s3 i2))))))",
                    "c6_y : B"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun s2 : state =>\n   ex\n     (fun i1 : state_incr s1 s2 =>\n      ex\n        (fun i2 : state_incr s2 s3 =>\n         and (eq (f s1) (OK (pair x y) s2 i1))\n           (eq (g x y s2) (OK z s3 i2)))))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun s2 : state =>\n   ex\n     (fun i1 : state_incr s1 s2 =>\n      ex\n        (fun i2 : state_incr s2 s3 =>\n         and (eq (f s1) (OK (pair x y) s2 i1))\n           (eq (g x y s2) (OK z s3 i2)))))",
                    "c6_s2 : state"
                ],
                "tactic_res": [
                    "c9_goal : ex\n  (fun i1 : state_incr s1 s2 =>\n   ex\n     (fun i2 : state_incr s2 s3 =>\n      and (eq (f s1) (OK (pair x y) s2 i1))\n        (eq (g x y s2) (OK z s3 i2))))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun i1 : state_incr s1 s2 =>\n   ex\n     (fun i2 : state_incr s2 s3 =>\n      and (eq (f s1) (OK (pair x y) s2 i1))\n        (eq (g x y s2) (OK z s3 i2))))",
                    "c6_i1 : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c10_goal : ex\n  (fun i2 : state_incr s2 s3 =>\n   and (eq (f s1) (OK (pair x y) s2 i1)) (eq (g x y s2) (OK z s3 i2)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c10_goal : ex\n  (fun i2 : state_incr s2 s3 =>\n   and (eq (f s1) (OK (pair x y) s2 i1)) (eq (g x y s2) (OK z s3 i2)))",
                    "c6_i2 : state_incr s2 s3"
                ],
                "tactic_res": [
                    "c11_goal : and (eq (f s1) (OK (pair x y) s2 i1)) (eq (g x y s2) (OK z s3 i2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : and (eq (f s1) (OK (pair x y) s2 i1)) (eq (g x y s2) (OK z s3 i2))",
                    "c6_Q : eq (g x y s2) (OK z s3 i2)",
                    "c6_P : eq (f s1) (OK (pair x y) s2 i1)",
                    "c6_i2 : state_incr s2 s3",
                    "c6_i1 : state_incr s1 s2",
                    "c6_s2 : state",
                    "c6_y : B",
                    "c6_x : A",
                    "c3_s1 : state",
                    "c3_s3 : state",
                    "c3_z : C",
                    "c3_g : forall (_ : A) (_ : B), mon C",
                    "c3_f : mon (prod A B)",
                    "c3_C : Type",
                    "c3_B : Type",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "instr_at_incr",
        "proof": [
            {
                "tactic_sig": "Lemma instr_at_incr : forall s1 s2 n i , state_incr s1 s2 -> s1. ( st_code ) !n = Some i -> s2. ( st_code ) !n = Some i .",
                "tactic_sig_no_out_arg": "Lemma instr_at_incr : forall s1 s2 n i , state_incr s1 s2 -> s1. ( st_code ) !n = Some i -> s2. ( st_code ) !n = Some i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (n : positive) (i : instruction)\n  (_ : state_incr s1 s2) (_ : eq (PTree.get n (st_code s1)) (Some i)),\neq (PTree.get n (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (n : positive) (i : instruction)\n  (_ : state_incr s1 s2) (_ : eq (PTree.get n (st_code s1)) (Some i)),\neq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_n : positive",
                    "c2_i : instruction",
                    "c2_H : state_incr s1 s2",
                    "c2_H0 : eq (PTree.get n (st_code s1)) (Some i)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_H : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c2_H3 : forall pc : positive,\nor (eq (PTree.get pc (st_code s1)) None)\n  (eq (PTree.get pc (st_code s2)) (PTree.get pc (st_code s1)))",
                    "c2_H2 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H1 : Ple (st_nextnode s1) (st_nextnode s2)"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_H3 : forall pc : positive,\nor (eq (PTree.get pc (st_code s1)) None)\n  (eq (PTree.get pc (st_code s2)) (PTree.get pc (st_code s1)))",
                    "c2_n : positive",
                    "c2_H2 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H1 : Ple (st_nextnode s1) (st_nextnode s2)",
                    "c2_H0 : eq (PTree.get n (st_code s1)) (Some i)",
                    "c2_i : instruction",
                    "c2_s2 : state"
                ],
                "tactic_res": [
                    "c3_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c3_H : eq (PTree.get n (st_code s1)) None",
                    "c4_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c4_H : eq (PTree.get n (st_code s2)) (PTree.get n (st_code s1))"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c3_goal : eq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : eq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_fresh_absurd",
        "proof": [
            {
                "tactic_sig": "Lemma valid_fresh_absurd : forall r s , reg_valid r s -> reg_fresh r s -> False .",
                "tactic_sig_no_out_arg": "Lemma valid_fresh_absurd : forall r s , reg_valid r s -> reg_fresh r s -> False .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (r : reg) (s : state) (_ : reg_valid r s) (_ : reg_fresh r s),\nFalse"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros r s .",
                "tactic_args": [
                    "c1_goal : forall (r : reg) (s : state) (_ : reg_valid r s) (_ : reg_fresh r s),\nFalse"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : reg_valid r s) (_ : reg_fresh r s), False",
                    "c2_r : reg",
                    "c2_s : state"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c2_goal : forall (_ : reg_valid r s) (_ : reg_fresh r s), False",
                    "_global_reg_valid : forall (_ : reg) (_ : state), Prop",
                    "_global_reg_fresh : forall (_ : reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : Plt r (st_nextreg s)) (_ : not (Plt r (st_nextreg s))),\nFalse"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c3_goal : forall (_ : Plt r (st_nextreg s)) (_ : not (Plt r (st_nextreg s))),\nFalse",
                    "c2_r : reg"
                ],
                "tactic_res": [
                    "c4_goal : forall (p : positive) (_ : Plt (xI p) (st_nextreg s))\n  (_ : not (Plt (xI p) (st_nextreg s))), False",
                    "c5_goal : forall (p : positive) (_ : Plt (xO p) (st_nextreg s))\n  (_ : not (Plt (xO p) (st_nextreg s))), False",
                    "c6_goal : forall (_ : Plt 1 (st_nextreg s)) (_ : not (Plt 1 (st_nextreg s))),\nFalse"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c4_goal : forall (p : positive) (_ : Plt (xI p) (st_nextreg s))\n  (_ : not (Plt (xI p) (st_nextreg s))), False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c5_goal : forall (p : positive) (_ : Plt (xO p) (st_nextreg s))\n  (_ : not (Plt (xO p) (st_nextreg s))), False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c6_goal : forall (_ : Plt 1 (st_nextreg s)) (_ : not (Plt 1 (st_nextreg s))),\nFalse"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_fresh_different",
        "proof": [
            {
                "tactic_sig": "Lemma valid_fresh_different : forall r1 r2 s , reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2 .",
                "tactic_sig_no_out_arg": "Lemma valid_fresh_different : forall r1 r2 s , reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (r1 r2 : reg) (s : state) (_ : reg_valid r1 s)\n  (_ : reg_fresh r2 s), not (eq r1 r2)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (r1 r2 : reg) (s : state) (_ : reg_valid r1 s)\n  (_ : reg_fresh r2 s), not (eq r1 r2)",
                    "_global_not : forall _ : Prop, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (r1 r2 : reg) (s : state) (_ : reg_valid r1 s)\n  (_ : reg_fresh r2 s) (_ : eq r1 r2), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (r1 r2 : reg) (s : state) (_ : reg_valid r1 s)\n  (_ : reg_fresh r2 s) (_ : eq r1 r2), False"
                ],
                "tactic_res": [
                    "c3_goal : False",
                    "c3_r1 : reg",
                    "c3_r2 : reg",
                    "c3_s : state",
                    "c3_H : reg_valid r1 s",
                    "c3_H0 : reg_fresh r2 s",
                    "c3_H1 : eq r1 r2"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_r2 : reg",
                    "c3_H1 : eq r1 r2"
                ],
                "tactic_res": [
                    "c3_H0 : reg_fresh r1 s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c3_goal : False",
                    "c3_H0 : reg_fresh r1 s",
                    "c3_H : reg_valid r1 s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reg_valid_incr",
        "proof": [
            {
                "tactic_sig": "Lemma reg_valid_incr : forall r s1 s2 , state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2 .",
                "tactic_sig_no_out_arg": "Lemma reg_valid_incr : forall r s1 s2 , state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n  (_ : reg_valid r s1), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros r s1 s2 INCR .",
                "tactic_args": [
                    "c1_goal : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n  (_ : reg_valid r s1), reg_valid r s2"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : reg_valid r s1, reg_valid r s2",
                    "c2_r : reg",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_INCR : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_INCR : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c2_H3 : eq s3 s2",
                    "c2_H2 : eq s0 s1",
                    "c2_H1 : forall pc : positive,\nor (eq (PTree.get pc (st_code s1)) None)\n  (eq (PTree.get pc (st_code s2)) (PTree.get pc (st_code s1)))",
                    "c2_H0 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H : Ple (st_nextnode s1) (st_nextnode s2)",
                    "c2_s3 : state",
                    "c2_s0 : state"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall _ : reg_valid r s1, reg_valid r s2",
                    "_global_reg_valid : forall (_ : reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : Plt r (st_nextreg s1), Plt r (st_nextreg s2)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall _ : Plt r (st_nextreg s1), Plt r (st_nextreg s2)"
                ],
                "tactic_res": [
                    "c4_goal : Plt r (st_nextreg s2)",
                    "c4_H4 : Plt r (st_nextreg s1)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c4_goal : Plt r (st_nextreg s2)",
                    "_global_Plt_Ple_trans : forall (p q r : positive) (_ : Plt p q) (_ : Ple q r), Plt p r",
                    "_global_st_nextreg : forall _ : state, positive",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c5_goal : Plt r (st_nextreg s1)",
                    "c6_goal : Ple (st_nextreg s1) (st_nextreg s2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : Plt r (st_nextreg s1)",
                    "c4_H4 : Plt r (st_nextreg s1)",
                    "c2_s1 : state",
                    "c2_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H0 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reg_fresh_decr",
        "proof": [
            {
                "tactic_sig": "Lemma reg_fresh_decr : forall r s1 s2 , state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1 .",
                "tactic_sig_no_out_arg": "Lemma reg_fresh_decr : forall r s1 s2 , state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n  (_ : reg_fresh r s2), reg_fresh r s1"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros r s1 s2 INCR .",
                "tactic_args": [
                    "c1_goal : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n  (_ : reg_fresh r s2), reg_fresh r s1"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : reg_fresh r s2, reg_fresh r s1",
                    "c2_r : reg",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_INCR : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_INCR : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c2_H3 : eq s3 s2",
                    "c2_H2 : eq s0 s1",
                    "c2_H1 : forall pc : positive,\nor (eq (PTree.get pc (st_code s1)) None)\n  (eq (PTree.get pc (st_code s2)) (PTree.get pc (st_code s1)))",
                    "c2_H0 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H : Ple (st_nextnode s1) (st_nextnode s2)",
                    "c2_s3 : state",
                    "c2_s0 : state"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall _ : reg_fresh r s2, reg_fresh r s1",
                    "_global_reg_fresh : forall (_ : reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : not (Plt r (st_nextreg s2)), not (Plt r (st_nextreg s1))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : forall _ : not (Plt r (st_nextreg s2)), not (Plt r (st_nextreg s1))",
                    "_global_not : forall _ : Prop, Prop"
                ],
                "tactic_res": [
                    "c4_goal : forall (_ : forall _ : Plt r (st_nextreg s2), False)\n  (_ : Plt r (st_nextreg s1)), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (_ : forall _ : Plt r (st_nextreg s2), False)\n  (_ : Plt r (st_nextreg s1)), False"
                ],
                "tactic_res": [
                    "c5_goal : False",
                    "c5_H4 : forall _ : Plt r (st_nextreg s2), False",
                    "c5_H5 : Plt r (st_nextreg s1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : False",
                    "c5_H4 : forall _ : Plt r (st_nextreg s2), False"
                ],
                "tactic_res": [
                    "c6_goal : Plt r (st_nextreg s2)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i _i ) .",
                "tactic_args": [
                    "c6_goal : Plt r (st_nextreg s2)",
                    "_global_Plt_Ple_trans : forall (p q r : positive) (_ : Plt p q) (_ : Ple q r), Plt p r",
                    "_global_st_nextreg : forall _ : state, positive",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c7_goal : Plt r (st_nextreg s1)",
                    "c8_goal : Ple (st_nextreg s1) (st_nextreg s2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Plt r (st_nextreg s1)",
                    "c5_H5 : Plt r (st_nextreg s1)",
                    "c2_s1 : state",
                    "c2_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_H0 : Ple (st_nextreg s1) (st_nextreg s2)",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "regs_valid_nil",
        "proof": [
            {
                "tactic_sig": "Lemma regs_valid_nil : forall s , regs_valid nil s .",
                "tactic_sig_no_out_arg": "Lemma regs_valid_nil : forall s , regs_valid nil s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall s : state, regs_valid nil s"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall s : state, regs_valid nil s"
                ],
                "tactic_res": [
                    "c2_goal : regs_valid nil s",
                    "c2_s : state"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : regs_valid nil s"
                ],
                "tactic_res": [
                    "c3_goal : forall (r : reg) (_ : In r nil), reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (r : reg) (_ : In r nil), reg_valid r s"
                ],
                "tactic_res": [
                    "c4_goal : reg_valid r s",
                    "c4_r : reg",
                    "c4_H : In r nil"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c4_goal : reg_valid r s",
                    "c4_H : In r nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "regs_valid_cons",
        "proof": [
            {
                "tactic_sig": "Lemma regs_valid_cons : forall r1 rl s , reg_valid r1 s -> regs_valid rl s -> regs_valid ( r1 :: rl ) s .",
                "tactic_sig_no_out_arg": "Lemma regs_valid_cons : forall r1 rl s , reg_valid r1 s -> regs_valid rl s -> regs_valid ( r1 :: rl ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (r1 : reg) (rl : list reg) (s : state) (_ : reg_valid r1 s)\n  (_ : regs_valid rl s), regs_valid (cons r1 rl) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (r1 : reg) (rl : list reg) (s : state) (_ : reg_valid r1 s)\n  (_ : regs_valid rl s), regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c2_goal : regs_valid (cons r1 rl) s",
                    "c2_r1 : reg",
                    "c2_rl : list reg",
                    "c2_s : state",
                    "c2_H : reg_valid r1 s",
                    "c2_H0 : regs_valid rl s"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c3_goal : forall (r : reg) (_ : In r (cons r1 rl)), reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (r : reg) (_ : In r (cons r1 rl)), reg_valid r s"
                ],
                "tactic_res": [
                    "c4_goal : reg_valid r s",
                    "c4_r : reg",
                    "c4_H1 : In r (cons r1 rl)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c4_goal : reg_valid r s",
                    "c4_H1 : In r (cons r1 rl)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq r1 r, reg_valid r s",
                    "c6_goal : forall _ : In r rl, reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c5_goal : forall _ : eq r1 r, reg_valid r s"
                ],
                "tactic_res": [
                    "c7_goal : reg_valid r s",
                    "c7_H2 : eq r1 r"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c6_goal : forall _ : In r rl, reg_valid r s"
                ],
                "tactic_res": [
                    "c8_goal : reg_valid r s",
                    "c8_H2 : In r rl"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c2_r1 : reg",
                    "c7_H2 : eq r1 r"
                ],
                "tactic_res": [
                    "c7_H : reg_valid r s",
                    "c7_H1 : In r (cons r rl)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : reg_valid r s",
                    "c7_H : reg_valid r s",
                    "c4_r : reg",
                    "c2_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : reg_valid r s",
                    "c8_H2 : In r rl",
                    "c4_r : reg",
                    "c2_H0 : regs_valid rl s",
                    "c2_s : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "regs_valid_app",
        "proof": [
            {
                "tactic_sig": "Lemma regs_valid_app : forall rl1 rl2 s , regs_valid rl1 s -> regs_valid rl2 s -> regs_valid ( rl1 ++ rl2 ) s .",
                "tactic_sig_no_out_arg": "Lemma regs_valid_app : forall rl1 rl2 s , regs_valid rl1 s -> regs_valid rl2 s -> regs_valid ( rl1 ++ rl2 ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (rl1 rl2 : list reg) (s : state) (_ : regs_valid rl1 s)\n  (_ : regs_valid rl2 s), regs_valid (app rl1 rl2) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (rl1 rl2 : list reg) (s : state) (_ : regs_valid rl1 s)\n  (_ : regs_valid rl2 s), regs_valid (app rl1 rl2) s"
                ],
                "tactic_res": [
                    "c2_goal : regs_valid (app rl1 rl2) s",
                    "c2_rl1 : list reg",
                    "c2_rl2 : list reg",
                    "c2_s : state",
                    "c2_H : regs_valid rl1 s",
                    "c2_H0 : regs_valid rl2 s"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : regs_valid (app rl1 rl2) s"
                ],
                "tactic_res": [
                    "c3_goal : forall (r : reg) (_ : In r (app rl1 rl2)), reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (r : reg) (_ : In r (app rl1 rl2)), reg_valid r s"
                ],
                "tactic_res": [
                    "c4_goal : reg_valid r s",
                    "c4_r : reg",
                    "c4_H1 : In r (app rl1 rl2)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_in_app_iff : forall (A : Type) (l l' : list A) (a : A),\n       iff (In a (app l l')) (or (In a l) (In a l'))",
                    "c4_H1 : In r (app rl1 rl2)"
                ],
                "tactic_res": [
                    "c4_H1 : or (In r rl1) (In r rl2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : reg_valid r s",
                    "c4_H1 : or (In r rl1) (In r rl2)",
                    "c4_r : reg",
                    "c2_H0 : regs_valid rl2 s",
                    "c2_H : regs_valid rl1 s",
                    "c2_s : state"
                ],
                "tactic_res": [
                    "c5_goal : reg_valid r s",
                    "c5_H1 : In r rl1",
                    "c6_goal : reg_valid r s",
                    "c6_H1 : In r rl2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : reg_valid r s",
                    "c5_H1 : In r rl1",
                    "c4_r : reg",
                    "c2_H : regs_valid rl1 s",
                    "c2_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : reg_valid r s",
                    "c6_H1 : In r rl2",
                    "c4_r : reg",
                    "c2_H0 : regs_valid rl2 s",
                    "c2_s : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "regs_valid_incr",
        "proof": [
            {
                "tactic_sig": "Lemma regs_valid_incr : forall s1 s2 rl , state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2 .",
                "tactic_sig_no_out_arg": "Lemma regs_valid_incr : forall s1 s2 rl , state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n  (_ : regs_valid rl s1), regs_valid rl s2"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n  (_ : regs_valid rl s1), regs_valid rl s2",
                    "_global_regs_valid : forall (_ : list reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n  (_ : forall (r : reg) (_ : In r rl), reg_valid r s1) \n  (r : reg) (_ : In r rl), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n  (_ : forall (r : reg) (_ : In r rl), reg_valid r s1) \n  (r : reg) (_ : In r rl), reg_valid r s2"
                ],
                "tactic_res": [
                    "c3_goal : reg_valid r s2",
                    "c3_s1 : state",
                    "c3_s2 : state",
                    "c3_rl : list reg",
                    "c3_H : state_incr s1 s2",
                    "c3_H0 : forall (r : reg) (_ : In r rl), reg_valid r s1",
                    "c3_r : reg",
                    "c3_H1 : In r rl"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c3_goal : reg_valid r s2",
                    "c3_H1 : In r rl",
                    "c3_r : reg",
                    "c3_H0 : forall (r : reg) (_ : In r rl), reg_valid r s1",
                    "c3_H : state_incr s1 s2",
                    "c3_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "map_valid_incr",
        "proof": [
            {
                "tactic_sig": "Lemma map_valid_incr : forall s1 s2 m , state_incr s1 s2 -> map_valid m s1 -> map_valid m s2 .",
                "tactic_sig_no_out_arg": "Lemma map_valid_incr : forall s1 s2 m , state_incr s1 s2 -> map_valid m s1 -> map_valid m s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (m : mapping) (_ : state_incr s1 s2)\n  (_ : map_valid m s1), map_valid m s2"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (m : mapping) (_ : state_incr s1 s2)\n  (_ : map_valid m s1), map_valid m s2",
                    "_global_map_valid : forall (_ : mapping) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (s1 s2 : state) (m : mapping) (_ : state_incr s1 s2)\n  (_ : forall (r : reg) (_ : reg_in_map m r), reg_valid r s1) \n  (r : reg) (_ : reg_in_map m r), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (m : mapping) (_ : state_incr s1 s2)\n  (_ : forall (r : reg) (_ : reg_in_map m r), reg_valid r s1) \n  (r : reg) (_ : reg_in_map m r), reg_valid r s2"
                ],
                "tactic_res": [
                    "c3_goal : reg_valid r s2",
                    "c3_s1 : state",
                    "c3_s2 : state",
                    "c3_m : mapping",
                    "c3_H : state_incr s1 s2",
                    "c3_H0 : forall (r : reg) (_ : reg_in_map m r), reg_valid r s1",
                    "c3_r : reg",
                    "c3_H1 : reg_in_map m r"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c3_goal : reg_valid r s2",
                    "c3_H1 : reg_in_map m r",
                    "c3_r : reg",
                    "c3_H0 : forall (r : reg) (_ : reg_in_map m r), reg_valid r s1",
                    "c3_H : state_incr s1 s2",
                    "c3_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_instr_at",
        "proof": [
            {
                "tactic_sig": "Lemma add_instr_at : forall s1 s2 incr i n , add_instr i s1 = OK n s2 incr -> s2. ( st_code ) !n = Some i .",
                "tactic_sig_no_out_arg": "Lemma add_instr_at : forall s1 s2 incr i n , add_instr i s1 = OK n s2 incr -> s2. ( st_code ) !n = Some i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (incr : state_incr s1 s2) (i : instruction)\n  (n : node) (_ : eq (add_instr i s1) (OK n s2 incr)),\neq (PTree.get n (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (incr : state_incr s1 s2) (i : instruction)\n  (n : node) (_ : eq (add_instr i s1) (OK n s2 incr)),\neq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_incr : state_incr s1 s2",
                    "c2_i : instruction",
                    "c2_n : node",
                    "c2_H : eq (add_instr i s1) (OK n s2 incr)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_H : eq (add_instr i s1) (OK n s2 incr)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (PTree.get (st_nextnode s1)\n     (st_code\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := Pos.succ (st_nextnode s1);\n          st_code := PTree.set (st_nextnode s1) i (st_code s1);\n          st_wf := add_instr_wf s1 i\n        |})) (Some i)",
                    "c3_incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := Pos.succ (st_nextnode s1);\n    st_code := PTree.set (st_nextnode s1) i (st_code s1);\n    st_wf := add_instr_wf s1 i\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq\n  (PTree.get (st_nextnode s1)\n     (st_code\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := Pos.succ (st_nextnode s1);\n          st_code := PTree.set (st_nextnode s1) i (st_code s1);\n          st_wf := add_instr_wf s1 i\n        |})) (Some i)"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (PTree.get (st_nextnode s1)\n     (PTree.set (st_nextnode s1) i (st_code s1))) \n  (Some i)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : eq\n  (PTree.get (st_nextnode s1)\n     (PTree.set (st_nextnode s1) i (st_code s1))) \n  (Some i)",
                    "_global_PTree.gss : forall (A : Type) (i : positive) (x : A) (m : PTree.tree A),\n       eq (PTree.get i (PTree.set i x m)) (Some x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "update_instr_at",
        "proof": [
            {
                "tactic_sig": "Lemma update_instr_at : forall n i s1 s2 incr u , update_instr n i s1 = OK u s2 incr -> s2. ( st_code ) !n = Some i .",
                "tactic_sig_no_out_arg": "Lemma update_instr_at : forall n i s1 s2 incr u , update_instr n i s1 = OK u s2 incr -> s2. ( st_code ) !n = Some i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : node) (i : instruction) (s1 s2 : state)\n  (incr : state_incr s1 s2) (u : unit)\n  (_ : eq (update_instr n i s1) (OK u s2 incr)),\neq (PTree.get n (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (n : node) (i : instruction) (s1 s2 : state)\n  (incr : state_incr s1 s2) (u : unit)\n  (_ : eq (update_instr n i s1) (OK u s2 incr)),\neq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_n : node",
                    "c2_i : instruction",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_incr : state_incr s1 s2",
                    "c2_u : unit",
                    "c2_H : eq (update_instr n i s1) (OK u s2 incr)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_update_instr : forall (_ : node) (_ : instruction), mon unit",
                    "c2_H : eq (update_instr n i s1) (OK u s2 incr)"
                ],
                "tactic_res": [
                    "c2_H : eq\n  match plt n (st_nextnode s1) with\n  | left LT =>\n      match check_empty_node s1 n with\n      | left EMPTY =>\n          OK tt\n            {|\n              st_nextreg := st_nextreg s1;\n              st_nextnode := st_nextnode s1;\n              st_code := PTree.set n i (st_code s1);\n              st_wf := update_instr_wf s1 n i LT\n            |} (update_instr_incr s1 n i LT EMPTY)\n      | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n      end\n  | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n  end (OK u s2 incr)"
                ]
            },
            {
                "tactic_sig": "destruct ( plt _i ( st_nextnode _i ) ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( plt _i ( st_nextnode _i ) ) .",
                "tactic_args": [
                    "c2_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_n : node",
                    "c2_s1 : state",
                    "c2_H : eq\n  match plt n (st_nextnode s1) with\n  | left LT =>\n      match check_empty_node s1 n with\n      | left EMPTY =>\n          OK tt\n            {|\n              st_nextreg := st_nextreg s1;\n              st_nextnode := st_nextnode s1;\n              st_code := PTree.set n i (st_code s1);\n              st_wf := update_instr_wf s1 n i LT\n            |} (update_instr_incr s1 n i LT EMPTY)\n      | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n      end\n  | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n  end (OK u s2 incr)",
                    "c2_s2 : state",
                    "c2_i : instruction"
                ],
                "tactic_res": [
                    "c3_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c3_H : eq\n  match check_empty_node s1 n with\n  | left EMPTY =>\n      OK tt\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := st_nextnode s1;\n          st_code := PTree.set n i (st_code s1);\n          st_wf := update_instr_wf s1 n i p\n        |} (update_instr_incr s1 n i p EMPTY)\n  | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n  end (OK u s2 incr)",
                    "c3_p : Plt n (st_nextnode s1)",
                    "c4_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c4_H : eq (Error (Errors.msg \"RTLgen.update_instr\")) (OK u s2 incr)",
                    "c4_n0 : not (Plt n (st_nextnode s1))"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c4_goal : eq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( check_empty_node _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( check_empty_node _i _i ) .",
                "tactic_args": [
                    "c3_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c2_s1 : state",
                    "c2_n : node",
                    "c3_H : eq\n  match check_empty_node s1 n with\n  | left EMPTY =>\n      OK tt\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := st_nextnode s1;\n          st_code := PTree.set n i (st_code s1);\n          st_wf := update_instr_wf s1 n i p\n        |} (update_instr_incr s1 n i p EMPTY)\n  | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n  end (OK u s2 incr)",
                    "c2_s2 : state",
                    "c2_i : instruction"
                ],
                "tactic_res": [
                    "c5_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c5_H : eq\n  (OK tt\n     {|\n       st_nextreg := st_nextreg s1;\n       st_nextnode := st_nextnode s1;\n       st_code := PTree.set n i (st_code s1);\n       st_wf := update_instr_wf s1 n i p\n     |} (update_instr_incr s1 n i p e)) (OK u s2 incr)",
                    "c5_e : eq (PTree.get n (st_code s1)) None",
                    "c6_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c6_H : eq (Error (Errors.msg \"RTLgen.update_instr\")) (OK u s2 incr)",
                    "c6_t : True"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : eq (PTree.get n (st_code s2)) (Some i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : eq (PTree.get n (st_code s2)) (Some i)",
                    "c5_H : eq\n  (OK tt\n     {|\n       st_nextreg := st_nextreg s1;\n       st_nextnode := st_nextnode s1;\n       st_code := PTree.set n i (st_code s1);\n       st_wf := update_instr_wf s1 n i p\n     |} (update_instr_incr s1 n i p e)) (OK u s2 incr)"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (PTree.get n\n     (st_code\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := st_nextnode s1;\n          st_code := PTree.set n i (st_code s1);\n          st_wf := update_instr_wf s1 n i p\n        |})) (Some i)",
                    "c7_incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := st_nextnode s1;\n    st_code := PTree.set n i (st_code s1);\n    st_wf := update_instr_wf s1 n i p\n  |}"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : eq\n  (PTree.get n\n     (st_code\n        {|\n          st_nextreg := st_nextreg s1;\n          st_nextnode := st_nextnode s1;\n          st_code := PTree.set n i (st_code s1);\n          st_wf := update_instr_wf s1 n i p\n        |})) (Some i)"
                ],
                "tactic_res": [
                    "c8_goal : eq (PTree.get n (PTree.set n i (st_code s1))) (Some i)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq (PTree.get n (PTree.set n i (st_code s1))) (Some i)",
                    "_global_PTree.gss : forall (A : Type) (i : positive) (x : A) (m : PTree.tree A),\n       eq (PTree.get i (PTree.set i x m)) (Some x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "new_reg_valid",
        "proof": [
            {
                "tactic_sig": "Lemma new_reg_valid : forall s1 s2 r i , new_reg s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_sig_no_out_arg": "Lemma new_reg_valid : forall s1 s2 r i , new_reg s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_valid r s2"
                ],
                "tactic_res": [
                    "c2_goal : reg_valid r s2",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_r : reg",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (new_reg s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : reg_valid r s2",
                    "c2_H : eq (new_reg s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c3_goal : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c3_i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "_global_reg_valid : forall (_ : reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c4_goal : Plt (st_nextreg s1)\n  (st_nextreg\n     {|\n       st_nextreg := Pos.succ (st_nextreg s1);\n       st_nextnode := st_nextnode s1;\n       st_code := st_code s1;\n       st_wf := st_wf s1\n     |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : Plt (st_nextreg s1)\n  (st_nextreg\n     {|\n       st_nextreg := Pos.succ (st_nextreg s1);\n       st_nextnode := st_nextnode s1;\n       st_code := st_code s1;\n       st_wf := st_wf s1\n     |})"
                ],
                "tactic_res": [
                    "c5_goal : Plt (st_nextreg s1) (Pos.succ (st_nextreg s1))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : Plt (st_nextreg s1) (Pos.succ (st_nextreg s1))",
                    "_global_Plt_succ : forall x : positive, Plt x (Pos.succ x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "new_reg_fresh",
        "proof": [
            {
                "tactic_sig": "Lemma new_reg_fresh : forall s1 s2 r i , new_reg s1 = OK r s2 i -> reg_fresh r s1 .",
                "tactic_sig_no_out_arg": "Lemma new_reg_fresh : forall s1 s2 r i , new_reg s1 = OK r s2 i -> reg_fresh r s1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_fresh r s1"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_fresh r s1"
                ],
                "tactic_res": [
                    "c2_goal : reg_fresh r s1",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_r : reg",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (new_reg s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : reg_fresh r s1",
                    "c2_H : eq (new_reg s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c3_goal : reg_fresh (st_nextreg s1) s1",
                    "c3_i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : reg_fresh (st_nextreg s1) s1",
                    "_global_reg_fresh : forall (_ : reg) (_ : state), Prop"
                ],
                "tactic_res": [
                    "c4_goal : not (Plt (st_nextreg s1) (st_nextreg s1))"
                ]
            },
            {
                "tactic_sig": "exact ( Plt_strict _ ) .",
                "tactic_sig_no_out_arg": "exact ( Plt_strict _ ) .",
                "tactic_args": [
                    "c4_goal : not (Plt (st_nextreg s1) (st_nextreg s1))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "new_reg_not_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma new_reg_not_in_map : forall s1 s2 m r i , new_reg s1 = OK r s2 i -> map_valid m s1 -> ~ ( reg_in_map m r ) .",
                "tactic_sig_no_out_arg": "Lemma new_reg_not_in_map : forall s1 s2 m r i , new_reg s1 = OK r s2 i -> map_valid m s1 -> ~ ( reg_in_map m r ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (m : mapping) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid m s1),\nnot (reg_in_map m r)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (m : mapping) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid m s1),\nnot (reg_in_map m r)",
                    "_global_not : forall _ : Prop, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (s1 s2 : state) (m : mapping) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid m s1)\n  (_ : reg_in_map m r), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (m : mapping) (r : reg) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid m s1)\n  (_ : reg_in_map m r), False"
                ],
                "tactic_res": [
                    "c3_goal : False",
                    "c3_s1 : state",
                    "c3_s2 : state",
                    "c3_m : mapping",
                    "c3_r : reg",
                    "c3_i : state_incr s1 s2",
                    "c3_H : eq (new_reg s1) (OK r s2 i)",
                    "c3_H0 : map_valid m s1",
                    "c3_H1 : reg_in_map m r"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c3_goal : False",
                    "c3_H1 : reg_in_map m r",
                    "c3_H0 : map_valid m s1",
                    "c3_H : eq (new_reg s1) (OK r s2 i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "init_mapping_valid",
        "proof": [
            {
                "tactic_sig": "Lemma init_mapping_valid : forall s , map_valid init_mapping s .",
                "tactic_sig_no_out_arg": "Lemma init_mapping_valid : forall s , map_valid init_mapping s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall s : state, map_valid init_mapping s"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall s : state, map_valid init_mapping s",
                    "_global_map_valid : forall (_ : mapping) (_ : state), Prop",
                    "_global_init_mapping : mapping"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : state) (r : reg)\n  (_ : reg_in_map {| map_vars := PTree.empty reg; map_letvars := nil |}\n         r), reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intros _o _o [ [ _o _o ] | _o ] .",
                "tactic_sig_no_out_arg": "intros s r [ [ id A ] | B ] .",
                "tactic_args": [
                    "c2_goal : forall (s : state) (r : reg)\n  (_ : reg_in_map {| map_vars := PTree.empty reg; map_letvars := nil |}\n         r), reg_valid r s"
                ],
                "tactic_res": [
                    "c3_goal : reg_valid r s",
                    "c4_s : state",
                    "c4_r : reg",
                    "c4_B : In r\n  (map_letvars {| map_vars := PTree.empty reg; map_letvars := nil |})",
                    "c4_goal : reg_valid r s",
                    "c3_s : state",
                    "c3_r : reg",
                    "c3_id : positive",
                    "c3_A : eq\n  (PTree.get id\n     (map_vars {| map_vars := PTree.empty reg; map_letvars := nil |}))\n  (Some r)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c3_A : eq\n  (PTree.get id\n     (map_vars {| map_vars := PTree.empty reg; map_letvars := nil |}))\n  (Some r)"
                ],
                "tactic_res": [
                    "c3_A : eq (PTree.get id (PTree.empty reg)) (Some r)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_PTree.gempty : forall (A : Type) (i : positive),\n       eq (PTree.get i (PTree.empty A)) None",
                    "c3_A : eq (PTree.get id (PTree.empty reg)) (Some r)"
                ],
                "tactic_res": [
                    "c3_A : eq None (Some r)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c3_goal : reg_valid r s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c4_B : In r\n  (map_letvars {| map_vars := PTree.empty reg; map_letvars := nil |})"
                ],
                "tactic_res": [
                    "c4_B : False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c4_goal : reg_valid r s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_var_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma find_var_in_map : forall s1 s2 map name r i , find_var map name s1 = OK r s2 i -> reg_in_map map r .",
                "tactic_sig_no_out_arg": "Lemma find_var_in_map : forall s1 s2 map name r i , find_var map name s1 = OK r s2 i -> reg_in_map map r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)), reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until r .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)), reg_in_map map r"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)), reg_in_map map r",
                    "c2_r : reg",
                    "c2_name : ident",
                    "c2_map : mapping",
                    "c2_s2 : state",
                    "c2_s1 : state"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)), reg_in_map map r",
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : state_incr s1 s2)\n  (_ : eq\n         (match PTree.get name (map_vars map) with\n          | Some r => ret r\n          | None =>\n              error\n                (cons (Errors.MSG \"RTLgen: unbound variable \")\n                   (cons (Errors.CTX name) nil))\n          end s1) (OK r s2 i)), reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "caseEq ( map. ( map_vars ) !name ) .",
                "tactic_sig_no_out_arg": "caseEq ( map. ( map_vars ) !name ) .",
                "tactic_args": [
                    "c3_goal : forall (i : state_incr s1 s2)\n  (_ : eq\n         (match PTree.get name (map_vars map) with\n          | Some r => ret r\n          | None =>\n              error\n                (cons (Errors.MSG \"RTLgen: unbound variable \")\n                   (cons (Errors.CTX name) nil))\n          end s1) (OK r s2 i)), reg_in_map map r"
                ],
                "tactic_res": [
                    "c4_goal : forall (r0 : reg) (_ : eq (PTree.get name (map_vars map)) (Some r0))\n  (i : state_incr s1 s2) (_ : eq (ret r0 s1) (OK r s2 i)),\nreg_in_map map r",
                    "c5_goal : forall (_ : eq (PTree.get name (map_vars map)) None)\n  (i : state_incr s1 s2)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX name) nil)) s1) (OK r s2 i)),\nreg_in_map map r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (r0 : reg) (_ : eq (PTree.get name (map_vars map)) (Some r0))\n  (i : state_incr s1 s2) (_ : eq (ret r0 s1) (OK r s2 i)),\nreg_in_map map r"
                ],
                "tactic_res": [
                    "c6_goal : reg_in_map map r",
                    "c6_r0 : reg",
                    "c6_H : eq (PTree.get name (map_vars map)) (Some r0)",
                    "c6_i : state_incr s1 s2",
                    "c6_H0 : eq (ret r0 s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_H0 : eq (ret r0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c6_i : state_incr s2 s2",
                    "c6_H : eq (PTree.get name (map_vars map)) (Some r)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c6_goal : reg_in_map map r"
                ],
                "tactic_res": [
                    "c7_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some r))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c7_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some r))",
                    "c2_name : ident"
                ],
                "tactic_res": [
                    "c8_goal : eq (PTree.get name (map_vars map)) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (PTree.get name (map_vars map)) (Some r)",
                    "c6_H : eq (PTree.get name (map_vars map)) (Some r)",
                    "c2_r : reg",
                    "c2_name : ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (_ : eq (PTree.get name (map_vars map)) None)\n  (i : state_incr s1 s2)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX name) nil)) s1) (OK r s2 i)),\nreg_in_map map r"
                ],
                "tactic_res": [
                    "c9_goal : reg_in_map map r",
                    "c9_H : eq (PTree.get name (map_vars map)) None",
                    "c9_i : state_incr s1 s2",
                    "c9_H0 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX name) nil)) s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : reg_in_map map r",
                    "c9_H0 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX name) nil)) s1) (OK r s2 i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_var_valid",
        "proof": [
            {
                "tactic_sig": "Lemma find_var_valid : forall s1 s2 map name r i , find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 .",
                "tactic_sig_no_out_arg": "Lemma find_var_valid : forall s1 s2 map name r i , find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)) (_ : map_valid map s1),\nreg_valid r s1"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_var map name s1) (OK r s2 i)) (_ : map_valid map s1),\nreg_valid r s1"
                ],
                "tactic_res": [
                    "c2_goal : reg_valid r s1",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_map : mapping",
                    "c2_name : ident",
                    "c2_r : reg",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (find_var map name s1) (OK r s2 i)",
                    "c2_H0 : map_valid map s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c2_goal : reg_valid r s1",
                    "c2_H0 : map_valid map s1",
                    "c2_H : eq (find_var map name s1) (OK r s2 i)",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_letvar_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma find_letvar_in_map : forall s1 s2 map idx r i , find_letvar map idx s1 = OK r s2 i -> reg_in_map map r .",
                "tactic_sig_no_out_arg": "Lemma find_letvar_in_map : forall s1 s2 map idx r i , find_letvar map idx s1 = OK r s2 i -> reg_in_map map r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (idx : nat) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)), reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until r .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (idx : nat) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)), reg_in_map map r"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)), reg_in_map map r",
                    "c2_r : reg",
                    "c2_idx : nat",
                    "c2_map : mapping",
                    "c2_s2 : state",
                    "c2_s1 : state"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)), reg_in_map map r",
                    "_global_find_letvar : forall (_ : mapping) (_ : nat), mon reg"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : state_incr s1 s2)\n  (_ : eq\n         (match nth_error (map_letvars map) idx with\n          | Some r => ret r\n          | None => error (Errors.msg \"RTLgen: unbound let variable\")\n          end s1) (OK r s2 i)), reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_sig_no_out_arg": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_args": [
                    "c3_goal : forall (i : state_incr s1 s2)\n  (_ : eq\n         (match nth_error (map_letvars map) idx with\n          | Some r => ret r\n          | None => error (Errors.msg \"RTLgen: unbound let variable\")\n          end s1) (OK r s2 i)), reg_in_map map r",
                    "c2_map : mapping",
                    "c2_idx : nat"
                ],
                "tactic_res": [
                    "c4_goal : forall (r0 : reg) (_ : eq (nth_error (map_letvars map) idx) (Some r0))\n  (i : state_incr s1 s2) (_ : eq (ret r0 s1) (OK r s2 i)),\nreg_in_map map r",
                    "c5_goal : forall (_ : eq (nth_error (map_letvars map) idx) None)\n  (i : state_incr s1 s2)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1)\n         (OK r s2 i)), reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (r0 : reg) (_ : eq (nth_error (map_letvars map) idx) (Some r0))\n  (i : state_incr s1 s2) (_ : eq (ret r0 s1) (OK r s2 i)),\nreg_in_map map r"
                ],
                "tactic_res": [
                    "c6_goal : reg_in_map map r",
                    "c6_r0 : reg",
                    "c6_H : eq (nth_error (map_letvars map) idx) (Some r0)",
                    "c6_i : state_incr s1 s2",
                    "c6_H0 : eq (ret r0 s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_H0 : eq (ret r0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c6_i : state_incr s2 s2",
                    "c6_H : eq (nth_error (map_letvars map) idx) (Some r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (_ : eq (nth_error (map_letvars map) idx) None)\n  (i : state_incr s1 s2)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1)\n         (OK r s2 i)), reg_in_map map r"
                ],
                "tactic_res": [
                    "c7_goal : reg_in_map map r",
                    "c7_H : eq (nth_error (map_letvars map) idx) None",
                    "c7_i : state_incr s1 s2",
                    "c7_H0 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c7_goal : reg_in_map map r",
                    "c7_H0 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1) (OK r s2 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c6_goal : reg_in_map map r"
                ],
                "tactic_res": [
                    "c8_goal : In r (map_letvars map)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c8_goal : In r (map_letvars map)",
                    "_global_nth_error_in : forall (A : Type) (n : nat) (l : list A) (x : A)\n         (_ : eq (nth_error l n) (Some x)), In x l",
                    "c2_idx : nat"
                ],
                "tactic_res": [
                    "c9_goal : eq (nth_error (map_letvars map) idx) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (nth_error (map_letvars map) idx) (Some r)",
                    "c6_H : eq (nth_error (map_letvars map) idx) (Some r)",
                    "c2_r : reg",
                    "c2_idx : nat",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_letvar_valid",
        "proof": [
            {
                "tactic_sig": "Lemma find_letvar_valid : forall s1 s2 map idx r i , find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 .",
                "tactic_sig_no_out_arg": "Lemma find_letvar_valid : forall s1 s2 map idx r i , find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (idx : nat) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)) (_ : map_valid map s1),\nreg_valid r s1"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (idx : nat) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (find_letvar map idx s1) (OK r s2 i)) (_ : map_valid map s1),\nreg_valid r s1"
                ],
                "tactic_res": [
                    "c2_goal : reg_valid r s1",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_map : mapping",
                    "c2_idx : nat",
                    "c2_r : reg",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (find_letvar map idx s1) (OK r s2 i)",
                    "c2_H0 : map_valid map s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c2_goal : reg_valid r s1",
                    "c2_H0 : map_valid map s1",
                    "c2_H : eq (find_letvar map idx s1) (OK r s2 i)",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_var_valid",
        "proof": [
            {
                "tactic_sig": "Lemma add_var_valid : forall s1 s2 map1 map2 name r i , add_var map1 name s1 = OK ( r , map2 ) s2 i -> map_valid map1 s1 -> reg_valid r s2 /\\ map_valid map2 s2 .",
                "tactic_sig_no_out_arg": "Lemma add_var_valid : forall s1 s2 map1 map2 name r i , add_var map1 name s1 = OK ( r , map2 ) s2 i -> map_valid map1 s1 -> reg_valid r s2 /\\ map_valid map2 s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map1 map2 : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (add_var map1 name s1) (OK (pair r map2) s2 i))\n  (_ : map_valid map1 s1), and (reg_valid r s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map1 map2 : mapping) (name : ident) \n  (r : reg) (i : state_incr s1 s2)\n  (_ : eq (add_var map1 name s1) (OK (pair r map2) s2 i))\n  (_ : map_valid map1 s1), and (reg_valid r s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c2_goal : and (reg_valid r s2) (map_valid map2 s2)",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_map1 : mapping",
                    "c2_map2 : mapping",
                    "c2_name : ident",
                    "c2_r : reg",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (add_var map1 name s1) (OK (pair r map2) s2 i)",
                    "c2_H0 : map_valid map1 s1"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : and (reg_valid r s2) (map_valid map2 s2)",
                    "c2_H : eq (add_var map1 name s1) (OK (pair r map2) s2 i)"
                ],
                "tactic_res": [
                    "c3_goal : and (reg_valid r s2)\n  (map_valid\n     {|\n       map_vars := PTree.set name r (map_vars map1);\n       map_letvars := map_letvars map1\n     |} s2)",
                    "c3_INCR0 : state_incr s2 s2",
                    "c3_EQ : eq (new_reg s1) (OK r s2 INCR)",
                    "c3_INCR : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c3_goal : and (reg_valid r s2)\n  (map_valid\n     {|\n       map_vars := PTree.set name r (map_vars map1);\n       map_letvars := map_letvars map1\n     |} s2)"
                ],
                "tactic_res": [
                    "c4_goal : reg_valid r s2",
                    "c5_goal : map_valid\n  {|\n    map_vars := PTree.set name r (map_vars map1);\n    map_letvars := map_letvars map1\n  |} s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c4_goal : reg_valid r s2",
                    "c3_EQ : eq (new_reg s1) (OK r s2 INCR)",
                    "c2_r : reg",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c5_goal : map_valid\n  {|\n    map_vars := PTree.set name r (map_vars map1);\n    map_letvars := map_letvars map1\n  |} s2",
                    "c3_EQ : eq (new_reg s1) (OK r s2 INCR)"
                ],
                "tactic_res": [
                    "c6_goal : map_valid\n  {|\n    map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n    map_letvars := map_letvars map1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c6_H2 : eq\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} s2",
                    "c6_H1 : eq (st_nextreg s1) r"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c2_r : reg",
                    "c2_s2 : state",
                    "c6_H2 : eq\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} s2",
                    "c6_H1 : eq (st_nextreg s1) r"
                ],
                "tactic_res": [
                    "c6_EQ : eq (new_reg s1)\n  (OK (st_nextreg s1)\n     {|\n       st_nextreg := Pos.succ (st_nextreg s1);\n       st_nextnode := st_nextnode s1;\n       st_code := st_code s1;\n       st_wf := st_wf s1\n     |} INCR)",
                    "c6_INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c6_INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c6_i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : map_valid\n  {|\n    map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n    map_letvars := map_letvars map1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ],
                "tactic_res": [
                    "c7_goal : forall (r : reg)\n  (_ : reg_in_map\n         {|\n           map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n           map_letvars := map_letvars map1\n         |} r),\nreg_valid r\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ]
            },
            {
                "tactic_sig": "intros _o [ [ _o _o ] | _o ] .",
                "tactic_sig_no_out_arg": "intros r' [ [ id A ] | B ] .",
                "tactic_args": [
                    "c7_goal : forall (r : reg)\n  (_ : reg_in_map\n         {|\n           map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n           map_letvars := map_letvars map1\n         |} r),\nreg_valid r\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ],
                "tactic_res": [
                    "c8_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c9_r' : reg",
                    "c9_B : In r'\n  (map_letvars\n     {|\n       map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n       map_letvars := map_letvars map1\n     |})",
                    "c9_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c8_r' : reg",
                    "c8_id : positive",
                    "c8_A : eq\n  (PTree.get id\n     (map_vars\n        {|\n          map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n          map_letvars := map_letvars map1\n        |})) (Some r')"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c8_A : eq\n  (PTree.get id\n     (map_vars\n        {|\n          map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n          map_letvars := map_letvars map1\n        |})) (Some r')"
                ],
                "tactic_res": [
                    "c8_A : eq (PTree.get id (PTree.set name (st_nextreg s1) (map_vars map1)))\n  (Some r')"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_PTree.gsspec : forall (A : Type) (i j : positive) (x : A) (m : PTree.t A),\n       eq (PTree.get i (PTree.set j x m))\n         (if peq i j then Some x else PTree.get i m)",
                    "c8_A : eq (PTree.get id (PTree.set name (st_nextreg s1) (map_vars map1)))\n  (Some r')"
                ],
                "tactic_res": [
                    "c8_A : eq\n  (if peq id name\n   then Some (st_nextreg s1)\n   else PTree.get id (map_vars map1)) (Some r')"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c8_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c8_id : positive",
                    "c2_name : ident",
                    "c8_A : eq\n  (if peq id name\n   then Some (st_nextreg s1)\n   else PTree.get id (map_vars map1)) (Some r')",
                    "c8_r' : reg",
                    "c6_EQ : eq (new_reg s1)\n  (OK (st_nextreg s1)\n     {|\n       st_nextreg := Pos.succ (st_nextreg s1);\n       st_nextnode := st_nextnode s1;\n       st_code := st_code s1;\n       st_wf := st_wf s1\n     |} INCR)",
                    "c6_INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c2_H0 : map_valid map1 s1",
                    "c6_i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c10_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c10_A : eq (Some (st_nextreg s1)) (Some r')",
                    "c10_e : eq id name",
                    "c11_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c11_A : eq (PTree.get id (map_vars map1)) (Some r')",
                    "c11_n : not (eq id name)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c10_A : eq (Some (st_nextreg s1)) (Some r')"
                ],
                "tactic_res": [
                    "c12_goal : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c12_goal : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c6_EQ : eq (new_reg s1)\n  (OK (st_nextreg s1)\n     {|\n       st_nextreg := Pos.succ (st_nextreg s1);\n       st_nextnode := st_nextnode s1;\n       st_code := st_code s1;\n       st_wf := st_wf s1\n     |} INCR)",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c11_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "_global_reg_valid_incr : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n         (_ : reg_valid r s1), reg_valid r s2",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c13_goal : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c14_goal : reg_valid r' s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c13_goal : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : reg_valid r' s1",
                    "c2_H0 : map_valid map1 s1"
                ],
                "tactic_res": [
                    "c15_goal : reg_in_map map1 r'"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c15_goal : reg_in_map map1 r'"
                ],
                "tactic_res": [
                    "c16_goal : ex (fun id : positive => eq (PTree.get id (map_vars map1)) (Some r'))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c16_goal : ex (fun id : positive => eq (PTree.get id (map_vars map1)) (Some r'))",
                    "c8_id : positive"
                ],
                "tactic_res": [
                    "c17_goal : eq (PTree.get id (map_vars map1)) (Some r')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq (PTree.get id (map_vars map1)) (Some r')",
                    "c11_A : eq (PTree.get id (map_vars map1)) (Some r')",
                    "c8_id : positive",
                    "c8_r' : reg",
                    "c2_map1 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c9_B : In r'\n  (map_letvars\n     {|\n       map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n       map_letvars := map_letvars map1\n     |})"
                ],
                "tactic_res": [
                    "c9_B : In r' (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c9_goal : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "_global_reg_valid_incr : forall (r : reg) (s1 s2 : state) (_ : state_incr s1 s2)\n         (_ : reg_valid r s1), reg_valid r s2",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c18_goal : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c19_goal : reg_valid r' s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c18_goal : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : reg_valid r' s1",
                    "c2_H0 : map_valid map1 s1"
                ],
                "tactic_res": [
                    "c20_goal : reg_in_map map1 r'"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c20_goal : reg_in_map map1 r'"
                ],
                "tactic_res": [
                    "c21_goal : In r' (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : In r' (map_letvars map1)",
                    "c9_B : In r' (map_letvars map1)",
                    "c9_r' : reg",
                    "c2_map1 : mapping"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_var_find",
        "proof": [
            {
                "tactic_sig": "Lemma add_var_find : forall s1 s2 map name r map' i , add_var map name s1 = OK ( r , map' ) s2 i -> map'. ( map_vars ) !name = Some r .",
                "tactic_sig_no_out_arg": "Lemma add_var_find : forall s1 s2 map name r map' i , add_var map name s1 = OK ( r , map' ) s2 i -> map'. ( map_vars ) !name = Some r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (map' : mapping) (i : state_incr s1 s2)\n  (_ : eq (add_var map name s1) (OK (pair r map') s2 i)),\neq (PTree.get name (map_vars map')) (Some r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (map : mapping) (name : ident) \n  (r : reg) (map' : mapping) (i : state_incr s1 s2)\n  (_ : eq (add_var map name s1) (OK (pair r map') s2 i)),\neq (PTree.get name (map_vars map')) (Some r)"
                ],
                "tactic_res": [
                    "c2_goal : eq (PTree.get name (map_vars map')) (Some r)",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_map : mapping",
                    "c2_name : ident",
                    "c2_r : reg",
                    "c2_map' : mapping",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (add_var map name s1) (OK (pair r map') s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : eq (PTree.get name (map_vars map')) (Some r)",
                    "c2_H : eq (add_var map name s1) (OK (pair r map') s2 i)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (PTree.get name\n     (map_vars\n        {|\n          map_vars := PTree.set name r (map_vars map);\n          map_letvars := map_letvars map\n        |})) (Some r)",
                    "c3_INCR0 : state_incr s2 s2",
                    "c3_EQ : eq (new_reg s1) (OK r s2 INCR)",
                    "c3_INCR : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq\n  (PTree.get name\n     (map_vars\n        {|\n          map_vars := PTree.set name r (map_vars map);\n          map_letvars := map_letvars map\n        |})) (Some r)"
                ],
                "tactic_res": [
                    "c4_goal : eq (PTree.get name (PTree.set name r (map_vars map))) (Some r)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : eq (PTree.get name (PTree.set name r (map_vars map))) (Some r)",
                    "_global_PTree.gss : forall (A : Type) (i : positive) (x : A) (m : PTree.tree A),\n       eq (PTree.get i (PTree.set i x m)) (Some x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_vars_valid",
        "proof": [
            {
                "tactic_sig": "Lemma add_vars_valid : forall namel s1 s2 map1 map2 rl i , add_vars map1 namel s1 = OK ( rl , map2 ) s2 i -> map_valid map1 s1 -> regs_valid rl s2 /\\ map_valid map2 s2 .",
                "tactic_sig_no_out_arg": "Lemma add_vars_valid : forall namel s1 s2 map1 map2 rl i , add_vars map1 namel s1 = OK ( rl , map2 ) s2 i -> map_valid map1 s1 -> regs_valid rl s2 /\\ map_valid map2 s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (namel : list ident) (s1 s2 : state) (map1 map2 : mapping)\n  (rl : list reg) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro namel .",
                "tactic_args": [
                    "c1_goal : forall (namel : list ident) (s1 s2 : state) (map1 map2 : mapping)\n  (rl : list reg) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)",
                    "c2_namel : list ident"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)",
                    "c2_namel : list ident"
                ],
                "tactic_res": [
                    "c3_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 nil s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)",
                    "c4_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 (cons a namel) s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)",
                    "c4_IHnamel : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)",
                    "c4_a : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 nil s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c5_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c6_goal : and (regs_valid rl s2) (map_valid map2 s2)",
                    "c6_s1 : state",
                    "c6_s2 : state",
                    "c6_map1 : mapping",
                    "c6_map2 : mapping",
                    "c6_rl : list reg",
                    "c6_i : state_incr s1 s2",
                    "c6_H : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)",
                    "c6_H0 : map_valid map1 s1"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : and (regs_valid rl s2) (map_valid map2 s2)",
                    "c6_H : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)"
                ],
                "tactic_res": [
                    "c7_goal : and (regs_valid nil s2) (map_valid map2 s2)",
                    "c7_i : state_incr s2 s2",
                    "c7_H0 : map_valid map2 s2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 (cons a namel) s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c8_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq\n         (bind2 (add_vars map1 namel)\n            (fun (rl0 : list reg) (map3 : mapping) =>\n             bind2 (add_var map3 a)\n               (fun (r1 : reg) (map4 : mapping) =>\n                ret (pair (cons r1 rl0) map4))) s1)\n         (OK (pair rl map2) s2 i)) (_ : map_valid map1 s1),\nand (regs_valid rl s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq\n         (bind2 (add_vars map1 namel)\n            (fun (rl0 : list reg) (map3 : mapping) =>\n             bind2 (add_var map3 a)\n               (fun (r1 : reg) (map4 : mapping) =>\n                ret (pair (cons r1 rl0) map4))) s1)\n         (OK (pair rl map2) s2 i)) (_ : map_valid map1 s1),\nand (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c9_goal : and (regs_valid rl s2) (map_valid map2 s2)",
                    "c9_s1 : state",
                    "c9_s2 : state",
                    "c9_map1 : mapping",
                    "c9_map2 : mapping",
                    "c9_rl : list reg",
                    "c9_i : state_incr s1 s2",
                    "c9_H : eq\n  (bind2 (add_vars map1 namel)\n     (fun (rl : list reg) (map1 : mapping) =>\n      bind2 (add_var map1 a)\n        (fun (r1 : reg) (map2 : mapping) =>\n         ret (pair (cons r1 rl) map2))) s1) (OK (pair rl map2) s2 i)",
                    "c9_H0 : map_valid map1 s1"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c9_goal : and (regs_valid rl s2) (map_valid map2 s2)",
                    "c9_H : eq\n  (bind2 (add_vars map1 namel)\n     (fun (rl : list reg) (map1 : mapping) =>\n      bind2 (add_var map1 a)\n        (fun (r1 : reg) (map2 : mapping) =>\n         ret (pair (cons r1 rl) map2))) s1) (OK (pair rl map2) s2 i)"
                ],
                "tactic_res": [
                    "c10_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)",
                    "c10_INCR2 : state_incr s2 s2",
                    "c10_EQ1 : eq (add_var x0 a s) (OK (pair x1 map2) s2 INCR1)",
                    "c10_INCR1 : state_incr s s2",
                    "c10_x1 : reg",
                    "c10_EQ : eq (add_vars map1 namel s1) (OK (pair x x0) s INCR)",
                    "c10_INCR0 : state_incr s s2",
                    "c10_INCR : state_incr s1 s",
                    "c10_s : state",
                    "c10_x0 : mapping",
                    "c10_x : list reg"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (regs_valid nil s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c11_goal : regs_valid nil s2",
                    "c12_goal : map_valid map2 s2"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : regs_valid nil s2"
                ],
                "tactic_res": [
                    "c13_goal : forall (r : reg) (_ : In r nil), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : forall (r : reg) (_ : In r nil), reg_valid r s2"
                ],
                "tactic_res": [
                    "c14_goal : forall (r : reg) (_ : False), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (r : reg) (_ : False), reg_valid r s2"
                ],
                "tactic_res": [
                    "c15_goal : reg_valid r s2",
                    "c15_r : reg",
                    "c15_H : False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c15_goal : reg_valid r s2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : map_valid map2 s2",
                    "c7_H0 : map_valid map2 s2",
                    "c6_map2 : mapping",
                    "c6_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c10_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)",
                    "c4_IHnamel : forall (s1 s2 : state) (map1 map2 : mapping) (rl : list reg)\n  (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 namel s1) (OK (pair rl map2) s2 i))\n  (_ : map_valid map1 s1), and (regs_valid rl s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c16_goal : eq (add_vars ?Goal1 namel ?Goal)\n  (OK (pair ?Goal3 ?Goal2) ?Goal0 ?Goal4)",
                    "c17_goal : map_valid map1 s1",
                    "c18_goal : forall _ : and (regs_valid x s) (map_valid x0 s),\nand (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : eq (add_vars ?Goal1 namel ?Goal)\n  (OK (pair ?Goal3 ?Goal2) ?Goal0 ?Goal4)",
                    "c10_EQ : eq (add_vars map1 namel s1) (OK (pair x x0) s INCR)",
                    "c2_namel : list ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : map_valid map1 s1",
                    "c9_H0 : map_valid map1 s1",
                    "c9_map1 : mapping",
                    "c9_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c18_goal : forall _ : and (regs_valid x s) (map_valid x0 s),\nand (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c19_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)",
                    "c19_A : regs_valid x s",
                    "c19_B : map_valid x0 s"
                ]
            },
            {
                "tactic_sig": "exploit add_var_valid .",
                "tactic_sig_no_out_arg": "exploit add_var_valid .",
                "tactic_args": [
                    "c19_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c20_goal : eq (add_var ?Goal1 ?Goal3 ?Goal)\n  (OK (pair ?Goal4 ?Goal2) ?Goal0 ?Goal5)",
                    "c21_goal : map_valid x0 s",
                    "c22_goal : forall _ : and (reg_valid x1 s2) (map_valid map2 s2),\nand (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : eq (add_var ?Goal1 ?Goal3 ?Goal)\n  (OK (pair ?Goal4 ?Goal2) ?Goal0 ?Goal5)",
                    "c10_EQ1 : eq (add_var x0 a s) (OK (pair x1 map2) s2 INCR1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : map_valid x0 s",
                    "c19_B : map_valid x0 s",
                    "c10_s : state",
                    "c10_x0 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ C D ] .",
                "tactic_args": [
                    "c22_goal : forall _ : and (reg_valid x1 s2) (map_valid map2 s2),\nand (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c23_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)",
                    "c23_C : reg_valid x1 s2",
                    "c23_D : map_valid map2 s2"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c23_goal : and (regs_valid (cons x1 x) s2) (map_valid map2 s2)"
                ],
                "tactic_res": [
                    "c24_goal : regs_valid (cons x1 x) s2",
                    "c25_goal : map_valid map2 s2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : regs_valid (cons x1 x) s2",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c26_goal : reg_valid x1 s2",
                    "c27_goal : regs_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c26_goal : reg_valid x1 s2",
                    "c23_C : reg_valid x1 s2",
                    "c10_x1 : reg",
                    "c9_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c27_goal : regs_valid x s2",
                    "c19_A : regs_valid x s",
                    "c10_x : list reg",
                    "c9_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : map_valid map2 s2",
                    "c23_D : map_valid map2 s2",
                    "c9_map2 : mapping",
                    "c9_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_var_letenv",
        "proof": [
            {
                "tactic_sig": "Lemma add_var_letenv : forall map1 id s1 r map2 s2 i , add_var map1 id s1 = OK ( r , map2 ) s2 i -> map2. ( map_letvars ) = map1. ( map_letvars ) .",
                "tactic_sig_no_out_arg": "Lemma add_var_letenv : forall map1 id s1 r map2 s2 i , add_var map1 id s1 = OK ( r , map2 ) s2 i -> map2. ( map_letvars ) = map1. ( map_letvars ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map1 : mapping) (id : ident) (s1 : state) \n  (r : reg) (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_var map1 id s1) (OK (pair r map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (map1 : mapping) (id : ident) (s1 : state) \n  (r : reg) (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_var map1 id s1) (OK (pair r map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c2_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c2_map1 : mapping",
                    "c2_id : ident",
                    "c2_s1 : state",
                    "c2_r : reg",
                    "c2_map2 : mapping",
                    "c2_s2 : state",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (add_var map1 id s1) (OK (pair r map2) s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c2_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c2_H : eq (add_var map1 id s1) (OK (pair r map2) s2 i)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (map_letvars\n     {|\n       map_vars := PTree.set id r (map_vars map1);\n       map_letvars := map_letvars map1\n     |}) (map_letvars map1)",
                    "c3_INCR0 : state_incr s2 s2",
                    "c3_EQ : eq (new_reg s1) (OK r s2 INCR)",
                    "c3_INCR : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : eq\n  (map_letvars\n     {|\n       map_vars := PTree.set id r (map_vars map1);\n       map_letvars := map_letvars map1\n     |}) (map_letvars map1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_vars_letenv",
        "proof": [
            {
                "tactic_sig": "Lemma add_vars_letenv : forall il map1 s1 rl map2 s2 i , add_vars map1 il s1 = OK ( rl , map2 ) s2 i -> map2. ( map_letvars ) = map1. ( map_letvars ) .",
                "tactic_sig_no_out_arg": "Lemma add_vars_letenv : forall il map1 s1 rl map2 s2 i , add_vars map1 il s1 = OK ( rl , map2 ) s2 i -> map2. ( map_letvars ) = map1. ( map_letvars ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (il : list ident) (map1 : mapping) (s1 : state) \n  (rl : list reg) (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro il .",
                "tactic_args": [
                    "c1_goal : forall (il : list ident) (map1 : mapping) (s1 : state) \n  (rl : list reg) (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c2_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)",
                    "c2_il : list ident"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)",
                    "c2_il : list ident"
                ],
                "tactic_res": [
                    "c3_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 nil s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)",
                    "c4_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 (cons a il) s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)",
                    "c4_IHil : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)",
                    "c4_a : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 nil s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c5_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c6_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c6_map1 : mapping",
                    "c6_s1 : state",
                    "c6_rl : list reg",
                    "c6_map2 : mapping",
                    "c6_s2 : state",
                    "c6_i : state_incr s1 s2",
                    "c6_H : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c6_H : eq (ret (pair nil map1) s1) (OK (pair rl map2) s2 i)"
                ],
                "tactic_res": [
                    "c7_goal : eq (map_letvars map2) (map_letvars map2)",
                    "c7_i : state_incr s2 s2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 (cons a il) s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c8_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq\n         (bind2 (add_vars map1 il)\n            (fun (rl0 : list reg) (map3 : mapping) =>\n             bind2 (add_var map3 a)\n               (fun (r1 : reg) (map4 : mapping) =>\n                ret (pair (cons r1 rl0) map4))) s1)\n         (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq\n         (bind2 (add_vars map1 il)\n            (fun (rl0 : list reg) (map3 : mapping) =>\n             bind2 (add_var map3 a)\n               (fun (r1 : reg) (map4 : mapping) =>\n                ret (pair (cons r1 rl0) map4))) s1)\n         (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c9_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c9_map1 : mapping",
                    "c9_s1 : state",
                    "c9_rl : list reg",
                    "c9_map2 : mapping",
                    "c9_s2 : state",
                    "c9_i : state_incr s1 s2",
                    "c9_H : eq\n  (bind2 (add_vars map1 il)\n     (fun (rl : list reg) (map1 : mapping) =>\n      bind2 (add_var map1 a)\n        (fun (r1 : reg) (map2 : mapping) =>\n         ret (pair (cons r1 rl) map2))) s1) (OK (pair rl map2) s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c9_H : eq\n  (bind2 (add_vars map1 il)\n     (fun (rl : list reg) (map1 : mapping) =>\n      bind2 (add_var map1 a)\n        (fun (r1 : reg) (map2 : mapping) =>\n         ret (pair (cons r1 rl) map2))) s1) (OK (pair rl map2) s2 i)"
                ],
                "tactic_res": [
                    "c9_INCR2 : state_incr s2 s2",
                    "c9_EQ1 : eq (add_var x0 a s) (OK (pair x1 map2) s2 INCR1)",
                    "c9_INCR1 : state_incr s s2",
                    "c9_x1 : reg",
                    "c9_EQ : eq (add_vars map1 il s1) (OK (pair x x0) s INCR)",
                    "c9_INCR0 : state_incr s s2",
                    "c9_INCR : state_incr s1 s",
                    "c9_s : state",
                    "c9_x0 : mapping",
                    "c9_x : list reg"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c7_goal : eq (map_letvars map2) (map_letvars map2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "transitivity ( map_letvars _i ) .",
                "tactic_sig_no_out_arg": "transitivity ( map_letvars _i ) .",
                "tactic_args": [
                    "c9_goal : eq (map_letvars map2) (map_letvars map1)",
                    "c9_x0 : mapping"
                ],
                "tactic_res": [
                    "c10_goal : eq (map_letvars map2) (map_letvars x0)",
                    "c11_goal : eq (map_letvars x0) (map_letvars map1)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : eq (map_letvars map2) (map_letvars x0)",
                    "_global_add_var_letenv : forall (map1 : mapping) (id : ident) (s1 : state) \n         (r : reg) (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n         (_ : eq (add_var map1 id s1) (OK (pair r map2) s2 i)),\n       eq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": [
                    "c12_goal : eq (add_var x0 ?id ?s1) (OK (pair ?r map2) ?s2 ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : eq (add_var x0 ?id ?s1) (OK (pair ?r map2) ?s2 ?i)",
                    "c9_EQ1 : eq (add_var x0 a s) (OK (pair x1 map2) s2 INCR1)",
                    "c9_x0 : mapping",
                    "c9_map2 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : eq (map_letvars x0) (map_letvars map1)",
                    "c9_EQ : eq (add_vars map1 il s1) (OK (pair x x0) s INCR)",
                    "c9_x0 : mapping",
                    "c9_map1 : mapping",
                    "c4_IHil : forall (map1 : mapping) (s1 : state) (rl : list reg) \n  (map2 : mapping) (s2 : state) (i : state_incr s1 s2)\n  (_ : eq (add_vars map1 il s1) (OK (pair rl map2) s2 i)),\neq (map_letvars map2) (map_letvars map1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_letvar_valid",
        "proof": [
            {
                "tactic_sig": "Lemma add_letvar_valid : forall map s r , map_valid map s -> reg_valid r s -> map_valid ( add_letvar map r ) s .",
                "tactic_sig_no_out_arg": "Lemma add_letvar_valid : forall map s r , map_valid map s -> reg_valid r s -> map_valid ( add_letvar map r ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (s : state) (r : reg) (_ : map_valid map s)\n  (_ : reg_valid r s), map_valid (add_letvar map r) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (s : state) (r : reg) (_ : map_valid map s)\n  (_ : reg_valid r s), map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c2_goal : map_valid (add_letvar map r) s",
                    "c2_map : mapping",
                    "c2_s : state",
                    "c2_r : reg",
                    "c2_H : map_valid map s",
                    "c2_H0 : reg_valid r s"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c3_goal : forall (r0 : reg) (_ : reg_in_map (add_letvar map r) r0),\nreg_valid r0 s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (r0 : reg) (_ : reg_in_map (add_letvar map r) r0),\nreg_valid r0 s"
                ],
                "tactic_res": [
                    "c4_goal : reg_valid r0 s",
                    "c4_r0 : reg",
                    "c4_H1 : reg_in_map (add_letvar map r) r0"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ [ id A ] |B ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ id A ] |B ] .",
                "tactic_args": [
                    "c4_goal : reg_valid r0 s",
                    "c4_H1 : reg_in_map (add_letvar map r) r0",
                    "c4_r0 : reg",
                    "c2_H0 : reg_valid r s",
                    "c2_H : map_valid map s",
                    "c2_s : state"
                ],
                "tactic_res": [
                    "c5_goal : reg_valid r0 s",
                    "c5_A : eq (PTree.get id (map_vars (add_letvar map r))) (Some r0)",
                    "c5_id : positive",
                    "c6_goal : reg_valid r0 s",
                    "c6_B : In r0 (map_letvars (add_letvar map r))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c5_A : eq (PTree.get id (map_vars (add_letvar map r))) (Some r0)"
                ],
                "tactic_res": [
                    "c5_A : eq (PTree.get id (map_vars map)) (Some r0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : reg_valid r0 s",
                    "c2_H : map_valid map s"
                ],
                "tactic_res": [
                    "c7_goal : reg_in_map map r0"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c7_goal : reg_in_map map r0"
                ],
                "tactic_res": [
                    "c8_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some r0))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c8_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some r0))",
                    "c5_id : positive"
                ],
                "tactic_res": [
                    "c9_goal : eq (PTree.get id (map_vars map)) (Some r0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (PTree.get id (map_vars map)) (Some r0)",
                    "c5_A : eq (PTree.get id (map_vars map)) (Some r0)",
                    "c5_id : positive",
                    "c4_r0 : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c6_B : In r0 (map_letvars (add_letvar map r))"
                ],
                "tactic_res": [
                    "c6_B : or (eq r r0) (In r0 (map_letvars map))"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c6_goal : reg_valid r0 s",
                    "c6_B : or (eq r r0) (In r0 (map_letvars map))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq r r0, reg_valid r0 s",
                    "c11_goal : forall _ : In r0 (map_letvars map), reg_valid r0 s"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c10_goal : forall _ : eq r r0, reg_valid r0 s"
                ],
                "tactic_res": [
                    "c12_goal : reg_valid r0 s",
                    "c12_H1 : eq r r0"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c11_goal : forall _ : In r0 (map_letvars map), reg_valid r0 s"
                ],
                "tactic_res": [
                    "c13_goal : reg_valid r0 s",
                    "c13_H1 : In r0 (map_letvars map)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c12_goal : reg_valid r0 s",
                    "c4_r0 : reg",
                    "c12_H1 : eq r r0"
                ],
                "tactic_res": [
                    "c14_goal : reg_valid r s",
                    "c14_B : or (eq r r) (In r (map_letvars map))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : reg_valid r s",
                    "c2_H0 : reg_valid r s",
                    "c2_r : reg",
                    "c2_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : reg_valid r0 s",
                    "c2_H : map_valid map s"
                ],
                "tactic_res": [
                    "c15_goal : reg_in_map map r0"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c15_goal : reg_in_map map r0"
                ],
                "tactic_res": [
                    "c16_goal : In r0 (map_letvars map)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : In r0 (map_letvars map)",
                    "c13_H1 : In r0 (map_letvars map)",
                    "c4_r0 : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_reg_valid",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_reg_valid : forall a s1 s2 map r i , map_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_sig_no_out_arg": "Lemma alloc_reg_valid : forall a s1 s2 map r i , map_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : expr) (s1 s2 : state) (map : mapping) \n  (r : reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until r .",
                "tactic_args": [
                    "c1_goal : forall (a : expr) (s1 s2 : state) (map : mapping) \n  (r : reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), reg_valid r s2"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), reg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s2 : state",
                    "c2_s1 : state",
                    "c2_a : expr"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), reg_valid r s2",
                    "_global_alloc_reg : forall (_ : mapping) (_ : expr), mon reg"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (match a with\n          | Evar id => find_var map id\n          | Eletvar n => find_letvar map n\n          | _ => new_reg\n          end s1) (OK r s2 i)), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c3_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (match a with\n          | Evar id => find_var map id\n          | Eletvar n => find_letvar map n\n          | _ => new_reg\n          end s1) (OK r s2 i)), reg_valid r s2",
                    "c2_a : expr"
                ],
                "tactic_res": [
                    "c4_goal : forall (i : ident) (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (find_var map i s1) (OK r s2 i0)), reg_valid r s2",
                    "c5_goal : forall (_ : operation) (_ : exprlist) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c6_goal : forall (_ : memory_chunk) (_ : addressing) (_ : exprlist)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_valid r s2",
                    "c7_goal : forall (_ : condexpr) (_ : expr) (_ : expr) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c8_goal : forall (_ : expr) (_ : expr) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c9_goal : forall (n : nat) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (find_letvar map n s1) (OK r s2 i)), reg_valid r s2",
                    "c10_goal : forall (_ : external_function) (_ : exprlist) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c11_goal : forall (_ : ident) (_ : signature) (_ : exprlist)\n  (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (new_reg s1) (OK r s2 i0)), reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c4_goal : forall (i : ident) (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (find_var map i s1) (OK r s2 i0)), reg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c5_goal : forall (_ : operation) (_ : exprlist) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c6_goal : forall (_ : memory_chunk) (_ : addressing) (_ : exprlist)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (new_reg s1) (OK r s2 i)), reg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c7_goal : forall (_ : condexpr) (_ : expr) (_ : expr) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c8_goal : forall (_ : expr) (_ : expr) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c9_goal : forall (n : nat) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (find_letvar map n s1) (OK r s2 i)), reg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c10_goal : forall (_ : external_function) (_ : exprlist) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : eq (new_reg s1) (OK r s2 i)),\nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c11_goal : forall (_ : ident) (_ : signature) (_ : exprlist)\n  (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (new_reg s1) (OK r s2 i0)), reg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_reg_fresh_or_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_reg_fresh_or_in_map : forall map a s r s' i , map_valid map s -> alloc_reg map a s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_sig_no_out_arg": "Lemma alloc_reg_fresh_or_in_map : forall map a s r s' i , map_valid map s -> alloc_reg map a s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (a : expr) (s : state) (r : reg) \n  (s' : state) (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_reg map a s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until s' .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (a : expr) (s : state) (r : reg) \n  (s' : state) (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_reg map a s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_reg map a s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c2_s' : state",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_a : expr",
                    "c2_map : mapping"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_reg map a s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "_global_alloc_reg : forall (_ : mapping) (_ : expr), mon reg"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq\n         (match a with\n          | Evar id => find_var map id\n          | Eletvar n => find_letvar map n\n          | _ => new_reg\n          end s) (OK r s' i)), or (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o _o | _o _o _o | _o _o | _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq\n         (match a with\n          | Evar id => find_var map id\n          | Eletvar n => find_letvar map n\n          | _ => new_reg\n          end s) (OK r s' i)), or (reg_in_map map r) (reg_fresh r s)",
                    "c2_a : expr",
                    "c2_s' : state",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c4_goal : forall (i0 : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_var map i s) (OK r s' i0)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c4_i : ident",
                    "c5_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c5_e : exprlist",
                    "c5_o : operation",
                    "c6_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c6_e : exprlist",
                    "c6_a : addressing",
                    "c6_m : memory_chunk",
                    "c7_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c7_a2 : expr",
                    "c7_a1 : expr",
                    "c7_c : condexpr",
                    "c8_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c8_a2 : expr",
                    "c8_a1 : expr",
                    "c9_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_letvar map n s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c9_n : nat",
                    "c10_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c10_e0 : exprlist",
                    "c10_e : external_function",
                    "c11_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c11_e : exprlist",
                    "c11_s0 : signature",
                    "c11_i : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (i0 : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_var map i s) (OK r s' i0)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c12_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c12_i0 : state_incr s s'",
                    "c12_H : map_valid map s",
                    "c12_H0 : eq (find_var map i s) (OK r s' i0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c13_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c13_i : state_incr s s'",
                    "c13_H : map_valid map s",
                    "c13_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c13_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c13_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c14_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c14_i : state_incr s s'",
                    "c14_H : map_valid map s",
                    "c14_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c14_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c14_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c15_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c15_i : state_incr s s'",
                    "c15_H : map_valid map s",
                    "c15_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c15_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c15_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c16_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c16_i : state_incr s s'",
                    "c16_H : map_valid map s",
                    "c16_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c16_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c16_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_letvar map n s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c17_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c17_i : state_incr s s'",
                    "c17_H : map_valid map s",
                    "c17_H0 : eq (find_letvar map n s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c18_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c18_i : state_incr s s'",
                    "c18_H : map_valid map s",
                    "c18_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c18_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c18_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c19_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c19_i0 : state_incr s s'",
                    "c19_H : map_valid map s",
                    "c19_H0 : eq (new_reg s) (OK r s' i0)"
                ]
            },
            {
                "tactic_sig": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_sig_no_out_arg": "try ( right ; eauto with rtlg ; fail ) .",
                "tactic_args": [
                    "c19_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c19_H0 : eq (new_reg s) (OK r s' i0)",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c12_goal : or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c20_goal : reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c20_goal : reg_in_map map r",
                    "c12_H0 : eq (find_var map i s) (OK r s' i0)",
                    "c2_r : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c17_goal : or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c21_goal : reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c21_goal : reg_in_map map r",
                    "c17_H0 : eq (find_letvar map n s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_regs_valid",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_regs_valid : forall al s1 s2 map rl i , map_valid map s1 -> alloc_regs map al s1 = OK rl s2 i -> regs_valid rl s2 .",
                "tactic_sig_no_out_arg": "Lemma alloc_regs_valid : forall al s1 s2 map rl i , map_valid map s1 -> alloc_regs map al s1 = OK rl s2 i -> regs_valid rl s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (al : exprlist) (s1 s2 : state) (map : mapping) \n  (rl : list reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro al .",
                "tactic_args": [
                    "c1_goal : forall (al : exprlist) (s1 s2 : state) (map : mapping) \n  (rl : list reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2"
                ],
                "tactic_res": [
                    "c2_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2",
                    "c2_al : exprlist"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2",
                    "c2_al : exprlist"
                ],
                "tactic_res": [
                    "c3_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map Enil s1) (OK rl s2 i)), \nregs_valid rl s2",
                    "c4_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)),\nregs_valid rl s2",
                    "c4_IHal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2",
                    "c4_e : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map Enil s1) (OK rl s2 i)), \nregs_valid rl s2"
                ],
                "tactic_res": [
                    "c5_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (ret nil s1) (OK rl s2 i)), regs_valid rl s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (ret nil s1) (OK rl s2 i)), regs_valid rl s2"
                ],
                "tactic_res": [
                    "c6_goal : regs_valid rl s2",
                    "c6_s1 : state",
                    "c6_s2 : state",
                    "c6_map : mapping",
                    "c6_rl : list reg",
                    "c6_i : state_incr s1 s2",
                    "c6_H : map_valid map s1",
                    "c6_H0 : eq (ret nil s1) (OK rl s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : regs_valid rl s2",
                    "c6_H0 : eq (ret nil s1) (OK rl s2 i)"
                ],
                "tactic_res": [
                    "c7_goal : regs_valid nil s2",
                    "c7_i : state_incr s2 s2",
                    "c7_H : map_valid map s2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)),\nregs_valid rl s2"
                ],
                "tactic_res": [
                    "c8_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (alloc_regs map al)\n               (fun rl0 : list reg => ret (cons r rl0))) s1)\n         (OK rl s2 i)), regs_valid rl s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (alloc_regs map al)\n               (fun rl0 : list reg => ret (cons r rl0))) s1)\n         (OK rl s2 i)), regs_valid rl s2"
                ],
                "tactic_res": [
                    "c9_goal : regs_valid rl s2",
                    "c9_s1 : state",
                    "c9_s2 : state",
                    "c9_map : mapping",
                    "c9_rl : list reg",
                    "c9_i : state_incr s1 s2",
                    "c9_H : map_valid map s1",
                    "c9_H0 : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (alloc_regs map al) (fun rl : list reg => ret (cons r rl)))\n     s1) (OK rl s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c9_goal : regs_valid rl s2",
                    "c9_H0 : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (alloc_regs map al) (fun rl : list reg => ret (cons r rl)))\n     s1) (OK rl s2 i)"
                ],
                "tactic_res": [
                    "c10_goal : regs_valid (cons x x0) s2",
                    "c10_INCR2 : state_incr s2 s2",
                    "c10_EQ1 : eq (alloc_regs map al s) (OK x0 s2 INCR1)",
                    "c10_INCR1 : state_incr s s2",
                    "c10_x0 : list reg",
                    "c10_EQ : eq (alloc_reg map e s1) (OK x s INCR)",
                    "c10_INCR0 : state_incr s s2",
                    "c10_INCR : state_incr s1 s",
                    "c10_s : state",
                    "c10_x : reg"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : regs_valid nil s2",
                    "_global_regs_valid_nil : forall s : state, regs_valid nil s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : regs_valid (cons x x0) s2",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c11_goal : reg_valid x s2",
                    "c12_goal : regs_valid x0 s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c11_goal : reg_valid x s2",
                    "c10_EQ : eq (alloc_reg map e s1) (OK x s INCR)",
                    "c10_x : reg",
                    "c9_H : map_valid map s1",
                    "c9_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c12_goal : regs_valid x0 s2",
                    "c10_EQ1 : eq (alloc_regs map al s) (OK x0 s2 INCR1)",
                    "c10_x0 : list reg",
                    "c9_H : map_valid map s1",
                    "c9_s2 : state",
                    "c4_IHal : forall (s1 s2 : state) (map : mapping) (rl : list reg)\n  (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)), regs_valid rl s2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_regs_fresh_or_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_regs_fresh_or_in_map : forall map al s rl s' i , map_valid map s -> alloc_regs map al s = OK rl s' i -> forall r , In r rl -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_sig_no_out_arg": "Lemma alloc_regs_fresh_or_in_map : forall map al s rl s' i , map_valid map s -> alloc_regs map al s = OK rl s' i -> forall r , In r rl -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (al : exprlist) (s : state) \n  (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros map al .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (al : exprlist) (s : state) \n  (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)",
                    "c2_map : mapping",
                    "c2_al : exprlist"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)",
                    "c2_al : exprlist"
                ],
                "tactic_res": [
                    "c3_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map Enil s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)",
                    "c4_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s)\n  (_ : eq (alloc_regs map (Econs e al) s) (OK rl s' i)) \n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)",
                    "c4_IHal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)",
                    "c4_e : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map Enil s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c5_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (ret nil s) (OK rl s' i)) \n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (ret nil s) (OK rl s' i)) \n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c6_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c6_s : state",
                    "c6_rl : list reg",
                    "c6_s' : state",
                    "c6_i : state_incr s s'",
                    "c6_H : map_valid map s",
                    "c6_H0 : eq (ret nil s) (OK rl s' i)",
                    "c6_r : reg",
                    "c6_H1 : In r rl"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c6_H0 : eq (ret nil s) (OK rl s' i)"
                ],
                "tactic_res": [
                    "c7_goal : or (reg_in_map map r) (reg_fresh r s')",
                    "c7_H1 : In r nil",
                    "c7_i : state_incr s' s'",
                    "c7_H : map_valid map s'"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s)\n  (_ : eq (alloc_regs map (Econs e al) s) (OK rl s' i)) \n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c8_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s)\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (alloc_regs map al)\n               (fun rl0 : list reg => ret (cons r rl0))) s)\n         (OK rl s' i)) (r : reg) (_ : In r rl),\nor (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s)\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (alloc_regs map al)\n               (fun rl0 : list reg => ret (cons r rl0))) s)\n         (OK rl s' i)) (r : reg) (_ : In r rl),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c9_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c9_s : state",
                    "c9_rl : list reg",
                    "c9_s' : state",
                    "c9_i : state_incr s s'",
                    "c9_H : map_valid map s",
                    "c9_H0 : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (alloc_regs map al) (fun rl : list reg => ret (cons r rl)))\n     s) (OK rl s' i)",
                    "c9_r : reg",
                    "c9_H1 : In r rl"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c9_H0 : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (alloc_regs map al) (fun rl : list reg => ret (cons r rl)))\n     s) (OK rl s' i)"
                ],
                "tactic_res": [
                    "c9_INCR2 : state_incr s' s'",
                    "c9_EQ1 : eq (alloc_regs map al s0) (OK x0 s' INCR1)",
                    "c9_INCR1 : state_incr s0 s'",
                    "c9_EQ : eq (alloc_reg map e s) (OK x s0 INCR)",
                    "c9_INCR0 : state_incr s0 s'",
                    "c9_INCR : state_incr s s0",
                    "c9_s0 : state",
                    "c9_H1 : In r (cons x x0)",
                    "c9_x0 : list reg",
                    "c9_x : reg"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c7_goal : or (reg_in_map map r) (reg_fresh r s')",
                    "c7_H1 : In r nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c9_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c9_H1 : In r (cons x x0)"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq x r, or (reg_in_map map r) (reg_fresh r s)",
                    "c11_goal : forall _ : In r x0, or (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c10_goal : forall _ : eq x r, or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c12_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c12_H0 : eq x r"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c11_goal : forall _ : In r x0, or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c13_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c13_H0 : In r x0"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c12_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c9_r : reg",
                    "c12_H0 : eq x r"
                ],
                "tactic_res": [
                    "c14_goal : or (reg_in_map map x) (reg_fresh x s)",
                    "c14_H1 : In x (cons x x0)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c14_goal : or (reg_in_map map x) (reg_fresh x s)",
                    "_global_alloc_reg_fresh_or_in_map : forall (map : mapping) (a : expr) (s : state) \n         (r : reg) (s' : state) (i : state_incr s s') \n         (_ : map_valid map s) (_ : eq (alloc_reg map a s) (OK r s' i)),\n       or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c15_goal : map_valid map s",
                    "c16_goal : eq (alloc_reg map ?a s) (OK x ?s' ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : map_valid map s",
                    "c9_H : map_valid map s",
                    "c9_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : eq (alloc_reg map ?a s) (OK x ?s' ?i)",
                    "c9_EQ : eq (alloc_reg map e s) (OK x s0 INCR)",
                    "c9_x : reg",
                    "c9_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c13_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c4_IHal : forall (s : state) (rl : list reg) (s' : state) (i : state_incr s s')\n  (_ : map_valid map s) (_ : eq (alloc_regs map al s) (OK rl s' i))\n  (r : reg) (_ : In r rl), or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c17_goal : map_valid map s0",
                    "c18_goal : eq (alloc_regs map al ?Goal) (OK ?Goal0 ?Goal1 ?Goal2)",
                    "c19_goal : In ?Goal5 ?Goal0",
                    "c20_goal : forall _ : or (reg_in_map map r) (reg_fresh r s0),\nor (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : eq (alloc_regs map al ?Goal) (OK ?Goal0 ?Goal1 ?Goal2)",
                    "c9_EQ1 : eq (alloc_regs map al s0) (OK x0 s' INCR1)",
                    "c2_al : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c17_goal : map_valid map s0",
                    "_global_map_valid_incr : forall (s1 s2 : state) (m : mapping) (_ : state_incr s1 s2)\n         (_ : map_valid m s1), map_valid m s2",
                    "c9_s : state"
                ],
                "tactic_res": [
                    "c21_goal : state_incr s s0",
                    "c22_goal : map_valid map s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c21_goal : state_incr s s0",
                    "c9_s0 : state",
                    "c9_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c22_goal : map_valid map s",
                    "c9_H : map_valid map s",
                    "c9_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : In ?Goal0 x0",
                    "c13_H0 : In r x0",
                    "c9_x0 : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ A|B ] .",
                "tactic_sig_no_out_arg": "intros [ A|B ] .",
                "tactic_args": [
                    "c20_goal : forall _ : or (reg_in_map map r) (reg_fresh r s0),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c23_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c24_B : reg_fresh r s0",
                    "c24_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c23_A : reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c23_A : reg_in_map map r",
                    "c9_r : reg",
                    "c9_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c24_goal : or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c25_goal : reg_fresh r s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c25_goal : reg_fresh r s",
                    "c24_B : reg_fresh r s0",
                    "c9_r : reg",
                    "c9_s : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_optreg_valid",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_optreg_valid : forall dest s1 s2 map r i , map_valid map s1 -> alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_sig_no_out_arg": "Lemma alloc_optreg_valid : forall dest s1 s2 map r i , map_valid map s1 -> alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (dest : option ident) (s1 s2 : state) (map : mapping) \n  (r : reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map dest s1) (OK r s2 i)), \nreg_valid r s2"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until r .",
                "tactic_args": [
                    "c1_goal : forall (dest : option ident) (s1 s2 : state) (map : mapping) \n  (r : reg) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map dest s1) (OK r s2 i)), \nreg_valid r s2"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map dest s1) (OK r s2 i)), \nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s2 : state",
                    "c2_s1 : state",
                    "c2_dest : option ident"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "_global_alloc_reg : forall (_ : mapping) (_ : expr), mon reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map dest s1) (OK r s2 i)), \nreg_valid r s2",
                    "c2_dest : option ident"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : ident) (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map (Some i) s1) (OK r s2 i0)), \nreg_valid r s2",
                    "c4_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map None s1) (OK r s2 i)), \nreg_valid r s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c3_goal : forall (i : ident) (i0 : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map (Some i) s1) (OK r s2 i0)), \nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c4_goal : forall (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map None s1) (OK r s2 i)), \nreg_valid r s2",
                    "c2_r : reg",
                    "c2_map : mapping",
                    "c2_s1 : state",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_optreg_fresh_or_in_map",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_optreg_fresh_or_in_map : forall map dest s r s' i , map_valid map s -> alloc_optreg map dest s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_sig_no_out_arg": "Lemma alloc_optreg_fresh_or_in_map : forall map dest s r s' i , map_valid map s -> alloc_optreg map dest s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (dest : option ident) (s : state) \n  (r : reg) (s' : state) (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_optreg map dest s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until s' .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (dest : option ident) (s : state) \n  (r : reg) (s' : state) (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_optreg map dest s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_optreg map dest s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c2_s' : state",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_dest : option ident",
                    "c2_map : mapping"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (alloc_optreg map dest s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "_global_alloc_optreg : forall (_ : mapping) (_ : option ident), mon reg"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq\n         (match dest with\n          | Some id => find_var map id\n          | None => new_reg\n          end s) (OK r s' i)), or (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq\n         (match dest with\n          | Some id => find_var map id\n          | None => new_reg\n          end s) (OK r s' i)), or (reg_in_map map r) (reg_fresh r s)",
                    "c2_dest : option ident",
                    "c2_s' : state",
                    "c2_r : reg",
                    "c2_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c4_goal : forall (i0 : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_var map i s) (OK r s' i0)),\nor (reg_in_map map r) (reg_fresh r s)",
                    "c4_i : ident",
                    "c5_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (i0 : state_incr s s') (_ : map_valid map s)\n  (_ : eq (find_var map i s) (OK r s' i0)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c6_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c6_i0 : state_incr s s'",
                    "c6_H : map_valid map s",
                    "c6_H0 : eq (find_var map i s) (OK r s' i0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (i : state_incr s s') (_ : map_valid map s)\n  (_ : eq (new_reg s) (OK r s' i)),\nor (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c7_goal : or (reg_in_map map r) (reg_fresh r s)",
                    "c7_i : state_incr s s'",
                    "c7_H : map_valid map s",
                    "c7_H0 : eq (new_reg s) (OK r s' i)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c6_goal : or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c8_goal : reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c8_goal : reg_in_map map r",
                    "c6_H0 : eq (find_var map i s) (OK r s' i0)",
                    "c2_r : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c7_goal : or (reg_in_map map r) (reg_fresh r s)"
                ],
                "tactic_res": [
                    "c9_goal : reg_fresh r s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c9_goal : reg_fresh r s",
                    "c7_H0 : eq (new_reg s) (OK r s' i)",
                    "c2_r : reg",
                    "c2_s : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "target_reg_ok_append",
        "proof": [
            {
                "tactic_sig": "Lemma target_reg_ok_append : forall map pr a r , target_reg_ok map pr a r -> forall pr' , ( forall r' , In r' pr' -> reg_in_map map r' \\/ r' <> r ) -> target_reg_ok map ( pr' ++ pr ) a r .",
                "tactic_sig_no_out_arg": "Lemma target_reg_ok_append : forall map pr a r , target_reg_ok map pr a r -> forall pr' , ( forall r' , In r' pr' -> reg_in_map map r' \\/ r' <> r ) -> target_reg_ok map ( pr' ++ pr ) a r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (r : reg) (_ : target_reg_ok map pr a r) (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) a r"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (r : reg) (_ : target_reg_ok map pr a r) (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) a r"
                ],
                "tactic_res": [
                    "c2_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) (Evar id) r",
                    "c2_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c2_r : reg",
                    "c2_id : positive",
                    "c2_pr : list reg",
                    "c2_map : mapping",
                    "c3_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) (Eletvar idx) r",
                    "c3_H : eq (nth_error (map_letvars map) idx) (Some r)",
                    "c3_r : reg",
                    "c3_idx : nat",
                    "c3_pr : list reg",
                    "c3_map : mapping",
                    "c4_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) a r",
                    "c4_H0 : not (In r pr)",
                    "c4_H : not (reg_in_map map r)",
                    "c4_r : reg",
                    "c4_a : expr",
                    "c4_pr : list reg",
                    "c4_map : mapping"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) (Evar id) r"
                ],
                "tactic_res": [
                    "c5_goal : target_reg_ok map (app pr' pr) (Evar id) r",
                    "c5_pr' : list reg",
                    "c5_H0 : forall (r' : reg) (_ : In r' pr'),\nor (reg_in_map map r') (not (eq r' r))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) (Eletvar idx) r"
                ],
                "tactic_res": [
                    "c6_goal : target_reg_ok map (app pr' pr) (Eletvar idx) r",
                    "c6_pr' : list reg",
                    "c6_H0 : forall (r' : reg) (_ : In r' pr'),\nor (reg_in_map map r') (not (eq r' r))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (pr' : list reg)\n  (_ : forall (r' : reg) (_ : In r' pr'),\n       or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (app pr' pr) a r"
                ],
                "tactic_res": [
                    "c7_goal : target_reg_ok map (app pr' pr) a r",
                    "c7_pr' : list reg",
                    "c7_H1 : forall (r' : reg) (_ : In r' pr'),\nor (reg_in_map map r') (not (eq r' r))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : target_reg_ok map (app pr' pr) (Evar id) r"
                ],
                "tactic_res": [
                    "c8_goal : eq (PTree.get id (map_vars map)) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (PTree.get id (map_vars map)) (Some r)",
                    "c2_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c2_r : reg",
                    "c2_id : positive",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : target_reg_ok map (app pr' pr) (Eletvar idx) r"
                ],
                "tactic_res": [
                    "c9_goal : eq (nth_error (map_letvars map) idx) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (nth_error (map_letvars map) idx) (Some r)",
                    "c3_H : eq (nth_error (map_letvars map) idx) (Some r)",
                    "c3_r : reg",
                    "c3_idx : nat",
                    "c3_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : target_reg_ok map (app pr' pr) a r"
                ],
                "tactic_res": [
                    "c10_goal : not (reg_in_map map r)",
                    "c11_goal : not (In r (app pr' pr))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : not (reg_in_map map r)",
                    "c4_H : not (reg_in_map map r)",
                    "c4_r : reg",
                    "c4_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : not (In r (app pr' pr))"
                ],
                "tactic_res": [
                    "c12_goal : forall _ : In r (app pr' pr), False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall _ : In r (app pr' pr), False"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_H2 : In r (app pr' pr)"
                ]
            },
            {
                "tactic_sig": "elim ( in_app_or _ _ _ _i ) .",
                "tactic_sig_no_out_arg": "elim ( in_app_or _ _ _ _i ) .",
                "tactic_args": [
                    "c13_goal : False",
                    "c13_H2 : In r (app pr' pr)"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : In r pr', False",
                    "c15_goal : forall _ : In r pr, False"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c14_goal : forall _ : In r pr', False"
                ],
                "tactic_res": [
                    "c16_goal : False",
                    "c16_H3 : In r pr'"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c15_goal : forall _ : In r pr, False"
                ],
                "tactic_res": [
                    "c17_goal : False",
                    "c17_H3 : In r pr"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _ _i ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _ _i ) .",
                "tactic_args": [
                    "c16_goal : False",
                    "c7_H1 : forall (r' : reg) (_ : In r' pr'),\nor (reg_in_map map r') (not (eq r' r))",
                    "c16_H3 : In r pr'"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : or (reg_in_map map r) (not (eq r r)), False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c18_goal : forall _ : or (reg_in_map map r) (not (eq r r)), False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c17_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "target_reg_ok_cons",
        "proof": [
            {
                "tactic_sig": "Lemma target_reg_ok_cons : forall map pr a r , target_reg_ok map pr a r -> forall r' , reg_in_map map r' \\/ r' <> r -> target_reg_ok map ( r' :: pr ) a r .",
                "tactic_sig_no_out_arg": "Lemma target_reg_ok_cons : forall map pr a r , target_reg_ok map pr a r -> forall r' , reg_in_map map r' \\/ r' <> r -> target_reg_ok map ( r' :: pr ) a r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (r : reg) (_ : target_reg_ok map pr a r) (r' : reg)\n  (_ : or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (cons r' pr) a r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (r : reg) (_ : target_reg_ok map pr a r) (r' : reg)\n  (_ : or (reg_in_map map r') (not (eq r' r))),\ntarget_reg_ok map (cons r' pr) a r"
                ],
                "tactic_res": [
                    "c2_goal : target_reg_ok map (cons r' pr) a r",
                    "c2_map : mapping",
                    "c2_pr : list reg",
                    "c2_a : expr",
                    "c2_r : reg",
                    "c2_H : target_reg_ok map pr a r",
                    "c2_r' : reg",
                    "c2_H0 : or (reg_in_map map r') (not (eq r' r))"
                ]
            },
            {
                "tactic_sig": "change ( _i :: _i ) with ( ( _i :: nil ) ++ _i ) .",
                "tactic_sig_no_out_arg": "change ( _i :: _i ) with ( ( _i :: nil ) ++ _i ) .",
                "tactic_args": [
                    "c2_goal : target_reg_ok map (cons r' pr) a r",
                    "c2_r' : reg",
                    "c2_pr : list reg",
                    "c2_r' : reg",
                    "c2_pr : list reg"
                ],
                "tactic_res": [
                    "c3_goal : target_reg_ok map (app (cons r' nil) pr) a r"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : target_reg_ok map (app (cons r' nil) pr) a r",
                    "_global_target_reg_ok_append : forall (map : mapping) (pr : list reg) (a : expr) \n         (r : reg) (_ : target_reg_ok map pr a r) \n         (pr' : list reg)\n         (_ : forall (r' : reg) (_ : In r' pr'),\n              or (reg_in_map map r') (not (eq r' r))),\n       target_reg_ok map (app pr' pr) a r"
                ],
                "tactic_res": [
                    "c4_goal : target_reg_ok map pr a r",
                    "c5_goal : forall (r'0 : reg) (_ : In r'0 (cons r' nil)),\nor (reg_in_map map r'0) (not (eq r'0 r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : target_reg_ok map pr a r",
                    "c2_H : target_reg_ok map pr a r",
                    "c2_r : reg",
                    "c2_a : expr",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o [ A|B ] .",
                "tactic_sig_no_out_arg": "intros r'' [ A|B ] .",
                "tactic_args": [
                    "c5_goal : forall (r'0 : reg) (_ : In r'0 (cons r' nil)),\nor (reg_in_map map r'0) (not (eq r'0 r))"
                ],
                "tactic_res": [
                    "c6_goal : or (reg_in_map map r'') (not (eq r'' r))",
                    "c7_r'' : reg",
                    "c7_B : In r'' nil",
                    "c7_goal : or (reg_in_map map r'') (not (eq r'' r))",
                    "c6_r'' : reg",
                    "c6_A : eq r' r''"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c6_goal : or (reg_in_map map r'') (not (eq r'' r))",
                    "c6_r'' : reg",
                    "c6_A : eq r' r''"
                ],
                "tactic_res": [
                    "c8_goal : or (reg_in_map map r') (not (eq r' r))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : or (reg_in_map map r') (not (eq r' r))",
                    "c2_H0 : or (reg_in_map map r') (not (eq r' r))",
                    "c2_r' : reg",
                    "c2_r : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c7_goal : or (reg_in_map map r'') (not (eq r'' r))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "new_reg_target_ok",
        "proof": [
            {
                "tactic_sig": "Lemma new_reg_target_ok : forall map pr s1 a r s2 i , map_valid map s1 -> regs_valid pr s1 -> new_reg s1 = OK r s2 i -> target_reg_ok map pr a r .",
                "tactic_sig_no_out_arg": "Lemma new_reg_target_ok : forall map pr s1 a r s2 i , map_valid map s1 -> regs_valid pr s1 -> new_reg s1 = OK r s2 i -> target_reg_ok map pr a r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (s1 : state) \n  (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (new_reg s1) (OK r s2 i)), target_reg_ok map pr a r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (s1 : state) \n  (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (new_reg s1) (OK r s2 i)), target_reg_ok map pr a r"
                ],
                "tactic_res": [
                    "c2_goal : target_reg_ok map pr a r",
                    "c2_map : mapping",
                    "c2_pr : list reg",
                    "c2_s1 : state",
                    "c2_a : expr",
                    "c2_r : reg",
                    "c2_s2 : state",
                    "c2_i : state_incr s1 s2",
                    "c2_H : map_valid map s1",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H1 : eq (new_reg s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : target_reg_ok map pr a r"
                ],
                "tactic_res": [
                    "c3_goal : not (reg_in_map map r)",
                    "c4_goal : not (In r pr)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : not (reg_in_map map r)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : reg_in_map map r, False"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c5_goal : forall _ : reg_in_map map r, False"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H2 : reg_in_map map r"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c6_goal : False",
                    "_global_valid_fresh_absurd : forall (r : reg) (s : state) (_ : reg_valid r s) (_ : reg_fresh r s),\n       False",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c7_goal : reg_valid r s1",
                    "c8_goal : reg_fresh r s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c7_goal : reg_valid r s1",
                    "c6_H2 : reg_in_map map r",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c8_goal : reg_fresh r s1",
                    "c2_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : not (In r pr)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : In r pr, False"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c9_goal : forall _ : In r pr, False"
                ],
                "tactic_res": [
                    "c10_goal : False",
                    "c10_H2 : In r pr"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c10_goal : False",
                    "_global_valid_fresh_absurd : forall (r : reg) (s : state) (_ : reg_valid r s) (_ : reg_fresh r s),\n       False",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": [
                    "c11_goal : reg_valid r s1",
                    "c12_goal : reg_fresh r s1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : reg_valid r s1",
                    "c10_H2 : In r pr",
                    "c2_H0 : regs_valid pr s1",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c12_goal : reg_fresh r s1",
                    "c2_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_r : reg",
                    "c2_s1 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_reg_target_ok",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_reg_target_ok : forall map pr s1 a r s2 i , map_valid map s1 -> regs_valid pr s1 -> alloc_reg map a s1 = OK r s2 i -> target_reg_ok map pr a r .",
                "tactic_sig_no_out_arg": "Lemma alloc_reg_target_ok : forall map pr s1 a r s2 i , map_valid map s1 -> regs_valid pr s1 -> alloc_reg map a s1 = OK r s2 i -> target_reg_ok map pr a r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (s1 : state) \n  (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), target_reg_ok map pr a r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (pr : list reg) (s1 : state) \n  (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (alloc_reg map a s1) (OK r s2 i)), target_reg_ok map pr a r"
                ],
                "tactic_res": [
                    "c2_goal : target_reg_ok map pr a r",
                    "c2_map : mapping",
                    "c2_pr : list reg",
                    "c2_s1 : state",
                    "c2_a : expr",
                    "c2_r : reg",
                    "c2_s2 : state",
                    "c2_i : state_incr s1 s2",
                    "c2_H : map_valid map s1",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H1 : eq (alloc_reg map a s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_alloc_reg : forall (_ : mapping) (_ : expr), mon reg",
                    "c2_H1 : eq (alloc_reg map a s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c2_H1 : eq\n  (match a with\n   | Evar id => find_var map id\n   | Eletvar n => find_letvar map n\n   | _ => new_reg\n   end s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o | _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : target_reg_ok map pr a r",
                    "c2_a : expr",
                    "c2_H1 : eq\n  (match a with\n   | Evar id => find_var map id\n   | Eletvar n => find_letvar map n\n   | _ => new_reg\n   end s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c3_goal : target_reg_ok map pr (Evar i0) r",
                    "c3_H1 : eq (find_var map i0 s1) (OK r s2 i)",
                    "c3_i0 : ident",
                    "c4_goal : target_reg_ok map pr (Eop o e) r",
                    "c4_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c4_e : exprlist",
                    "c4_o : operation",
                    "c5_goal : target_reg_ok map pr (Eload m a e) r",
                    "c5_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c5_e : exprlist",
                    "c5_a : addressing",
                    "c5_m : memory_chunk",
                    "c6_goal : target_reg_ok map pr (Econdition c a1 a2) r",
                    "c6_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c6_a2 : expr",
                    "c6_a1 : expr",
                    "c6_c : condexpr",
                    "c7_goal : target_reg_ok map pr (Elet a1 a2) r",
                    "c7_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c7_a2 : expr",
                    "c7_a1 : expr",
                    "c8_goal : target_reg_ok map pr (Eletvar n) r",
                    "c8_H1 : eq (find_letvar map n s1) (OK r s2 i)",
                    "c8_n : nat",
                    "c9_goal : target_reg_ok map pr (Ebuiltin e e0) r",
                    "c9_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c9_e0 : exprlist",
                    "c9_e : external_function",
                    "c10_goal : target_reg_ok map pr (Eexternal i0 s e) r",
                    "c10_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c10_e : exprlist",
                    "c10_s : signature",
                    "c10_i0 : ident"
                ]
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c4_goal : target_reg_ok map pr (Eop o e) r",
                    "c4_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c4_e : exprlist",
                    "c4_o : operation",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c5_goal : target_reg_ok map pr (Eload m a e) r",
                    "c5_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c5_e : exprlist",
                    "c5_a : addressing",
                    "c5_m : memory_chunk",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c6_goal : target_reg_ok map pr (Econdition c a1 a2) r",
                    "c6_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c6_a1 : expr",
                    "c6_a2 : expr",
                    "c6_c : condexpr",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c7_goal : target_reg_ok map pr (Elet a1 a2) r",
                    "c7_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c7_a1 : expr",
                    "c7_a2 : expr",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c9_goal : target_reg_ok map pr (Ebuiltin e e0) r",
                    "c9_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c9_e0 : exprlist",
                    "c9_e : external_function",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_sig_no_out_arg": "try ( eapply new_reg_target_ok ; eauto ; fail ) .",
                "tactic_args": [
                    "c10_goal : target_reg_ok map pr (Eexternal i0 s e) r",
                    "c10_H1 : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : regs_valid pr s1",
                    "c2_H : map_valid map s1",
                    "c2_r : reg",
                    "c10_e : exprlist",
                    "c10_s : signature",
                    "c10_i0 : ident",
                    "c2_pr : list reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c3_goal : target_reg_ok map pr (Evar i0) r",
                    "c3_H1 : eq (find_var map i0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : eq (find_var map i0 s1) (OK r s2 i),\ntarget_reg_ok map pr (Evar i0) r"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c11_goal : forall _ : eq (find_var map i0 s1) (OK r s2 i),\ntarget_reg_ok map pr (Evar i0) r",
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg"
                ],
                "tactic_res": [
                    "c12_goal : forall\n  _ : eq\n        (match PTree.get i0 (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i0) nil))\n         end s1) (OK r s2 i), target_reg_ok map pr (Evar i0) r"
                ]
            },
            {
                "tactic_sig": "caseEq ( map_vars _i ) !i0 .",
                "tactic_sig_no_out_arg": "caseEq ( map_vars _i ) !i0 .",
                "tactic_args": [
                    "c12_goal : forall\n  _ : eq\n        (match PTree.get i0 (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i0) nil))\n         end s1) (OK r s2 i), target_reg_ok map pr (Evar i0) r",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c13_goal : forall (r0 : reg) (_ : eq (PTree.get i0 (map_vars map)) (Some r0))\n  (_ : eq (ret r0 s1) (OK r s2 i)), target_reg_ok map pr (Evar i0) r",
                    "c14_goal : forall (_ : eq (PTree.get i0 (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)),\ntarget_reg_ok map pr (Evar i0) r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (r0 : reg) (_ : eq (PTree.get i0 (map_vars map)) (Some r0))\n  (_ : eq (ret r0 s1) (OK r s2 i)), target_reg_ok map pr (Evar i0) r"
                ],
                "tactic_res": [
                    "c15_goal : target_reg_ok map pr (Evar i0) r",
                    "c15_r0 : reg",
                    "c15_H2 : eq (PTree.get i0 (map_vars map)) (Some r0)",
                    "c15_H3 : eq (ret r0 s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (_ : eq (PTree.get i0 (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)),\ntarget_reg_ok map pr (Evar i0) r"
                ],
                "tactic_res": [
                    "c16_goal : target_reg_ok map pr (Evar i0) r",
                    "c16_H2 : eq (PTree.get i0 (map_vars map)) None",
                    "c16_H3 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_H3 : eq (ret r0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c15_H2 : eq (PTree.get i0 (map_vars map)) (Some r)",
                    "c15_H : map_valid map s2",
                    "c15_H0 : regs_valid pr s2",
                    "c15_H1 : eq (find_var map i0 s2) (OK r s2 i)",
                    "c15_i : state_incr s2 s2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c15_goal : target_reg_ok map pr (Evar i0) r"
                ],
                "tactic_res": [
                    "c17_goal : eq (PTree.get i0 (map_vars map)) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq (PTree.get i0 (map_vars map)) (Some r)",
                    "c15_H2 : eq (PTree.get i0 (map_vars map)) (Some r)",
                    "c2_r : reg",
                    "c3_i0 : ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : target_reg_ok map pr (Evar i0) r",
                    "c16_H3 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c8_goal : target_reg_ok map pr (Eletvar n) r",
                    "c8_H1 : eq (find_letvar map n s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : eq (find_letvar map n s1) (OK r s2 i),\ntarget_reg_ok map pr (Eletvar n) r"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c18_goal : forall _ : eq (find_letvar map n s1) (OK r s2 i),\ntarget_reg_ok map pr (Eletvar n) r",
                    "_global_find_letvar : forall (_ : mapping) (_ : nat), mon reg"
                ],
                "tactic_res": [
                    "c19_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s1) (OK r s2 i), target_reg_ok map pr (Eletvar n) r"
                ]
            },
            {
                "tactic_sig": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_sig_no_out_arg": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_args": [
                    "c19_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s1) (OK r s2 i), target_reg_ok map pr (Eletvar n) r",
                    "c2_map : mapping",
                    "c8_n : nat"
                ],
                "tactic_res": [
                    "c20_goal : forall (r0 : reg) (_ : eq (nth_error (map_letvars map) n) (Some r0))\n  (_ : eq (ret r0 s1) (OK r s2 i)), target_reg_ok map pr (Eletvar n) r",
                    "c21_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1)\n         (OK r s2 i)), target_reg_ok map pr (Eletvar n) r"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c20_goal : forall (r0 : reg) (_ : eq (nth_error (map_letvars map) n) (Some r0))\n  (_ : eq (ret r0 s1) (OK r s2 i)), target_reg_ok map pr (Eletvar n) r"
                ],
                "tactic_res": [
                    "c22_goal : target_reg_ok map pr (Eletvar n) r",
                    "c22_r0 : reg",
                    "c22_H2 : eq (nth_error (map_letvars map) n) (Some r0)",
                    "c22_H3 : eq (ret r0 s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1)\n         (OK r s2 i)), target_reg_ok map pr (Eletvar n) r"
                ],
                "tactic_res": [
                    "c23_goal : target_reg_ok map pr (Eletvar n) r",
                    "c23_H2 : eq (nth_error (map_letvars map) n) None",
                    "c23_H3 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c22_H3 : eq (ret r0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c22_H2 : eq (nth_error (map_letvars map) n) (Some r)",
                    "c22_H : map_valid map s2",
                    "c22_H0 : regs_valid pr s2",
                    "c22_H1 : eq (find_letvar map n s2) (OK r s2 i)",
                    "c22_i : state_incr s2 s2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c22_goal : target_reg_ok map pr (Eletvar n) r"
                ],
                "tactic_res": [
                    "c24_goal : eq (nth_error (map_letvars map) n) (Some r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (nth_error (map_letvars map) n) (Some r)",
                    "c22_H2 : eq (nth_error (map_letvars map) n) (Some r)",
                    "c2_r : reg",
                    "c8_n : nat",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c23_goal : target_reg_ok map pr (Eletvar n) r",
                    "c23_H3 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s1) (OK r s2 i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_regs_target_ok",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_regs_target_ok : forall map al pr s1 rl s2 i , map_valid map s1 -> regs_valid pr s1 -> alloc_regs map al s1 = OK rl s2 i -> target_regs_ok map pr al rl .",
                "tactic_sig_no_out_arg": "Lemma alloc_regs_target_ok : forall map al pr s1 rl s2 i , map_valid map s1 -> regs_valid pr s1 -> alloc_regs map al s1 = OK rl s2 i -> target_regs_ok map pr al rl .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (al : exprlist) (pr : list reg) \n  (s1 : state) (rl : list reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros map al .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (al : exprlist) (pr : list reg) \n  (s1 : state) (rl : list reg) (s2 : state) (i : state_incr s1 s2)\n  (_ : map_valid map s1) (_ : regs_valid pr s1)\n  (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl"
                ],
                "tactic_res": [
                    "c2_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl",
                    "c2_map : mapping",
                    "c2_al : exprlist"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl",
                    "c2_al : exprlist"
                ],
                "tactic_res": [
                    "c3_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map Enil s1) (OK rl s2 i)),\ntarget_regs_ok map pr Enil rl",
                    "c4_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1)\n  (_ : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)),\ntarget_regs_ok map pr (Econs e al) rl",
                    "c4_IHal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl",
                    "c4_e : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map Enil s1) (OK rl s2 i)),\ntarget_regs_ok map pr Enil rl"
                ],
                "tactic_res": [
                    "c5_goal : target_regs_ok map pr Enil rl",
                    "c5_pr : list reg",
                    "c5_s1 : state",
                    "c5_rl : list reg",
                    "c5_s2 : state",
                    "c5_i : state_incr s1 s2",
                    "c5_H : map_valid map s1",
                    "c5_H0 : regs_valid pr s1",
                    "c5_H1 : eq (alloc_regs map Enil s1) (OK rl s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c5_goal : target_regs_ok map pr Enil rl",
                    "c5_H1 : eq (alloc_regs map Enil s1) (OK rl s2 i)"
                ],
                "tactic_res": [
                    "c6_goal : target_regs_ok map pr Enil nil",
                    "c6_i : state_incr s2 s2",
                    "c6_H : map_valid map s2",
                    "c6_H0 : regs_valid pr s2"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1)\n  (_ : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)),\ntarget_regs_ok map pr (Econs e al) rl"
                ],
                "tactic_res": [
                    "c7_goal : target_regs_ok map pr (Econs e al) rl",
                    "c7_pr : list reg",
                    "c7_s1 : state",
                    "c7_rl : list reg",
                    "c7_s2 : state",
                    "c7_i : state_incr s1 s2",
                    "c7_H : map_valid map s1",
                    "c7_H0 : regs_valid pr s1",
                    "c7_H1 : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c7_goal : target_regs_ok map pr (Econs e al) rl",
                    "c7_H1 : eq (alloc_regs map (Econs e al) s1) (OK rl s2 i)"
                ],
                "tactic_res": [
                    "c8_goal : target_regs_ok map pr (Econs e al) (cons x x0)",
                    "c8_INCR2 : state_incr s2 s2",
                    "c8_EQ1 : eq (alloc_regs map al s) (OK x0 s2 INCR1)",
                    "c8_INCR1 : state_incr s s2",
                    "c8_x0 : list reg",
                    "c8_EQ : eq (alloc_reg map e s1) (OK x s INCR)",
                    "c8_INCR0 : state_incr s s2",
                    "c8_INCR : state_incr s1 s",
                    "c8_s : state",
                    "c8_x : reg"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : target_regs_ok map pr Enil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : target_regs_ok map pr (Econs e al) (cons x x0)"
                ],
                "tactic_res": [
                    "c9_goal : target_reg_ok map pr e x",
                    "c10_goal : target_regs_ok map (cons x pr) al x0"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c9_goal : target_reg_ok map pr e x",
                    "_global_alloc_reg_target_ok : forall (map : mapping) (pr : list reg) (s1 : state) \n         (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2)\n         (_ : map_valid map s1) (_ : regs_valid pr s1)\n         (_ : eq (alloc_reg map a s1) (OK r s2 i)), \n       target_reg_ok map pr a r"
                ],
                "tactic_res": [
                    "c11_goal : map_valid map ?s1",
                    "c12_goal : regs_valid pr s1",
                    "c13_goal : eq (alloc_reg map e s1) (OK x ?s2 ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : map_valid map ?s1",
                    "c7_H : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : regs_valid pr s1",
                    "c7_H0 : regs_valid pr s1",
                    "c7_s1 : state",
                    "c7_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : eq (alloc_reg map e s1) (OK x ?s2 ?i)",
                    "c8_EQ : eq (alloc_reg map e s1) (OK x s INCR)",
                    "c8_x : reg",
                    "c7_s1 : state",
                    "c4_e : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i _i .",
                "tactic_args": [
                    "c10_goal : target_regs_ok map (cons x pr) al x0",
                    "c4_IHal : forall (pr : list reg) (s1 : state) (rl : list reg) \n  (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : regs_valid pr s1) (_ : eq (alloc_regs map al s1) (OK rl s2 i)),\ntarget_regs_ok map pr al rl",
                    "c8_s : state",
                    "c7_s2 : state",
                    "c8_INCR1 : state_incr s s2"
                ],
                "tactic_res": [
                    "c14_goal : map_valid map s",
                    "c15_goal : regs_valid (cons x pr) s",
                    "c16_goal : eq (alloc_regs map al s) (OK x0 s2 INCR1)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c14_goal : map_valid map s",
                    "c8_s : state",
                    "c7_H : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c16_goal : eq (alloc_regs map al s) (OK x0 s2 INCR1)",
                    "c8_EQ1 : eq (alloc_regs map al s) (OK x0 s2 INCR1)",
                    "c8_INCR1 : state_incr s s2",
                    "c8_x0 : list reg",
                    "c8_s : state",
                    "c7_s2 : state",
                    "c2_al : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : regs_valid (cons x pr) s",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c17_goal : reg_valid x s",
                    "c18_goal : regs_valid pr s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c17_goal : reg_valid x s",
                    "c8_EQ : eq (alloc_reg map e s1) (OK x s INCR)",
                    "c8_s : state",
                    "c8_x : reg",
                    "c7_H : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c18_goal : regs_valid pr s",
                    "c8_s : state",
                    "c7_H0 : regs_valid pr s1",
                    "c7_pr : list reg"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "return_reg_ok_incr",
        "proof": [
            {
                "tactic_sig": "Lemma return_reg_ok_incr : forall s map rret , return_reg_ok s map rret -> forall s' , state_incr s s' -> return_reg_ok s' map rret .",
                "tactic_sig_no_out_arg": "Lemma return_reg_ok_incr : forall s map rret , return_reg_ok s map rret -> forall s' , state_incr s s' -> return_reg_ok s' map rret .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s : state) (map : mapping) (rret : option reg)\n  (_ : return_reg_ok s map rret) (s' : state) (_ : state_incr s s'),\nreturn_reg_ok s' map rret"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (s : state) (map : mapping) (rret : option reg)\n  (_ : return_reg_ok s map rret) (s' : state) (_ : state_incr s s'),\nreturn_reg_ok s' map rret"
                ],
                "tactic_res": [
                    "c2_goal : forall (s' : state) (_ : state_incr s s'), return_reg_ok s' map None",
                    "c2_map : mapping",
                    "c2_s : state",
                    "c3_goal : forall (s' : state) (_ : state_incr s s'),\nreturn_reg_ok s' map (Some r)",
                    "c3_H0 : reg_valid r s",
                    "c3_H : not (reg_in_map map r)",
                    "c3_r : reg",
                    "c3_map : mapping",
                    "c3_s : state"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (s' : state) (_ : state_incr s s'), return_reg_ok s' map None"
                ],
                "tactic_res": [
                    "c4_goal : return_reg_ok s' map None",
                    "c4_s' : state",
                    "c4_H : state_incr s s'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c4_goal : return_reg_ok s' map None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (s' : state) (_ : state_incr s s'),\nreturn_reg_ok s' map (Some r)"
                ],
                "tactic_res": [
                    "c5_goal : return_reg_ok s' map (Some r)",
                    "c5_s' : state",
                    "c5_H1 : state_incr s s'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c5_goal : return_reg_ok s' map (Some r)"
                ],
                "tactic_res": [
                    "c6_goal : not (reg_in_map map r)",
                    "c7_goal : reg_valid r s'"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c6_goal : not (reg_in_map map r)",
                    "c3_H : not (reg_in_map map r)",
                    "c3_r : reg",
                    "c3_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c7_goal : reg_valid r s'",
                    "c5_H1 : state_incr s s'",
                    "c5_s' : state",
                    "c3_H0 : reg_valid r s",
                    "c3_r : reg"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "new_reg_return_ok",
        "proof": [
            {
                "tactic_sig": "Lemma new_reg_return_ok : forall s1 r s2 map sig i , new_reg s1 = OK r s2 i -> map_valid map s1 -> return_reg_ok s2 map ( ret_reg sig r ) .",
                "tactic_sig_no_out_arg": "Lemma new_reg_return_ok : forall s1 r s2 map sig i , new_reg s1 = OK r s2 i -> map_valid map s1 -> return_reg_ok s2 map ( ret_reg sig r ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 : state) (r : reg) (s2 : state) (map : mapping)\n  (sig : signature) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid map s1),\nreturn_reg_ok s2 map (ret_reg sig r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s1 : state) (r : reg) (s2 : state) (map : mapping)\n  (sig : signature) (i : state_incr s1 s2)\n  (_ : eq (new_reg s1) (OK r s2 i)) (_ : map_valid map s1),\nreturn_reg_ok s2 map (ret_reg sig r)"
                ],
                "tactic_res": [
                    "c2_goal : return_reg_ok s2 map (ret_reg sig r)",
                    "c2_s1 : state",
                    "c2_r : reg",
                    "c2_s2 : state",
                    "c2_map : mapping",
                    "c2_sig : signature",
                    "c2_i : state_incr s1 s2",
                    "c2_H : eq (new_reg s1) (OK r s2 i)",
                    "c2_H0 : map_valid map s1"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : return_reg_ok s2 map (ret_reg sig r)",
                    "_global_ret_reg : forall (_ : signature) (_ : reg), option reg"
                ],
                "tactic_res": [
                    "c3_goal : return_reg_ok s2 map\n  (if xtype_eq (sig_res sig) Xvoid then None else Some r)"
                ]
            },
            {
                "tactic_sig": "destruct ( xtype_eq ( sig_res _i ) Xvoid ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( xtype_eq ( sig_res _i ) Xvoid ) .",
                "tactic_args": [
                    "c3_goal : return_reg_ok s2 map\n  (if xtype_eq (sig_res sig) Xvoid then None else Some r)",
                    "c2_sig : signature",
                    "c2_H0 : map_valid map s1",
                    "c2_H : eq (new_reg s1) (OK r s2 i)",
                    "c2_map : mapping",
                    "c2_s2 : state",
                    "c2_r : reg"
                ],
                "tactic_res": [
                    "c4_goal : return_reg_ok s2 map None",
                    "c4_e : eq (sig_res sig) Xvoid",
                    "c5_goal : return_reg_ok s2 map (Some r)",
                    "c5_n : not (eq (sig_res sig) Xvoid)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : return_reg_ok s2 map None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : return_reg_ok s2 map (Some r)"
                ],
                "tactic_res": [
                    "c6_goal : not (reg_in_map map r)",
                    "c7_goal : reg_valid r s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c6_goal : not (reg_in_map map r)",
                    "c2_H0 : map_valid map s1",
                    "c2_H : eq (new_reg s1) (OK r s2 i)",
                    "c2_map : mapping",
                    "c2_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c7_goal : reg_valid r s2",
                    "c2_H : eq (new_reg s1) (OK r s2 i)",
                    "c2_s2 : state",
                    "c2_r : reg"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "tr_move_incr",
        "proof": [
            {
                "tactic_sig": "Lemma tr_move_incr : forall s1 s2 , state_incr s1 s2 -> forall ns rs nd rd , tr_move s1. ( st_code ) ns rs nd rd -> tr_move s2. ( st_code ) ns rs nd rd .",
                "tactic_sig_no_out_arg": "Lemma tr_move_incr : forall s1 s2 , state_incr s1 s2 -> forall ns rs nd rd , tr_move s1. ( st_code ) ns rs nd rd -> tr_move s2. ( st_code ) ns rs nd rd .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (ns : node) \n  (rs : reg) (nd : node) (rd : reg)\n  (_ : tr_move (st_code s1) ns rs nd rd),\ntr_move (st_code s2) ns rs nd rd"
                ]
            },
            {
                "tactic_sig": "induction 2 .",
                "tactic_sig_no_out_arg": "induction 2 .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (ns : node) \n  (rs : reg) (nd : node) (rd : reg)\n  (_ : tr_move (st_code s1) ns rs nd rd),\ntr_move (st_code s2) ns rs nd rd"
                ],
                "tactic_res": [
                    "c2_goal : tr_move (st_code s2) n r n r",
                    "c2_r : reg",
                    "c2_n : node",
                    "c2_H : state_incr s1 s2",
                    "c2_s2 : state",
                    "c2_s1 : state",
                    "c3_goal : tr_move (st_code s2) ns rs nd rd",
                    "c3_H0 : eq (PTree.get ns (st_code s1)) (Some (Iop Omove (cons rs nil) rd nd))",
                    "c3_rd : reg",
                    "c3_nd : node",
                    "c3_rs : reg",
                    "c3_ns : positive",
                    "c3_H : state_incr s1 s2",
                    "c3_s2 : state",
                    "c3_s1 : state"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c2_goal : tr_move (st_code s2) n r n r"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c3_goal : tr_move (st_code s2) ns rs nd rd"
                ],
                "tactic_res": [
                    "c4_goal : eq (PTree.get ns (st_code s2)) (Some (Iop Omove (cons rs nil) rd nd))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c4_goal : eq (PTree.get ns (st_code s2)) (Some (Iop Omove (cons rs nil) rd nd))",
                    "c3_H0 : eq (PTree.get ns (st_code s1)) (Some (Iop Omove (cons rs nil) rd nd))",
                    "c3_rd : reg",
                    "c3_nd : node",
                    "c3_rs : reg",
                    "c3_ns : positive",
                    "c3_H : state_incr s1 s2",
                    "c3_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "tr_expr_incr",
        "proof": [
            {
                "tactic_sig": "Lemma tr_expr_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr a ns nd rd dst , tr_expr s1. ( st_code ) map pr a ns nd rd dst -> tr_expr s2. ( st_code ) map pr a ns nd rd dst with tr_condition_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr a ns ntrue nfalse , tr_condition s1. ( st_code ) map pr a ns ntrue nfalse -> tr_condition s2. ( st_code ) map pr a ns ntrue nfalse with tr_exprlist_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr al ns nd rl , tr_exprlist s1. ( st_code ) map pr al ns nd rl -> tr_exprlist s2. ( st_code ) map pr al ns nd rl .",
                "tactic_sig_no_out_arg": "Lemma tr_expr_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr a ns nd rd dst , tr_expr s1. ( st_code ) map pr a ns nd rd dst -> tr_expr s2. ( st_code ) map pr a ns nd rd dst with tr_condition_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr a ns ntrue nfalse , tr_condition s1. ( st_code ) map pr a ns ntrue nfalse -> tr_condition s2. ( st_code ) map pr a ns ntrue nfalse with tr_exprlist_incr : forall s1 s2 , state_incr s1 s2 -> forall map pr al ns nd rl , tr_exprlist s1. ( st_code ) map pr al ns nd rl -> tr_exprlist s2. ( st_code ) map pr al ns nd rl .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c1_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c1_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c1_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c2_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c2_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c3_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c3_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c3_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c3_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 EXT .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst"
                ],
                "tactic_res": [
                    "c4_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (ns nd : node) (rd : reg) (dst : option ident)\n  (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c4_s1 : state",
                    "c4_s2 : state",
                    "c4_EXT : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_sig_no_out_arg": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_args": [
                    "c4_s1 : state",
                    "c4_s2 : state",
                    "c4_EXT : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (pr : list reg) (a : expr) \n  (ns nd : node) (rd : reg) (dst : option ident)\n  (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst"
                ],
                "tactic_res": [
                    "c5_goal : tr_expr (st_code s2) map pr (Evar id) ns nd rd dst",
                    "c5_H1 : tr_move (st_code s1) ns r nd rd",
                    "c5_H0 : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c5_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c5_dst : option ident",
                    "c5_rd : reg",
                    "c5_r : reg",
                    "c5_nd : node",
                    "c5_ns : node",
                    "c5_id : positive",
                    "c5_pr : list reg",
                    "c5_map : mapping",
                    "c6_goal : tr_expr (st_code s2) map pr (Eop op al) ns nd rd dst",
                    "c6_H2 : not (In rd pr)",
                    "c6_H1 : reg_map_ok map rd dst",
                    "c6_H0 : eq (PTree.get n1 (st_code s1)) (Some (Iop op rl rd nd))",
                    "c6_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c6_dst : option ident",
                    "c6_rl : list reg",
                    "c6_n1 : node",
                    "c6_rd : reg",
                    "c6_nd : node",
                    "c6_ns : node",
                    "c6_al : exprlist",
                    "c6_op : operation",
                    "c6_pr : list reg",
                    "c6_map : mapping",
                    "c7_goal : tr_expr (st_code s2) map pr (Eload chunk addr al) ns nd rd dst",
                    "c7_H2 : not (In rd pr)",
                    "c7_H1 : reg_map_ok map rd dst",
                    "c7_H0 : eq (PTree.get n1 (st_code s1)) (Some (Iload chunk addr rl rd nd))",
                    "c7_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c7_dst : option ident",
                    "c7_rl : list reg",
                    "c7_n1 : node",
                    "c7_rd : reg",
                    "c7_nd : node",
                    "c7_ns : node",
                    "c7_al : exprlist",
                    "c7_addr : addressing",
                    "c7_chunk : memory_chunk",
                    "c7_pr : list reg",
                    "c7_map : mapping",
                    "c8_goal : tr_expr (st_code s2) map pr (Econdition a ifso ifnot) ns nd rd dst",
                    "c8_IHtr_expr2 : tr_expr (st_code s2) map pr ifnot nfalse nd rd dst",
                    "c8_IHtr_expr1 : tr_expr (st_code s2) map pr ifso ntrue nd rd dst",
                    "c8_H1 : tr_expr (st_code s1) map pr ifnot nfalse nd rd dst",
                    "c8_H0 : tr_expr (st_code s1) map pr ifso ntrue nd rd dst",
                    "c8_H : tr_condition (st_code s1) map pr a ns ntrue nfalse",
                    "c8_dst : option ident",
                    "c8_nfalse : node",
                    "c8_ntrue : node",
                    "c8_rd : reg",
                    "c8_nd : node",
                    "c8_ns : node",
                    "c8_ifnot : expr",
                    "c8_ifso : expr",
                    "c8_a : condexpr",
                    "c8_pr : list reg",
                    "c8_map : mapping",
                    "c9_goal : tr_expr (st_code s2) map pr (Elet b1 b2) ns nd rd dst",
                    "c9_IHtr_expr2 : tr_expr (st_code s2) (add_letvar map r) pr b2 n1 nd rd dst",
                    "c9_IHtr_expr1 : tr_expr (st_code s2) map pr b1 ns n1 r None",
                    "c9_H1 : tr_expr (st_code s1) (add_letvar map r) pr b2 n1 nd rd dst",
                    "c9_H0 : tr_expr (st_code s1) map pr b1 ns n1 r None",
                    "c9_H : not (reg_in_map map r)",
                    "c9_dst : option ident",
                    "c9_r : reg",
                    "c9_n1 : node",
                    "c9_rd : reg",
                    "c9_nd : node",
                    "c9_ns : node",
                    "c9_b2 : expr",
                    "c9_b1 : expr",
                    "c9_pr : list reg",
                    "c9_map : mapping",
                    "c10_goal : tr_expr (st_code s2) map pr (Eletvar n) ns nd rd dst",
                    "c10_H1 : tr_move (st_code s1) ns r nd rd",
                    "c10_H0 : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c10_H : eq (nth_error (map_letvars map) n) (Some r)",
                    "c10_dst : option ident",
                    "c10_r : reg",
                    "c10_rd : reg",
                    "c10_nd : node",
                    "c10_ns : node",
                    "c10_n : nat",
                    "c10_pr : list reg",
                    "c10_map : mapping",
                    "c11_goal : tr_expr (st_code s2) map pr (Ebuiltin ef al) ns nd rd dst",
                    "c11_H2 : not (In rd pr)",
                    "c11_H1 : reg_map_ok map rd dst",
                    "c11_H0 : eq (PTree.get n1 (st_code s1))\n  (Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd))",
                    "c11_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c11_rl : list reg",
                    "c11_n1 : node",
                    "c11_dst : option ident",
                    "c11_rd : reg",
                    "c11_nd : node",
                    "c11_ns : node",
                    "c11_al : exprlist",
                    "c11_ef : external_function",
                    "c11_pr : list reg",
                    "c11_map : mapping",
                    "c12_goal : tr_expr (st_code s2) map pr (Eexternal id sg al) ns nd rd dst",
                    "c12_H2 : not (In rd pr)",
                    "c12_H1 : reg_map_ok map rd dst",
                    "c12_H0 : eq (PTree.get n1 (st_code s1)) (Some (Icall sg (inr id) rl rd nd))",
                    "c12_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c12_rl : list reg",
                    "c12_n1 : node",
                    "c12_dst : option ident",
                    "c12_rd : reg",
                    "c12_nd : node",
                    "c12_ns : node",
                    "c12_al : exprlist",
                    "c12_sg : signature",
                    "c12_id : ident",
                    "c12_pr : list reg",
                    "c12_map : mapping"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c5_goal : tr_expr (st_code s2) map pr (Evar id) ns nd rd dst"
                ],
                "tactic_res": [
                    "c13_goal : eq (PTree.get id (map_vars map)) (Some ?r)",
                    "c14_goal : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c15_goal : tr_move (st_code s2) ns r nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : eq (PTree.get id (map_vars map)) (Some ?r)",
                    "c5_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c5_id : positive",
                    "c5_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c5_H0 : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c5_dst : option ident",
                    "c5_r : reg",
                    "c5_rd : reg",
                    "c5_pr : list reg",
                    "c5_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c6_goal : tr_expr (st_code s2) map pr (Eop op al) ns nd rd dst"
                ],
                "tactic_res": [
                    "c16_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c17_goal : eq (PTree.get n1 (st_code s2)) (Some (Iop op rl rd nd))",
                    "c18_goal : reg_map_ok map rd dst",
                    "c19_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c6_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c6_ns : node",
                    "c6_al : exprlist",
                    "c6_pr : list reg",
                    "c6_map : mapping",
                    "c4_s2 : state",
                    "c1_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : eq (PTree.get n1 (st_code s2)) (Some (Iop op rl rd nd))",
                    "c6_H0 : eq (PTree.get n1 (st_code s1)) (Some (Iop op rl rd nd))",
                    "c6_rl : list reg",
                    "c6_n1 : node",
                    "c6_rd : reg",
                    "c6_nd : node",
                    "c6_op : operation",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : reg_map_ok map rd dst",
                    "c6_H1 : reg_map_ok map rd dst",
                    "c6_dst : option ident",
                    "c6_rd : reg",
                    "c6_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : not (In rd pr)",
                    "c6_H2 : not (In rd pr)",
                    "c6_rd : reg",
                    "c6_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c7_goal : tr_expr (st_code s2) map pr (Eload chunk addr al) ns nd rd dst"
                ],
                "tactic_res": [
                    "c20_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c21_goal : eq (PTree.get n1 (st_code s2)) (Some (Iload chunk addr rl rd nd))",
                    "c22_goal : reg_map_ok map rd dst",
                    "c23_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c7_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c7_ns : node",
                    "c7_al : exprlist",
                    "c7_pr : list reg",
                    "c7_map : mapping",
                    "c4_s2 : state",
                    "c1_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : eq (PTree.get n1 (st_code s2)) (Some (Iload chunk addr rl rd nd))",
                    "c7_H0 : eq (PTree.get n1 (st_code s1)) (Some (Iload chunk addr rl rd nd))",
                    "c7_rl : list reg",
                    "c7_n1 : node",
                    "c7_rd : reg",
                    "c7_nd : node",
                    "c7_addr : addressing",
                    "c7_chunk : memory_chunk",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : reg_map_ok map rd dst",
                    "c7_H1 : reg_map_ok map rd dst",
                    "c7_dst : option ident",
                    "c7_rd : reg",
                    "c7_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : not (In rd pr)",
                    "c7_H2 : not (In rd pr)",
                    "c7_rd : reg",
                    "c7_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c8_goal : tr_expr (st_code s2) map pr (Econdition a ifso ifnot) ns nd rd dst"
                ],
                "tactic_res": [
                    "c24_goal : tr_condition (st_code s2) map pr a ns ?ntrue ?nfalse",
                    "c25_goal : tr_expr (st_code s2) map pr ifso ntrue nd rd dst",
                    "c26_goal : tr_expr (st_code s2) map pr ifnot nfalse nd rd dst"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : tr_condition (st_code s2) map pr a ns ?ntrue ?nfalse",
                    "c8_H : tr_condition (st_code s1) map pr a ns ntrue nfalse",
                    "c8_ns : node",
                    "c8_a : condexpr",
                    "c8_pr : list reg",
                    "c8_map : mapping",
                    "c4_s2 : state",
                    "c1_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : tr_expr (st_code s2) map pr ifso ntrue nd rd dst",
                    "c8_dst : option ident",
                    "c8_ntrue : node",
                    "c8_rd : reg",
                    "c8_nd : node",
                    "c8_ifso : expr",
                    "c8_pr : list reg",
                    "c8_map : mapping",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : tr_expr (st_code s2) map pr ifnot nfalse nd rd dst",
                    "c8_dst : option ident",
                    "c8_nfalse : node",
                    "c8_rd : reg",
                    "c8_nd : node",
                    "c8_ifnot : expr",
                    "c8_pr : list reg",
                    "c8_map : mapping",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c9_goal : tr_expr (st_code s2) map pr (Elet b1 b2) ns nd rd dst"
                ],
                "tactic_res": [
                    "c27_goal : not (reg_in_map map ?r)",
                    "c28_goal : tr_expr (st_code s2) map pr b1 ns ?n1 r None",
                    "c29_goal : tr_expr (st_code s2) (add_letvar map r) pr b2 n1 nd rd dst"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : not (reg_in_map map ?r)",
                    "c9_H : not (reg_in_map map r)",
                    "c9_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : tr_expr (st_code s2) map pr b1 ns ?n1 r None",
                    "c9_r : reg",
                    "c9_ns : node",
                    "c9_b1 : expr",
                    "c9_pr : list reg",
                    "c9_map : mapping",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : tr_expr (st_code s2) (add_letvar map r) pr b2 n1 nd rd dst",
                    "c9_dst : option ident",
                    "c9_r : reg",
                    "c9_n1 : node",
                    "c9_rd : reg",
                    "c9_nd : node",
                    "c9_b2 : expr",
                    "c9_pr : list reg",
                    "c9_map : mapping",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c10_goal : tr_expr (st_code s2) map pr (Eletvar n) ns nd rd dst"
                ],
                "tactic_res": [
                    "c30_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c31_goal : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c32_goal : tr_move (st_code s2) ns r nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c30_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c10_H : eq (nth_error (map_letvars map) n) (Some r)",
                    "c10_n : nat",
                    "c10_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c10_H0 : or (and (eq rd r) (eq dst None))\n  (and (reg_map_ok map rd dst) (not (In rd pr)))",
                    "c10_dst : option ident",
                    "c10_rd : reg",
                    "c10_r : reg",
                    "c10_pr : list reg",
                    "c10_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c11_goal : tr_expr (st_code s2) map pr (Ebuiltin ef al) ns nd rd dst"
                ],
                "tactic_res": [
                    "c33_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c34_goal : eq (PTree.get n1 (st_code s2))\n  (Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd))",
                    "c35_goal : reg_map_ok map rd dst",
                    "c36_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c11_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c11_ns : node",
                    "c11_al : exprlist",
                    "c11_pr : list reg",
                    "c11_map : mapping",
                    "c4_s2 : state",
                    "c1_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c34_goal : eq (PTree.get n1 (st_code s2))\n  (Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd))",
                    "c11_H0 : eq (PTree.get n1 (st_code s1))\n  (Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd))",
                    "c11_rl : list reg",
                    "c11_n1 : node",
                    "c11_rd : reg",
                    "c11_nd : node",
                    "c11_ef : external_function",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c35_goal : reg_map_ok map rd dst",
                    "c11_H1 : reg_map_ok map rd dst",
                    "c11_dst : option ident",
                    "c11_rd : reg",
                    "c11_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c36_goal : not (In rd pr)",
                    "c11_H2 : not (In rd pr)",
                    "c11_rd : reg",
                    "c11_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c12_goal : tr_expr (st_code s2) map pr (Eexternal id sg al) ns nd rd dst"
                ],
                "tactic_res": [
                    "c37_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c38_goal : eq (PTree.get n1 (st_code s2)) (Some (Icall sg (inr id) rl rd nd))",
                    "c39_goal : reg_map_ok map rd dst",
                    "c40_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c37_goal : tr_exprlist (st_code s2) map pr al ns ?n1 ?rl",
                    "c12_H : tr_exprlist (st_code s1) map pr al ns n1 rl",
                    "c12_ns : node",
                    "c12_al : exprlist",
                    "c12_pr : list reg",
                    "c12_map : mapping",
                    "c4_s2 : state",
                    "c1_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c38_goal : eq (PTree.get n1 (st_code s2)) (Some (Icall sg (inr id) rl rd nd))",
                    "c12_H0 : eq (PTree.get n1 (st_code s1)) (Some (Icall sg (inr id) rl rd nd))",
                    "c12_rl : list reg",
                    "c12_n1 : node",
                    "c12_rd : reg",
                    "c12_nd : node",
                    "c12_sg : signature",
                    "c12_id : ident",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c39_goal : reg_map_ok map rd dst",
                    "c12_H1 : reg_map_ok map rd dst",
                    "c12_dst : option ident",
                    "c12_rd : reg",
                    "c12_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : not (In rd pr)",
                    "c12_H2 : not (In rd pr)",
                    "c12_rd : reg",
                    "c12_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c15_goal : tr_move (st_code s2) ns r nd rd",
                    "_global_tr_move_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (ns : node) (rs : reg) (nd : node) (rd : reg)\n         (_ : tr_move (st_code s1) ns rs nd rd),\n       tr_move (st_code s2) ns rs nd rd"
                ],
                "tactic_res": [
                    "c41_goal : state_incr ?s1 s2",
                    "c42_goal : tr_move (st_code s1) ns r nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c41_goal : state_incr ?s1 s2",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c42_goal : tr_move (st_code s1) ns r nd rd",
                    "c5_H1 : tr_move (st_code s1) ns r nd rd",
                    "c5_r : reg",
                    "c5_rd : reg",
                    "c5_ns : node",
                    "c5_nd : node",
                    "c4_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c32_goal : tr_move (st_code s2) ns r nd rd",
                    "_global_tr_move_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (ns : node) (rs : reg) (nd : node) (rd : reg)\n         (_ : tr_move (st_code s1) ns rs nd rd),\n       tr_move (st_code s2) ns rs nd rd"
                ],
                "tactic_res": [
                    "c43_goal : state_incr ?s1 s2",
                    "c44_goal : tr_move (st_code s1) ns r nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c43_goal : state_incr ?s1 s2",
                    "c4_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c44_goal : tr_move (st_code s1) ns r nd rd",
                    "c10_H1 : tr_move (st_code s1) ns r nd rd",
                    "c10_rd : reg",
                    "c10_r : reg",
                    "c10_ns : node",
                    "c10_nd : node",
                    "c4_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 EXT .",
                "tactic_args": [
                    "c2_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c45_goal : forall (map : mapping) (pr : list reg) (a : condexpr)\n  (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c45_s1 : state",
                    "c45_s2 : state",
                    "c45_EXT : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_sig_no_out_arg": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_args": [
                    "c45_s1 : state",
                    "c45_s2 : state",
                    "c45_EXT : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c45_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c45_goal : forall (map : mapping) (pr : list reg) (a : condexpr)\n  (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c46_goal : tr_condition (st_code s2) map pr (CEcond cond bl) ns ntrue nfalse",
                    "c46_H0 : eq (PTree.get n1 (st_code s1)) (Some (Icond cond rl ntrue nfalse))",
                    "c46_H : tr_exprlist (st_code s1) map pr bl ns n1 rl",
                    "c46_rl : list reg",
                    "c46_n1 : node",
                    "c46_nfalse : node",
                    "c46_ntrue : node",
                    "c46_ns : node",
                    "c46_bl : exprlist",
                    "c46_cond : condition",
                    "c46_pr : list reg",
                    "c46_map : mapping",
                    "c47_goal : tr_condition (st_code s2) map pr (CEcondition a1 a2 a3) ns ntrue nfalse",
                    "c47_IHtr_condition3 : tr_condition (st_code s2) map pr a3 n3 ntrue nfalse",
                    "c47_IHtr_condition2 : tr_condition (st_code s2) map pr a2 n2 ntrue nfalse",
                    "c47_IHtr_condition1 : tr_condition (st_code s2) map pr a1 ns n2 n3",
                    "c47_H1 : tr_condition (st_code s1) map pr a3 n3 ntrue nfalse",
                    "c47_H0 : tr_condition (st_code s1) map pr a2 n2 ntrue nfalse",
                    "c47_H : tr_condition (st_code s1) map pr a1 ns n2 n3",
                    "c47_n3 : node",
                    "c47_n2 : node",
                    "c47_nfalse : node",
                    "c47_ntrue : node",
                    "c47_ns : node",
                    "c47_a3 : condexpr",
                    "c47_a2 : condexpr",
                    "c47_a1 : condexpr",
                    "c47_pr : list reg",
                    "c47_map : mapping",
                    "c48_goal : tr_condition (st_code s2) map pr (CElet a b) ns ntrue nfalse",
                    "c48_IHtr_condition : tr_condition (st_code s2) (add_letvar map r) pr b n1 ntrue nfalse",
                    "c48_H1 : tr_condition (st_code s1) (add_letvar map r) pr b n1 ntrue nfalse",
                    "c48_H0 : tr_expr (st_code s1) map pr a ns n1 r None",
                    "c48_H : not (reg_in_map map r)",
                    "c48_n1 : node",
                    "c48_r : reg",
                    "c48_nfalse : node",
                    "c48_ntrue : node",
                    "c48_ns : node",
                    "c48_b : condexpr",
                    "c48_a : expr",
                    "c48_pr : list reg",
                    "c48_map : mapping"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c46_goal : tr_condition (st_code s2) map pr (CEcond cond bl) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c49_goal : tr_exprlist (st_code s2) map pr bl ns ?n1 ?rl",
                    "c50_goal : eq (PTree.get n1 (st_code s2)) (Some (Icond cond rl ntrue nfalse))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c49_goal : tr_exprlist (st_code s2) map pr bl ns ?n1 ?rl",
                    "c46_H : tr_exprlist (st_code s1) map pr bl ns n1 rl",
                    "c46_ns : node",
                    "c46_bl : exprlist",
                    "c46_pr : list reg",
                    "c46_map : mapping",
                    "c45_s2 : state",
                    "c2_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c50_goal : eq (PTree.get n1 (st_code s2)) (Some (Icond cond rl ntrue nfalse))",
                    "c46_H0 : eq (PTree.get n1 (st_code s1)) (Some (Icond cond rl ntrue nfalse))",
                    "c46_rl : list reg",
                    "c46_ntrue : node",
                    "c46_nfalse : node",
                    "c46_n1 : node",
                    "c46_cond : condition",
                    "c45_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c45_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c47_goal : tr_condition (st_code s2) map pr (CEcondition a1 a2 a3) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c51_goal : tr_condition (st_code s2) map pr a1 ns ?n2 ?n3",
                    "c52_goal : tr_condition (st_code s2) map pr a2 n2 ntrue nfalse",
                    "c53_goal : tr_condition (st_code s2) map pr a3 n3 ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c51_goal : tr_condition (st_code s2) map pr a1 ns ?n2 ?n3",
                    "c47_ns : node",
                    "c47_a1 : condexpr",
                    "c47_pr : list reg",
                    "c47_map : mapping",
                    "c45_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c52_goal : tr_condition (st_code s2) map pr a2 n2 ntrue nfalse",
                    "c47_ntrue : node",
                    "c47_nfalse : node",
                    "c47_n2 : node",
                    "c47_a2 : condexpr",
                    "c47_pr : list reg",
                    "c47_map : mapping",
                    "c45_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c53_goal : tr_condition (st_code s2) map pr a3 n3 ntrue nfalse",
                    "c47_ntrue : node",
                    "c47_nfalse : node",
                    "c47_n3 : node",
                    "c47_a3 : condexpr",
                    "c47_pr : list reg",
                    "c47_map : mapping",
                    "c45_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c48_goal : tr_condition (st_code s2) map pr (CElet a b) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c54_goal : not (reg_in_map map ?r)",
                    "c55_goal : tr_expr (st_code s2) map pr a ns ?n1 r None",
                    "c56_goal : tr_condition (st_code s2) (add_letvar map r) pr b n1 ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c54_goal : not (reg_in_map map ?r)",
                    "c48_H : not (reg_in_map map r)",
                    "c48_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c55_goal : tr_expr (st_code s2) map pr a ns ?n1 r None",
                    "c48_H0 : tr_expr (st_code s1) map pr a ns n1 r None",
                    "c48_r : reg",
                    "c48_ns : node",
                    "c48_a : expr",
                    "c48_pr : list reg",
                    "c48_map : mapping",
                    "c45_s2 : state",
                    "c2_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c56_goal : tr_condition (st_code s2) (add_letvar map r) pr b n1 ntrue nfalse",
                    "c48_n1 : node",
                    "c48_r : reg",
                    "c48_ntrue : node",
                    "c48_nfalse : node",
                    "c48_b : condexpr",
                    "c48_pr : list reg",
                    "c48_map : mapping",
                    "c45_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 EXT .",
                "tactic_args": [
                    "c3_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c57_goal : forall (map : mapping) (pr : list reg) (al : exprlist) \n  (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c57_s1 : state",
                    "c57_s2 : state",
                    "c57_EXT : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_sig_no_out_arg": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_args": [
                    "c57_s1 : state",
                    "c57_s2 : state",
                    "c57_EXT : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c57_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c57_goal : forall (map : mapping) (pr : list reg) (al : exprlist) \n  (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c58_goal : tr_exprlist (st_code s2) map pr Enil n n nil",
                    "c58_n : node",
                    "c58_pr : list reg",
                    "c58_map : mapping",
                    "c59_goal : tr_exprlist (st_code s2) map pr (Econs a1 al) ns nd (cons r1 rl)",
                    "c59_IHtr_exprlist : tr_exprlist (st_code s2) map (cons r1 pr) al n1 nd rl",
                    "c59_H0 : tr_exprlist (st_code s1) map (cons r1 pr) al n1 nd rl",
                    "c59_H : tr_expr (st_code s1) map pr a1 ns n1 r1 None",
                    "c59_n1 : node",
                    "c59_rl : list reg",
                    "c59_r1 : reg",
                    "c59_nd : node",
                    "c59_ns : node",
                    "c59_al : exprlist",
                    "c59_a1 : expr",
                    "c59_pr : list reg",
                    "c59_map : mapping"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c58_goal : tr_exprlist (st_code s2) map pr Enil n n nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c59_goal : tr_exprlist (st_code s2) map pr (Econs a1 al) ns nd (cons r1 rl)"
                ],
                "tactic_res": [
                    "c60_goal : tr_expr (st_code s2) map pr a1 ns ?n1 r1 None",
                    "c61_goal : tr_exprlist (st_code s2) map (cons r1 pr) al n1 nd rl"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c60_goal : tr_expr (st_code s2) map pr a1 ns ?n1 r1 None",
                    "c59_H : tr_expr (st_code s1) map pr a1 ns n1 r1 None",
                    "c59_r1 : reg",
                    "c59_ns : node",
                    "c59_a1 : expr",
                    "c59_pr : list reg",
                    "c59_map : mapping",
                    "c57_s2 : state",
                    "c3_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c61_goal : tr_exprlist (st_code s2) map (cons r1 pr) al n1 nd rl",
                    "c59_n1 : node",
                    "c59_rl : list reg",
                    "c59_r1 : reg",
                    "c59_nd : node",
                    "c59_al : exprlist",
                    "c59_pr : list reg",
                    "c59_map : mapping",
                    "c57_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_move_charact",
        "proof": [
            {
                "tactic_sig": "Lemma add_move_charact : forall s ns rs nd rd s' i , add_move rs rd nd s = OK ns s' i -> tr_move s'. ( st_code ) ns rs nd rd .",
                "tactic_sig_no_out_arg": "Lemma add_move_charact : forall s ns rs nd rd s' i , add_move rs rd nd s = OK ns s' i -> tr_move s'. ( st_code ) ns rs nd rd .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s : state) (ns : node) (rs : reg) (nd : node) \n  (rd : reg) (s' : state) (i : state_incr s s')\n  (_ : eq (add_move rs rd nd s) (OK ns s' i)),\ntr_move (st_code s') ns rs nd rd"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s : state) (ns : node) (rs : reg) (nd : node) \n  (rd : reg) (s' : state) (i : state_incr s s')\n  (_ : eq (add_move rs rd nd s) (OK ns s' i)),\ntr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c2_goal : tr_move (st_code s') ns rs nd rd",
                    "c2_s : state",
                    "c2_ns : node",
                    "c2_rs : reg",
                    "c2_nd : node",
                    "c2_rd : reg",
                    "c2_s' : state",
                    "c2_i : state_incr s s'",
                    "c2_H : eq (add_move rs rd nd s) (OK ns s' i)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_add_move : forall (_ : reg) (_ : reg) (_ : node), mon node",
                    "c2_H : eq (add_move rs rd nd s) (OK ns s' i)"
                ],
                "tactic_res": [
                    "c2_H : eq\n  ((if Reg.eq rs rd\n    then ret nd\n    else add_instr (Iop Omove (cons rs nil) rd nd)) s) \n  (OK ns s' i)"
                ]
            },
            {
                "tactic_sig": "destruct ( Reg.eq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Reg.eq _i _i ) .",
                "tactic_args": [
                    "c2_goal : tr_move (st_code s') ns rs nd rd",
                    "c2_rs : reg",
                    "c2_rd : reg",
                    "c2_H : eq\n  ((if Reg.eq rs rd\n    then ret nd\n    else add_instr (Iop Omove (cons rs nil) rd nd)) s) \n  (OK ns s' i)",
                    "c2_s' : state",
                    "c2_nd : node",
                    "c2_ns : node"
                ],
                "tactic_res": [
                    "c3_goal : tr_move (st_code s') ns rs nd rd",
                    "c3_H : eq (ret nd s) (OK ns s' i)",
                    "c3_e : eq rs rd",
                    "c4_goal : tr_move (st_code s') ns rs nd rd",
                    "c4_H : eq (add_instr (Iop Omove (cons rs nil) rd nd) s) (OK ns s' i)",
                    "c4_n : not (eq rs rd)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : tr_move (st_code s') ns rs nd rd",
                    "c3_H : eq (ret nd s) (OK ns s' i)"
                ],
                "tactic_res": [
                    "c5_goal : tr_move (st_code s') ns rd ns rd",
                    "c5_i : state_incr s' s'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : tr_move (st_code s') ns rd ns rd"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : tr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c6_goal : eq (PTree.get ns (st_code s')) (Some (Iop Omove (cons rs nil) rd nd))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c6_goal : eq (PTree.get ns (st_code s')) (Some (Iop Omove (cons rs nil) rd nd))",
                    "c4_H : eq (add_instr (Iop Omove (cons rs nil) rd nd) s) (OK ns s' i)",
                    "c2_s' : state",
                    "c2_rd : reg",
                    "c2_nd : node",
                    "c2_rs : reg",
                    "c2_ns : node"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_expr_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_expr_charact : forall a map rd nd s ns s' pr INCR ( TR : transl_expr map a rd nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : target_reg_ok map pr a rd ) ( VALID : regs_valid pr s ) ( VALID2 : reg_valid rd s ) , tr_expr s'. ( st_code ) map pr a ns nd rd None with transl_exprlist_charact : forall al map rl nd s ns s' pr INCR ( TR : transl_exprlist map al rl nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : target_regs_ok map pr al rl ) ( VALID1 : regs_valid pr s ) ( VALID2 : regs_valid rl s ) , tr_exprlist s'. ( st_code ) map pr al ns nd rl with transl_condexpr_charact : forall a map ntrue nfalse s ns s' pr INCR ( TR : transl_condexpr map a ntrue nfalse s = OK ns s' INCR ) ( WF : map_valid map s ) ( VALID : regs_valid pr s ) , tr_condition s'. ( st_code ) map pr a ns ntrue nfalse .",
                "tactic_sig_no_out_arg": "Lemma transl_expr_charact : forall a map rd nd s ns s' pr INCR ( TR : transl_expr map a rd nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : target_reg_ok map pr a rd ) ( VALID : regs_valid pr s ) ( VALID2 : reg_valid rd s ) , tr_expr s'. ( st_code ) map pr a ns nd rd None with transl_exprlist_charact : forall al map rl nd s ns s' pr INCR ( TR : transl_exprlist map al rl nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : target_regs_ok map pr al rl ) ( VALID1 : regs_valid pr s ) ( VALID2 : regs_valid rl s ) , tr_exprlist s'. ( st_code ) map pr al ns nd rl with transl_condexpr_charact : forall a map ntrue nfalse s ns s' pr INCR ( TR : transl_condexpr map a ntrue nfalse s = OK ns s' INCR ) ( WF : map_valid map s ) ( VALID : regs_valid pr s ) , tr_condition s'. ( st_code ) map pr a ns ntrue nfalse .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None",
                    "c1_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c1_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c1_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None",
                    "c2_goal : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c2_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c2_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c2_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None",
                    "c3_goal : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c3_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c3_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c3_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro a .",
                "tactic_args": [
                    "c1_goal : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c4_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None",
                    "c4_a : expr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None",
                    "c4_a : expr"
                ],
                "tactic_res": [
                    "c5_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Evar i) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Evar i) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c5_i : ident",
                    "c6_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eop o e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eop o e) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eop o e) ns nd rd None",
                    "c6_e : exprlist",
                    "c6_o : operation",
                    "c7_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eload m a e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eload m a e) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eload m a e) ns nd rd None",
                    "c7_e : exprlist",
                    "c7_a : addressing",
                    "c7_m : memory_chunk",
                    "c8_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : target_reg_ok map pr (Econdition c a1 a2) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Econdition c a1 a2) ns nd rd None",
                    "c8_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a2 rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a2 ns nd rd None",
                    "c8_IHa1 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a1 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a1 rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a1 ns nd rd None",
                    "c8_a2 : expr",
                    "c8_a1 : expr",
                    "c8_c : condexpr",
                    "c9_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Elet a1 a2) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Elet a1 a2) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Elet a1 a2) ns nd rd None",
                    "c9_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a2 rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a2 ns nd rd None",
                    "c9_IHa1 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a1 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a1 rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a1 ns nd rd None",
                    "c9_a2 : expr",
                    "c9_a1 : expr",
                    "c10_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eletvar n) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eletvar n) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c10_n : nat",
                    "c11_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Ebuiltin e e0) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Ebuiltin e e0) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Ebuiltin e e0) ns nd rd None",
                    "c11_e0 : exprlist",
                    "c11_e : external_function",
                    "c12_goal : forall (map : mapping) (rd : reg) (nd : node) (s0 : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s0 s')\n  (_ : eq (transl_expr map (Eexternal i s e) rd nd s0) (OK ns s' INCR))\n  (_ : map_valid map s0)\n  (_ : target_reg_ok map pr (Eexternal i s e) rd)\n  (_ : regs_valid pr s0) (_ : reg_valid rd s0),\ntr_expr (st_code s') map pr (Eexternal i s e) ns nd rd None",
                    "c12_e : exprlist",
                    "c12_s : signature",
                    "c12_i : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Evar i) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Evar i) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ],
                "tactic_res": [
                    "c13_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c13_map : mapping",
                    "c13_rd : reg",
                    "c13_nd : node",
                    "c13_s : state",
                    "c13_ns : node",
                    "c13_s' : state",
                    "c13_pr : list reg",
                    "c13_INCR : state_incr s s'",
                    "c13_TR : eq (transl_expr map (Evar i) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c13_WF : map_valid map s",
                    "c13_OK : target_reg_ok map pr (Evar i) rd",
                    "c13_VALID : regs_valid pr s",
                    "c13_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c13_TR : eq (transl_expr map (Evar i) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c13_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c13_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)",
                    "c13_INCR1 : state_incr s0 s'",
                    "c13_INCR0 : state_incr s s0",
                    "c13_s0 : state",
                    "c13_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eop o e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eop o e) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eop o e) ns nd rd None"
                ],
                "tactic_res": [
                    "c14_goal : tr_expr (st_code s') map pr (Eop o e) ns nd rd None",
                    "c14_map : mapping",
                    "c14_rd : reg",
                    "c14_nd : node",
                    "c14_s : state",
                    "c14_ns : node",
                    "c14_s' : state",
                    "c14_pr : list reg",
                    "c14_INCR : state_incr s s'",
                    "c14_TR : eq (transl_expr map (Eop o e) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c14_WF : map_valid map s",
                    "c14_OK : target_reg_ok map pr (Eop o e) rd",
                    "c14_VALID : regs_valid pr s",
                    "c14_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c14_TR : eq (transl_expr map (Eop o e) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c14_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c14_EQ1 : eq (add_instr (Iop o x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c14_INCR3 : state_incr s1 s'",
                    "c14_INCR2 : state_incr s0 s1",
                    "c14_s1 : state",
                    "c14_x0 : node",
                    "c14_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c14_INCR1 : state_incr s0 s'",
                    "c14_INCR0 : state_incr s s0",
                    "c14_s0 : state",
                    "c14_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eload m a e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eload m a e) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eload m a e) ns nd rd None"
                ],
                "tactic_res": [
                    "c15_goal : tr_expr (st_code s') map pr (Eload m a e) ns nd rd None",
                    "c15_map : mapping",
                    "c15_rd : reg",
                    "c15_nd : node",
                    "c15_s : state",
                    "c15_ns : node",
                    "c15_s' : state",
                    "c15_pr : list reg",
                    "c15_INCR : state_incr s s'",
                    "c15_TR : eq (transl_expr map (Eload m a e) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c15_WF : map_valid map s",
                    "c15_OK : target_reg_ok map pr (Eload m a e) rd",
                    "c15_VALID : regs_valid pr s",
                    "c15_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c15_TR : eq (transl_expr map (Eload m a e) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c15_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c15_EQ1 : eq (add_instr (Iload m a x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c15_INCR3 : state_incr s1 s'",
                    "c15_INCR2 : state_incr s0 s1",
                    "c15_s1 : state",
                    "c15_x0 : node",
                    "c15_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c15_INCR1 : state_incr s0 s'",
                    "c15_INCR0 : state_incr s s0",
                    "c15_s0 : state",
                    "c15_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : target_reg_ok map pr (Econdition c a1 a2) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Econdition c a1 a2) ns nd rd None"
                ],
                "tactic_res": [
                    "c16_goal : tr_expr (st_code s') map pr (Econdition c a1 a2) ns nd rd None",
                    "c16_map : mapping",
                    "c16_rd : reg",
                    "c16_nd : node",
                    "c16_s : state",
                    "c16_ns : node",
                    "c16_s' : state",
                    "c16_pr : list reg",
                    "c16_INCR : state_incr s s'",
                    "c16_TR : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n  (RTLgen.OK ns s' INCR)",
                    "c16_WF : map_valid map s",
                    "c16_OK : target_reg_ok map pr (Econdition c a1 a2) rd",
                    "c16_VALID : regs_valid pr s",
                    "c16_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c16_TR : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c16_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c16_EQ1 : eq (transl_expr map a1 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c16_INCR3 : state_incr s1 s'",
                    "c16_INCR2 : state_incr s0 s1",
                    "c16_s1 : state",
                    "c16_x0 : node",
                    "c16_EQ : eq (transl_expr map a2 rd nd s) (RTLgen.OK x s0 INCR0)",
                    "c16_INCR1 : state_incr s0 s'",
                    "c16_INCR0 : state_incr s s0",
                    "c16_s0 : state",
                    "c16_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Elet a1 a2) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Elet a1 a2) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Elet a1 a2) ns nd rd None"
                ],
                "tactic_res": [
                    "c17_goal : tr_expr (st_code s') map pr (Elet a1 a2) ns nd rd None",
                    "c17_map : mapping",
                    "c17_rd : reg",
                    "c17_nd : node",
                    "c17_s : state",
                    "c17_ns : node",
                    "c17_s' : state",
                    "c17_pr : list reg",
                    "c17_INCR : state_incr s s'",
                    "c17_TR : eq (transl_expr map (Elet a1 a2) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c17_WF : map_valid map s",
                    "c17_OK : target_reg_ok map pr (Elet a1 a2) rd",
                    "c17_VALID : regs_valid pr s",
                    "c17_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c17_TR : eq (transl_expr map (Elet a1 a2) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c17_EQ2 : eq (transl_expr map a1 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c17_EQ1 : eq (transl_expr (add_letvar map x) a2 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c17_INCR3 : state_incr s1 s'",
                    "c17_INCR2 : state_incr s0 s1",
                    "c17_s1 : state",
                    "c17_x0 : node",
                    "c17_EQ : eq (new_reg s) (RTLgen.OK x s0 INCR0)",
                    "c17_INCR1 : state_incr s0 s'",
                    "c17_INCR0 : state_incr s s0",
                    "c17_s0 : state",
                    "c17_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eletvar n) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Eletvar n) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ],
                "tactic_res": [
                    "c18_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c18_map : mapping",
                    "c18_rd : reg",
                    "c18_nd : node",
                    "c18_s : state",
                    "c18_ns : node",
                    "c18_s' : state",
                    "c18_pr : list reg",
                    "c18_INCR : state_incr s s'",
                    "c18_TR : eq (transl_expr map (Eletvar n) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c18_WF : map_valid map s",
                    "c18_OK : target_reg_ok map pr (Eletvar n) rd",
                    "c18_VALID : regs_valid pr s",
                    "c18_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c18_TR : eq (transl_expr map (Eletvar n) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c18_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c18_EQ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0)",
                    "c18_INCR1 : state_incr s0 s'",
                    "c18_INCR0 : state_incr s s0",
                    "c18_s0 : state",
                    "c18_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Ebuiltin e e0) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr (Ebuiltin e e0) rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr (Ebuiltin e e0) ns nd rd None"
                ],
                "tactic_res": [
                    "c19_goal : tr_expr (st_code s') map pr (Ebuiltin e e0) ns nd rd None",
                    "c19_map : mapping",
                    "c19_rd : reg",
                    "c19_nd : node",
                    "c19_s : state",
                    "c19_ns : node",
                    "c19_s' : state",
                    "c19_pr : list reg",
                    "c19_INCR : state_incr s s'",
                    "c19_TR : eq (transl_expr map (Ebuiltin e e0) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c19_WF : map_valid map s",
                    "c19_OK : target_reg_ok map pr (Ebuiltin e e0) rd",
                    "c19_VALID : regs_valid pr s",
                    "c19_VALID2 : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c19_TR : eq (transl_expr map (Ebuiltin e e0) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c19_EQ2 : eq (transl_exprlist map e0 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c19_EQ1 : eq (add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c19_INCR3 : state_incr s1 s'",
                    "c19_INCR2 : state_incr s0 s1",
                    "c19_s1 : state",
                    "c19_x0 : node",
                    "c19_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c19_INCR1 : state_incr s0 s'",
                    "c19_INCR0 : state_incr s s0",
                    "c19_s0 : state",
                    "c19_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (map : mapping) (rd : reg) (nd : node) (s0 : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s0 s')\n  (_ : eq (transl_expr map (Eexternal i s e) rd nd s0) (OK ns s' INCR))\n  (_ : map_valid map s0)\n  (_ : target_reg_ok map pr (Eexternal i s e) rd)\n  (_ : regs_valid pr s0) (_ : reg_valid rd s0),\ntr_expr (st_code s') map pr (Eexternal i s e) ns nd rd None"
                ],
                "tactic_res": [
                    "c20_goal : tr_expr (st_code s') map pr (Eexternal i s e) ns nd rd None",
                    "c20_map : mapping",
                    "c20_rd : reg",
                    "c20_nd : node",
                    "c20_s0 : state",
                    "c20_ns : node",
                    "c20_s' : state",
                    "c20_pr : list reg",
                    "c20_INCR : state_incr s0 s'",
                    "c20_TR : eq (transl_expr map (Eexternal i s e) rd nd s0) (RTLgen.OK ns s' INCR)",
                    "c20_WF : map_valid map s0",
                    "c20_OK : target_reg_ok map pr (Eexternal i s e) rd",
                    "c20_VALID : regs_valid pr s0",
                    "c20_VALID2 : reg_valid rd s0"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c20_TR : eq (transl_expr map (Eexternal i s e) rd nd s0) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c20_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c20_EQ1 : eq (add_instr (Icall s (inr i) x rd nd) s1) (RTLgen.OK x0 s2 INCR2)",
                    "c20_INCR3 : state_incr s2 s'",
                    "c20_INCR2 : state_incr s1 s2",
                    "c20_s2 : state",
                    "c20_x0 : node",
                    "c20_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c20_INCR1 : state_incr s1 s'",
                    "c20_INCR0 : state_incr s0 s1",
                    "c20_s1 : state",
                    "c20_x : list reg"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c13_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c13_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c21_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c21_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg"
                ],
                "tactic_res": [
                    "c22_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "caseEq ( map_vars _i ) !i .",
                "tactic_sig_no_out_arg": "caseEq ( map_vars _i ) !i .",
                "tactic_args": [
                    "c22_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c13_map : mapping"
                ],
                "tactic_res": [
                    "c23_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c24_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ],
                "tactic_res": [
                    "c25_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c25_r : reg",
                    "c25_H : eq (PTree.get i (map_vars map)) (Some r)",
                    "c25_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c25_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c25_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c25_EQ : eq (find_var map i s0) (RTLgen.OK x s0 INCR0)",
                    "c25_VALID : regs_valid pr s0",
                    "c25_VALID2 : reg_valid rd s0",
                    "c25_INCR : state_incr s0 s'",
                    "c25_WF : map_valid map s0",
                    "c25_INCR0 : state_incr s0 s0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c24_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ],
                "tactic_res": [
                    "c26_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c26_H : eq (PTree.get i (map_vars map)) None",
                    "c26_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c26_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None",
                    "c26_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c25_goal : tr_expr (st_code s') map pr (Evar i) ns nd rd None"
                ],
                "tactic_res": [
                    "c27_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c28_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c29_goal : tr_move (st_code s') ns x nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c25_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c13_map : mapping",
                    "c5_i : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c28_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c13_OK : target_reg_ok map pr (Evar i) rd"
                ],
                "tactic_res": [
                    "c30_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c30_H1 : eq (PTree.get i (map_vars map)) (Some rd)",
                    "c31_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c31_H1 : not (In rd pr)",
                    "c31_H0 : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c30_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))"
                ],
                "tactic_res": [
                    "c32_goal : and (eq rd x) (eq None None)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c32_goal : and (eq rd x) (eq None None)"
                ],
                "tactic_res": [
                    "c33_goal : eq rd x",
                    "c34_goal : eq None None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c33_goal : eq rd x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c34_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c31_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))"
                ],
                "tactic_res": [
                    "c35_goal : and (reg_map_ok map rd None) (not (In rd pr))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c35_goal : and (reg_map_ok map rd None) (not (In rd pr))",
                    "c31_H1 : not (In rd pr)",
                    "c31_H0 : not (reg_in_map map rd)",
                    "c13_pr : list reg",
                    "c13_rd : reg",
                    "c13_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c29_goal : tr_move (st_code s') ns x nd rd",
                    "_global_add_move_charact : forall (s : state) (ns : node) (rs : reg) (nd : node) \n         (rd : reg) (s' : state) (i : state_incr s s')\n         (_ : eq (add_move rs rd nd s) (RTLgen.OK ns s' i)),\n       tr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c36_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c36_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)",
                    "c13_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c13_x : reg",
                    "c13_s' : state",
                    "c13_nd : node",
                    "c13_ns : node",
                    "c13_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_OK : target_reg_ok map pr (Eop o e) rd"
                ],
                "tactic_res": [
                    "c14_H0 : not (In rd pr)",
                    "c14_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c14_goal : tr_expr (st_code s') map pr (Eop o e) ns nd rd None"
                ],
                "tactic_res": [
                    "c37_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c38_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iop o ?rl rd nd))",
                    "c39_goal : reg_map_ok map rd None",
                    "c40_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c38_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iop o ?rl rd nd))",
                    "c14_EQ1 : eq (add_instr (Iop o x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c14_s' : state",
                    "c14_nd : node",
                    "c14_rd : reg",
                    "c6_o : operation"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c39_goal : reg_map_ok map rd None",
                    "c14_H : not (reg_in_map map rd)",
                    "c14_rd : reg",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c40_goal : not (In rd pr)",
                    "c14_H0 : not (In rd pr)",
                    "c14_pr : list reg",
                    "c14_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c37_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c1_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c41_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c42_goal : map_valid map s1",
                    "c43_goal : target_regs_ok map pr e x",
                    "c44_goal : regs_valid pr s1",
                    "c45_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c41_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c14_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c14_x0 : node",
                    "c14_x : list reg",
                    "c14_s' : state",
                    "c14_ns : node",
                    "c14_map : mapping",
                    "c6_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c42_goal : map_valid map s1",
                    "c14_s1 : state",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c43_goal : target_regs_ok map pr e x",
                    "c14_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c14_x : list reg",
                    "c14_VALID : regs_valid pr s",
                    "c14_WF : map_valid map s",
                    "c14_pr : list reg",
                    "c14_map : mapping",
                    "c6_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c44_goal : regs_valid pr s1",
                    "c14_s1 : state",
                    "c14_VALID : regs_valid pr s",
                    "c14_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c45_goal : regs_valid x s1",
                    "c14_s1 : state",
                    "c14_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c14_x : list reg",
                    "c14_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_OK : target_reg_ok map pr (Eload m a e) rd"
                ],
                "tactic_res": [
                    "c15_H0 : not (In rd pr)",
                    "c15_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c15_goal : tr_expr (st_code s') map pr (Eload m a e) ns nd rd None"
                ],
                "tactic_res": [
                    "c46_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c47_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iload m a ?rl rd nd))",
                    "c48_goal : reg_map_ok map rd None",
                    "c49_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c47_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iload m a ?rl rd nd))",
                    "c15_EQ1 : eq (add_instr (Iload m a x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c15_s' : state",
                    "c15_nd : node",
                    "c15_rd : reg",
                    "c7_a : addressing",
                    "c7_m : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c48_goal : reg_map_ok map rd None",
                    "c15_H : not (reg_in_map map rd)",
                    "c15_rd : reg",
                    "c15_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c49_goal : not (In rd pr)",
                    "c15_H0 : not (In rd pr)",
                    "c15_pr : list reg",
                    "c15_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c46_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c1_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c50_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c51_goal : map_valid map s1",
                    "c52_goal : target_regs_ok map pr e x",
                    "c53_goal : regs_valid pr s1",
                    "c54_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c50_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c15_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c15_x0 : node",
                    "c15_x : list reg",
                    "c15_s' : state",
                    "c15_ns : node",
                    "c15_map : mapping",
                    "c7_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c51_goal : map_valid map s1",
                    "c15_s1 : state",
                    "c15_WF : map_valid map s",
                    "c15_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c52_goal : target_regs_ok map pr e x",
                    "c15_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c15_x : list reg",
                    "c15_VALID : regs_valid pr s",
                    "c15_WF : map_valid map s",
                    "c15_pr : list reg",
                    "c15_map : mapping",
                    "c7_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c53_goal : regs_valid pr s1",
                    "c15_s1 : state",
                    "c15_VALID : regs_valid pr s",
                    "c15_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c54_goal : regs_valid x s1",
                    "c15_s1 : state",
                    "c15_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c15_x : list reg",
                    "c15_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_OK : target_reg_ok map pr (Econdition c a1 a2) rd"
                ],
                "tactic_res": [
                    "c16_H0 : not (In rd pr)",
                    "c16_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c16_goal : tr_expr (st_code s') map pr (Econdition c a1 a2) ns nd rd None"
                ],
                "tactic_res": [
                    "c55_goal : tr_condition (st_code s') map pr c ns ?ntrue ?nfalse",
                    "c56_goal : tr_expr (st_code s') map pr a1 x0 nd rd None",
                    "c57_goal : tr_expr (st_code s') map pr a2 x nd rd None"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c55_goal : tr_condition (st_code s') map pr c ns ?ntrue ?nfalse",
                    "c16_INCR4 : state_incr s s1",
                    "c16_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c16_VALID : regs_valid pr s",
                    "c16_WF : map_valid map s",
                    "c16_pr : list reg",
                    "c16_s' : state",
                    "c16_ns : node",
                    "c16_map : mapping",
                    "c8_c : condexpr",
                    "c1_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c56_goal : tr_expr (st_code s') map pr a1 x0 nd rd None",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c16_s1 : state"
                ],
                "tactic_res": [
                    "c58_goal : state_incr s1 s'",
                    "c59_goal : tr_expr (st_code s1) map pr a1 x0 nd rd None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c58_goal : state_incr s1 s'",
                    "c16_s1 : state",
                    "c16_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c59_goal : tr_expr (st_code s1) map pr a1 x0 nd rd None",
                    "c1_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c60_goal : eq (transl_expr map a1 rd nd ?s) (OK x0 s1 ?INCR)",
                    "c61_goal : map_valid map s0",
                    "c62_goal : target_reg_ok map pr a1 rd",
                    "c63_goal : regs_valid pr s0",
                    "c64_goal : reg_valid rd s0"
                ]
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c60_goal : eq (transl_expr map a1 rd nd ?s) (OK x0 s1 ?INCR)",
                    "c16_EQ1 : eq (transl_expr map a1 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c16_s1 : state",
                    "c16_x0 : node",
                    "c16_nd : node",
                    "c16_rd : reg",
                    "c16_map : mapping",
                    "c8_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c61_goal : map_valid map s0",
                    "c16_s0 : state",
                    "c16_WF : map_valid map s",
                    "c16_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c63_goal : regs_valid pr s0",
                    "c16_s0 : state",
                    "c16_VALID : regs_valid pr s",
                    "c16_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c64_goal : reg_valid rd s0",
                    "c16_s0 : state",
                    "c16_VALID2 : reg_valid rd s",
                    "c16_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c62_goal : target_reg_ok map pr a1 rd"
                ],
                "tactic_res": [
                    "c65_goal : not (reg_in_map map rd)",
                    "c66_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c65_goal : not (reg_in_map map rd)",
                    "c16_H : not (reg_in_map map rd)",
                    "c16_rd : reg",
                    "c16_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c66_goal : not (In rd pr)",
                    "c16_H0 : not (In rd pr)",
                    "c16_pr : list reg",
                    "c16_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c57_goal : tr_expr (st_code s') map pr a2 x nd rd None",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c16_s0 : state"
                ],
                "tactic_res": [
                    "c67_goal : state_incr s0 s'",
                    "c68_goal : tr_expr (st_code s0) map pr a2 x nd rd None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c67_goal : state_incr s0 s'",
                    "c16_INCR1 : state_incr s0 s'",
                    "c16_s0 : state",
                    "c16_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c68_goal : tr_expr (st_code s0) map pr a2 x nd rd None",
                    "c1_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c69_goal : eq (transl_expr map a2 rd nd ?s) (OK x s0 ?INCR)",
                    "c70_goal : map_valid map s",
                    "c71_goal : target_reg_ok map pr a2 rd",
                    "c72_goal : regs_valid pr s",
                    "c73_goal : reg_valid rd s"
                ]
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c69_goal : eq (transl_expr map a2 rd nd ?s) (OK x s0 ?INCR)",
                    "c16_EQ : eq (transl_expr map a2 rd nd s) (RTLgen.OK x s0 INCR0)",
                    "c16_s0 : state",
                    "c16_x : node",
                    "c16_nd : node",
                    "c16_rd : reg",
                    "c16_map : mapping",
                    "c8_a2 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c70_goal : map_valid map s",
                    "c16_WF : map_valid map s",
                    "c16_s : state",
                    "c16_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c72_goal : regs_valid pr s",
                    "c16_VALID : regs_valid pr s",
                    "c16_pr : list reg",
                    "c16_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c73_goal : reg_valid rd s",
                    "c16_VALID2 : reg_valid rd s",
                    "c16_s : state",
                    "c16_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c71_goal : target_reg_ok map pr a2 rd"
                ],
                "tactic_res": [
                    "c74_goal : not (reg_in_map map rd)",
                    "c75_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : not (reg_in_map map rd)",
                    "c16_H : not (reg_in_map map rd)",
                    "c16_rd : reg",
                    "c16_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c75_goal : not (In rd pr)",
                    "c16_H0 : not (In rd pr)",
                    "c16_pr : list reg",
                    "c16_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c17_OK : target_reg_ok map pr (Elet a1 a2) rd"
                ],
                "tactic_res": [
                    "c17_H0 : not (In rd pr)",
                    "c17_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c17_goal : tr_expr (st_code s') map pr (Elet a1 a2) ns nd rd None"
                ],
                "tactic_res": [
                    "c76_goal : not (reg_in_map map ?r)",
                    "c77_goal : tr_expr (st_code s') map pr a1 ns ?n1 x None",
                    "c78_goal : tr_expr (st_code s') (add_letvar map x) pr a2 x0 nd rd None"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c76_goal : not (reg_in_map map ?r)",
                    "_global_new_reg_not_in_map : forall (s1 s2 : state) (m : mapping) (r : reg) \n         (i : state_incr s1 s2) (_ : eq (new_reg s1) (OK r s2 i))\n         (_ : map_valid m s1), not (reg_in_map m r)"
                ],
                "tactic_res": [
                    "c79_goal : eq (new_reg ?s1) (OK ?r ?s2 ?i)",
                    "c80_goal : map_valid map s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c79_goal : eq (new_reg ?s1) (OK ?r ?s2 ?i)",
                    "c17_EQ : eq (new_reg s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c80_goal : map_valid map s",
                    "c17_WF : map_valid map s",
                    "c17_s : state",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c77_goal : tr_expr (st_code s') map pr a1 ns ?n1 x None",
                    "c1_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c81_goal : eq (transl_expr map a1 x ?n1 ?s) (OK ns s' ?INCR)",
                    "c82_goal : map_valid map s1",
                    "c83_goal : target_reg_ok map pr a1 x",
                    "c84_goal : regs_valid pr s1",
                    "c85_goal : reg_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c81_goal : eq (transl_expr map a1 x ?n1 ?s) (OK ns s' ?INCR)",
                    "c17_EQ2 : eq (transl_expr map a1 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c17_x : reg",
                    "c17_s' : state",
                    "c17_ns : node",
                    "c17_map : mapping",
                    "c9_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c82_goal : map_valid map s1",
                    "c17_s1 : state",
                    "c17_WF : map_valid map s",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c83_goal : target_reg_ok map pr a1 x",
                    "c17_EQ : eq (new_reg s) (RTLgen.OK x s0 INCR0)",
                    "c17_x : reg",
                    "c17_VALID : regs_valid pr s",
                    "c17_WF : map_valid map s",
                    "c17_pr : list reg",
                    "c17_map : mapping",
                    "c9_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c84_goal : regs_valid pr s1",
                    "c17_s1 : state",
                    "c17_VALID : regs_valid pr s",
                    "c17_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c85_goal : reg_valid x s1",
                    "c17_s1 : state",
                    "c17_EQ : eq (new_reg s) (RTLgen.OK x s0 INCR0)",
                    "c17_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c78_goal : tr_expr (st_code s') (add_letvar map x) pr a2 x0 nd rd None",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c17_s1 : state"
                ],
                "tactic_res": [
                    "c86_goal : state_incr s1 s'",
                    "c87_goal : tr_expr (st_code s1) (add_letvar map x) pr a2 x0 nd rd None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : state_incr s1 s'",
                    "c17_s1 : state",
                    "c17_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c87_goal : tr_expr (st_code s1) (add_letvar map x) pr a2 x0 nd rd None",
                    "c1_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c88_goal : eq (transl_expr (add_letvar map x) a2 rd nd ?s) (OK x0 s1 ?INCR)",
                    "c89_goal : map_valid (add_letvar map x) s0",
                    "c90_goal : target_reg_ok (add_letvar map x) pr a2 rd",
                    "c91_goal : regs_valid pr s0",
                    "c92_goal : reg_valid rd s0"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c88_goal : eq (transl_expr (add_letvar map x) a2 rd nd ?s) (OK x0 s1 ?INCR)",
                    "c17_EQ1 : eq (transl_expr (add_letvar map x) a2 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c17_s1 : state",
                    "c17_x0 : node",
                    "c17_x : reg",
                    "c17_nd : node",
                    "c17_rd : reg",
                    "c17_map : mapping",
                    "c9_a2 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c89_goal : map_valid (add_letvar map x) s0",
                    "_global_add_letvar_valid : forall (map : mapping) (s : state) (r : reg) \n         (_ : map_valid map s) (_ : reg_valid r s),\n       map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c93_goal : map_valid map s0",
                    "c94_goal : reg_valid x s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c93_goal : map_valid map s0",
                    "c17_s0 : state",
                    "c17_WF : map_valid map s",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c94_goal : reg_valid x s0",
                    "c17_EQ : eq (new_reg s) (RTLgen.OK x s0 INCR0)",
                    "c17_s0 : state",
                    "c17_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c90_goal : target_reg_ok (add_letvar map x) pr a2 rd"
                ],
                "tactic_res": [
                    "c95_goal : not (reg_in_map (add_letvar map x) rd)",
                    "c96_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c96_goal : not (In rd pr)",
                    "c17_H0 : not (In rd pr)",
                    "c17_pr : list reg",
                    "c17_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c95_goal : not (reg_in_map (add_letvar map x) rd)"
                ],
                "tactic_res": [
                    "c97_goal : forall _ : reg_in_map (add_letvar map x) rd, False"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c97_goal : forall _ : reg_in_map (add_letvar map x) rd, False",
                    "_global_reg_in_map : forall (_ : mapping) (_ : reg), Prop"
                ],
                "tactic_res": [
                    "c98_goal : forall\n  _ : or\n        (ex\n           (fun id : positive =>\n            eq (PTree.get id (map_vars (add_letvar map x))) (Some rd)))\n        (In rd (map_letvars (add_letvar map x))), False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c98_goal : forall\n  _ : or\n        (ex\n           (fun id : positive =>\n            eq (PTree.get id (map_vars (add_letvar map x))) (Some rd)))\n        (In rd (map_letvars (add_letvar map x))), False"
                ],
                "tactic_res": [
                    "c99_goal : forall\n  _ : or\n        (ex\n           (fun id : positive =>\n            eq (PTree.get id (map_vars map)) (Some rd)))\n        (or (eq x rd) (In rd (map_letvars map))), False"
                ]
            },
            {
                "tactic_sig": "intros [ [ _o _o ] | [ _o | _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ [ id A ] | [ B | C ] ] .",
                "tactic_args": [
                    "c99_goal : forall\n  _ : or\n        (ex\n           (fun id : positive =>\n            eq (PTree.get id (map_vars map)) (Some rd)))\n        (or (eq x rd) (In rd (map_letvars map))), False"
                ],
                "tactic_res": [
                    "c100_goal : False",
                    "c102_C : In rd (map_letvars map)",
                    "c102_goal : False",
                    "c101_B : eq x rd",
                    "c101_goal : False",
                    "c100_id : positive",
                    "c100_A : eq (PTree.get id (map_vars map)) (Some rd)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c100_goal : False",
                    "c17_H : not (reg_in_map map rd)"
                ],
                "tactic_res": [
                    "c103_goal : reg_in_map map rd"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c103_goal : reg_in_map map rd"
                ],
                "tactic_res": [
                    "c104_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some rd))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c104_goal : ex (fun id : positive => eq (PTree.get id (map_vars map)) (Some rd))",
                    "c100_id : positive"
                ],
                "tactic_res": [
                    "c105_goal : eq (PTree.get id (map_vars map)) (Some rd)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c105_goal : eq (PTree.get id (map_vars map)) (Some rd)",
                    "c100_A : eq (PTree.get id (map_vars map)) (Some rd)",
                    "c100_id : positive",
                    "c17_rd : reg",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c17_x : reg",
                    "c101_B : eq x rd"
                ],
                "tactic_res": [
                    "c101_EQ1 : eq (transl_expr (add_letvar map rd) a2 rd nd s0) (OK x0 s1 INCR2)",
                    "c101_EQ2 : eq (transl_expr map a1 rd x0 s1) (OK ns s' INCR3)",
                    "c101_EQ : eq (new_reg s) (OK rd s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "apply _i with _i _i .",
                "tactic_sig_no_out_arg": "apply _i with _i _i .",
                "tactic_args": [
                    "c101_goal : False",
                    "_global_valid_fresh_absurd : forall (r : reg) (s : state) (_ : reg_valid r s) (_ : reg_fresh r s),\n       False",
                    "c17_rd : reg",
                    "c17_s : state"
                ],
                "tactic_res": [
                    "c106_goal : reg_valid rd s",
                    "c107_goal : reg_fresh rd s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c106_goal : reg_valid rd s",
                    "c17_VALID2 : reg_valid rd s",
                    "c17_s : state",
                    "c17_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c107_goal : reg_fresh rd s",
                    "c101_EQ : eq (new_reg s) (OK rd s0 INCR0)",
                    "c17_s : state",
                    "c17_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c102_goal : False",
                    "c17_H : not (reg_in_map map rd)"
                ],
                "tactic_res": [
                    "c108_goal : reg_in_map map rd"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c108_goal : reg_in_map map rd"
                ],
                "tactic_res": [
                    "c109_goal : In rd (map_letvars map)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c109_goal : In rd (map_letvars map)",
                    "c102_C : In rd (map_letvars map)",
                    "c17_rd : reg",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c91_goal : regs_valid pr s0",
                    "c17_s0 : state",
                    "c17_VALID : regs_valid pr s",
                    "c17_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c92_goal : reg_valid rd s0",
                    "c17_s0 : state",
                    "c17_VALID2 : reg_valid rd s",
                    "c17_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c18_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c18_EQ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c110_goal : forall _ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c110_goal : forall _ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "_global_find_letvar : forall (_ : mapping) (_ : nat), mon reg"
                ],
                "tactic_res": [
                    "c111_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_sig_no_out_arg": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_args": [
                    "c111_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c18_map : mapping",
                    "c10_n : nat"
                ],
                "tactic_res": [
                    "c112_goal : forall (r : reg) (_ : eq (nth_error (map_letvars map) n) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c113_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n         (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c112_goal : forall (r : reg) (_ : eq (nth_error (map_letvars map) n) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ],
                "tactic_res": [
                    "c114_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c114_r : reg",
                    "c114_H : eq (nth_error (map_letvars map) n) (Some r)",
                    "c114_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c114_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c113_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n         (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ],
                "tactic_res": [
                    "c115_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c115_H : eq (nth_error (map_letvars map) n) None",
                    "c115_EQ1 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n  (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c115_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c114_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c114_H : eq (nth_error (map_letvars map) n) (Some x)",
                    "c114_EQ : eq (find_letvar map n s0) (RTLgen.OK x s0 INCR0)",
                    "c114_VALID : regs_valid pr s0",
                    "c114_VALID2 : reg_valid rd s0",
                    "c114_INCR : state_incr s0 s'",
                    "c114_WF : map_valid map s0",
                    "c114_INCR0 : state_incr s0 s0"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c114_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None"
                ],
                "tactic_res": [
                    "c116_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c117_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c118_goal : tr_move (st_code s') ns x nd rd"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c116_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c114_H : eq (nth_error (map_letvars map) n) (Some x)",
                    "c18_map : mapping",
                    "c10_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c117_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c18_OK : target_reg_ok map pr (Eletvar n) rd"
                ],
                "tactic_res": [
                    "c119_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c119_H2 : eq (nth_error (map_letvars map) n) (Some rd)",
                    "c120_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))",
                    "c120_H2 : not (In rd pr)",
                    "c120_H0 : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c119_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))"
                ],
                "tactic_res": [
                    "c121_goal : and (eq rd x) (eq None None)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c121_goal : and (eq rd x) (eq None None)"
                ],
                "tactic_res": [
                    "c122_goal : eq rd x",
                    "c123_goal : eq None None"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c122_goal : eq rd x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c123_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c120_goal : or (and (eq rd x) (eq None None))\n  (and (reg_map_ok map rd None) (not (In rd pr)))"
                ],
                "tactic_res": [
                    "c124_goal : and (reg_map_ok map rd None) (not (In rd pr))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c124_goal : and (reg_map_ok map rd None) (not (In rd pr))",
                    "c120_H2 : not (In rd pr)",
                    "c120_H0 : not (reg_in_map map rd)",
                    "c18_pr : list reg",
                    "c18_rd : reg",
                    "c18_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c118_goal : tr_move (st_code s') ns x nd rd",
                    "_global_add_move_charact : forall (s : state) (ns : node) (rs : reg) (nd : node) \n         (rd : reg) (s' : state) (i : state_incr s s')\n         (_ : eq (add_move rs rd nd s) (RTLgen.OK ns s' i)),\n       tr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c125_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c125_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)",
                    "c114_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c18_x : reg",
                    "c18_s' : state",
                    "c18_nd : node",
                    "c18_ns : node",
                    "c18_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c115_goal : tr_expr (st_code s') map pr (Eletvar n) ns nd rd None",
                    "c115_EQ1 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n  (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_OK : target_reg_ok map pr (Ebuiltin e e0) rd"
                ],
                "tactic_res": [
                    "c19_H0 : not (In rd pr)",
                    "c19_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c19_goal : tr_expr (st_code s') map pr (Ebuiltin e e0) ns nd rd None"
                ],
                "tactic_res": [
                    "c126_goal : tr_exprlist (st_code s') map pr e0 ns x0 x",
                    "c127_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (List.map (BA (A:=reg)) ?rl) (BR rd) nd))",
                    "c128_goal : reg_map_ok map rd None",
                    "c129_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c127_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (List.map (BA (A:=reg)) ?rl) (BR rd) nd))",
                    "c19_EQ1 : eq (add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c19_s' : state",
                    "c19_nd : node",
                    "c19_rd : reg",
                    "c11_e : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c128_goal : reg_map_ok map rd None",
                    "c19_H : not (reg_in_map map rd)",
                    "c19_rd : reg",
                    "c19_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c129_goal : not (In rd pr)",
                    "c19_H0 : not (In rd pr)",
                    "c19_pr : list reg",
                    "c19_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c126_goal : tr_exprlist (st_code s') map pr e0 ns x0 x",
                    "c1_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c130_goal : eq (transl_exprlist map e0 x x0 ?s) (OK ns s' ?INCR)",
                    "c131_goal : map_valid map s1",
                    "c132_goal : target_regs_ok map pr e0 x",
                    "c133_goal : regs_valid pr s1",
                    "c134_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c130_goal : eq (transl_exprlist map e0 x x0 ?s) (OK ns s' ?INCR)",
                    "c19_EQ2 : eq (transl_exprlist map e0 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c19_x0 : node",
                    "c19_x : list reg",
                    "c19_s' : state",
                    "c19_ns : node",
                    "c19_map : mapping",
                    "c11_e0 : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c131_goal : map_valid map s1",
                    "c19_s1 : state",
                    "c19_WF : map_valid map s",
                    "c19_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c132_goal : target_regs_ok map pr e0 x",
                    "c19_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c19_x : list reg",
                    "c19_VALID : regs_valid pr s",
                    "c19_WF : map_valid map s",
                    "c19_pr : list reg",
                    "c19_map : mapping",
                    "c11_e0 : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c133_goal : regs_valid pr s1",
                    "c19_s1 : state",
                    "c19_VALID : regs_valid pr s",
                    "c19_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c134_goal : regs_valid x s1",
                    "c19_s1 : state",
                    "c19_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c19_x : list reg",
                    "c19_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c20_OK : target_reg_ok map pr (Eexternal i s e) rd"
                ],
                "tactic_res": [
                    "c20_H0 : not (In rd pr)",
                    "c20_H : not (reg_in_map map rd)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c20_goal : tr_expr (st_code s') map pr (Eexternal i s e) ns nd rd None"
                ],
                "tactic_res": [
                    "c135_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c136_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icall s (inr i) ?rl rd nd))",
                    "c137_goal : reg_map_ok map rd None",
                    "c138_goal : not (In rd pr)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c136_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icall s (inr i) ?rl rd nd))",
                    "c20_EQ1 : eq (add_instr (Icall s (inr i) x rd nd) s1) (RTLgen.OK x0 s2 INCR2)",
                    "c20_s' : state",
                    "c20_nd : node",
                    "c20_rd : reg",
                    "c12_s : signature",
                    "c12_i : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c137_goal : reg_map_ok map rd None",
                    "c20_H : not (reg_in_map map rd)",
                    "c20_rd : reg",
                    "c20_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c138_goal : not (In rd pr)",
                    "c20_H0 : not (In rd pr)",
                    "c20_pr : list reg",
                    "c20_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c135_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c1_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c139_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c140_goal : map_valid map s2",
                    "c141_goal : target_regs_ok map pr e x",
                    "c142_goal : regs_valid pr s2",
                    "c143_goal : regs_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c139_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c20_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c20_x0 : node",
                    "c20_x : list reg",
                    "c20_s' : state",
                    "c20_ns : node",
                    "c20_map : mapping",
                    "c12_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c140_goal : map_valid map s2",
                    "c20_s2 : state",
                    "c20_WF : map_valid map s0",
                    "c20_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c141_goal : target_regs_ok map pr e x",
                    "c20_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c20_x : list reg",
                    "c20_VALID : regs_valid pr s0",
                    "c20_WF : map_valid map s0",
                    "c20_pr : list reg",
                    "c20_map : mapping",
                    "c12_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c142_goal : regs_valid pr s2",
                    "c20_s2 : state",
                    "c20_VALID : regs_valid pr s0",
                    "c20_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c143_goal : regs_valid x s2",
                    "c20_s2 : state",
                    "c20_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c20_x : list reg",
                    "c20_WF : map_valid map s0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction al .",
                "tactic_sig_no_out_arg": "induction al .",
                "tactic_args": [
                    "c2_goal : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c144_goal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map Enil rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr Enil rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr Enil ns nd rl",
                    "c145_goal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map (Econs e al) rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr (Econs e al) rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr (Econs e al) ns nd rl",
                    "c145_IHal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c145_al : exprlist",
                    "c145_e : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c144_goal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map Enil rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr Enil rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr Enil ns nd rl"
                ],
                "tactic_res": [
                    "c146_goal : tr_exprlist (st_code s') map pr Enil ns nd rl",
                    "c146_map : mapping",
                    "c146_rl : list reg",
                    "c146_nd : node",
                    "c146_s : state",
                    "c146_ns : node",
                    "c146_s' : state",
                    "c146_pr : list reg",
                    "c146_INCR : state_incr s s'",
                    "c146_TR : eq (transl_exprlist map Enil rl nd s) (RTLgen.OK ns s' INCR)",
                    "c146_WF : map_valid map s",
                    "c146_OK : target_regs_ok map pr Enil rl",
                    "c146_VALID1 : regs_valid pr s",
                    "c146_VALID2 : regs_valid rl s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c146_TR : eq (transl_exprlist map Enil rl nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c145_goal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map (Econs e al) rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr (Econs e al) rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr (Econs e al) ns nd rl"
                ],
                "tactic_res": [
                    "c147_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd rl",
                    "c147_map : mapping",
                    "c147_rl : list reg",
                    "c147_nd : node",
                    "c147_s : state",
                    "c147_ns : node",
                    "c147_s' : state",
                    "c147_pr : list reg",
                    "c147_INCR : state_incr s s'",
                    "c147_TR : eq (transl_exprlist map (Econs e al) rl nd s) (RTLgen.OK ns s' INCR)",
                    "c147_WF : map_valid map s",
                    "c147_OK : target_regs_ok map pr (Econs e al) rl",
                    "c147_VALID1 : regs_valid pr s",
                    "c147_VALID2 : regs_valid rl s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c147_TR : eq (transl_exprlist map (Econs e al) rl nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c146_goal : tr_exprlist (st_code s') map pr Enil ns nd rl",
                    "c146_rl : list reg",
                    "c146_VALID2 : regs_valid rl s",
                    "c146_VALID1 : regs_valid pr s",
                    "c146_OK : target_regs_ok map pr Enil rl",
                    "c146_WF : map_valid map s",
                    "c146_TR : eq (transl_exprlist map Enil rl nd s) (RTLgen.OK ns s' INCR)",
                    "c146_pr : list reg",
                    "c146_s' : state",
                    "c146_ns : node",
                    "c146_nd : node",
                    "c146_map : mapping",
                    "c2_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c2_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c2_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c148_goal : tr_exprlist (st_code s') map pr Enil ns nd nil",
                    "c148_VALID2 : regs_valid nil s",
                    "c148_OK : target_regs_ok map pr Enil nil",
                    "c148_TR : eq (transl_exprlist map Enil nil nd s) (RTLgen.OK ns s' INCR)",
                    "c149_goal : tr_exprlist (st_code s') map pr Enil ns nd (cons r rl)",
                    "c149_VALID2 : regs_valid (cons r rl) s",
                    "c149_OK : target_regs_ok map pr Enil (cons r rl)",
                    "c149_TR : eq (transl_exprlist map Enil (cons r rl) nd s) (RTLgen.OK ns s' INCR)",
                    "c149_r : reg"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c148_goal : tr_exprlist (st_code s') map pr Enil ns nd nil",
                    "c148_TR : eq (transl_exprlist map Enil nil nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c150_goal : tr_exprlist (st_code s') map pr Enil ns ns nil",
                    "c150_VALID1 : regs_valid pr s'",
                    "c150_VALID2 : regs_valid nil s'",
                    "c150_INCR : state_incr s' s'",
                    "c150_WF : map_valid map s'"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c149_goal : tr_exprlist (st_code s') map pr Enil ns nd (cons r rl)",
                    "c149_TR : eq (transl_exprlist map Enil (cons r rl) nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c150_goal : tr_exprlist (st_code s') map pr Enil ns ns nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c147_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd rl",
                    "c147_rl : list reg",
                    "c147_VALID2 : regs_valid rl s",
                    "c147_VALID1 : regs_valid pr s",
                    "c147_OK : target_regs_ok map pr (Econs e al) rl",
                    "c147_WF : map_valid map s",
                    "c147_TR : eq (transl_exprlist map (Econs e al) rl nd s) (RTLgen.OK ns s' INCR)",
                    "c147_pr : list reg",
                    "c147_s' : state",
                    "c147_ns : node",
                    "c147_nd : node",
                    "c147_map : mapping",
                    "c145_IHal : forall (map : mapping) (rl : list reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c145_al : exprlist",
                    "c145_e : expr",
                    "c2_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c2_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl",
                    "c2_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c151_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd nil",
                    "c151_VALID2 : regs_valid nil s",
                    "c151_OK : target_regs_ok map pr (Econs e al) nil",
                    "c151_TR : eq (transl_exprlist map (Econs e al) nil nd s) (RTLgen.OK ns s' INCR)",
                    "c152_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd (cons r rl)",
                    "c152_VALID2 : regs_valid (cons r rl) s",
                    "c152_OK : target_regs_ok map pr (Econs e al) (cons r rl)",
                    "c152_TR : eq (transl_exprlist map (Econs e al) (cons r rl) nd s)\n  (RTLgen.OK ns s' INCR)",
                    "c152_r : reg"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c151_TR : eq (transl_exprlist map (Econs e al) nil nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c151_TR : eq (error (Errors.msg \"RTLgen.transl_exprlist\") s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c151_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd nil",
                    "c151_TR : eq (error (Errors.msg \"RTLgen.transl_exprlist\") s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c152_TR : eq (transl_exprlist map (Econs e al) (cons r rl) nd s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c152_TR : eq\n  (bind (transl_exprlist map al rl nd)\n     (fun no : node => transl_expr map e r no) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c152_TR : eq\n  (bind (transl_exprlist map al rl nd)\n     (fun no : node => transl_expr map e r no) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c152_EQ0 : eq (transl_expr map e r x s0) (RTLgen.OK ns s' INCR1)",
                    "c152_EQ : eq (transl_exprlist map al rl nd s) (RTLgen.OK x s0 INCR0)",
                    "c152_INCR1 : state_incr s0 s'",
                    "c152_INCR0 : state_incr s s0",
                    "c152_s0 : state",
                    "c152_x : node"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c152_OK : target_regs_ok map pr (Econs e al) (cons r rl)"
                ],
                "tactic_res": [
                    "c152_H4 : target_regs_ok map (cons r pr) al rl",
                    "c152_H2 : target_reg_ok map pr e r"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c152_goal : tr_exprlist (st_code s') map pr (Econs e al) ns nd (cons r rl)"
                ],
                "tactic_res": [
                    "c153_goal : tr_expr (st_code s') map pr e ns ?n1 r None",
                    "c154_goal : tr_exprlist (st_code s') map (cons r pr) al x nd rl"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c153_goal : tr_expr (st_code s') map pr e ns ?n1 r None",
                    "c2_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c155_goal : eq (transl_expr map e r ?n1 ?s) (OK ns s' ?INCR)",
                    "c156_goal : map_valid map s0",
                    "c157_goal : target_reg_ok map pr e r",
                    "c158_goal : regs_valid pr s0",
                    "c159_goal : reg_valid r s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c155_goal : eq (transl_expr map e r ?n1 ?s) (OK ns s' ?INCR)",
                    "c152_EQ0 : eq (transl_expr map e r x s0) (RTLgen.OK ns s' INCR1)",
                    "c147_s' : state",
                    "c147_ns : node",
                    "c152_r : reg",
                    "c147_map : mapping",
                    "c145_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c156_goal : map_valid map s0",
                    "c152_s0 : state",
                    "c147_WF : map_valid map s",
                    "c147_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c157_goal : target_reg_ok map pr e r",
                    "c152_H2 : target_reg_ok map pr e r",
                    "c147_pr : list reg",
                    "c152_r : reg",
                    "c147_map : mapping",
                    "c145_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c158_goal : regs_valid pr s0",
                    "c152_s0 : state",
                    "c147_VALID1 : regs_valid pr s",
                    "c147_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( _i _i ( in_eq _ _ ) ) .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ( in_eq _ _ ) ) .",
                "tactic_args": [
                    "c159_goal : reg_valid r s0",
                    "c152_VALID2 : regs_valid (cons r rl) s",
                    "c152_r : reg"
                ],
                "tactic_res": [
                    "c160_goal : forall _ : reg_valid r s, reg_valid r s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c160_goal : forall _ : reg_valid r s, reg_valid r s0",
                    "c152_s0 : state",
                    "c147_s : state",
                    "c152_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c154_goal : tr_exprlist (st_code s') map (cons r pr) al x nd rl",
                    "_global_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (al : exprlist) \n         (ns nd : node) (rl : list reg)\n         (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\n       tr_exprlist (st_code s2) map pr al ns nd rl",
                    "c152_s0 : state"
                ],
                "tactic_res": [
                    "c161_goal : state_incr s0 s'",
                    "c162_goal : tr_exprlist (st_code s0) map (cons r pr) al x nd rl"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c161_goal : state_incr s0 s'",
                    "c152_s0 : state",
                    "c147_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c162_goal : tr_exprlist (st_code s0) map (cons r pr) al x nd rl",
                    "c2_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c163_goal : eq (transl_exprlist map al rl nd ?s) (OK x s0 ?INCR)",
                    "c164_goal : map_valid map s",
                    "c165_goal : target_regs_ok map (cons r pr) al rl",
                    "c166_goal : regs_valid (cons r pr) s",
                    "c167_goal : regs_valid rl s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c163_goal : eq (transl_exprlist map al rl nd ?s) (OK x s0 ?INCR)",
                    "c152_EQ : eq (transl_exprlist map al rl nd s) (RTLgen.OK x s0 INCR0)",
                    "c152_s0 : state",
                    "c152_x : node",
                    "c147_nd : node",
                    "c147_rl : list reg",
                    "c147_map : mapping",
                    "c145_al : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c164_goal : map_valid map s",
                    "c147_WF : map_valid map s",
                    "c147_s : state",
                    "c147_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c165_goal : target_regs_ok map (cons r pr) al rl",
                    "c152_H4 : target_regs_ok map (cons r pr) al rl",
                    "c147_pr : list reg",
                    "c147_rl : list reg",
                    "c152_r : reg",
                    "c147_map : mapping",
                    "c145_al : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c166_goal : regs_valid (cons r pr) s",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c168_goal : reg_valid r s",
                    "c169_goal : regs_valid pr s"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c168_goal : reg_valid r s",
                    "c152_VALID2 : regs_valid (cons r rl) s"
                ],
                "tactic_res": [
                    "c170_goal : In r (cons r rl)"
                ]
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c170_goal : In r (cons r rl)",
                    "c147_rl : list reg",
                    "c152_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c169_goal : regs_valid pr s",
                    "c147_VALID1 : regs_valid pr s",
                    "c147_pr : list reg",
                    "c147_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c167_goal : regs_valid rl s"
                ],
                "tactic_res": [
                    "c171_goal : forall (r : reg) (_ : In r rl), reg_valid r s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c171_goal : forall (r : reg) (_ : In r rl), reg_valid r s"
                ],
                "tactic_res": [
                    "c172_goal : reg_valid r0 s",
                    "c172_r0 : reg",
                    "c172_H : In r0 rl"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c172_goal : reg_valid r0 s",
                    "c152_VALID2 : regs_valid (cons r rl) s"
                ],
                "tactic_res": [
                    "c173_goal : In r0 (cons r rl)"
                ]
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c173_goal : In r0 (cons r rl)",
                    "c172_H : In r0 rl",
                    "c172_r0 : reg",
                    "c147_rl : list reg",
                    "c152_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction a .",
                "tactic_sig_no_out_arg": "induction a .",
                "tactic_args": [
                    "c3_goal : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c174_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CEcond c e) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CEcond c e) ns ntrue nfalse",
                    "c174_e : exprlist",
                    "c174_c : condition",
                    "c175_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CEcondition a1 a2 a3) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CEcondition a1 a2 a3) ns ntrue nfalse",
                    "c175_IHa3 : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a3 ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a3 ns ntrue nfalse",
                    "c175_IHa2 : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a2 ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a2 ns ntrue nfalse",
                    "c175_IHa1 : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a1 ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a1 ns ntrue nfalse",
                    "c175_a3 : condexpr",
                    "c175_a2 : condexpr",
                    "c175_a1 : condexpr",
                    "c176_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CElet e a) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CElet e a) ns ntrue nfalse",
                    "c176_IHa : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse",
                    "c176_a : condexpr",
                    "c176_e : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c174_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CEcond c e) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CEcond c e) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c177_goal : tr_condition (st_code s') map pr (CEcond c e) ns ntrue nfalse",
                    "c177_map : mapping",
                    "c177_ntrue : node",
                    "c177_nfalse : node",
                    "c177_s : state",
                    "c177_ns : node",
                    "c177_s' : state",
                    "c177_pr : list reg",
                    "c177_INCR : state_incr s s'",
                    "c177_TR : eq (transl_condexpr map (CEcond c e) ntrue nfalse s) (OK ns s' INCR)",
                    "c177_WF : map_valid map s",
                    "c177_VALID : regs_valid pr s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c177_TR : eq (transl_condexpr map (CEcond c e) ntrue nfalse s) (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c177_EQ2 : eq (transl_exprlist map e x x0 s1) (OK ns s' INCR3)",
                    "c177_EQ1 : eq (add_instr (Icond c x ntrue nfalse) s0) (OK x0 s1 INCR2)",
                    "c177_INCR3 : state_incr s1 s'",
                    "c177_INCR2 : state_incr s0 s1",
                    "c177_s1 : state",
                    "c177_x0 : node",
                    "c177_EQ : eq (alloc_regs map e s) (OK x s0 INCR0)",
                    "c177_INCR1 : state_incr s0 s'",
                    "c177_INCR0 : state_incr s s0",
                    "c177_s0 : state",
                    "c177_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c175_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CEcondition a1 a2 a3) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CEcondition a1 a2 a3) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c178_goal : tr_condition (st_code s') map pr (CEcondition a1 a2 a3) ns ntrue nfalse",
                    "c178_map : mapping",
                    "c178_ntrue : node",
                    "c178_nfalse : node",
                    "c178_s : state",
                    "c178_ns : node",
                    "c178_s' : state",
                    "c178_pr : list reg",
                    "c178_INCR : state_incr s s'",
                    "c178_TR : eq (transl_condexpr map (CEcondition a1 a2 a3) ntrue nfalse s)\n  (OK ns s' INCR)",
                    "c178_WF : map_valid map s",
                    "c178_VALID : regs_valid pr s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c178_TR : eq (transl_condexpr map (CEcondition a1 a2 a3) ntrue nfalse s)\n  (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c178_EQ2 : eq (transl_condexpr map a1 x0 x s1) (OK ns s' INCR3)",
                    "c178_EQ1 : eq (transl_condexpr map a2 ntrue nfalse s0) (OK x0 s1 INCR2)",
                    "c178_INCR3 : state_incr s1 s'",
                    "c178_INCR2 : state_incr s0 s1",
                    "c178_s1 : state",
                    "c178_x0 : node",
                    "c178_EQ : eq (transl_condexpr map a3 ntrue nfalse s) (OK x s0 INCR0)",
                    "c178_INCR1 : state_incr s0 s'",
                    "c178_INCR0 : state_incr s s0",
                    "c178_s0 : state",
                    "c178_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c176_goal : forall (map : mapping) (ntrue nfalse : node) (s : state) \n  (ns : node) (s' : state) (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map (CElet e a) ntrue nfalse s)\n         (OK ns s' INCR)) (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr (CElet e a) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c179_goal : tr_condition (st_code s') map pr (CElet e a) ns ntrue nfalse",
                    "c179_map : mapping",
                    "c179_ntrue : node",
                    "c179_nfalse : node",
                    "c179_s : state",
                    "c179_ns : node",
                    "c179_s' : state",
                    "c179_pr : list reg",
                    "c179_INCR : state_incr s s'",
                    "c179_TR : eq (transl_condexpr map (CElet e a) ntrue nfalse s) (OK ns s' INCR)",
                    "c179_WF : map_valid map s",
                    "c179_VALID : regs_valid pr s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c179_TR : eq (transl_condexpr map (CElet e a) ntrue nfalse s) (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c179_EQ2 : eq (transl_expr map e x x0 s1) (OK ns s' INCR3)",
                    "c179_EQ1 : eq (transl_condexpr (add_letvar map x) a ntrue nfalse s0)\n  (OK x0 s1 INCR2)",
                    "c179_INCR3 : state_incr s1 s'",
                    "c179_INCR2 : state_incr s0 s1",
                    "c179_s1 : state",
                    "c179_x0 : node",
                    "c179_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c179_INCR1 : state_incr s0 s'",
                    "c179_INCR0 : state_incr s s0",
                    "c179_s0 : state",
                    "c179_x : reg"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c177_goal : tr_condition (st_code s') map pr (CEcond c e) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c180_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c181_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icond c ?rl ntrue nfalse))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c181_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icond c ?rl ntrue nfalse))",
                    "c177_EQ1 : eq (add_instr (Icond c x ntrue nfalse) s0) (OK x0 s1 INCR2)",
                    "c177_s' : state",
                    "c177_ntrue : node",
                    "c177_nfalse : node",
                    "c174_c : condition"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c180_goal : tr_exprlist (st_code s') map pr e ns x0 x",
                    "c3_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n  (nd : node) (s : state) (ns : node) (s' : state) \n  (pr : list reg) (INCR : state_incr s s')\n  (_ : eq (transl_exprlist map al rl nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n  (_ : regs_valid pr s) (_ : regs_valid rl s),\ntr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c182_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c183_goal : map_valid map s1",
                    "c184_goal : target_regs_ok map pr e x",
                    "c185_goal : regs_valid pr s1",
                    "c186_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c182_goal : eq (transl_exprlist map e x x0 ?s) (OK ns s' ?INCR)",
                    "c177_EQ2 : eq (transl_exprlist map e x x0 s1) (OK ns s' INCR3)",
                    "c177_x0 : node",
                    "c177_x : list reg",
                    "c177_s' : state",
                    "c177_ns : node",
                    "c177_map : mapping",
                    "c174_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c183_goal : map_valid map s1",
                    "c177_s1 : state",
                    "c177_WF : map_valid map s",
                    "c177_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c184_goal : target_regs_ok map pr e x",
                    "c177_EQ : eq (alloc_regs map e s) (OK x s0 INCR0)",
                    "c177_x : list reg",
                    "c177_VALID : regs_valid pr s",
                    "c177_WF : map_valid map s",
                    "c177_pr : list reg",
                    "c177_map : mapping",
                    "c174_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c185_goal : regs_valid pr s1",
                    "c177_s1 : state",
                    "c177_VALID : regs_valid pr s",
                    "c177_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c186_goal : regs_valid x s1",
                    "c177_s1 : state",
                    "c177_EQ : eq (alloc_regs map e s) (OK x s0 INCR0)",
                    "c177_x : list reg",
                    "c177_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c178_goal : tr_condition (st_code s') map pr (CEcondition a1 a2 a3) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c187_goal : tr_condition (st_code s') map pr a1 ns ?n2 ?n3",
                    "c188_goal : tr_condition (st_code s') map pr a2 x0 ntrue nfalse",
                    "c189_goal : tr_condition (st_code s') map pr a3 x ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c187_goal : tr_condition (st_code s') map pr a1 ns ?n2 ?n3",
                    "c178_INCR4 : state_incr s s1",
                    "c178_EQ2 : eq (transl_condexpr map a1 x0 x s1) (OK ns s' INCR3)",
                    "c178_VALID : regs_valid pr s",
                    "c178_WF : map_valid map s",
                    "c178_pr : list reg",
                    "c178_s' : state",
                    "c178_ns : node",
                    "c178_map : mapping",
                    "c175_a1 : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c188_goal : tr_condition (st_code s') map pr a2 x0 ntrue nfalse",
                    "_global_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c178_s1 : state"
                ],
                "tactic_res": [
                    "c190_goal : state_incr s1 s'",
                    "c191_goal : tr_condition (st_code s1) map pr a2 x0 ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c190_goal : state_incr s1 s'",
                    "c178_s1 : state",
                    "c178_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c191_goal : tr_condition (st_code s1) map pr a2 x0 ntrue nfalse",
                    "c178_EQ1 : eq (transl_condexpr map a2 ntrue nfalse s0) (OK x0 s1 INCR2)",
                    "c178_s1 : state",
                    "c178_x0 : node",
                    "c178_VALID : regs_valid pr s",
                    "c178_WF : map_valid map s",
                    "c178_pr : list reg",
                    "c178_ntrue : node",
                    "c178_nfalse : node",
                    "c178_map : mapping",
                    "c175_a2 : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c189_goal : tr_condition (st_code s') map pr a3 x ntrue nfalse",
                    "_global_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c178_s0 : state"
                ],
                "tactic_res": [
                    "c192_goal : state_incr s0 s'",
                    "c193_goal : tr_condition (st_code s0) map pr a3 x ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c192_goal : state_incr s0 s'",
                    "c178_INCR1 : state_incr s0 s'",
                    "c178_s0 : state",
                    "c178_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c193_goal : tr_condition (st_code s0) map pr a3 x ntrue nfalse",
                    "c178_EQ : eq (transl_condexpr map a3 ntrue nfalse s) (OK x s0 INCR0)",
                    "c178_s0 : state",
                    "c178_x : node",
                    "c178_VALID : regs_valid pr s",
                    "c178_WF : map_valid map s",
                    "c178_pr : list reg",
                    "c178_ntrue : node",
                    "c178_nfalse : node",
                    "c178_map : mapping",
                    "c175_a3 : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c179_goal : tr_condition (st_code s') map pr (CElet e a) ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c194_goal : not (reg_in_map map ?r)",
                    "c195_goal : tr_expr (st_code s') map pr e ns ?n1 x None",
                    "c196_goal : tr_condition (st_code s') (add_letvar map x) pr a x0 ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c194_goal : not (reg_in_map map ?r)",
                    "c179_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c179_WF : map_valid map s",
                    "c179_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c195_goal : tr_expr (st_code s') map pr e ns ?n1 x None",
                    "c3_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) (nd : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n  (_ : regs_valid pr s) (_ : reg_valid rd s),\ntr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c197_goal : eq (transl_expr map e x ?n1 ?s) (OK ns s' ?INCR)",
                    "c198_goal : map_valid map s1",
                    "c199_goal : target_reg_ok map pr e x",
                    "c200_goal : regs_valid pr s1",
                    "c201_goal : reg_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c197_goal : eq (transl_expr map e x ?n1 ?s) (OK ns s' ?INCR)",
                    "c179_EQ2 : eq (transl_expr map e x x0 s1) (OK ns s' INCR3)",
                    "c179_x : reg",
                    "c179_s' : state",
                    "c179_ns : node",
                    "c179_map : mapping",
                    "c176_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c198_goal : map_valid map s1",
                    "c179_s1 : state",
                    "c179_WF : map_valid map s",
                    "c179_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c199_goal : target_reg_ok map pr e x",
                    "c179_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c179_x : reg",
                    "c179_VALID : regs_valid pr s",
                    "c179_WF : map_valid map s",
                    "c179_pr : list reg",
                    "c179_map : mapping",
                    "c176_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c200_goal : regs_valid pr s1",
                    "c179_s1 : state",
                    "c179_VALID : regs_valid pr s",
                    "c179_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c201_goal : reg_valid x s1",
                    "c179_s1 : state",
                    "c179_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c179_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c196_goal : tr_condition (st_code s') (add_letvar map x) pr a x0 ntrue nfalse",
                    "_global_tr_condition_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c179_s1 : state"
                ],
                "tactic_res": [
                    "c202_goal : state_incr s1 s'",
                    "c203_goal : tr_condition (st_code s1) (add_letvar map x) pr a x0 ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c202_goal : state_incr s1 s'",
                    "c179_s1 : state",
                    "c179_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c203_goal : tr_condition (st_code s1) (add_letvar map x) pr a x0 ntrue nfalse",
                    "c3_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node) \n  (s : state) (ns : node) (s' : state) (pr : list reg)\n  (INCR : state_incr s s')\n  (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : regs_valid pr s),\ntr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c204_goal : eq (transl_condexpr (add_letvar map x) a ntrue nfalse ?s)\n  (OK x0 s1 ?INCR)",
                    "c205_goal : map_valid (add_letvar map x) s0",
                    "c206_goal : regs_valid pr s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c204_goal : eq (transl_condexpr (add_letvar map x) a ntrue nfalse ?s)\n  (OK x0 s1 ?INCR)",
                    "c179_EQ1 : eq (transl_condexpr (add_letvar map x) a ntrue nfalse s0)\n  (OK x0 s1 INCR2)",
                    "c179_s1 : state",
                    "c179_x0 : node",
                    "c179_x : reg",
                    "c179_ntrue : node",
                    "c179_nfalse : node",
                    "c179_map : mapping",
                    "c176_a : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c206_goal : regs_valid pr s0",
                    "c179_s0 : state",
                    "c179_VALID : regs_valid pr s",
                    "c179_pr : list reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c205_goal : map_valid (add_letvar map x) s0",
                    "_global_add_letvar_valid : forall (map : mapping) (s : state) (r : reg) \n         (_ : map_valid map s) (_ : reg_valid r s),\n       map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c207_goal : map_valid map s0",
                    "c208_goal : reg_valid x s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c207_goal : map_valid map s0",
                    "c179_s0 : state",
                    "c179_WF : map_valid map s",
                    "c179_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c208_goal : reg_valid x s0",
                    "c179_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c179_s0 : state",
                    "c179_x : reg"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_expr_assign_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_expr_assign_charact : forall id a map rd nd s ns s' INCR ( TR : transl_expr map a rd nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : reg_map_ok map rd ( Some id ) ) , tr_expr s'. ( st_code ) map nil a ns nd rd ( Some id ) .",
                "tactic_sig_no_out_arg": "Lemma transl_expr_assign_charact : forall id a map rd nd s ns s' INCR ( TR : transl_expr map a rd nd s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : reg_map_ok map rd ( Some id ) ) , tr_expr s'. ( st_code ) map nil a ns nd rd ( Some id ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (id : ident) (a : expr) (map : mapping) (rd : reg) \n  (nd : node) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros id a .",
                "tactic_args": [
                    "c1_goal : forall (id : ident) (a : expr) (map : mapping) (rd : reg) \n  (nd : node) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c2_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a ns nd rd (Some id)",
                    "c2_id : ident",
                    "c2_a : expr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a ns nd rd (Some id)",
                    "c2_a : expr"
                ],
                "tactic_res": [
                    "c3_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Evar i) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c3_i : ident",
                    "c4_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eop o e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eop o e) ns nd rd (Some id)",
                    "c4_e : exprlist",
                    "c4_o : operation",
                    "c5_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eload m a e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eload m a e) ns nd rd (Some id)",
                    "c5_e : exprlist",
                    "c5_a : addressing",
                    "c5_m : memory_chunk",
                    "c6_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Econdition c a1 a2) ns nd rd (Some id)",
                    "c6_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a2 ns nd rd (Some id)",
                    "c6_IHa1 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a1 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a1 ns nd rd (Some id)",
                    "c6_a2 : expr",
                    "c6_a1 : expr",
                    "c6_c : condexpr",
                    "c7_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Elet a1 a2) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Elet a1 a2) ns nd rd (Some id)",
                    "c7_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a2 ns nd rd (Some id)",
                    "c7_IHa1 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a1 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a1 ns nd rd (Some id)",
                    "c7_a2 : expr",
                    "c7_a1 : expr",
                    "c8_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eletvar n) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c8_n : nat",
                    "c9_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Ebuiltin e e0) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Ebuiltin e e0) ns nd rd (Some id)",
                    "c9_e0 : exprlist",
                    "c9_e : external_function",
                    "c10_goal : forall (map : mapping) (rd : reg) (nd : node) (s0 : state) \n  (ns : node) (s' : state) (INCR : state_incr s0 s')\n  (_ : eq (transl_expr map (Eexternal i s e) rd nd s0) (OK ns s' INCR))\n  (_ : map_valid map s0) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eexternal i s e) ns nd rd (Some id)",
                    "c10_e : exprlist",
                    "c10_s : signature",
                    "c10_i : ident"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Evar i) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c11_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c11_map : mapping",
                    "c11_rd : reg",
                    "c11_nd : node",
                    "c11_s : state",
                    "c11_ns : node",
                    "c11_s' : state",
                    "c11_INCR : state_incr s s'",
                    "c11_TR : eq (transl_expr map (Evar i) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c11_WF : map_valid map s",
                    "c11_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c11_TR : eq (transl_expr map (Evar i) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c11_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c11_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)",
                    "c11_INCR1 : state_incr s0 s'",
                    "c11_INCR0 : state_incr s s0",
                    "c11_s0 : state",
                    "c11_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eop o e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eop o e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c12_goal : tr_expr (st_code s') map nil (Eop o e) ns nd rd (Some id)",
                    "c12_map : mapping",
                    "c12_rd : reg",
                    "c12_nd : node",
                    "c12_s : state",
                    "c12_ns : node",
                    "c12_s' : state",
                    "c12_INCR : state_incr s s'",
                    "c12_TR : eq (transl_expr map (Eop o e) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c12_WF : map_valid map s",
                    "c12_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c12_TR : eq (transl_expr map (Eop o e) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c12_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c12_EQ1 : eq (add_instr (Iop o x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c12_INCR3 : state_incr s1 s'",
                    "c12_INCR2 : state_incr s0 s1",
                    "c12_s1 : state",
                    "c12_x0 : node",
                    "c12_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c12_INCR1 : state_incr s0 s'",
                    "c12_INCR0 : state_incr s s0",
                    "c12_s0 : state",
                    "c12_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eload m a e) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eload m a e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c13_goal : tr_expr (st_code s') map nil (Eload m a e) ns nd rd (Some id)",
                    "c13_map : mapping",
                    "c13_rd : reg",
                    "c13_nd : node",
                    "c13_s : state",
                    "c13_ns : node",
                    "c13_s' : state",
                    "c13_INCR : state_incr s s'",
                    "c13_TR : eq (transl_expr map (Eload m a e) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c13_WF : map_valid map s",
                    "c13_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c13_TR : eq (transl_expr map (Eload m a e) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c13_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c13_EQ1 : eq (add_instr (Iload m a x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c13_INCR3 : state_incr s1 s'",
                    "c13_INCR2 : state_incr s0 s1",
                    "c13_s1 : state",
                    "c13_x0 : node",
                    "c13_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c13_INCR1 : state_incr s0 s'",
                    "c13_INCR0 : state_incr s s0",
                    "c13_s0 : state",
                    "c13_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Econdition c a1 a2) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c14_goal : tr_expr (st_code s') map nil (Econdition c a1 a2) ns nd rd (Some id)",
                    "c14_map : mapping",
                    "c14_rd : reg",
                    "c14_nd : node",
                    "c14_s : state",
                    "c14_ns : node",
                    "c14_s' : state",
                    "c14_INCR : state_incr s s'",
                    "c14_TR : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n  (RTLgen.OK ns s' INCR)",
                    "c14_WF : map_valid map s",
                    "c14_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c14_TR : eq (transl_expr map (Econdition c a1 a2) rd nd s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c14_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c14_EQ1 : eq (transl_expr map a1 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c14_INCR3 : state_incr s1 s'",
                    "c14_INCR2 : state_incr s0 s1",
                    "c14_s1 : state",
                    "c14_x0 : node",
                    "c14_EQ : eq (transl_expr map a2 rd nd s) (RTLgen.OK x s0 INCR0)",
                    "c14_INCR1 : state_incr s0 s'",
                    "c14_INCR0 : state_incr s s0",
                    "c14_s0 : state",
                    "c14_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Elet a1 a2) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Elet a1 a2) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c15_goal : tr_expr (st_code s') map nil (Elet a1 a2) ns nd rd (Some id)",
                    "c15_map : mapping",
                    "c15_rd : reg",
                    "c15_nd : node",
                    "c15_s : state",
                    "c15_ns : node",
                    "c15_s' : state",
                    "c15_INCR : state_incr s s'",
                    "c15_TR : eq (transl_expr map (Elet a1 a2) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c15_WF : map_valid map s",
                    "c15_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c15_TR : eq (transl_expr map (Elet a1 a2) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c15_EQ2 : eq (transl_expr map a1 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c15_EQ1 : eq (transl_expr (add_letvar map x) a2 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c15_INCR3 : state_incr s1 s'",
                    "c15_INCR2 : state_incr s0 s1",
                    "c15_s1 : state",
                    "c15_x0 : node",
                    "c15_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c15_INCR1 : state_incr s0 s'",
                    "c15_INCR0 : state_incr s s0",
                    "c15_s0 : state",
                    "c15_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Eletvar n) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c16_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c16_map : mapping",
                    "c16_rd : reg",
                    "c16_nd : node",
                    "c16_s : state",
                    "c16_ns : node",
                    "c16_s' : state",
                    "c16_INCR : state_incr s s'",
                    "c16_TR : eq (transl_expr map (Eletvar n) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c16_WF : map_valid map s",
                    "c16_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c16_TR : eq (transl_expr map (Eletvar n) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c16_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c16_EQ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0)",
                    "c16_INCR1 : state_incr s0 s'",
                    "c16_INCR0 : state_incr s s0",
                    "c16_s0 : state",
                    "c16_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map (Ebuiltin e e0) rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Ebuiltin e e0) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c17_goal : tr_expr (st_code s') map nil (Ebuiltin e e0) ns nd rd (Some id)",
                    "c17_map : mapping",
                    "c17_rd : reg",
                    "c17_nd : node",
                    "c17_s : state",
                    "c17_ns : node",
                    "c17_s' : state",
                    "c17_INCR : state_incr s s'",
                    "c17_TR : eq (transl_expr map (Ebuiltin e e0) rd nd s) (RTLgen.OK ns s' INCR)",
                    "c17_WF : map_valid map s",
                    "c17_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c17_TR : eq (transl_expr map (Ebuiltin e e0) rd nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c17_EQ2 : eq (transl_exprlist map e0 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c17_EQ1 : eq (add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c17_INCR3 : state_incr s1 s'",
                    "c17_INCR2 : state_incr s0 s1",
                    "c17_s1 : state",
                    "c17_x0 : node",
                    "c17_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c17_INCR1 : state_incr s0 s'",
                    "c17_INCR0 : state_incr s s0",
                    "c17_s0 : state",
                    "c17_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (map : mapping) (rd : reg) (nd : node) (s0 : state) \n  (ns : node) (s' : state) (INCR : state_incr s0 s')\n  (_ : eq (transl_expr map (Eexternal i s e) rd nd s0) (OK ns s' INCR))\n  (_ : map_valid map s0) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil (Eexternal i s e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c18_goal : tr_expr (st_code s') map nil (Eexternal i s e) ns nd rd (Some id)",
                    "c18_map : mapping",
                    "c18_rd : reg",
                    "c18_nd : node",
                    "c18_s0 : state",
                    "c18_ns : node",
                    "c18_s' : state",
                    "c18_INCR : state_incr s0 s'",
                    "c18_TR : eq (transl_expr map (Eexternal i s e) rd nd s0) (RTLgen.OK ns s' INCR)",
                    "c18_WF : map_valid map s0",
                    "c18_OK : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c18_TR : eq (transl_expr map (Eexternal i s e) rd nd s0) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c18_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c18_EQ1 : eq (add_instr (Icall s (inr i) x rd nd) s1) (RTLgen.OK x0 s2 INCR2)",
                    "c18_INCR3 : state_incr s2 s'",
                    "c18_INCR2 : state_incr s1 s2",
                    "c18_s2 : state",
                    "c18_x0 : node",
                    "c18_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c18_INCR1 : state_incr s1 s'",
                    "c18_INCR0 : state_incr s0 s1",
                    "c18_s1 : state",
                    "c18_x : list reg"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c11_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c11_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg"
                ],
                "tactic_res": [
                    "c20_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "caseEq ( map_vars _i ) !i .",
                "tactic_sig_no_out_arg": "caseEq ( map_vars _i ) !i .",
                "tactic_args": [
                    "c20_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c11_map : mapping"
                ],
                "tactic_res": [
                    "c21_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c22_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c21_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c23_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c23_r : reg",
                    "c23_H : eq (PTree.get i (map_vars map)) (Some r)",
                    "c23_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c23_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c23_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c23_EQ : eq (find_var map i s0) (RTLgen.OK x s0 INCR0)",
                    "c23_INCR : state_incr s0 s'",
                    "c23_WF : map_valid map s0",
                    "c23_INCR0 : state_incr s0 s0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c22_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c24_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c24_H : eq (PTree.get i (map_vars map)) None",
                    "c24_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c24_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)",
                    "c24_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c23_goal : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c25_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c26_goal : or (and (eq rd x) (eq (Some id) None))\n  (and (reg_map_ok map rd (Some id)) (not (In rd nil)))",
                    "c27_goal : tr_move (st_code s') ns x nd rd"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c23_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c11_map : mapping",
                    "c3_i : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : or (and (eq rd x) (eq (Some id) None))\n  (and (reg_map_ok map rd (Some id)) (not (In rd nil)))",
                    "c11_x : reg",
                    "c11_OK : reg_map_ok map rd (Some id)",
                    "c11_rd : reg",
                    "c11_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c27_goal : tr_move (st_code s') ns x nd rd",
                    "_global_add_move_charact : forall (s : state) (ns : node) (rs : reg) (nd : node) \n         (rd : reg) (s' : state) (i : state_incr s s')\n         (_ : eq (add_move rs rd nd s) (RTLgen.OK ns s' i)),\n       tr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c28_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)",
                    "c11_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c11_x : reg",
                    "c11_s' : state",
                    "c11_nd : node",
                    "c11_ns : node",
                    "c11_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c12_goal : tr_expr (st_code s') map nil (Eop o e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c29_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "c30_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iop o ?rl rd nd))",
                    "c31_goal : reg_map_ok map rd (Some id)",
                    "c32_goal : not (In rd nil)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c30_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iop o ?rl rd nd))",
                    "c12_EQ1 : eq (add_instr (Iop o x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c12_s' : state",
                    "c12_nd : node",
                    "c12_rd : reg",
                    "c4_o : operation"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c31_goal : reg_map_ok map rd (Some id)",
                    "c12_OK : reg_map_ok map rd (Some id)",
                    "c12_rd : reg",
                    "c12_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c32_goal : not (In rd nil)",
                    "c12_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c29_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c33_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c34_goal : map_valid map s1",
                    "c35_goal : target_regs_ok map nil e x",
                    "c36_goal : regs_valid nil s1",
                    "c37_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c33_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c12_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c12_x0 : node",
                    "c12_x : list reg",
                    "c12_s' : state",
                    "c12_ns : node",
                    "c12_map : mapping",
                    "c4_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c34_goal : map_valid map s1",
                    "c12_s1 : state",
                    "c12_WF : map_valid map s",
                    "c12_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c35_goal : target_regs_ok map nil e x",
                    "c12_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c12_x : list reg",
                    "c12_WF : map_valid map s",
                    "c12_map : mapping",
                    "c4_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c36_goal : regs_valid nil s1",
                    "c12_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c37_goal : regs_valid x s1",
                    "c12_s1 : state",
                    "c12_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c12_x : list reg",
                    "c12_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c13_goal : tr_expr (st_code s') map nil (Eload m a e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c38_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "c39_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iload m a ?rl rd nd))",
                    "c40_goal : reg_map_ok map rd (Some id)",
                    "c41_goal : not (In rd nil)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c39_goal : eq (PTree.get ?n1 (st_code s')) (Some (Iload m a ?rl rd nd))",
                    "c13_EQ1 : eq (add_instr (Iload m a x rd nd) s0) (RTLgen.OK x0 s1 INCR2)",
                    "c13_s' : state",
                    "c13_nd : node",
                    "c13_rd : reg",
                    "c5_a : addressing",
                    "c5_m : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c40_goal : reg_map_ok map rd (Some id)",
                    "c13_OK : reg_map_ok map rd (Some id)",
                    "c13_rd : reg",
                    "c13_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c41_goal : not (In rd nil)",
                    "c13_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c38_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c42_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c43_goal : map_valid map s1",
                    "c44_goal : target_regs_ok map nil e x",
                    "c45_goal : regs_valid nil s1",
                    "c46_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c42_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c13_EQ2 : eq (transl_exprlist map e x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c13_x0 : node",
                    "c13_x : list reg",
                    "c13_s' : state",
                    "c13_ns : node",
                    "c13_map : mapping",
                    "c5_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c43_goal : map_valid map s1",
                    "c13_s1 : state",
                    "c13_WF : map_valid map s",
                    "c13_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c44_goal : target_regs_ok map nil e x",
                    "c13_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c13_x : list reg",
                    "c13_WF : map_valid map s",
                    "c13_map : mapping",
                    "c5_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c45_goal : regs_valid nil s1",
                    "c13_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c46_goal : regs_valid x s1",
                    "c13_s1 : state",
                    "c13_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c13_x : list reg",
                    "c13_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c14_goal : tr_expr (st_code s') map nil (Econdition c a1 a2) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c47_goal : tr_condition (st_code s') map nil c ns ?ntrue ?nfalse",
                    "c48_goal : tr_expr (st_code s') map nil a1 x0 nd rd (Some id)",
                    "c49_goal : tr_expr (st_code s') map nil a2 x nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c47_goal : tr_condition (st_code s') map nil c ns ?ntrue ?nfalse",
                    "_global_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node)\n         (s : state) (ns : node) (s' : state) (pr : list reg)\n         (INCR : state_incr s s')\n         (_ : eq (transl_condexpr map a ntrue nfalse s)\n                (RTLgen.OK ns s' INCR)) (_ : map_valid map s)\n         (_ : regs_valid pr s),\n       tr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c50_goal : eq (transl_condexpr map c ?ntrue ?nfalse ?s) (RTLgen.OK ns s' ?INCR)",
                    "c51_goal : map_valid map s1",
                    "c52_goal : regs_valid nil s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c50_goal : eq (transl_condexpr map c ?ntrue ?nfalse ?s) (RTLgen.OK ns s' ?INCR)",
                    "c14_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c14_s' : state",
                    "c14_ns : node",
                    "c14_map : mapping",
                    "c6_c : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c51_goal : map_valid map s1",
                    "c14_s1 : state",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c52_goal : regs_valid nil s1",
                    "c14_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c48_goal : tr_expr (st_code s') map nil a1 x0 nd rd (Some id)",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c14_s1 : state"
                ],
                "tactic_res": [
                    "c53_goal : state_incr s1 s'",
                    "c54_goal : tr_expr (st_code s1) map nil a1 x0 nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : state_incr s1 s'",
                    "c14_s1 : state",
                    "c14_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c54_goal : tr_expr (st_code s1) map nil a1 x0 nd rd (Some id)",
                    "c6_IHa1 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a1 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a1 ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c55_goal : eq (transl_expr map a1 rd nd ?s) (RTLgen.OK x0 s1 ?INCR)",
                    "c56_goal : map_valid map s0",
                    "c57_goal : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c55_goal : eq (transl_expr map a1 rd nd ?s) (RTLgen.OK x0 s1 ?INCR)",
                    "c14_EQ1 : eq (transl_expr map a1 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c14_s1 : state",
                    "c14_x0 : node",
                    "c14_nd : node",
                    "c14_rd : reg",
                    "c14_map : mapping",
                    "c6_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c56_goal : map_valid map s0",
                    "c14_s0 : state",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c57_goal : reg_map_ok map rd (Some id)",
                    "c14_OK : reg_map_ok map rd (Some id)",
                    "c14_rd : reg",
                    "c14_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c49_goal : tr_expr (st_code s') map nil a2 x nd rd (Some id)",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c14_s0 : state"
                ],
                "tactic_res": [
                    "c58_goal : state_incr s0 s'",
                    "c59_goal : tr_expr (st_code s0) map nil a2 x nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c58_goal : state_incr s0 s'",
                    "c14_INCR1 : state_incr s0 s'",
                    "c14_s0 : state",
                    "c14_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c59_goal : tr_expr (st_code s0) map nil a2 x nd rd (Some id)",
                    "c6_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a2 ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c60_goal : eq (transl_expr map a2 rd nd ?s) (RTLgen.OK x s0 ?INCR)",
                    "c61_goal : map_valid map s",
                    "c62_goal : reg_map_ok map rd (Some id)"
                ]
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c60_goal : eq (transl_expr map a2 rd nd ?s) (RTLgen.OK x s0 ?INCR)",
                    "c14_EQ : eq (transl_expr map a2 rd nd s) (RTLgen.OK x s0 INCR0)",
                    "c14_s0 : state",
                    "c14_x : node",
                    "c14_nd : node",
                    "c14_rd : reg",
                    "c14_map : mapping",
                    "c6_a2 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c61_goal : map_valid map s",
                    "c14_WF : map_valid map s",
                    "c14_s : state",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 2 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 2 with rtlg .",
                "tactic_args": [
                    "c62_goal : reg_map_ok map rd (Some id)",
                    "c14_OK : reg_map_ok map rd (Some id)",
                    "c14_rd : reg",
                    "c14_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c15_goal : tr_expr (st_code s') map nil (Elet a1 a2) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c63_goal : not (reg_in_map map ?r)",
                    "c64_goal : tr_expr (st_code s') map nil a1 ns ?n1 x None",
                    "c65_goal : tr_expr (st_code s') (add_letvar map x) nil a2 x0 nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c63_goal : not (reg_in_map map ?r)",
                    "_global_new_reg_not_in_map : forall (s1 s2 : state) (m : mapping) (r : reg) \n         (i : state_incr s1 s2) (_ : eq (new_reg s1) (RTLgen.OK r s2 i))\n         (_ : map_valid m s1), not (reg_in_map m r)"
                ],
                "tactic_res": [
                    "c66_goal : eq (new_reg ?s1) (RTLgen.OK ?r ?s2 ?i)",
                    "c67_goal : map_valid map s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c66_goal : eq (new_reg ?s1) (RTLgen.OK ?r ?s2 ?i)",
                    "c15_EQ : eq (new_reg s) (OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c67_goal : map_valid map s",
                    "c15_WF : map_valid map s",
                    "c15_s : state",
                    "c15_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c64_goal : tr_expr (st_code s') map nil a1 ns ?n1 x None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c68_goal : eq (transl_expr map a1 x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c69_goal : map_valid map s1",
                    "c70_goal : target_reg_ok map nil a1 x",
                    "c71_goal : regs_valid nil s1",
                    "c72_goal : reg_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c68_goal : eq (transl_expr map a1 x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c15_EQ2 : eq (transl_expr map a1 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c15_x : reg",
                    "c15_s' : state",
                    "c15_ns : node",
                    "c15_map : mapping",
                    "c7_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c69_goal : map_valid map s1",
                    "c15_s1 : state",
                    "c15_WF : map_valid map s",
                    "c15_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c70_goal : target_reg_ok map nil a1 x",
                    "c15_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c15_x : reg",
                    "c15_WF : map_valid map s",
                    "c15_map : mapping",
                    "c7_a1 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c71_goal : regs_valid nil s1",
                    "c15_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c72_goal : reg_valid x s1",
                    "c15_s1 : state",
                    "c15_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c15_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c65_goal : tr_expr (st_code s') (add_letvar map x) nil a2 x0 nd rd (Some id)",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c15_s1 : state"
                ],
                "tactic_res": [
                    "c73_goal : state_incr s1 s'",
                    "c74_goal : tr_expr (st_code s1) (add_letvar map x) nil a2 x0 nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c73_goal : state_incr s1 s'",
                    "c15_s1 : state",
                    "c15_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c74_goal : tr_expr (st_code s1) (add_letvar map x) nil a2 x0 nd rd (Some id)",
                    "c7_IHa2 : forall (map : mapping) (rd : reg) (nd : node) (s : state) \n  (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_expr map a2 rd nd s) (OK ns s' INCR))\n  (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\ntr_expr (st_code s') map nil a2 ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c75_goal : eq (transl_expr (add_letvar map x) a2 rd nd ?s) (RTLgen.OK x0 s1 ?INCR)",
                    "c76_goal : map_valid (add_letvar map x) s0",
                    "c77_goal : reg_map_ok (add_letvar map x) rd (Some id)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c75_goal : eq (transl_expr (add_letvar map x) a2 rd nd ?s) (RTLgen.OK x0 s1 ?INCR)",
                    "c15_EQ1 : eq (transl_expr (add_letvar map x) a2 rd nd s0) (RTLgen.OK x0 s1 INCR2)",
                    "c15_s1 : state",
                    "c15_x0 : node",
                    "c15_x : reg",
                    "c15_nd : node",
                    "c15_rd : reg",
                    "c15_map : mapping",
                    "c7_a2 : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c76_goal : map_valid (add_letvar map x) s0",
                    "_global_add_letvar_valid : forall (map : mapping) (s : state) (r : reg) \n         (_ : map_valid map s) (_ : reg_valid r s),\n       map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c78_goal : map_valid map s0",
                    "c79_goal : reg_valid x s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c78_goal : map_valid map s0",
                    "c15_s0 : state",
                    "c15_WF : map_valid map s",
                    "c15_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c79_goal : reg_valid x s0",
                    "c15_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c15_s0 : state",
                    "c15_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_OK : reg_map_ok map rd (Some id)"
                ],
                "tactic_res": [
                    "c77_H2 : eq (PTree.get id (map_vars map)) (Some rd)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c77_goal : reg_map_ok (add_letvar map x) rd (Some id)"
                ],
                "tactic_res": [
                    "c80_goal : eq (PTree.get id (map_vars (add_letvar map x))) (Some rd)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c80_goal : eq (PTree.get id (map_vars (add_letvar map x))) (Some rd)",
                    "c77_H2 : eq (PTree.get id (map_vars map)) (Some rd)",
                    "c15_x : reg",
                    "c15_rd : reg",
                    "c15_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c16_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c16_EQ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c81_goal : forall _ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c81_goal : forall _ : eq (find_letvar map n s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "_global_find_letvar : forall (_ : mapping) (_ : nat), mon reg"
                ],
                "tactic_res": [
                    "c82_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_sig_no_out_arg": "caseEq ( nth_error ( map_letvars _i ) _i ) .",
                "tactic_args": [
                    "c82_goal : forall\n  _ : eq\n        (match nth_error (map_letvars map) n with\n         | Some r => ret r\n         | None => error (Errors.msg \"RTLgen: unbound let variable\")\n         end s) (RTLgen.OK x s0 INCR0),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c16_map : mapping",
                    "c8_n : nat"
                ],
                "tactic_res": [
                    "c83_goal : forall (r : reg) (_ : eq (nth_error (map_letvars map) n) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c84_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n         (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c83_goal : forall (r : reg) (_ : eq (nth_error (map_letvars map) n) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c85_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c85_r : reg",
                    "c85_H : eq (nth_error (map_letvars map) n) (Some r)",
                    "c85_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c85_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c84_goal : forall (_ : eq (nth_error (map_letvars map) n) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n         (RTLgen.OK x s0 INCR0)),\ntr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c86_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c86_H : eq (nth_error (map_letvars map) n) None",
                    "c86_EQ1 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n  (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_EQ0 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c86_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c85_EQ1 : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c85_H : eq (nth_error (map_letvars map) n) (Some x)",
                    "c85_EQ : eq (find_letvar map n s0) (RTLgen.OK x s0 INCR0)",
                    "c85_INCR : state_incr s0 s'",
                    "c85_WF : map_valid map s0",
                    "c85_INCR0 : state_incr s0 s0"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c85_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c87_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c88_goal : or (and (eq rd x) (eq (Some id) None))\n  (and (reg_map_ok map rd (Some id)) (not (In rd nil)))",
                    "c89_goal : tr_move (st_code s') ns x nd rd"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c87_goal : eq (nth_error (map_letvars map) n) (Some ?r)",
                    "c85_H : eq (nth_error (map_letvars map) n) (Some x)",
                    "c16_map : mapping",
                    "c8_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c88_goal : or (and (eq rd x) (eq (Some id) None))\n  (and (reg_map_ok map rd (Some id)) (not (In rd nil)))",
                    "c16_x : reg",
                    "c16_OK : reg_map_ok map rd (Some id)",
                    "c16_rd : reg",
                    "c16_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c89_goal : tr_move (st_code s') ns x nd rd",
                    "_global_add_move_charact : forall (s : state) (ns : node) (rs : reg) (nd : node) \n         (rd : reg) (s' : state) (i : state_incr s s')\n         (_ : eq (add_move rs rd nd s) (RTLgen.OK ns s' i)),\n       tr_move (st_code s') ns rs nd rd"
                ],
                "tactic_res": [
                    "c90_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c90_goal : eq (add_move x rd nd ?s) (RTLgen.OK ns s' ?i)",
                    "c85_H1 : eq (add_move x rd nd s0) (RTLgen.OK ns s' INCR1)",
                    "c16_x : reg",
                    "c16_s' : state",
                    "c16_nd : node",
                    "c16_ns : node",
                    "c16_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c86_goal : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id)",
                    "c86_EQ1 : eq (error (Errors.msg \"RTLgen: unbound let variable\") s)\n  (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c17_goal : tr_expr (st_code s') map nil (Ebuiltin e e0) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c91_goal : tr_exprlist (st_code s') map nil e0 ns x0 x",
                    "c92_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (List.map (BA (A:=reg)) ?rl) (BR rd) nd))",
                    "c93_goal : reg_map_ok map rd (Some id)",
                    "c94_goal : not (In rd nil)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c92_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (List.map (BA (A:=reg)) ?rl) (BR rd) nd))",
                    "c17_EQ1 : eq (add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c17_s' : state",
                    "c17_nd : node",
                    "c17_rd : reg",
                    "c9_e : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c93_goal : reg_map_ok map rd (Some id)",
                    "c17_OK : reg_map_ok map rd (Some id)",
                    "c17_rd : reg",
                    "c17_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c94_goal : not (In rd nil)",
                    "c17_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c91_goal : tr_exprlist (st_code s') map nil e0 ns x0 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c95_goal : eq (transl_exprlist map e0 x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c96_goal : map_valid map s1",
                    "c97_goal : target_regs_ok map nil e0 x",
                    "c98_goal : regs_valid nil s1",
                    "c99_goal : regs_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c95_goal : eq (transl_exprlist map e0 x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c17_EQ2 : eq (transl_exprlist map e0 x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c17_x0 : node",
                    "c17_x : list reg",
                    "c17_s' : state",
                    "c17_ns : node",
                    "c17_map : mapping",
                    "c9_e0 : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c96_goal : map_valid map s1",
                    "c17_s1 : state",
                    "c17_WF : map_valid map s",
                    "c17_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c97_goal : target_regs_ok map nil e0 x",
                    "c17_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c17_x : list reg",
                    "c17_WF : map_valid map s",
                    "c17_map : mapping",
                    "c9_e0 : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c98_goal : regs_valid nil s1",
                    "c17_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c99_goal : regs_valid x s1",
                    "c17_s1 : state",
                    "c17_EQ : eq (alloc_regs map e0 s) (RTLgen.OK x s0 INCR0)",
                    "c17_x : list reg",
                    "c17_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c18_goal : tr_expr (st_code s') map nil (Eexternal i s e) ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c100_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "c101_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icall s (inr i) ?rl rd nd))",
                    "c102_goal : reg_map_ok map rd (Some id)",
                    "c103_goal : not (In rd nil)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c101_goal : eq (PTree.get ?n1 (st_code s')) (Some (Icall s (inr i) ?rl rd nd))",
                    "c18_EQ1 : eq (add_instr (Icall s (inr i) x rd nd) s1) (RTLgen.OK x0 s2 INCR2)",
                    "c18_s' : state",
                    "c18_nd : node",
                    "c18_rd : reg",
                    "c10_s : signature",
                    "c10_i : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c102_goal : reg_map_ok map rd (Some id)",
                    "c18_OK : reg_map_ok map rd (Some id)",
                    "c18_rd : reg",
                    "c18_map : mapping",
                    "c2_id : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c103_goal : not (In rd nil)",
                    "c18_rd : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c100_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c104_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c105_goal : map_valid map s2",
                    "c106_goal : target_regs_ok map nil e x",
                    "c107_goal : regs_valid nil s2",
                    "c108_goal : regs_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c104_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c18_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c18_x0 : node",
                    "c18_x : list reg",
                    "c18_s' : state",
                    "c18_ns : node",
                    "c18_map : mapping",
                    "c10_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c105_goal : map_valid map s2",
                    "c18_s2 : state",
                    "c18_WF : map_valid map s0",
                    "c18_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c106_goal : target_regs_ok map nil e x",
                    "c18_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c18_x : list reg",
                    "c18_WF : map_valid map s0",
                    "c18_map : mapping",
                    "c10_e : exprlist"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c107_goal : regs_valid nil s2",
                    "c18_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c108_goal : regs_valid x s2",
                    "c18_s2 : state",
                    "c18_EQ : eq (alloc_regs map e s0) (RTLgen.OK x s1 INCR0)",
                    "c18_x : list reg",
                    "c18_WF : map_valid map s0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "alloc_optreg_map_ok",
        "proof": [
            {
                "tactic_sig": "Lemma alloc_optreg_map_ok : forall map optid s1 r s2 i , map_valid map s1 -> alloc_optreg map optid s1 = OK r s2 i -> reg_map_ok map r optid .",
                "tactic_sig_no_out_arg": "Lemma alloc_optreg_map_ok : forall map optid s1 r s2 i , map_valid map s1 -> alloc_optreg map optid s1 = OK r s2 i -> reg_map_ok map r optid .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (optid : option ident) (s1 : state) \n  (r : reg) (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map optid s1) (OK r s2 i)),\nreg_map_ok map r optid"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (optid : option ident) (s1 : state) \n  (r : reg) (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq (alloc_optreg map optid s1) (OK r s2 i)),\nreg_map_ok map r optid",
                    "_global_alloc_optreg : forall (_ : mapping) (_ : option ident), mon reg"
                ],
                "tactic_res": [
                    "c2_goal : forall (map : mapping) (optid : option ident) (s1 : state) \n  (r : reg) (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (match optid with\n          | Some id => find_var map id\n          | None => new_reg\n          end s1) (OK r s2 i)), reg_map_ok map r optid"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (map : mapping) (optid : option ident) (s1 : state) \n  (r : reg) (s2 : state) (i : state_incr s1 s2) (_ : map_valid map s1)\n  (_ : eq\n         (match optid with\n          | Some id => find_var map id\n          | None => new_reg\n          end s1) (OK r s2 i)), reg_map_ok map r optid"
                ],
                "tactic_res": [
                    "c3_goal : reg_map_ok map r optid",
                    "c3_map : mapping",
                    "c3_optid : option ident",
                    "c3_s1 : state",
                    "c3_r : reg",
                    "c3_s2 : state",
                    "c3_i : state_incr s1 s2",
                    "c3_H : map_valid map s1",
                    "c3_H0 : eq\n  (match optid with\n   | Some id => find_var map id\n   | None => new_reg\n   end s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : reg_map_ok map r optid",
                    "c3_optid : option ident",
                    "c3_H0 : eq\n  (match optid with\n   | Some id => find_var map id\n   | None => new_reg\n   end s1) (OK r s2 i)",
                    "c3_H : map_valid map s1",
                    "c3_r : reg",
                    "c3_map : mapping"
                ],
                "tactic_res": [
                    "c4_goal : reg_map_ok map r (Some i0)",
                    "c4_H0 : eq (find_var map i0 s1) (OK r s2 i)",
                    "c4_i0 : ident",
                    "c5_goal : reg_map_ok map r None",
                    "c5_H0 : eq (new_reg s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : reg_map_ok map r (Some i0)"
                ],
                "tactic_res": [
                    "c6_goal : eq (PTree.get i0 (map_vars map)) (Some r)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg",
                    "c6_H0 : eq (find_var map i0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c6_H0 : eq\n  (match PTree.get i0 (map_vars map) with\n   | Some r => ret r\n   | None =>\n       error\n         (cons (Errors.MSG \"RTLgen: unbound variable \")\n            (cons (Errors.CTX i0) nil))\n   end s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "destruct ( map_vars _i ) !i0 as [  _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( map_vars _i ) !i0 .",
                "tactic_args": [
                    "c6_goal : eq (PTree.get i0 (map_vars map)) (Some r)",
                    "c3_map : mapping",
                    "c6_H0 : eq\n  (match PTree.get i0 (map_vars map) with\n   | Some r => ret r\n   | None =>\n       error\n         (cons (Errors.MSG \"RTLgen: unbound variable \")\n            (cons (Errors.CTX i0) nil))\n   end s1) (OK r s2 i)",
                    "c3_H : map_valid map s1",
                    "c3_r : reg",
                    "c4_i0 : ident"
                ],
                "tactic_res": [
                    "c7_goal : eq (Some r0) (Some r)",
                    "c7_H0 : eq (ret r0 s1) (OK r s2 i)",
                    "c7_r0 : reg",
                    "c8_goal : eq None (Some r)",
                    "c8_H0 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c7_goal : eq (Some r0) (Some r)",
                    "c7_H0 : eq (ret r0 s1) (OK r s2 i)"
                ],
                "tactic_res": [
                    "c9_goal : eq (Some r) (Some r)",
                    "c9_i : state_incr s2 s2",
                    "c9_H : map_valid map s2"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c8_goal : eq None (Some r)",
                    "c8_H0 : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i0) nil)) s1) (OK r s2 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (Some r) (Some r)",
                    "c3_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : reg_map_ok map r None"
                ],
                "tactic_res": [
                    "c10_goal : not (reg_in_map map r)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c10_goal : not (reg_in_map map r)",
                    "_global_new_reg_not_in_map : forall (s1 s2 : state) (m : mapping) (r : reg) \n         (i : state_incr s1 s2) (_ : eq (new_reg s1) (OK r s2 i))\n         (_ : map_valid m s1), not (reg_in_map m r)"
                ],
                "tactic_res": [
                    "c11_goal : eq (new_reg ?s1) (OK r ?s2 ?i)",
                    "c12_goal : map_valid map s1"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : eq (new_reg ?s1) (OK r ?s2 ?i)",
                    "c5_H0 : eq (new_reg s1) (OK r s2 i)",
                    "c3_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : map_valid map s1",
                    "c3_H : map_valid map s1",
                    "c3_s1 : state",
                    "c3_map : mapping"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "tr_exitexpr_incr",
        "proof": [
            {
                "tactic_sig": "Lemma tr_exitexpr_incr : forall s1 s2 , state_incr s1 s2 -> forall map a ns nexits , tr_exitexpr s1. ( st_code ) map a ns nexits -> tr_exitexpr s2. ( st_code ) map a ns nexits .",
                "tactic_sig_no_out_arg": "Lemma tr_exitexpr_incr : forall s1 s2 , state_incr s1 s2 -> forall map a ns nexits , tr_exitexpr s1. ( st_code ) map a ns nexits -> tr_exitexpr s2. ( st_code ) map a ns nexits .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 EXT .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ],
                "tactic_res": [
                    "c2_goal : forall (map : mapping) (a : exitexpr) (ns : node) \n  (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_EXT : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "generalize tr_expr_incr tr_condition_incr .",
                "tactic_sig_no_out_arg": "generalize tr_expr_incr tr_condition_incr .",
                "tactic_args": [
                    "c2_goal : forall (map : mapping) (a : exitexpr) (ns : node) \n  (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse)\n  (map : mapping) (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros I1 I2 .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse)\n  (map : mapping) (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ],
                "tactic_res": [
                    "c4_goal : forall (map : mapping) (a : exitexpr) (ns : node) \n  (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c4_I2 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (a : exitexpr) (ns : node) \n  (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ],
                "tactic_res": [
                    "c5_goal : tr_exitexpr (st_code s2) map (XEexit x) n nexits",
                    "c5_H : eq (nth_error nexits x) (Some n)",
                    "c5_nexits : list node",
                    "c5_n : node",
                    "c5_x : nat",
                    "c5_map : mapping",
                    "c6_goal : tr_exitexpr (st_code s2) map (XEjumptable a tbl) ns nexits",
                    "c6_H1 : eq (PTree.get n1 (st_code s1)) (Some (Ijumptable r tbl'))",
                    "c6_H0 : tr_expr (st_code s1) map nil a ns n1 r None",
                    "c6_H : tr_jumptable nexits tbl tbl'",
                    "c6_tbl' : list node",
                    "c6_r : reg",
                    "c6_n1 : node",
                    "c6_nexits : list node",
                    "c6_ns : node",
                    "c6_tbl : list nat",
                    "c6_a : expr",
                    "c6_map : mapping",
                    "c7_goal : tr_exitexpr (st_code s2) map (XEcondition a1 a2 a3) ns nexits",
                    "c7_IHtr_exitexpr2 : tr_exitexpr (st_code s2) map a3 n3 nexits",
                    "c7_IHtr_exitexpr1 : tr_exitexpr (st_code s2) map a2 n2 nexits",
                    "c7_H1 : tr_exitexpr (st_code s1) map a3 n3 nexits",
                    "c7_H0 : tr_exitexpr (st_code s1) map a2 n2 nexits",
                    "c7_H : tr_condition (st_code s1) map nil a1 ns n2 n3",
                    "c7_n3 : node",
                    "c7_n2 : node",
                    "c7_nexits : list node",
                    "c7_ns : node",
                    "c7_a3 : exitexpr",
                    "c7_a2 : exitexpr",
                    "c7_a1 : condexpr",
                    "c7_map : mapping",
                    "c8_goal : tr_exitexpr (st_code s2) map (XElet a b) ns nexits",
                    "c8_IHtr_exitexpr : tr_exitexpr (st_code s2) (add_letvar map r) b n1 nexits",
                    "c8_H1 : tr_exitexpr (st_code s1) (add_letvar map r) b n1 nexits",
                    "c8_H0 : tr_expr (st_code s1) map nil a ns n1 r None",
                    "c8_H : not (reg_in_map map r)",
                    "c8_n1 : node",
                    "c8_r : reg",
                    "c8_nexits : list node",
                    "c8_ns : node",
                    "c8_b : exitexpr",
                    "c8_a : expr",
                    "c8_map : mapping"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c5_goal : tr_exitexpr (st_code s2) map (XEexit x) n nexits"
                ],
                "tactic_res": [
                    "c9_goal : eq (nth_error nexits x) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c9_goal : eq (nth_error nexits x) (Some n)",
                    "c5_H : eq (nth_error nexits x) (Some n)",
                    "c5_nexits : list node",
                    "c5_n : node",
                    "c5_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c6_goal : tr_exitexpr (st_code s2) map (XEjumptable a tbl) ns nexits"
                ],
                "tactic_res": [
                    "c10_goal : tr_jumptable nexits tbl ?tbl'",
                    "c11_goal : tr_expr (st_code s2) map nil a ns ?n1 ?r None",
                    "c12_goal : eq (PTree.get n1 (st_code s2)) (Some (Ijumptable r tbl'))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c10_goal : tr_jumptable nexits tbl ?tbl'",
                    "c6_H : tr_jumptable nexits tbl tbl'",
                    "c6_nexits : list node",
                    "c6_tbl : list nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c11_goal : tr_expr (st_code s2) map nil a ns ?n1 ?r None",
                    "c6_H0 : tr_expr (st_code s1) map nil a ns n1 r None",
                    "c6_ns : node",
                    "c6_a : expr",
                    "c6_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_EXT : state_incr s1 s2",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c12_goal : eq (PTree.get n1 (st_code s2)) (Some (Ijumptable r tbl'))",
                    "c6_H1 : eq (PTree.get n1 (st_code s1)) (Some (Ijumptable r tbl'))",
                    "c6_tbl' : list node",
                    "c6_r : reg",
                    "c6_n1 : node",
                    "c2_EXT : state_incr s1 s2",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c7_goal : tr_exitexpr (st_code s2) map (XEcondition a1 a2 a3) ns nexits"
                ],
                "tactic_res": [
                    "c13_goal : tr_condition (st_code s2) map nil a1 ns ?n2 ?n3",
                    "c14_goal : tr_exitexpr (st_code s2) map a2 n2 nexits",
                    "c15_goal : tr_exitexpr (st_code s2) map a3 n3 nexits"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c13_goal : tr_condition (st_code s2) map nil a1 ns ?n2 ?n3",
                    "c7_H : tr_condition (st_code s1) map nil a1 ns n2 n3",
                    "c7_ns : node",
                    "c7_a1 : condexpr",
                    "c7_map : mapping",
                    "c4_I2 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c2_EXT : state_incr s1 s2",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c14_goal : tr_exitexpr (st_code s2) map a2 n2 nexits",
                    "c7_IHtr_exitexpr1 : tr_exitexpr (st_code s2) map a2 n2 nexits",
                    "c7_n2 : node",
                    "c7_nexits : list node",
                    "c7_a2 : exitexpr",
                    "c7_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c15_goal : tr_exitexpr (st_code s2) map a3 n3 nexits",
                    "c7_IHtr_exitexpr2 : tr_exitexpr (st_code s2) map a3 n3 nexits",
                    "c7_n3 : node",
                    "c7_nexits : list node",
                    "c7_a3 : exitexpr",
                    "c7_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c8_goal : tr_exitexpr (st_code s2) map (XElet a b) ns nexits"
                ],
                "tactic_res": [
                    "c16_goal : not (reg_in_map map ?r)",
                    "c17_goal : tr_expr (st_code s2) map nil a ns ?n1 r None",
                    "c18_goal : tr_exitexpr (st_code s2) (add_letvar map r) b n1 nexits"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c16_goal : not (reg_in_map map ?r)",
                    "c8_H : not (reg_in_map map r)",
                    "c8_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c17_goal : tr_expr (st_code s2) map nil a ns ?n1 r None",
                    "c8_H0 : tr_expr (st_code s1) map nil a ns n1 r None",
                    "c8_r : reg",
                    "c8_ns : node",
                    "c8_a : expr",
                    "c8_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_EXT : state_incr s1 s2",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c18_goal : tr_exitexpr (st_code s2) (add_letvar map r) b n1 nexits",
                    "c8_IHtr_exitexpr : tr_exitexpr (st_code s2) (add_letvar map r) b n1 nexits",
                    "c8_n1 : node",
                    "c8_r : reg",
                    "c8_nexits : list node",
                    "c8_b : exitexpr",
                    "c8_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "tr_stmt_incr",
        "proof": [
            {
                "tactic_sig": "Lemma tr_stmt_incr : forall s1 s2 , state_incr s1 s2 -> forall map s ns nd nexits ngoto nret rret , tr_stmt s1. ( st_code ) map s ns nd nexits ngoto nret rret -> tr_stmt s2. ( st_code ) map s ns nd nexits ngoto nret rret .",
                "tactic_sig_no_out_arg": "Lemma tr_stmt_incr : forall s1 s2 , state_incr s1 s2 -> forall map s ns nd nexits ngoto nret rret , tr_stmt s1. ( st_code ) map s ns nd nexits ngoto nret rret -> tr_stmt s2. ( st_code ) map s ns nd nexits ngoto nret rret .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (s : stmt) (ns nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros s1 s2 EXT .",
                "tactic_args": [
                    "c1_goal : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (s : stmt) (ns nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c2_goal : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_EXT : state_incr s1 s2"
                ]
            },
            {
                "tactic_sig": "generalize tr_expr_incr tr_condition_incr tr_exprlist_incr tr_exitexpr_incr .",
                "tactic_sig_no_out_arg": "generalize tr_expr_incr tr_condition_incr tr_exprlist_incr tr_exitexpr_incr .",
                "tactic_args": [
                    "c2_goal : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (al : exprlist) \n         (ns nd : node) (rl : list reg)\n         (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\n       tr_exprlist (st_code s2) map pr al ns nd rl)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (a : exitexpr) (ns : node)\n         (nexits : list node)\n         (_ : tr_exitexpr (st_code s1) map a ns nexits),\n       tr_exitexpr (st_code s2) map a ns nexits) (map : mapping)\n  (s : stmt) (ns nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros I1 I2 I3 I4 .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : condexpr)\n         (ns ntrue nfalse : node)\n         (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\n       tr_condition (st_code s2) map pr a ns ntrue nfalse)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (al : exprlist) \n         (ns nd : node) (rl : list reg)\n         (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\n       tr_exprlist (st_code s2) map pr al ns nd rl)\n  (_ : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (a : exitexpr) (ns : node)\n         (nexits : list node)\n         (_ : tr_exitexpr (st_code s1) map a ns nexits),\n       tr_exitexpr (st_code s2) map a ns nexits) (map : mapping)\n  (s : stmt) (ns nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c4_goal : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c4_I2 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c4_I4 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits"
                ]
            },
            {
                "tactic_sig": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_sig_no_out_arg": "pose ( AT := fun pc i => instr_at_incr _i _i pc i _i ) .",
                "tactic_args": [
                    "c2_s1 : state",
                    "c2_s2 : state",
                    "c2_EXT : state_incr s1 s2"
                ],
                "tactic_res": [
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg)\n  (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c5_goal : tr_stmt (st_code s2) map Sskip ns ns nexits ngoto nret rret",
                    "c5_rret : option reg",
                    "c5_nret : node",
                    "c5_ngoto : labelmap",
                    "c5_nexits : list node",
                    "c5_ns : node",
                    "c5_map : mapping",
                    "c6_goal : tr_stmt (st_code s2) map (Sassign id a) ns nd nexits ngoto nret rret",
                    "c6_H0 : tr_expr (st_code s1) map nil a ns nd r (Some id)",
                    "c6_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c6_r : reg",
                    "c6_rret : option reg",
                    "c6_nret : node",
                    "c6_ngoto : labelmap",
                    "c6_nexits : list node",
                    "c6_nd : node",
                    "c6_ns : node",
                    "c6_a : expr",
                    "c6_id : positive",
                    "c6_map : mapping",
                    "c7_goal : tr_stmt (st_code s2) map (Sstore chunk addr al b) ns nd nexits ngoto\n  nret rret",
                    "c7_H1 : eq (PTree.get n2 (st_code s1)) (Some (Istore chunk addr rl rd nd))",
                    "c7_H0 : tr_expr (st_code s1) map rl b n1 n2 rd None",
                    "c7_H : tr_exprlist (st_code s1) map nil al ns n1 rl",
                    "c7_n2 : node",
                    "c7_rl : list reg",
                    "c7_n1 : node",
                    "c7_rd : reg",
                    "c7_rret : option reg",
                    "c7_nret : node",
                    "c7_ngoto : labelmap",
                    "c7_nexits : list node",
                    "c7_nd : node",
                    "c7_ns : node",
                    "c7_b : expr",
                    "c7_al : exprlist",
                    "c7_addr : addressing",
                    "c7_chunk : memory_chunk",
                    "c7_map : mapping",
                    "c8_goal : tr_stmt (st_code s2) map (Scall optid sig (inl b) cl) ns nd nexits\n  ngoto nret rret",
                    "c8_H2 : reg_map_ok map rd optid",
                    "c8_H1 : eq (PTree.get n2 (st_code s1)) (Some (Icall sig (inl rf) rargs rd nd))",
                    "c8_H0 : tr_exprlist (st_code s1) map (cons rf nil) cl n1 n2 rargs",
                    "c8_H : tr_expr (st_code s1) map nil b ns n1 rf None",
                    "c8_rargs : list reg",
                    "c8_n2 : node",
                    "c8_rf : reg",
                    "c8_n1 : node",
                    "c8_rd : reg",
                    "c8_rret : option reg",
                    "c8_nret : node",
                    "c8_ngoto : labelmap",
                    "c8_nexits : list node",
                    "c8_nd : node",
                    "c8_ns : node",
                    "c8_cl : exprlist",
                    "c8_b : expr",
                    "c8_sig : signature",
                    "c8_optid : option ident",
                    "c8_map : mapping",
                    "c9_goal : tr_stmt (st_code s2) map (Scall optid sig (inr id) cl) ns nd nexits\n  ngoto nret rret",
                    "c9_H1 : reg_map_ok map rd optid",
                    "c9_H0 : eq (PTree.get n2 (st_code s1)) (Some (Icall sig (inr id) rargs rd nd))",
                    "c9_H : tr_exprlist (st_code s1) map nil cl ns n2 rargs",
                    "c9_rargs : list reg",
                    "c9_n2 : node",
                    "c9_rd : reg",
                    "c9_rret : option reg",
                    "c9_nret : node",
                    "c9_ngoto : labelmap",
                    "c9_nexits : list node",
                    "c9_nd : node",
                    "c9_ns : node",
                    "c9_cl : exprlist",
                    "c9_id : ident",
                    "c9_sig : signature",
                    "c9_optid : option ident",
                    "c9_map : mapping",
                    "c10_goal : tr_stmt (st_code s2) map (Stailcall sig (inl b) cl) ns nd nexits ngoto\n  nret rret",
                    "c10_H1 : eq (PTree.get n2 (st_code s1)) (Some (Itailcall sig (inl rf) rargs))",
                    "c10_H0 : tr_exprlist (st_code s1) map (cons rf nil) cl n1 n2 rargs",
                    "c10_H : tr_expr (st_code s1) map nil b ns n1 rf None",
                    "c10_rargs : list reg",
                    "c10_n2 : node",
                    "c10_rf : reg",
                    "c10_n1 : node",
                    "c10_rret : option reg",
                    "c10_nret : node",
                    "c10_ngoto : labelmap",
                    "c10_nexits : list node",
                    "c10_nd : node",
                    "c10_ns : node",
                    "c10_cl : exprlist",
                    "c10_b : expr",
                    "c10_sig : signature",
                    "c10_map : mapping",
                    "c11_goal : tr_stmt (st_code s2) map (Stailcall sig (inr id) cl) ns nd nexits ngoto\n  nret rret",
                    "c11_H0 : eq (PTree.get n2 (st_code s1)) (Some (Itailcall sig (inr id) rargs))",
                    "c11_H : tr_exprlist (st_code s1) map nil cl ns n2 rargs",
                    "c11_rargs : list reg",
                    "c11_n2 : node",
                    "c11_rret : option reg",
                    "c11_nret : node",
                    "c11_ngoto : labelmap",
                    "c11_nexits : list node",
                    "c11_nd : node",
                    "c11_ns : node",
                    "c11_cl : exprlist",
                    "c11_id : ident",
                    "c11_sig : signature",
                    "c11_map : mapping",
                    "c12_goal : tr_stmt (st_code s2) map (Sbuiltin res ef args) ns nd nexits ngoto nret\n  rret",
                    "c12_H1 : tr_builtin_res map res res'",
                    "c12_H0 : eq (PTree.get n1 (st_code s1))\n  (Some (Ibuiltin ef (convert_builtin_args args rargs) res' nd))",
                    "c12_H : tr_exprlist (st_code s1) map nil\n  (exprlist_of_expr_list (params_of_builtin_args args)) ns n1 rargs",
                    "c12_rargs : list reg",
                    "c12_n1 : node",
                    "c12_res' : builtin_res reg",
                    "c12_rret : option reg",
                    "c12_nret : node",
                    "c12_ngoto : labelmap",
                    "c12_nexits : list node",
                    "c12_nd : node",
                    "c12_ns : node",
                    "c12_args : list (builtin_arg expr)",
                    "c12_ef : external_function",
                    "c12_res : builtin_res ident",
                    "c12_map : mapping",
                    "c13_goal : tr_stmt (st_code s2) map (Sseq s0 s3) ns nd nexits ngoto nret rret",
                    "c13_IHtr_stmt2 : tr_stmt (st_code s2) map s0 ns n nexits ngoto nret rret",
                    "c13_IHtr_stmt1 : tr_stmt (st_code s2) map s3 n nd nexits ngoto nret rret",
                    "c13_H0 : tr_stmt (st_code s1) map s0 ns n nexits ngoto nret rret",
                    "c13_H : tr_stmt (st_code s1) map s3 n nd nexits ngoto nret rret",
                    "c13_n : node",
                    "c13_rret : option reg",
                    "c13_nret : node",
                    "c13_ngoto : labelmap",
                    "c13_nexits : list node",
                    "c13_nd : node",
                    "c13_ns : node",
                    "c13_s3 : stmt",
                    "c13_s0 : stmt",
                    "c13_map : mapping",
                    "c14_goal : tr_stmt (st_code s2) map (Sifthenelse a strue sfalse) ns nd nexits\n  ngoto nret rret",
                    "c14_IHtr_stmt2 : tr_stmt (st_code s2) map sfalse nfalse nd nexits ngoto nret rret",
                    "c14_IHtr_stmt1 : tr_stmt (st_code s2) map strue ntrue nd nexits ngoto nret rret",
                    "c14_H1 : tr_condition (st_code s1) map nil a ns ntrue nfalse",
                    "c14_H0 : tr_stmt (st_code s1) map sfalse nfalse nd nexits ngoto nret rret",
                    "c14_H : tr_stmt (st_code s1) map strue ntrue nd nexits ngoto nret rret",
                    "c14_nfalse : node",
                    "c14_ntrue : node",
                    "c14_rret : option reg",
                    "c14_nret : node",
                    "c14_ngoto : labelmap",
                    "c14_nexits : list node",
                    "c14_nd : node",
                    "c14_ns : node",
                    "c14_sfalse : stmt",
                    "c14_strue : stmt",
                    "c14_a : condexpr",
                    "c14_map : mapping",
                    "c15_goal : tr_stmt (st_code s2) map (Sloop sbody) ns nd nexits ngoto nret rret",
                    "c15_IHtr_stmt : tr_stmt (st_code s2) map sbody nloop nend nexits ngoto nret rret",
                    "c15_H1 : eq (PTree.get nend (st_code s1)) (Some (Inop nloop))",
                    "c15_H0 : eq (PTree.get ns (st_code s1)) (Some (Inop nloop))",
                    "c15_H : tr_stmt (st_code s1) map sbody nloop nend nexits ngoto nret rret",
                    "c15_nend : node",
                    "c15_nloop : node",
                    "c15_rret : option reg",
                    "c15_nret : node",
                    "c15_ngoto : labelmap",
                    "c15_nexits : list node",
                    "c15_nd : node",
                    "c15_ns : positive",
                    "c15_sbody : stmt",
                    "c15_map : mapping",
                    "c16_goal : tr_stmt (st_code s2) map (Sblock sbody) ns nd nexits ngoto nret rret",
                    "c16_IHtr_stmt : tr_stmt (st_code s2) map sbody ns nd (cons nd nexits) ngoto nret rret",
                    "c16_H : tr_stmt (st_code s1) map sbody ns nd (cons nd nexits) ngoto nret rret",
                    "c16_rret : option reg",
                    "c16_nret : node",
                    "c16_ngoto : labelmap",
                    "c16_nexits : list node",
                    "c16_nd : node",
                    "c16_ns : node",
                    "c16_sbody : stmt",
                    "c16_map : mapping",
                    "c17_goal : tr_stmt (st_code s2) map (Sexit n) ns nd nexits ngoto nret rret",
                    "c17_H : eq (nth_error nexits n) (Some ns)",
                    "c17_rret : option reg",
                    "c17_nret : node",
                    "c17_ngoto : labelmap",
                    "c17_nexits : list node",
                    "c17_nd : node",
                    "c17_ns : node",
                    "c17_n : nat",
                    "c17_map : mapping",
                    "c18_goal : tr_stmt (st_code s2) map (Sswitch a) ns nd nexits ngoto nret rret",
                    "c18_H : tr_exitexpr (st_code s1) map a ns nexits",
                    "c18_rret : option reg",
                    "c18_nret : node",
                    "c18_ngoto : labelmap",
                    "c18_nexits : list node",
                    "c18_nd : node",
                    "c18_ns : node",
                    "c18_a : exitexpr",
                    "c18_map : mapping",
                    "c19_goal : tr_stmt (st_code s2) map (Sreturn None) nret nd nexits ngoto nret rret",
                    "c19_rret : option reg",
                    "c19_ngoto : labelmap",
                    "c19_nexits : list node",
                    "c19_nd : node",
                    "c19_nret : node",
                    "c19_map : mapping",
                    "c20_goal : tr_stmt (st_code s2) map (Sreturn (Some a)) ns nd nexits ngoto nret\n  (Some rret)",
                    "c20_H : tr_expr (st_code s1) map nil a ns nret rret None",
                    "c20_rret : reg",
                    "c20_nret : node",
                    "c20_ngoto : labelmap",
                    "c20_nexits : list node",
                    "c20_nd : node",
                    "c20_ns : node",
                    "c20_a : expr",
                    "c20_map : mapping",
                    "c21_goal : tr_stmt (st_code s2) map (Slabel lbl s) ns nd nexits ngoto nret rret",
                    "c21_IHtr_stmt : tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c21_H1 : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret",
                    "c21_H0 : eq (PTree.get n (st_code s1)) (Some (Inop ns))",
                    "c21_H : eq (PTree.get lbl ngoto) (Some n)",
                    "c21_n : positive",
                    "c21_rret : option reg",
                    "c21_nret : node",
                    "c21_ngoto : PTree.tree positive",
                    "c21_nexits : list node",
                    "c21_nd : node",
                    "c21_ns : node",
                    "c21_s : stmt",
                    "c21_lbl : positive",
                    "c21_map : mapping",
                    "c22_goal : tr_stmt (st_code s2) map (Sgoto lbl) ns nd nexits ngoto nret rret",
                    "c22_H : eq (PTree.get lbl ngoto) (Some ns)",
                    "c22_rret : option reg",
                    "c22_nret : node",
                    "c22_ngoto : PTree.tree node",
                    "c22_nexits : list node",
                    "c22_nd : node",
                    "c22_ns : node",
                    "c22_lbl : positive",
                    "c22_map : mapping"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c5_goal : tr_stmt (st_code s2) map Sskip ns ns nexits ngoto nret rret"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c6_goal : tr_stmt (st_code s2) map (Sassign id a) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c23_goal : eq (PTree.get id (map_vars map)) (Some ?r)",
                    "c24_goal : tr_expr (st_code s2) map nil a ns nd r (Some id)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : eq (PTree.get id (map_vars map)) (Some ?r)",
                    "c6_H : eq (PTree.get id (map_vars map)) (Some r)",
                    "c6_id : positive",
                    "c6_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : tr_expr (st_code s2) map nil a ns nd r (Some id)",
                    "c6_H0 : tr_expr (st_code s1) map nil a ns nd r (Some id)",
                    "c6_r : reg",
                    "c6_ns : node",
                    "c6_nd : node",
                    "c6_a : expr",
                    "c6_id : positive",
                    "c6_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c7_goal : tr_stmt (st_code s2) map (Sstore chunk addr al b) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c25_goal : tr_exprlist (st_code s2) map nil al ns ?n1 ?rl",
                    "c26_goal : tr_expr (st_code s2) map rl b n1 ?n2 ?rd None",
                    "c27_goal : eq (PTree.get n2 (st_code s2)) (Some (Istore chunk addr rl rd nd))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : tr_exprlist (st_code s2) map nil al ns ?n1 ?rl",
                    "c7_H : tr_exprlist (st_code s1) map nil al ns n1 rl",
                    "c7_ns : node",
                    "c7_al : exprlist",
                    "c7_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : tr_expr (st_code s2) map rl b n1 ?n2 ?rd None",
                    "c7_H0 : tr_expr (st_code s1) map rl b n1 n2 rd None",
                    "c7_rl : list reg",
                    "c7_n1 : node",
                    "c7_b : expr",
                    "c7_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : eq (PTree.get n2 (st_code s2)) (Some (Istore chunk addr rl rd nd))",
                    "c7_H1 : eq (PTree.get n2 (st_code s1)) (Some (Istore chunk addr rl rd nd))",
                    "c7_n2 : node",
                    "c7_rl : list reg",
                    "c7_rd : reg",
                    "c7_nd : node",
                    "c7_addr : addressing",
                    "c7_chunk : memory_chunk",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c8_goal : tr_stmt (st_code s2) map (Scall optid sig (inl b) cl) ns nd nexits\n  ngoto nret rret"
                ],
                "tactic_res": [
                    "c28_goal : tr_expr (st_code s2) map nil b ns ?n1 ?rf None",
                    "c29_goal : tr_exprlist (st_code s2) map (cons rf nil) cl n1 ?n2 ?rargs",
                    "c30_goal : eq (PTree.get n2 (st_code s2)) (Some (Icall sig (inl rf) rargs ?rd nd))",
                    "c31_goal : reg_map_ok map rd optid"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : tr_expr (st_code s2) map nil b ns ?n1 ?rf None",
                    "c8_H : tr_expr (st_code s1) map nil b ns n1 rf None",
                    "c8_ns : node",
                    "c8_b : expr",
                    "c8_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : tr_exprlist (st_code s2) map (cons rf nil) cl n1 ?n2 ?rargs",
                    "c8_H0 : tr_exprlist (st_code s1) map (cons rf nil) cl n1 n2 rargs",
                    "c8_rf : reg",
                    "c8_n1 : node",
                    "c8_cl : exprlist",
                    "c8_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c30_goal : eq (PTree.get n2 (st_code s2)) (Some (Icall sig (inl rf) rargs ?rd nd))",
                    "c8_H1 : eq (PTree.get n2 (st_code s1)) (Some (Icall sig (inl rf) rargs rd nd))",
                    "c8_rargs : list reg",
                    "c8_n2 : node",
                    "c8_rf : reg",
                    "c8_nd : node",
                    "c8_sig : signature",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : reg_map_ok map rd optid",
                    "c8_H2 : reg_map_ok map rd optid",
                    "c8_rd : reg",
                    "c8_optid : option ident",
                    "c8_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c9_goal : tr_stmt (st_code s2) map (Scall optid sig (inr id) cl) ns nd nexits\n  ngoto nret rret"
                ],
                "tactic_res": [
                    "c32_goal : tr_exprlist (st_code s2) map nil cl ns ?n2 ?rargs",
                    "c33_goal : eq (PTree.get n2 (st_code s2)) (Some (Icall sig (inr id) rargs ?rd nd))",
                    "c34_goal : reg_map_ok map rd optid"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c32_goal : tr_exprlist (st_code s2) map nil cl ns ?n2 ?rargs",
                    "c9_H : tr_exprlist (st_code s1) map nil cl ns n2 rargs",
                    "c9_ns : node",
                    "c9_cl : exprlist",
                    "c9_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : eq (PTree.get n2 (st_code s2)) (Some (Icall sig (inr id) rargs ?rd nd))",
                    "c9_H0 : eq (PTree.get n2 (st_code s1)) (Some (Icall sig (inr id) rargs rd nd))",
                    "c9_rargs : list reg",
                    "c9_n2 : node",
                    "c9_nd : node",
                    "c9_id : ident",
                    "c9_sig : signature",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c34_goal : reg_map_ok map rd optid",
                    "c9_H1 : reg_map_ok map rd optid",
                    "c9_rd : reg",
                    "c9_optid : option ident",
                    "c9_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c10_goal : tr_stmt (st_code s2) map (Stailcall sig (inl b) cl) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c35_goal : tr_expr (st_code s2) map nil b ns ?n1 ?rf None",
                    "c36_goal : tr_exprlist (st_code s2) map (cons rf nil) cl n1 ?n2 ?rargs",
                    "c37_goal : eq (PTree.get n2 (st_code s2)) (Some (Itailcall sig (inl rf) rargs))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c35_goal : tr_expr (st_code s2) map nil b ns ?n1 ?rf None",
                    "c10_H : tr_expr (st_code s1) map nil b ns n1 rf None",
                    "c10_ns : node",
                    "c10_b : expr",
                    "c10_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c36_goal : tr_exprlist (st_code s2) map (cons rf nil) cl n1 ?n2 ?rargs",
                    "c10_H0 : tr_exprlist (st_code s1) map (cons rf nil) cl n1 n2 rargs",
                    "c10_rf : reg",
                    "c10_n1 : node",
                    "c10_cl : exprlist",
                    "c10_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c37_goal : eq (PTree.get n2 (st_code s2)) (Some (Itailcall sig (inl rf) rargs))",
                    "c10_H1 : eq (PTree.get n2 (st_code s1)) (Some (Itailcall sig (inl rf) rargs))",
                    "c10_rargs : list reg",
                    "c10_n2 : node",
                    "c10_rf : reg",
                    "c10_sig : signature",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c11_goal : tr_stmt (st_code s2) map (Stailcall sig (inr id) cl) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c38_goal : tr_exprlist (st_code s2) map nil cl ns ?n2 ?rargs",
                    "c39_goal : eq (PTree.get n2 (st_code s2)) (Some (Itailcall sig (inr id) rargs))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c38_goal : tr_exprlist (st_code s2) map nil cl ns ?n2 ?rargs",
                    "c11_H : tr_exprlist (st_code s1) map nil cl ns n2 rargs",
                    "c11_ns : node",
                    "c11_cl : exprlist",
                    "c11_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c39_goal : eq (PTree.get n2 (st_code s2)) (Some (Itailcall sig (inr id) rargs))",
                    "c11_H0 : eq (PTree.get n2 (st_code s1)) (Some (Itailcall sig (inr id) rargs))",
                    "c11_rargs : list reg",
                    "c11_n2 : node",
                    "c11_id : ident",
                    "c11_sig : signature",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c12_goal : tr_stmt (st_code s2) map (Sbuiltin res ef args) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c40_goal : tr_exprlist (st_code s2) map nil\n  (exprlist_of_expr_list (params_of_builtin_args args)) ns \n  ?n1 ?rargs",
                    "c41_goal : eq (PTree.get n1 (st_code s2))\n  (Some (Ibuiltin ef (convert_builtin_args args rargs) ?res' nd))",
                    "c42_goal : tr_builtin_res map res res'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : tr_exprlist (st_code s2) map nil\n  (exprlist_of_expr_list (params_of_builtin_args args)) ns \n  ?n1 ?rargs",
                    "c12_H : tr_exprlist (st_code s1) map nil\n  (exprlist_of_expr_list (params_of_builtin_args args)) ns n1 rargs",
                    "c12_ns : node",
                    "c12_args : list (builtin_arg expr)",
                    "c12_map : mapping",
                    "c4_I3 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (al : exprlist) (ns nd : node) (rl : list reg)\n  (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\ntr_exprlist (st_code s2) map pr al ns nd rl",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c41_goal : eq (PTree.get n1 (st_code s2))\n  (Some (Ibuiltin ef (convert_builtin_args args rargs) ?res' nd))",
                    "c12_H0 : eq (PTree.get n1 (st_code s1))\n  (Some (Ibuiltin ef (convert_builtin_args args rargs) res' nd))",
                    "c12_rargs : list reg",
                    "c12_n1 : node",
                    "c12_nd : node",
                    "c12_args : list (builtin_arg expr)",
                    "c12_ef : external_function",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c42_goal : tr_builtin_res map res res'",
                    "c12_H1 : tr_builtin_res map res res'",
                    "c12_res' : builtin_res reg",
                    "c12_res : builtin_res ident",
                    "c12_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c13_goal : tr_stmt (st_code s2) map (Sseq s0 s3) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c43_goal : tr_stmt (st_code s2) map s3 ?n nd nexits ngoto nret rret",
                    "c44_goal : tr_stmt (st_code s2) map s0 ns n nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c43_goal : tr_stmt (st_code s2) map s3 ?n nd nexits ngoto nret rret",
                    "c13_IHtr_stmt1 : tr_stmt (st_code s2) map s3 n nd nexits ngoto nret rret",
                    "c13_rret : option reg",
                    "c13_nret : node",
                    "c13_ngoto : labelmap",
                    "c13_nexits : list node",
                    "c13_nd : node",
                    "c13_s3 : stmt",
                    "c13_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c44_goal : tr_stmt (st_code s2) map s0 ns n nexits ngoto nret rret",
                    "c13_IHtr_stmt2 : tr_stmt (st_code s2) map s0 ns n nexits ngoto nret rret",
                    "c13_n : node",
                    "c13_rret : option reg",
                    "c13_nret : node",
                    "c13_ngoto : labelmap",
                    "c13_nexits : list node",
                    "c13_ns : node",
                    "c13_s0 : stmt",
                    "c13_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c14_goal : tr_stmt (st_code s2) map (Sifthenelse a strue sfalse) ns nd nexits\n  ngoto nret rret"
                ],
                "tactic_res": [
                    "c45_goal : tr_stmt (st_code s2) map strue ?ntrue nd nexits ngoto nret rret",
                    "c46_goal : tr_stmt (st_code s2) map sfalse ?nfalse nd nexits ngoto nret rret",
                    "c47_goal : tr_condition (st_code s2) map nil a ns ntrue nfalse"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c45_goal : tr_stmt (st_code s2) map strue ?ntrue nd nexits ngoto nret rret",
                    "c14_IHtr_stmt1 : tr_stmt (st_code s2) map strue ntrue nd nexits ngoto nret rret",
                    "c14_rret : option reg",
                    "c14_nret : node",
                    "c14_ngoto : labelmap",
                    "c14_nexits : list node",
                    "c14_nd : node",
                    "c14_strue : stmt",
                    "c14_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c46_goal : tr_stmt (st_code s2) map sfalse ?nfalse nd nexits ngoto nret rret",
                    "c14_IHtr_stmt2 : tr_stmt (st_code s2) map sfalse nfalse nd nexits ngoto nret rret",
                    "c14_rret : option reg",
                    "c14_nret : node",
                    "c14_ngoto : labelmap",
                    "c14_nexits : list node",
                    "c14_nd : node",
                    "c14_sfalse : stmt",
                    "c14_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c47_goal : tr_condition (st_code s2) map nil a ns ntrue nfalse",
                    "c14_H1 : tr_condition (st_code s1) map nil a ns ntrue nfalse",
                    "c14_ntrue : node",
                    "c14_nfalse : node",
                    "c14_ns : node",
                    "c14_a : condexpr",
                    "c14_map : mapping",
                    "c4_I2 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : condexpr) (ns ntrue nfalse : node)\n  (_ : tr_condition (st_code s1) map pr a ns ntrue nfalse),\ntr_condition (st_code s2) map pr a ns ntrue nfalse",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c15_goal : tr_stmt (st_code s2) map (Sloop sbody) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c48_goal : tr_stmt (st_code s2) map sbody ?nloop ?nend nexits ngoto nret rret",
                    "c49_goal : eq (PTree.get ns (st_code s2)) (Some (Inop nloop))",
                    "c50_goal : eq (PTree.get nend (st_code s2)) (Some (Inop nloop))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c48_goal : tr_stmt (st_code s2) map sbody ?nloop ?nend nexits ngoto nret rret",
                    "c15_IHtr_stmt : tr_stmt (st_code s2) map sbody nloop nend nexits ngoto nret rret",
                    "c15_rret : option reg",
                    "c15_nret : node",
                    "c15_ngoto : labelmap",
                    "c15_nexits : list node",
                    "c15_sbody : stmt",
                    "c15_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c49_goal : eq (PTree.get ns (st_code s2)) (Some (Inop nloop))",
                    "c15_H0 : eq (PTree.get ns (st_code s1)) (Some (Inop nloop))",
                    "c15_nloop : node",
                    "c15_ns : positive",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c50_goal : eq (PTree.get nend (st_code s2)) (Some (Inop nloop))",
                    "c15_H1 : eq (PTree.get nend (st_code s1)) (Some (Inop nloop))",
                    "c15_nloop : node",
                    "c15_nend : node",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c16_goal : tr_stmt (st_code s2) map (Sblock sbody) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c51_goal : tr_stmt (st_code s2) map sbody ns nd (cons nd nexits) ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c51_goal : tr_stmt (st_code s2) map sbody ns nd (cons nd nexits) ngoto nret rret",
                    "c16_IHtr_stmt : tr_stmt (st_code s2) map sbody ns nd (cons nd nexits) ngoto nret rret",
                    "c16_rret : option reg",
                    "c16_nret : node",
                    "c16_ngoto : labelmap",
                    "c16_nexits : list node",
                    "c16_ns : node",
                    "c16_nd : node",
                    "c16_sbody : stmt",
                    "c16_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c17_goal : tr_stmt (st_code s2) map (Sexit n) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c52_goal : eq (nth_error nexits n) (Some ns)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c52_goal : eq (nth_error nexits n) (Some ns)",
                    "c17_H : eq (nth_error nexits n) (Some ns)",
                    "c17_nexits : list node",
                    "c17_ns : node",
                    "c17_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c18_goal : tr_stmt (st_code s2) map (Sswitch a) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c53_goal : tr_exitexpr (st_code s2) map a ns nexits"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c53_goal : tr_exitexpr (st_code s2) map a ns nexits",
                    "c18_H : tr_exitexpr (st_code s1) map a ns nexits",
                    "c18_nexits : list node",
                    "c18_ns : node",
                    "c18_a : exitexpr",
                    "c18_map : mapping",
                    "c4_I4 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (a : exitexpr) (ns : node) (nexits : list node)\n  (_ : tr_exitexpr (st_code s1) map a ns nexits),\ntr_exitexpr (st_code s2) map a ns nexits",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c19_goal : tr_stmt (st_code s2) map (Sreturn None) nret nd nexits ngoto nret rret"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c20_goal : tr_stmt (st_code s2) map (Sreturn (Some a)) ns nd nexits ngoto nret\n  (Some rret)"
                ],
                "tactic_res": [
                    "c54_goal : tr_expr (st_code s2) map nil a ns nret rret None"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c54_goal : tr_expr (st_code s2) map nil a ns nret rret None",
                    "c20_H : tr_expr (st_code s1) map nil a ns nret rret None",
                    "c20_rret : reg",
                    "c20_nret : node",
                    "c20_ns : node",
                    "c20_a : expr",
                    "c20_map : mapping",
                    "c4_I1 : forall (s1 s2 : state) (_ : state_incr s1 s2) (map : mapping)\n  (pr : list reg) (a : expr) (ns nd : node) (rd : reg)\n  (dst : option ident) (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\ntr_expr (st_code s2) map pr a ns nd rd dst",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c21_goal : tr_stmt (st_code s2) map (Slabel lbl s) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c55_goal : eq (PTree.get lbl ngoto) (Some ?n)",
                    "c56_goal : eq (PTree.get n (st_code s2)) (Some (Inop ns))",
                    "c57_goal : tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c55_goal : eq (PTree.get lbl ngoto) (Some ?n)",
                    "c21_H : eq (PTree.get lbl ngoto) (Some n)",
                    "c21_ngoto : PTree.tree positive",
                    "c21_lbl : positive"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c56_goal : eq (PTree.get n (st_code s2)) (Some (Inop ns))",
                    "c21_H0 : eq (PTree.get n (st_code s1)) (Some (Inop ns))",
                    "c21_n : positive",
                    "c21_ns : node",
                    "c4_AT : forall (pc : positive) (i : instruction)\n  (_ : eq (PTree.get pc (st_code s1)) (Some i)),\neq (PTree.get pc (st_code s2)) (Some i)",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c57_goal : tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c21_IHtr_stmt : tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c21_rret : option reg",
                    "c21_nret : node",
                    "c21_ngoto : PTree.tree positive",
                    "c21_nexits : list node",
                    "c21_ns : node",
                    "c21_nd : node",
                    "c21_s : stmt",
                    "c21_map : mapping",
                    "c2_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c22_goal : tr_stmt (st_code s2) map (Sgoto lbl) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c58_goal : eq (PTree.get lbl ngoto) (Some ns)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c58_goal : eq (PTree.get lbl ngoto) (Some ns)",
                    "c22_H : eq (PTree.get lbl ngoto) (Some ns)",
                    "c22_ngoto : PTree.tree node",
                    "c22_ns : node",
                    "c22_lbl : positive"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_exit_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_exit_charact : forall nexits n s ne s' incr , transl_exit nexits n s = OK ne s' incr -> nth_error nexits n = Some ne /\\ s' = s .",
                "tactic_sig_no_out_arg": "Lemma transl_exit_charact : forall nexits n s ne s' incr , transl_exit nexits n s = OK ne s' incr -> nth_error nexits n = Some ne /\\ s' = s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nexits : list node) (n : nat) (s : state) \n  (ne : node) (s' : state) (incr : state_incr s s')\n  (_ : eq (transl_exit nexits n s) (OK ne s' incr)),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until incr .",
                "tactic_args": [
                    "c1_goal : forall (nexits : list node) (n : nat) (s : state) \n  (ne : node) (s' : state) (incr : state_incr s s')\n  (_ : eq (transl_exit nexits n s) (OK ne s' incr)),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (transl_exit nexits n s) (OK ne s' incr),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)",
                    "c2_incr : state_incr s s'",
                    "c2_s' : state",
                    "c2_ne : node",
                    "c2_s : state",
                    "c2_n : nat",
                    "c2_nexits : list node"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (transl_exit nexits n s) (OK ne s' incr),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)",
                    "_global_transl_exit : forall (_ : list node) (_ : nat), mon node"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : eq\n        (match nth_error nexits n with\n         | Some ne => ret ne\n         | None => error (Errors.msg \"RTLgen: wrong exit\")\n         end s) (OK ne s' incr),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "destruct ( nth_error _i _i ) as [  _o | ] .",
                "tactic_sig_no_out_arg": "destruct ( nth_error _i _i ) .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : eq\n        (match nth_error nexits n with\n         | Some ne => ret ne\n         | None => error (Errors.msg \"RTLgen: wrong exit\")\n         end s) (OK ne s' incr),\nand (eq (nth_error nexits n) (Some ne)) (eq s' s)",
                    "c2_nexits : list node",
                    "c2_n : nat",
                    "c2_incr : state_incr s s'",
                    "c2_s' : state",
                    "c2_ne : node",
                    "c2_s : state"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq (ret n0 s) (OK ne s' incr),\nand (eq (Some n0) (Some ne)) (eq s' s)",
                    "c4_n0 : node",
                    "c5_goal : forall\n  _ : eq (error (Errors.msg \"RTLgen: wrong exit\") s) (OK ne s' incr),\nand (eq None (Some ne)) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (ret n0 s) (OK ne s' incr),\nand (eq (Some n0) (Some ne)) (eq s' s)"
                ],
                "tactic_res": [
                    "c6_goal : and (eq (Some n0) (Some ne)) (eq s' s)",
                    "c6_H : eq (ret n0 s) (OK ne s' incr)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : and (eq (Some n0) (Some ne)) (eq s' s)",
                    "c6_H : eq (ret n0 s) (OK ne s' incr)"
                ],
                "tactic_res": [
                    "c7_goal : and (eq (Some ne) (Some ne)) (eq s' s')",
                    "c7_incr : state_incr s' s'"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : eq (error (Errors.msg \"RTLgen: wrong exit\") s) (OK ne s' incr),\nand (eq None (Some ne)) (eq s' s)"
                ],
                "tactic_res": [
                    "c8_goal : and (eq None (Some ne)) (eq s' s)",
                    "c8_H : eq (error (Errors.msg \"RTLgen: wrong exit\") s) (OK ne s' incr)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c8_goal : and (eq None (Some ne)) (eq s' s)",
                    "c8_H : eq (error (Errors.msg \"RTLgen: wrong exit\") s) (OK ne s' incr)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : and (eq (Some ne) (Some ne)) (eq s' s')",
                    "c2_s' : state",
                    "c2_ne : node"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_jumptable_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_jumptable_charact : forall nexits tbl s nl s' incr , transl_jumptable nexits tbl s = OK nl s' incr -> tr_jumptable nexits tbl nl /\\ s' = s .",
                "tactic_sig_no_out_arg": "Lemma transl_jumptable_charact : forall nexits tbl s nl s' incr , transl_jumptable nexits tbl s = OK nl s' incr -> tr_jumptable nexits tbl nl /\\ s' = s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nexits : list node) (tbl : list nat) (s : state)\n  (nl : list node) (s' : state) (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros nexits tbl .",
                "tactic_args": [
                    "c1_goal : forall (nexits : list node) (tbl : list nat) (s : state)\n  (nl : list node) (s' : state) (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)",
                    "c2_nexits : list node",
                    "c2_tbl : list nat"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)",
                    "c2_tbl : list nat"
                ],
                "tactic_res": [
                    "c3_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits nil s) (OK nl s' incr)),\nand (tr_jumptable nexits nil nl) (eq s' s)",
                    "c4_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits (cons a tbl) s) (OK nl s' incr)),\nand (tr_jumptable nexits (cons a tbl) nl) (eq s' s)",
                    "c4_IHtbl : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)",
                    "c4_a : nat"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits nil s) (OK nl s' incr)),\nand (tr_jumptable nexits nil nl) (eq s' s)"
                ],
                "tactic_res": [
                    "c5_goal : and (tr_jumptable nexits nil nl) (eq s' s)",
                    "c5_s : state",
                    "c5_nl : list node",
                    "c5_s' : state",
                    "c5_incr : state_incr s s'",
                    "c5_H : eq (transl_jumptable nexits nil s) (OK nl s' incr)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits (cons a tbl) s) (OK nl s' incr)),\nand (tr_jumptable nexits (cons a tbl) nl) (eq s' s)"
                ],
                "tactic_res": [
                    "c6_goal : and (tr_jumptable nexits (cons a tbl) nl) (eq s' s)",
                    "c6_s : state",
                    "c6_nl : list node",
                    "c6_s' : state",
                    "c6_incr : state_incr s s'",
                    "c6_H : eq (transl_jumptable nexits (cons a tbl) s) (OK nl s' incr)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c5_goal : and (tr_jumptable nexits nil nl) (eq s' s)",
                    "c5_H : eq (transl_jumptable nexits nil s) (OK nl s' incr)"
                ],
                "tactic_res": [
                    "c7_goal : and (tr_jumptable nexits nil nil) (eq s' s')",
                    "c7_incr : state_incr s' s'"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (tr_jumptable nexits nil nil) (eq s' s')"
                ],
                "tactic_res": [
                    "c8_goal : tr_jumptable nexits nil nil",
                    "c9_goal : eq s' s'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c8_goal : tr_jumptable nexits nil nil"
                ],
                "tactic_res": [
                    "c10_goal : forall (v : Z) (act : nat) (_ : eq (list_nth_z nil v) (Some act)),\nex\n  (fun n : node =>\n   and (eq (list_nth_z nil v) (Some n))\n     (eq (nth_error nexits act) (Some n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall (v : Z) (act : nat) (_ : eq (list_nth_z nil v) (Some act)),\nex\n  (fun n : node =>\n   and (eq (list_nth_z nil v) (Some n))\n     (eq (nth_error nexits act) (Some n)))"
                ],
                "tactic_res": [
                    "c11_goal : forall (_ : Z) (act : nat) (_ : eq None (Some act)),\nex\n  (fun n : node =>\n   and (eq None (Some n)) (eq (nth_error nexits act) (Some n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (_ : Z) (act : nat) (_ : eq None (Some act)),\nex\n  (fun n : node =>\n   and (eq None (Some n)) (eq (nth_error nexits act) (Some n)))"
                ],
                "tactic_res": [
                    "c12_goal : ex\n  (fun n : node =>\n   and (eq None (Some n)) (eq (nth_error nexits act) (Some n)))",
                    "c12_v : Z",
                    "c12_act : nat",
                    "c12_H : eq None (Some act)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun n : node =>\n   and (eq None (Some n)) (eq (nth_error nexits act) (Some n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq s' s'",
                    "c5_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_goal : and (tr_jumptable nexits (cons a tbl) nl) (eq s' s)",
                    "c6_H : eq (transl_jumptable nexits (cons a tbl) s) (OK nl s' incr)"
                ],
                "tactic_res": [
                    "c13_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)",
                    "c13_INCR2 : state_incr s' s'",
                    "c13_EQ1 : eq (transl_jumptable nexits tbl s0) (OK x0 s' INCR1)",
                    "c13_INCR1 : state_incr s0 s'",
                    "c13_x0 : list node",
                    "c13_EQ : eq (transl_exit nexits a s) (OK x s0 INCR)",
                    "c13_INCR0 : state_incr s0 s'",
                    "c13_INCR : state_incr s s0",
                    "c13_s0 : state",
                    "c13_x : node"
                ]
            },
            {
                "tactic_sig": "exploit transl_exit_charact .",
                "tactic_sig_no_out_arg": "exploit transl_exit_charact .",
                "tactic_args": [
                    "c13_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ],
                "tactic_res": [
                    "c14_goal : eq (transl_exit ?Goal ?Goal0 ?Goal1) (OK ?Goal2 ?Goal3 ?Goal4)",
                    "c15_goal : forall\n  _ : and (eq (nth_error ?Goal ?Goal0) (Some ?Goal2))\n        (eq ?Goal3 ?Goal1),\nand (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq (transl_exit ?Goal ?Goal0 ?Goal1) (OK ?Goal2 ?Goal3 ?Goal4)",
                    "c13_EQ : eq (transl_exit nexits a s) (OK x s0 INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c15_goal : forall _ : and (eq (nth_error nexits a) (Some x)) (eq s0 s),\nand (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ],
                "tactic_res": [
                    "c16_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)",
                    "c16_A : eq (nth_error nexits a) (Some x)",
                    "c16_B : eq s0 s"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c16_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)",
                    "c4_IHtbl : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)"
                ],
                "tactic_res": [
                    "c17_goal : eq (transl_jumptable nexits tbl ?Goal) (OK ?Goal0 ?Goal1 ?Goal2)",
                    "c18_goal : forall _ : and (tr_jumptable nexits tbl x0) (eq s' s0),\nand (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : eq (transl_jumptable nexits tbl ?Goal) (OK ?Goal0 ?Goal1 ?Goal2)",
                    "c13_EQ1 : eq (transl_jumptable nexits tbl s0) (OK x0 s' INCR1)",
                    "c2_tbl : list nat",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ C D ] .",
                "tactic_args": [
                    "c18_goal : forall _ : and (tr_jumptable nexits tbl x0) (eq s' s0),\nand (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ],
                "tactic_res": [
                    "c19_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)",
                    "c19_C : tr_jumptable nexits tbl x0",
                    "c19_D : eq s' s0"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c19_goal : and (tr_jumptable nexits (cons a tbl) (cons x x0)) (eq s' s)"
                ],
                "tactic_res": [
                    "c20_goal : tr_jumptable nexits (cons a tbl) (cons x x0)",
                    "c21_goal : eq s' s"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c20_goal : tr_jumptable nexits (cons a tbl) (cons x x0)"
                ],
                "tactic_res": [
                    "c22_goal : forall (v : Z) (act : nat)\n  (_ : eq (list_nth_z (cons a tbl) v) (Some act)),\nex\n  (fun n : node =>\n   and (eq (list_nth_z (cons x x0) v) (Some n))\n     (eq (nth_error nexits act) (Some n)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : forall (v : Z) (act : nat)\n  (_ : eq (list_nth_z (cons a tbl) v) (Some act)),\nex\n  (fun n : node =>\n   and (eq (list_nth_z (cons x x0) v) (Some n))\n     (eq (nth_error nexits act) (Some n)))"
                ],
                "tactic_res": [
                    "c23_goal : forall (v : Z) (act : nat)\n  (_ : eq (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v))\n         (Some act)),\nex\n  (fun n : node =>\n   and\n     (eq (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v))\n        (Some n)) (eq (nth_error nexits act) (Some n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall (v : Z) (act : nat)\n  (_ : eq (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v))\n         (Some act)),\nex\n  (fun n : node =>\n   and\n     (eq (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v))\n        (Some n)) (eq (nth_error nexits act) (Some n)))"
                ],
                "tactic_res": [
                    "c24_goal : ex\n  (fun n : node =>\n   and\n     (eq (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v))\n        (Some n)) (eq (nth_error nexits act) (Some n)))",
                    "c24_v : Z",
                    "c24_act : nat",
                    "c24_H : eq (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) (Some act)"
                ]
            },
            {
                "tactic_sig": "destruct ( zeq _i 0 ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zeq _i 0 ) .",
                "tactic_args": [
                    "c24_goal : ex\n  (fun n : node =>\n   and\n     (eq (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v))\n        (Some n)) (eq (nth_error nexits act) (Some n)))",
                    "c24_v : Z",
                    "c24_H : eq (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) (Some act)",
                    "c24_act : nat",
                    "c19_D : eq s' s0",
                    "c19_C : tr_jumptable nexits tbl x0",
                    "c16_B : eq s0 s",
                    "c16_A : eq (nth_error nexits a) (Some x)",
                    "c13_INCR2 : state_incr s' s'",
                    "c13_EQ1 : eq (transl_jumptable nexits tbl s0) (OK x0 s' INCR1)",
                    "c13_x0 : list node",
                    "c13_EQ : eq (transl_exit nexits a s) (OK x s0 INCR)",
                    "c13_INCR0 : state_incr s0 s'",
                    "c13_x : node",
                    "c6_incr : state_incr s s'",
                    "c4_IHtbl : forall (s : state) (nl : list node) (s' : state)\n  (incr : state_incr s s')\n  (_ : eq (transl_jumptable nexits tbl s) (OK nl s' incr)),\nand (tr_jumptable nexits tbl nl) (eq s' s)",
                    "c2_nexits : list node"
                ],
                "tactic_res": [
                    "c25_goal : ex\n  (fun n : node =>\n   and (eq (Some x) (Some n)) (eq (nth_error nexits act) (Some n)))",
                    "c25_H : eq (Some a) (Some act)",
                    "c25_e : eq v 0",
                    "c26_goal : ex\n  (fun n : node =>\n   and (eq (list_nth_z x0 (Z.pred v)) (Some n))\n     (eq (nth_error nexits act) (Some n)))",
                    "c26_H : eq (list_nth_z tbl (Z.pred v)) (Some act)",
                    "c26_n : not (eq v 0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c25_H : eq (Some a) (Some act)"
                ],
                "tactic_res": [
                    "c25_A : eq (nth_error nexits act) (Some x)",
                    "c25_EQ1 : eq (transl_jumptable nexits tbl s) (OK x0 s INCR1)",
                    "c25_INCR1 : state_incr s s",
                    "c25_INCR2 : state_incr s s",
                    "c25_INCR0 : state_incr s s",
                    "c25_EQ : eq (transl_exit nexits act s) (OK x s INCR)",
                    "c25_INCR : state_incr s s",
                    "c25_incr : state_incr s s"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun n : node =>\n   and (eq (Some x) (Some n)) (eq (nth_error nexits act) (Some n)))",
                    "c13_x : node"
                ],
                "tactic_res": [
                    "c27_goal : and (eq (Some x) (Some x)) (eq (nth_error nexits act) (Some x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : and (eq (Some x) (Some x)) (eq (nth_error nexits act) (Some x))",
                    "c25_A : eq (nth_error nexits act) (Some x)",
                    "c24_act : nat",
                    "c13_x : node",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : ex\n  (fun n : node =>\n   and (eq (list_nth_z x0 (Z.pred v)) (Some n))\n     (eq (nth_error nexits act) (Some n)))",
                    "c26_H : eq (list_nth_z tbl (Z.pred v)) (Some act)",
                    "c24_act : nat",
                    "c24_v : Z",
                    "c19_C : tr_jumptable nexits tbl x0",
                    "c13_x0 : list node",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c21_goal : eq s' s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_exitexpr_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_exitexpr_charact : forall nexits a map s ns s' INCR ( TR : transl_exitexpr map a nexits s = OK ns s' INCR ) ( WF : map_valid map s ) , tr_exitexpr s'. ( st_code ) map a ns nexits .",
                "tactic_sig_no_out_arg": "Lemma transl_exitexpr_charact : forall nexits a map s ns s' INCR ( TR : transl_exitexpr map a nexits s = OK ns s' INCR ) ( WF : map_valid map s ) , tr_exitexpr s'. ( st_code ) map a ns nexits .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nexits : list node) (a : exitexpr) (map : mapping) \n  (s : state) (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros nexits a .",
                "tactic_args": [
                    "c1_goal : forall (nexits : list node) (a : exitexpr) (map : mapping) \n  (s : state) (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits"
                ],
                "tactic_res": [
                    "c2_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits",
                    "c2_nexits : list node",
                    "c2_a : exitexpr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits",
                    "c2_a : exitexpr"
                ],
                "tactic_res": [
                    "c3_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEexit n) nexits s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits",
                    "c3_n : nat",
                    "c4_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEjumptable e l) nexits s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits",
                    "c4_l : list nat",
                    "c4_e : expr",
                    "c5_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEcondition c a1 a2) nexits s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits",
                    "c5_IHa2 : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a2 nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a2 ns nexits",
                    "c5_IHa1 : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a1 nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a1 ns nexits",
                    "c5_a2 : exitexpr",
                    "c5_a1 : exitexpr",
                    "c5_c : condexpr",
                    "c6_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XElet e a) nexits s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XElet e a) ns nexits",
                    "c6_IHa : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits",
                    "c6_e : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEexit n) nexits s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ],
                "tactic_res": [
                    "c7_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exit nexits n s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exit nexits n s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ],
                "tactic_res": [
                    "c8_goal : tr_exitexpr (st_code s') map (XEexit n) ns nexits",
                    "c8_map : mapping",
                    "c8_s : state",
                    "c8_ns : node",
                    "c8_s' : state",
                    "c8_INCR : state_incr s s'",
                    "c8_TR : eq (transl_exit nexits n s) (OK ns s' INCR)",
                    "c8_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c8_TR : eq (transl_exit nexits n s) (OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEjumptable e l) nexits s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ],
                "tactic_res": [
                    "c9_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (transl_jumptable nexits l)\n               (fun tbl' : list node =>\n                bind (add_instr (Ijumptable r tbl'))\n                  (fun n1 : node => transl_expr map e r n1))) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind (alloc_reg map e)\n            (fun r : reg =>\n             bind (transl_jumptable nexits l)\n               (fun tbl' : list node =>\n                bind (add_instr (Ijumptable r tbl'))\n                  (fun n1 : node => transl_expr map e r n1))) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ],
                "tactic_res": [
                    "c10_goal : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits",
                    "c10_map : mapping",
                    "c10_s : state",
                    "c10_ns : node",
                    "c10_s' : state",
                    "c10_INCR : state_incr s s'",
                    "c10_TR : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (transl_jumptable nexits l)\n        (fun tbl' : list node =>\n         bind (add_instr (Ijumptable r tbl'))\n           (fun n1 : node => transl_expr map e r n1))) s)\n  (OK ns s' INCR)",
                    "c10_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c10_TR : eq\n  (bind (alloc_reg map e)\n     (fun r : reg =>\n      bind (transl_jumptable nexits l)\n        (fun tbl' : list node =>\n         bind (add_instr (Ijumptable r tbl'))\n           (fun n1 : node => transl_expr map e r n1))) s)\n  (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c10_EQ3 : eq (transl_expr map e x x1 s2) (OK ns s' INCR5)",
                    "c10_EQ0 : eq (add_instr (Ijumptable x x0) s1) (OK x1 s2 INCR4)",
                    "c10_INCR5 : state_incr s2 s'",
                    "c10_INCR4 : state_incr s1 s2",
                    "c10_s2 : state",
                    "c10_x1 : node",
                    "c10_EQ1 : eq (transl_jumptable nexits l s0) (OK x0 s1 INCR2)",
                    "c10_INCR3 : state_incr s1 s'",
                    "c10_INCR2 : state_incr s0 s1",
                    "c10_s1 : state",
                    "c10_x0 : list node",
                    "c10_EQ : eq (alloc_reg map e s) (OK x s0 INCR0)",
                    "c10_INCR1 : state_incr s0 s'",
                    "c10_INCR0 : state_incr s s0",
                    "c10_s0 : state",
                    "c10_x : reg"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XEcondition c a1 a2) nexits s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits"
                ],
                "tactic_res": [
                    "c11_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind (transl_exitexpr map a2 nexits)\n            (fun nc : node =>\n             bind (transl_exitexpr map a1 nexits)\n               (fun nb : node => transl_condexpr map c nb nc)) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind (transl_exitexpr map a2 nexits)\n            (fun nc : node =>\n             bind (transl_exitexpr map a1 nexits)\n               (fun nb : node => transl_condexpr map c nb nc)) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits"
                ],
                "tactic_res": [
                    "c12_goal : tr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits",
                    "c12_map : mapping",
                    "c12_s : state",
                    "c12_ns : node",
                    "c12_s' : state",
                    "c12_INCR : state_incr s s'",
                    "c12_TR : eq\n  (bind (transl_exitexpr map a2 nexits)\n     (fun nc : node =>\n      bind (transl_exitexpr map a1 nexits)\n        (fun nb : node => transl_condexpr map c nb nc)) s)\n  (OK ns s' INCR)",
                    "c12_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c12_TR : eq\n  (bind (transl_exitexpr map a2 nexits)\n     (fun nc : node =>\n      bind (transl_exitexpr map a1 nexits)\n        (fun nb : node => transl_condexpr map c nb nc)) s)\n  (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c12_EQ2 : eq (transl_condexpr map c x0 x s1) (OK ns s' INCR3)",
                    "c12_EQ1 : eq (transl_exitexpr map a1 nexits s0) (OK x0 s1 INCR2)",
                    "c12_INCR3 : state_incr s1 s'",
                    "c12_INCR2 : state_incr s0 s1",
                    "c12_s1 : state",
                    "c12_x0 : node",
                    "c12_EQ : eq (transl_exitexpr map a2 nexits s) (OK x s0 INCR0)",
                    "c12_INCR1 : state_incr s0 s'",
                    "c12_INCR0 : state_incr s s0",
                    "c12_s0 : state",
                    "c12_x : node"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map (XElet e a) nexits s) (OK ns s' INCR))\n  (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XElet e a) ns nexits"
                ],
                "tactic_res": [
                    "c13_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind new_reg\n            (fun r : reg =>\n             bind (transl_exitexpr (add_letvar map r) a nexits)\n               (fun n1 : node => transl_expr map e r n1)) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XElet e a) ns nexits"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         (bind new_reg\n            (fun r : reg =>\n             bind (transl_exitexpr (add_letvar map r) a nexits)\n               (fun n1 : node => transl_expr map e r n1)) s)\n         (OK ns s' INCR)) (_ : map_valid map s),\ntr_exitexpr (st_code s') map (XElet e a) ns nexits"
                ],
                "tactic_res": [
                    "c14_goal : tr_exitexpr (st_code s') map (XElet e a) ns nexits",
                    "c14_map : mapping",
                    "c14_s : state",
                    "c14_ns : node",
                    "c14_s' : state",
                    "c14_INCR : state_incr s s'",
                    "c14_TR : eq\n  (bind new_reg\n     (fun r : reg =>\n      bind (transl_exitexpr (add_letvar map r) a nexits)\n        (fun n1 : node => transl_expr map e r n1)) s) \n  (OK ns s' INCR)",
                    "c14_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c14_TR : eq\n  (bind new_reg\n     (fun r : reg =>\n      bind (transl_exitexpr (add_letvar map r) a nexits)\n        (fun n1 : node => transl_expr map e r n1)) s) \n  (OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c14_EQ2 : eq (transl_expr map e x x0 s1) (OK ns s' INCR3)",
                    "c14_EQ1 : eq (transl_exitexpr (add_letvar map x) a nexits s0) (OK x0 s1 INCR2)",
                    "c14_INCR3 : state_incr s1 s'",
                    "c14_INCR2 : state_incr s0 s1",
                    "c14_s1 : state",
                    "c14_x0 : node",
                    "c14_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c14_INCR1 : state_incr s0 s'",
                    "c14_INCR0 : state_incr s s0",
                    "c14_s0 : state",
                    "c14_x : reg"
                ]
            },
            {
                "tactic_sig": "exploit transl_exit_charact .",
                "tactic_sig_no_out_arg": "exploit transl_exit_charact .",
                "tactic_args": [
                    "c8_goal : tr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ],
                "tactic_res": [
                    "c15_goal : eq (transl_exit ?Goal2 ?Goal3 ?Goal4) (OK ?Goal5 ?Goal6 ?Goal7)",
                    "c16_goal : forall\n  _ : and (eq (nth_error ?Goal2 ?Goal3) (Some ?Goal5))\n        (eq ?Goal6 ?Goal4),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : eq (transl_exit ?Goal2 ?Goal3 ?Goal4) (OK ?Goal5 ?Goal6 ?Goal7)",
                    "c8_TR : eq (transl_exit nexits n s) (OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c16_goal : forall _ : and (eq (nth_error nexits n) (Some ns)) (eq s' s),\ntr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ],
                "tactic_res": [
                    "c17_goal : tr_exitexpr (st_code s') map (XEexit n) ns nexits",
                    "c17_A : eq (nth_error nexits n) (Some ns)",
                    "c17_B : eq s' s"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c17_goal : tr_exitexpr (st_code s') map (XEexit n) ns nexits"
                ],
                "tactic_res": [
                    "c18_goal : eq (nth_error nexits n) (Some ns)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : eq (nth_error nexits n) (Some ns)",
                    "c17_A : eq (nth_error nexits n) (Some ns)",
                    "c8_ns : node",
                    "c3_n : nat",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit transl_jumptable_charact .",
                "tactic_sig_no_out_arg": "exploit transl_jumptable_charact .",
                "tactic_args": [
                    "c10_goal : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ],
                "tactic_res": [
                    "c19_goal : eq (transl_jumptable ?Goal1 ?Goal2 ?Goal3) (OK ?Goal4 ?Goal5 ?Goal6)",
                    "c20_goal : forall _ : and (tr_jumptable nexits l x0) (eq s1 s0),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : eq (transl_jumptable ?Goal1 ?Goal2 ?Goal3) (OK ?Goal4 ?Goal5 ?Goal6)",
                    "c10_EQ1 : eq (transl_jumptable nexits l s0) (OK x0 s1 INCR2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c20_goal : forall _ : and (tr_jumptable nexits l x0) (eq s1 s0),\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ],
                "tactic_res": [
                    "c21_goal : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits",
                    "c21_A : tr_jumptable nexits l x0",
                    "c21_B : eq s1 s0"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c21_goal : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits"
                ],
                "tactic_res": [
                    "c22_goal : tr_jumptable nexits l ?tbl'",
                    "c23_goal : tr_expr (st_code s') map nil e ns ?n1 ?r None",
                    "c24_goal : eq (PTree.get x1 (st_code s')) (Some (Ijumptable x x0))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : tr_jumptable nexits l ?tbl'",
                    "c21_A : tr_jumptable nexits l x0",
                    "c4_l : list nat",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c23_goal : tr_expr (st_code s') map nil e ns ?n1 ?r None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c25_goal : eq (transl_expr map e ?r ?n1 ?s) (OK ns s' ?INCR)",
                    "c26_goal : map_valid map s2",
                    "c27_goal : target_reg_ok map nil e x",
                    "c28_goal : regs_valid nil s2",
                    "c29_goal : reg_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c25_goal : eq (transl_expr map e ?r ?n1 ?s) (OK ns s' ?INCR)",
                    "c10_EQ3 : eq (transl_expr map e x x1 s2) (OK ns s' INCR5)",
                    "c10_s' : state",
                    "c10_ns : node",
                    "c10_map : mapping",
                    "c4_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c26_goal : map_valid map s2",
                    "c10_s2 : state",
                    "c10_WF : map_valid map s",
                    "c10_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c27_goal : target_reg_ok map nil e x",
                    "c10_EQ : eq (alloc_reg map e s) (OK x s0 INCR0)",
                    "c10_x : reg",
                    "c10_WF : map_valid map s",
                    "c10_map : mapping",
                    "c4_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c28_goal : regs_valid nil s2",
                    "c10_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c29_goal : reg_valid x s2",
                    "c10_s2 : state",
                    "c10_EQ : eq (alloc_reg map e s) (OK x s0 INCR0)",
                    "c10_x : reg",
                    "c10_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c24_goal : eq (PTree.get x1 (st_code s')) (Some (Ijumptable x x0))",
                    "c10_EQ0 : eq (add_instr (Ijumptable x x0) s1) (OK x1 s2 INCR4)",
                    "c10_x1 : node",
                    "c10_x0 : list node",
                    "c10_x : reg",
                    "c10_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c12_goal : tr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits"
                ],
                "tactic_res": [
                    "c30_goal : tr_condition (st_code s') map nil c ns ?n2 ?n3",
                    "c31_goal : tr_exitexpr (st_code s') map a1 x0 nexits",
                    "c32_goal : tr_exitexpr (st_code s') map a2 x nexits"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c30_goal : tr_condition (st_code s') map nil c ns ?n2 ?n3",
                    "_global_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node)\n         (s : state) (ns : node) (s' : state) (pr : list reg)\n         (INCR : state_incr s s')\n         (_ : eq (transl_condexpr map a ntrue nfalse s) (OK ns s' INCR))\n         (_ : map_valid map s) (_ : regs_valid pr s),\n       tr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c33_goal : eq (transl_condexpr map c ?n2 ?n3 ?s) (OK ns s' ?INCR)",
                    "c34_goal : map_valid map s1",
                    "c35_goal : regs_valid nil s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c33_goal : eq (transl_condexpr map c ?n2 ?n3 ?s) (OK ns s' ?INCR)",
                    "c12_EQ2 : eq (transl_condexpr map c x0 x s1) (OK ns s' INCR3)",
                    "c12_s' : state",
                    "c12_ns : node",
                    "c12_map : mapping",
                    "c5_c : condexpr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c34_goal : map_valid map s1",
                    "c12_s1 : state",
                    "c12_WF : map_valid map s",
                    "c12_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c35_goal : regs_valid nil s1",
                    "c12_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c31_goal : tr_exitexpr (st_code s') map a1 x0 nexits",
                    "_global_tr_exitexpr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (a : exitexpr) (ns : node) \n         (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\n       tr_exitexpr (st_code s2) map a ns nexits",
                    "c12_s1 : state"
                ],
                "tactic_res": [
                    "c36_goal : state_incr s1 s'",
                    "c37_goal : tr_exitexpr (st_code s1) map a1 x0 nexits"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c36_goal : state_incr s1 s'",
                    "c12_s1 : state",
                    "c12_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c37_goal : tr_exitexpr (st_code s1) map a1 x0 nexits",
                    "c12_EQ1 : eq (transl_exitexpr map a1 nexits s0) (OK x0 s1 INCR2)",
                    "c12_s1 : state",
                    "c12_x0 : node",
                    "c12_WF : map_valid map s",
                    "c12_map : mapping",
                    "c5_IHa1 : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a1 nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a1 ns nexits",
                    "c5_a1 : exitexpr",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c32_goal : tr_exitexpr (st_code s') map a2 x nexits",
                    "_global_tr_exitexpr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (a : exitexpr) (ns : node) \n         (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\n       tr_exitexpr (st_code s2) map a ns nexits",
                    "c12_s0 : state"
                ],
                "tactic_res": [
                    "c38_goal : state_incr s0 s'",
                    "c39_goal : tr_exitexpr (st_code s0) map a2 x nexits"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c38_goal : state_incr s0 s'",
                    "c12_INCR1 : state_incr s0 s'",
                    "c12_s0 : state",
                    "c12_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c39_goal : tr_exitexpr (st_code s0) map a2 x nexits",
                    "c12_EQ : eq (transl_exitexpr map a2 nexits s) (OK x s0 INCR0)",
                    "c12_s0 : state",
                    "c12_x : node",
                    "c12_WF : map_valid map s",
                    "c12_map : mapping",
                    "c5_IHa2 : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a2 nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a2 ns nexits",
                    "c5_a2 : exitexpr",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c14_goal : tr_exitexpr (st_code s') map (XElet e a) ns nexits"
                ],
                "tactic_res": [
                    "c40_goal : not (reg_in_map map ?r)",
                    "c41_goal : tr_expr (st_code s') map nil e ns ?n1 x None",
                    "c42_goal : tr_exitexpr (st_code s') (add_letvar map x) a x0 nexits"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c40_goal : not (reg_in_map map ?r)",
                    "c14_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c41_goal : tr_expr (st_code s') map nil e ns ?n1 x None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c43_goal : eq (transl_expr map e x ?n1 ?s) (OK ns s' ?INCR)",
                    "c44_goal : map_valid map s1",
                    "c45_goal : target_reg_ok map nil e x",
                    "c46_goal : regs_valid nil s1",
                    "c47_goal : reg_valid x s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c43_goal : eq (transl_expr map e x ?n1 ?s) (OK ns s' ?INCR)",
                    "c14_EQ2 : eq (transl_expr map e x x0 s1) (OK ns s' INCR3)",
                    "c14_x : reg",
                    "c14_s' : state",
                    "c14_ns : node",
                    "c14_map : mapping",
                    "c6_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c44_goal : map_valid map s1",
                    "c14_s1 : state",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c45_goal : target_reg_ok map nil e x",
                    "c14_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c14_x : reg",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping",
                    "c6_e : expr"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c46_goal : regs_valid nil s1",
                    "c14_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c47_goal : reg_valid x s1",
                    "c14_s1 : state",
                    "c14_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c14_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c42_goal : tr_exitexpr (st_code s') (add_letvar map x) a x0 nexits",
                    "_global_tr_exitexpr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (a : exitexpr) (ns : node) \n         (nexits : list node) (_ : tr_exitexpr (st_code s1) map a ns nexits),\n       tr_exitexpr (st_code s2) map a ns nexits",
                    "c14_s1 : state"
                ],
                "tactic_res": [
                    "c48_goal : state_incr s1 s'",
                    "c49_goal : tr_exitexpr (st_code s1) (add_letvar map x) a x0 nexits"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : state_incr s1 s'",
                    "c14_s1 : state",
                    "c14_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c49_goal : tr_exitexpr (st_code s1) (add_letvar map x) a x0 nexits",
                    "c6_IHa : forall (map : mapping) (s : state) (ns : node) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (transl_exitexpr map a nexits s) (OK ns s' INCR))\n  (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits"
                ],
                "tactic_res": [
                    "c50_goal : eq (transl_exitexpr (add_letvar map x) a nexits ?s) (OK x0 s1 ?INCR)",
                    "c51_goal : map_valid (add_letvar map x) s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c50_goal : eq (transl_exitexpr (add_letvar map x) a nexits ?s) (OK x0 s1 ?INCR)",
                    "c14_EQ1 : eq (transl_exitexpr (add_letvar map x) a nexits s0) (OK x0 s1 INCR2)",
                    "c14_s1 : state",
                    "c14_x0 : node",
                    "c14_x : reg",
                    "c14_map : mapping",
                    "c2_a : exitexpr",
                    "c2_nexits : list node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c51_goal : map_valid (add_letvar map x) s0",
                    "_global_add_letvar_valid : forall (map : mapping) (s : state) (r : reg) \n         (_ : map_valid map s) (_ : reg_valid r s),\n       map_valid (add_letvar map r) s"
                ],
                "tactic_res": [
                    "c52_goal : map_valid map s0",
                    "c53_goal : reg_valid x s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c52_goal : map_valid map s0",
                    "c14_s0 : state",
                    "c14_WF : map_valid map s",
                    "c14_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c53_goal : reg_valid x s0",
                    "c14_EQ : eq (new_reg s) (OK x s0 INCR0)",
                    "c14_s0 : state",
                    "c14_x : reg"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "convert_builtin_res_charact",
        "proof": [
            {
                "tactic_sig": "Lemma convert_builtin_res_charact : forall map oty res s res' s' INCR ( TR : convert_builtin_res map oty res s = OK res' s' INCR ) ( WF : map_valid map s ) , tr_builtin_res map res res' .",
                "tactic_sig_no_out_arg": "Lemma convert_builtin_res_charact : forall map oty res s res' s' INCR ( TR : convert_builtin_res map oty res s = OK res' s' INCR ) ( WF : map_valid map s ) , tr_builtin_res map res res' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (oty : xtype) (res0 : builtin_res ident)\n  (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty res0 s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map res0 res'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros map oty res .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (oty : xtype) (res0 : builtin_res ident)\n  (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty res0 s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map res0 res'"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty res s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map res res'",
                    "c2_map : mapping",
                    "c2_oty : xtype",
                    "c2_res : builtin_res ident"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty res s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map res res'",
                    "c2_res : builtin_res ident",
                    "c2_oty : xtype",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c3_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty (BR x) s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map (BR x) res'",
                    "c3_x : ident",
                    "c4_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty BR_none s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map BR_none res'",
                    "c5_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty (BR_splitlong res1 res2) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR_splitlong res1 res2) res'",
                    "c5_res2 : builtin_res ident",
                    "c5_res1 : builtin_res ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty (BR x) s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map (BR x) res'"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (bind (find_var map x) (fun r : reg => ret (BR r)) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR x) res'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (bind (find_var map x) (fun r : reg => ret (BR r)) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR x) res'"
                ],
                "tactic_res": [
                    "c7_goal : tr_builtin_res map (BR x) res'",
                    "c7_s : state",
                    "c7_res' : builtin_res reg",
                    "c7_s' : state",
                    "c7_INCR : state_incr s s'",
                    "c7_TR : eq (bind (find_var map x) (fun r : reg => ret (BR r)) s)\n  (OK res' s' INCR)",
                    "c7_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty BR_none s) (OK res' s' INCR))\n  (_ : map_valid map s), tr_builtin_res map BR_none res'"
                ],
                "tactic_res": [
                    "c8_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         ((if xtype_eq oty Xvoid\n           then ret BR_none\n           else bind new_reg (fun r : reg => ret (BR r))) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map BR_none res'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq\n         ((if xtype_eq oty Xvoid\n           then ret BR_none\n           else bind new_reg (fun r : reg => ret (BR r))) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map BR_none res'"
                ],
                "tactic_res": [
                    "c9_goal : tr_builtin_res map BR_none res'",
                    "c9_s : state",
                    "c9_res' : builtin_res reg",
                    "c9_s' : state",
                    "c9_INCR : state_incr s s'",
                    "c9_TR : eq\n  ((if xtype_eq oty Xvoid\n    then ret BR_none\n    else bind new_reg (fun r : reg => ret (BR r))) s) \n  (OK res' s' INCR)",
                    "c9_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (convert_builtin_res map oty (BR_splitlong res1 res2) s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR_splitlong res1 res2) res'"
                ],
                "tactic_res": [
                    "c10_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (error (Errors.msg \"RTLgen: bad builtin_res\") s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR_splitlong res1 res2) res'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (s : state) (res' : builtin_res reg) (s' : state)\n  (INCR : state_incr s s')\n  (_ : eq (error (Errors.msg \"RTLgen: bad builtin_res\") s)\n         (OK res' s' INCR)) (_ : map_valid map s),\ntr_builtin_res map (BR_splitlong res1 res2) res'"
                ],
                "tactic_res": [
                    "c11_goal : tr_builtin_res map (BR_splitlong res1 res2) res'",
                    "c11_s : state",
                    "c11_res' : builtin_res reg",
                    "c11_s' : state",
                    "c11_INCR : state_incr s s'",
                    "c11_TR : eq (error (Errors.msg \"RTLgen: bad builtin_res\") s) (OK res' s' INCR)",
                    "c11_WF : map_valid map s"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c7_goal : tr_builtin_res map (BR x) res'",
                    "c7_TR : eq (bind (find_var map x) (fun r : reg => ret (BR r)) s)\n  (OK res' s' INCR)"
                ],
                "tactic_res": [
                    "c12_goal : tr_builtin_res map (BR x) (BR x0)",
                    "c12_INCR1 : state_incr s' s'",
                    "c12_EQ : eq (find_var map x s) (OK x0 s' INCR0)",
                    "c12_INCR0 : state_incr s s'",
                    "c12_x0 : reg"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : tr_builtin_res map (BR x) (BR x0)"
                ],
                "tactic_res": [
                    "c13_goal : eq (PTree.get x (map_vars map)) (Some x0)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg",
                    "c13_EQ : eq (find_var map x s) (OK x0 s' INCR0)"
                ],
                "tactic_res": [
                    "c13_EQ : eq\n  (match PTree.get x (map_vars map) with\n   | Some r => ret r\n   | None =>\n       error\n         (cons (Errors.MSG \"RTLgen: unbound variable \")\n            (cons (Errors.CTX x) nil))\n   end s) (OK x0 s' INCR0)"
                ]
            },
            {
                "tactic_sig": "destruct ( map_vars _i ) !x as [  _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( map_vars _i ) !x .",
                "tactic_args": [
                    "c13_goal : eq (PTree.get x (map_vars map)) (Some x0)",
                    "c2_map : mapping",
                    "c12_INCR1 : state_incr s' s'",
                    "c13_EQ : eq\n  (match PTree.get x (map_vars map) with\n   | Some r => ret r\n   | None =>\n       error\n         (cons (Errors.MSG \"RTLgen: unbound variable \")\n            (cons (Errors.CTX x) nil))\n   end s) (OK x0 s' INCR0)",
                    "c12_x0 : reg",
                    "c7_WF : map_valid map s",
                    "c7_INCR : state_incr s s'",
                    "c3_x : ident",
                    "c2_oty : xtype"
                ],
                "tactic_res": [
                    "c14_goal : eq (Some r) (Some x0)",
                    "c14_EQ : eq (ret r s) (OK x0 s' INCR0)",
                    "c14_r : reg",
                    "c15_goal : eq None (Some x0)",
                    "c15_EQ : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX x) nil)) s) (OK x0 s' INCR0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : eq (Some r) (Some x0)",
                    "c14_EQ : eq (ret r s) (OK x0 s' INCR0)"
                ],
                "tactic_res": [
                    "c16_goal : eq (Some x0) (Some x0)",
                    "c16_INCR0 : state_incr s' s'",
                    "c16_INCR : state_incr s' s'",
                    "c16_WF : map_valid map s'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (Some x0) (Some x0)",
                    "c12_x0 : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c15_goal : eq None (Some x0)",
                    "c15_EQ : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX x) nil)) s) (OK x0 s' INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( xtype_eq _i Xvoid ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( xtype_eq _i Xvoid ) .",
                "tactic_args": [
                    "c9_goal : tr_builtin_res map BR_none res'",
                    "c2_oty : xtype",
                    "c9_WF : map_valid map s",
                    "c9_TR : eq\n  ((if xtype_eq oty Xvoid\n    then ret BR_none\n    else bind new_reg (fun r : reg => ret (BR r))) s) \n  (OK res' s' INCR)",
                    "c9_res' : builtin_res reg",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c17_goal : tr_builtin_res map BR_none res'",
                    "c17_TR : eq (ret BR_none s) (OK res' s' INCR)",
                    "c17_e : eq oty Xvoid",
                    "c18_goal : tr_builtin_res map BR_none res'",
                    "c18_TR : eq (bind new_reg (fun r : reg => ret (BR r)) s) (OK res' s' INCR)",
                    "c18_n : not (eq oty Xvoid)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c17_goal : tr_builtin_res map BR_none res'",
                    "c17_TR : eq (ret BR_none s) (OK res' s' INCR)"
                ],
                "tactic_res": [
                    "c19_goal : tr_builtin_res map BR_none BR_none",
                    "c19_INCR : state_incr s' s'",
                    "c19_WF : map_valid map s'"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c18_goal : tr_builtin_res map BR_none res'",
                    "c18_TR : eq (bind new_reg (fun r : reg => ret (BR r)) s) (OK res' s' INCR)"
                ],
                "tactic_res": [
                    "c20_goal : tr_builtin_res map BR_none (BR x)",
                    "c20_INCR1 : state_incr s' s'",
                    "c20_EQ : eq (new_reg s) (OK x s' INCR0)",
                    "c20_INCR0 : state_incr s s'",
                    "c20_x : reg"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c19_goal : tr_builtin_res map BR_none BR_none"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c20_goal : tr_builtin_res map BR_none (BR x)"
                ],
                "tactic_res": [
                    "c21_goal : not (reg_in_map map x)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c21_goal : not (reg_in_map map x)",
                    "c20_EQ : eq (new_reg s) (OK x s' INCR0)",
                    "c20_x : reg",
                    "c9_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c11_goal : tr_builtin_res map (BR_splitlong res1 res2) res'",
                    "c11_TR : eq (error (Errors.msg \"RTLgen: bad builtin_res\") s) (OK res' s' INCR)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_stmt_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_stmt_charact : forall map stmt nd nexits ngoto nret rret s ns s' INCR ( TR : transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : return_reg_ok s map rret ) , tr_stmt s'. ( st_code ) map stmt ns nd nexits ngoto nret rret .",
                "tactic_sig_no_out_arg": "Lemma transl_stmt_charact : forall map stmt nd nexits ngoto nret rret s ns s' INCR ( TR : transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR ) ( WF : map_valid map s ) ( OK : return_reg_ok s map rret ) , tr_stmt s'. ( st_code ) map stmt ns nd nexits ngoto nret rret .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (map : mapping) (stmt : stmt) (nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg) \n  (s : state) (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros map stmt .",
                "tactic_args": [
                    "c1_goal : forall (map : mapping) (stmt : stmt) (nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg) \n  (s : state) (ns : node) (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c2_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c2_map : mapping",
                    "c2_stmt : CminorSel\\.stmt"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c2_stmt : CminorSel\\.stmt"
                ],
                "tactic_res": [
                    "c3_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map Sskip nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map Sskip ns nd nexits ngoto nret rret",
                    "c4_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sassign i e) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c4_e : expr",
                    "c4_i : ident",
                    "c5_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sstore m a e e0) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sstore m a e e0) ns nd nexits ngoto nret rret",
                    "c5_e0 : expr",
                    "c5_e : exprlist",
                    "c5_a : addressing",
                    "c5_m : memory_chunk",
                    "c6_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s1 : state) (ns : node)\n  (s' : state) (INCR : state_incr s1 s')\n  (_ : eq\n         (transl_stmt map (Scall o s s0 e) nd nexits ngoto nret rret s1)\n         (OK ns s' INCR)) (_ : map_valid map s1)\n  (_ : return_reg_ok s1 map rret),\ntr_stmt (st_code s') map (Scall o s s0 e) ns nd nexits ngoto nret rret",
                    "c6_e : exprlist",
                    "c6_s0 : sum expr ident",
                    "c6_s : signature",
                    "c6_o : option ident",
                    "c7_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s1 : state) (ns : node)\n  (s' : state) (INCR : state_incr s1 s')\n  (_ : eq\n         (transl_stmt map (Stailcall s s0 e) nd nexits ngoto nret rret\n            s1) (OK ns s' INCR)) (_ : map_valid map s1)\n  (_ : return_reg_ok s1 map rret),\ntr_stmt (st_code s') map (Stailcall s s0 e) ns nd nexits ngoto nret\n  rret",
                    "c7_e : exprlist",
                    "c7_s0 : sum expr ident",
                    "c7_s : signature",
                    "c8_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sbuiltin b e l) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sbuiltin b e l) ns nd nexits ngoto nret rret",
                    "c8_l : list (builtin_arg expr)",
                    "c8_e : external_function",
                    "c8_b : builtin_res ident",
                    "c9_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sseq stmt1 stmt2) nd nexits ngoto nret rret\n            s) (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sseq stmt1 stmt2) ns nd nexits ngoto nret\n  rret",
                    "c9_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret",
                    "c9_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret",
                    "c9_stmt2 : CminorSel\\.stmt",
                    "c9_stmt1 : CminorSel\\.stmt",
                    "c10_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sifthenelse c stmt1 stmt2) nd nexits ngoto\n            nret rret s) (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret",
                    "c10_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret",
                    "c10_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret",
                    "c10_stmt2 : CminorSel\\.stmt",
                    "c10_stmt1 : CminorSel\\.stmt",
                    "c10_c : condexpr",
                    "c11_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sloop stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sloop stmt) ns nd nexits ngoto nret rret",
                    "c11_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c12_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sblock stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sblock stmt) ns nd nexits ngoto nret rret",
                    "c12_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c13_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sexit n) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret",
                    "c13_n : nat",
                    "c14_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sswitch e) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sswitch e) ns nd nexits ngoto nret rret",
                    "c14_e : exitexpr",
                    "c15_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sreturn o) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sreturn o) ns nd nexits ngoto nret rret",
                    "c15_o : option expr",
                    "c16_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Slabel l stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c16_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c16_l : Cminor\\.label",
                    "c17_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sgoto l) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c17_l : Cminor\\.label"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map Sskip nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map Sskip ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c18_goal : tr_stmt (st_code s') map Sskip ns nd nexits ngoto nret rret",
                    "c18_nd : node",
                    "c18_nexits : list node",
                    "c18_ngoto : labelmap",
                    "c18_nret : node",
                    "c18_rret : option reg",
                    "c18_s : state",
                    "c18_ns : node",
                    "c18_s' : state",
                    "c18_INCR : state_incr s s'",
                    "c18_TR : eq (transl_stmt map Sskip nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c18_WF : map_valid map s",
                    "c18_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c18_TR : eq (transl_stmt map Sskip nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c18_TR : eq (ret nd s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c18_goal : tr_stmt (st_code s') map Sskip ns nd nexits ngoto nret rret",
                    "c18_TR : eq (ret nd s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c19_goal : tr_stmt (st_code s') map Sskip ns ns nexits ngoto nret rret",
                    "c19_INCR : state_incr s' s'",
                    "c19_WF : map_valid map s'",
                    "c19_OK : return_reg_ok s' map rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sassign i e) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c20_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c20_nd : node",
                    "c20_nexits : list node",
                    "c20_ngoto : labelmap",
                    "c20_nret : node",
                    "c20_rret : option reg",
                    "c20_s : state",
                    "c20_ns : node",
                    "c20_s' : state",
                    "c20_INCR : state_incr s s'",
                    "c20_TR : eq (transl_stmt map (Sassign i e) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c20_WF : map_valid map s",
                    "c20_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c20_TR : eq (transl_stmt map (Sassign i e) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c20_TR : eq (bind (find_var map i) (fun r : reg => transl_expr map e r nd) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c20_TR : eq (bind (find_var map i) (fun r : reg => transl_expr map e r nd) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c20_EQ0 : eq (transl_expr map e x nd s0) (RTLgen.OK ns s' INCR1)",
                    "c20_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)",
                    "c20_INCR1 : state_incr s0 s'",
                    "c20_INCR0 : state_incr s s0",
                    "c20_s0 : state",
                    "c20_x : reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sstore m a e e0) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sstore m a e e0) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c21_goal : tr_stmt (st_code s') map (Sstore m a e e0) ns nd nexits ngoto nret rret",
                    "c21_nd : node",
                    "c21_nexits : list node",
                    "c21_ngoto : labelmap",
                    "c21_nret : node",
                    "c21_rret : option reg",
                    "c21_s : state",
                    "c21_ns : node",
                    "c21_s' : state",
                    "c21_INCR : state_incr s s'",
                    "c21_TR : eq (transl_stmt map (Sstore m a e e0) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c21_WF : map_valid map s",
                    "c21_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c21_TR : eq (transl_stmt map (Sstore m a e e0) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c21_TR : eq\n  (bind (alloc_regs map e)\n     (fun rl : list reg =>\n      bind (alloc_reg map e0)\n        (fun r : reg =>\n         bind (add_instr (Istore m a rl r nd))\n           (fun no : node =>\n            bind (transl_expr map e0 r no)\n              (fun ns : node => transl_exprlist map e rl ns)))) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c21_TR : eq\n  (bind (alloc_regs map e)\n     (fun rl : list reg =>\n      bind (alloc_reg map e0)\n        (fun r : reg =>\n         bind (add_instr (Istore m a rl r nd))\n           (fun no : node =>\n            bind (transl_expr map e0 r no)\n              (fun ns : node => transl_exprlist map e rl ns)))) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c21_EQ4 : eq (transl_exprlist map e x x2 s3) (RTLgen.OK ns s' INCR7)",
                    "c21_EQ2 : eq (transl_expr map e0 x0 x1 s2) (RTLgen.OK x2 s3 INCR6)",
                    "c21_INCR7 : state_incr s3 s'",
                    "c21_INCR6 : state_incr s2 s3",
                    "c21_s3 : state",
                    "c21_x2 : node",
                    "c21_EQ0 : eq (add_instr (Istore m a x x0 nd) s1) (RTLgen.OK x1 s2 INCR4)",
                    "c21_INCR5 : state_incr s2 s'",
                    "c21_INCR4 : state_incr s1 s2",
                    "c21_s2 : state",
                    "c21_x1 : node",
                    "c21_EQ1 : eq (alloc_reg map e0 s0) (RTLgen.OK x0 s1 INCR2)",
                    "c21_INCR3 : state_incr s1 s'",
                    "c21_INCR2 : state_incr s0 s1",
                    "c21_s1 : state",
                    "c21_x0 : reg",
                    "c21_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c21_INCR1 : state_incr s0 s'",
                    "c21_INCR0 : state_incr s s0",
                    "c21_s0 : state",
                    "c21_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s1 : state) (ns : node)\n  (s' : state) (INCR : state_incr s1 s')\n  (_ : eq\n         (transl_stmt map (Scall o s s0 e) nd nexits ngoto nret rret s1)\n         (OK ns s' INCR)) (_ : map_valid map s1)\n  (_ : return_reg_ok s1 map rret),\ntr_stmt (st_code s') map (Scall o s s0 e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c22_goal : tr_stmt (st_code s') map (Scall o s s0 e) ns nd nexits ngoto nret rret",
                    "c22_nd : node",
                    "c22_nexits : list node",
                    "c22_ngoto : labelmap",
                    "c22_nret : node",
                    "c22_rret : option reg",
                    "c22_s1 : state",
                    "c22_ns : node",
                    "c22_s' : state",
                    "c22_INCR : state_incr s1 s'",
                    "c22_TR : eq (transl_stmt map (Scall o s s0 e) nd nexits ngoto nret rret s1)\n  (RTLgen.OK ns s' INCR)",
                    "c22_WF : map_valid map s1",
                    "c22_OK : return_reg_ok s1 map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c22_TR : eq (transl_stmt map (Scall o s s0 e) nd nexits ngoto nret rret s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c22_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (alloc_optreg map o)\n               (fun r : reg =>\n                bind (add_instr (Icall s (inl rf) rargs r nd))\n                  (fun n1 : node =>\n                   bind (transl_exprlist map e rargs n1)\n                     (fun n2 : node => transl_expr map b rf n2)))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (alloc_optreg map o)\n            (fun r : reg =>\n             bind (add_instr (Icall s (inr id) rargs r nd))\n               (fun n1 : node => transl_exprlist map e rargs n1)))\n   end s1) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c22_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (alloc_optreg map o)\n               (fun r : reg =>\n                bind (add_instr (Icall s (inl rf) rargs r nd))\n                  (fun n1 : node =>\n                   bind (transl_exprlist map e rargs n1)\n                     (fun n2 : node => transl_expr map b rf n2)))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (alloc_optreg map o)\n            (fun r : reg =>\n             bind (add_instr (Icall s (inr id) rargs r nd))\n               (fun n1 : node => transl_exprlist map e rargs n1)))\n   end s1) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s1 : state) (ns : node)\n  (s' : state) (INCR : state_incr s1 s')\n  (_ : eq\n         (transl_stmt map (Stailcall s s0 e) nd nexits ngoto nret rret\n            s1) (OK ns s' INCR)) (_ : map_valid map s1)\n  (_ : return_reg_ok s1 map rret),\ntr_stmt (st_code s') map (Stailcall s s0 e) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c23_goal : tr_stmt (st_code s') map (Stailcall s s0 e) ns nd nexits ngoto nret\n  rret",
                    "c23_nd : node",
                    "c23_nexits : list node",
                    "c23_ngoto : labelmap",
                    "c23_nret : node",
                    "c23_rret : option reg",
                    "c23_s1 : state",
                    "c23_ns : node",
                    "c23_s' : state",
                    "c23_INCR : state_incr s1 s'",
                    "c23_TR : eq (transl_stmt map (Stailcall s s0 e) nd nexits ngoto nret rret s1)\n  (RTLgen.OK ns s' INCR)",
                    "c23_WF : map_valid map s1",
                    "c23_OK : return_reg_ok s1 map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c23_TR : eq (transl_stmt map (Stailcall s s0 e) nd nexits ngoto nret rret s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c23_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (add_instr (Itailcall s (inl rf) rargs))\n               (fun n1 : node =>\n                bind (transl_exprlist map e rargs n1)\n                  (fun n2 : node => transl_expr map b rf n2))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (add_instr (Itailcall s (inr id) rargs))\n            (fun n1 : node => transl_exprlist map e rargs n1))\n   end s1) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c23_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (add_instr (Itailcall s (inl rf) rargs))\n               (fun n1 : node =>\n                bind (transl_exprlist map e rargs n1)\n                  (fun n2 : node => transl_expr map b rf n2))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (add_instr (Itailcall s (inr id) rargs))\n            (fun n1 : node => transl_exprlist map e rargs n1))\n   end s1) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sbuiltin b e l) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sbuiltin b e l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c24_goal : tr_stmt (st_code s') map (Sbuiltin b e l) ns nd nexits ngoto nret rret",
                    "c24_nd : node",
                    "c24_nexits : list node",
                    "c24_ngoto : labelmap",
                    "c24_nret : node",
                    "c24_rret : option reg",
                    "c24_s : state",
                    "c24_ns : node",
                    "c24_s' : state",
                    "c24_INCR : state_incr s s'",
                    "c24_TR : eq (transl_stmt map (Sbuiltin b e l) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c24_WF : map_valid map s",
                    "c24_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c24_TR : eq (transl_stmt map (Sbuiltin b e l) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c24_TR : eq\n  (bind\n     (alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)))\n     (fun rargs : list reg =>\n      bind (convert_builtin_res map (sig_res (ef_sig e)) b)\n        (fun res' : builtin_res reg =>\n         bind\n           (add_instr\n              (Ibuiltin e (convert_builtin_args l rargs) res' nd))\n           (fun n1 : node =>\n            transl_exprlist map\n              (exprlist_of_expr_list (params_of_builtin_args l)) rargs\n              n1))) s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c24_TR : eq\n  (bind\n     (alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)))\n     (fun rargs : list reg =>\n      bind (convert_builtin_res map (sig_res (ef_sig e)) b)\n        (fun res' : builtin_res reg =>\n         bind\n           (add_instr\n              (Ibuiltin e (convert_builtin_args l rargs) res' nd))\n           (fun n1 : node =>\n            transl_exprlist map\n              (exprlist_of_expr_list (params_of_builtin_args l)) rargs\n              n1))) s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c24_EQ3 : eq\n  (transl_exprlist map\n     (exprlist_of_expr_list (params_of_builtin_args l)) x x1 s2)\n  (RTLgen.OK ns s' INCR5)",
                    "c24_EQ0 : eq (add_instr (Ibuiltin e (convert_builtin_args l x) x0 nd) s1)\n  (RTLgen.OK x1 s2 INCR4)",
                    "c24_INCR5 : state_incr s2 s'",
                    "c24_INCR4 : state_incr s1 s2",
                    "c24_s2 : state",
                    "c24_x1 : node",
                    "c24_EQ1 : eq (convert_builtin_res map (sig_res (ef_sig e)) b s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c24_INCR3 : state_incr s1 s'",
                    "c24_INCR2 : state_incr s0 s1",
                    "c24_s1 : state",
                    "c24_x0 : builtin_res reg",
                    "c24_EQ : eq\n  (alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s)\n  (RTLgen.OK x s0 INCR0)",
                    "c24_INCR1 : state_incr s0 s'",
                    "c24_INCR0 : state_incr s s0",
                    "c24_s0 : state",
                    "c24_x : list reg"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sseq stmt1 stmt2) nd nexits ngoto nret rret\n            s) (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sseq stmt1 stmt2) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c25_goal : tr_stmt (st_code s') map (Sseq stmt1 stmt2) ns nd nexits ngoto nret\n  rret",
                    "c25_nd : node",
                    "c25_nexits : list node",
                    "c25_ngoto : labelmap",
                    "c25_nret : node",
                    "c25_rret : option reg",
                    "c25_s : state",
                    "c25_ns : node",
                    "c25_s' : state",
                    "c25_INCR : state_incr s s'",
                    "c25_TR : eq (transl_stmt map (Sseq stmt1 stmt2) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c25_WF : map_valid map s",
                    "c25_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c25_TR : eq (transl_stmt map (Sseq stmt1 stmt2) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c25_TR : eq\n  (bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n     (fun ns : node => transl_stmt map stmt1 ns nexits ngoto nret rret)\n     s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c25_TR : eq\n  (bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n     (fun ns : node => transl_stmt map stmt1 ns nexits ngoto nret rret)\n     s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c25_EQ0 : eq (transl_stmt map stmt1 x nexits ngoto nret rret s0)\n  (RTLgen.OK ns s' INCR1)",
                    "c25_EQ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c25_INCR1 : state_incr s0 s'",
                    "c25_INCR0 : state_incr s s0",
                    "c25_s0 : state",
                    "c25_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq\n         (transl_stmt map (Sifthenelse c stmt1 stmt2) nd nexits ngoto\n            nret rret s) (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c26_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret",
                    "c26_nd : node",
                    "c26_nexits : list node",
                    "c26_ngoto : labelmap",
                    "c26_nret : node",
                    "c26_rret : option reg",
                    "c26_s : state",
                    "c26_ns : node",
                    "c26_s' : state",
                    "c26_INCR : state_incr s s'",
                    "c26_TR : eq\n  (transl_stmt map (Sifthenelse c stmt1 stmt2) nd nexits ngoto nret\n     rret s) (RTLgen.OK ns s' INCR)",
                    "c26_WF : map_valid map s",
                    "c26_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c26_TR : eq\n  (transl_stmt map (Sifthenelse c stmt1 stmt2) nd nexits ngoto nret\n     rret s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c26_TR : eq\n  ((if more_likely c stmt1 stmt2\n    then\n     bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n       (fun nfalse : node =>\n        bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n          (fun ntrue : node => transl_condexpr map c ntrue nfalse))\n    else\n     bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n       (fun ntrue : node =>\n        bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n          (fun nfalse : node => transl_condexpr map c ntrue nfalse))) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c26_TR : eq\n  ((if more_likely c stmt1 stmt2\n    then\n     bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n       (fun nfalse : node =>\n        bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n          (fun ntrue : node => transl_condexpr map c ntrue nfalse))\n    else\n     bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n       (fun ntrue : node =>\n        bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n          (fun nfalse : node => transl_condexpr map c ntrue nfalse))) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sloop stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sloop stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c27_goal : tr_stmt (st_code s') map (Sloop stmt) ns nd nexits ngoto nret rret",
                    "c27_nd : node",
                    "c27_nexits : list node",
                    "c27_ngoto : labelmap",
                    "c27_nret : node",
                    "c27_rret : option reg",
                    "c27_s : state",
                    "c27_ns : node",
                    "c27_s' : state",
                    "c27_INCR : state_incr s s'",
                    "c27_TR : eq (transl_stmt map (Sloop stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c27_WF : map_valid map s",
                    "c27_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c27_TR : eq (transl_stmt map (Sloop stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c27_TR : eq\n  (bind reserve_instr\n     (fun n1 : node =>\n      bind (transl_stmt map stmt n1 nexits ngoto nret rret)\n        (fun n2 : node =>\n         bind (update_instr n1 (Inop n2))\n           (fun _ : unit => add_instr (Inop n2)))) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c27_TR : eq\n  (bind reserve_instr\n     (fun n1 : node =>\n      bind (transl_stmt map stmt n1 nexits ngoto nret rret)\n        (fun n2 : node =>\n         bind (update_instr n1 (Inop n2))\n           (fun _ : unit => add_instr (Inop n2)))) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c27_EQ3 : eq (add_instr (Inop x0) s2) (RTLgen.OK ns s' INCR5)",
                    "c27_EQ0 : eq (update_instr x (Inop x0) s1) (RTLgen.OK x1 s2 INCR4)",
                    "c27_INCR5 : state_incr s2 s'",
                    "c27_INCR4 : state_incr s1 s2",
                    "c27_s2 : state",
                    "c27_x1 : unit",
                    "c27_EQ1 : eq (transl_stmt map stmt x nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c27_INCR3 : state_incr s1 s'",
                    "c27_INCR2 : state_incr s0 s1",
                    "c27_s1 : state",
                    "c27_x0 : node",
                    "c27_EQ : eq (reserve_instr s) (RTLgen.OK x s0 INCR0)",
                    "c27_INCR1 : state_incr s0 s'",
                    "c27_INCR0 : state_incr s s0",
                    "c27_s0 : state",
                    "c27_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sblock stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sblock stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c28_goal : tr_stmt (st_code s') map (Sblock stmt) ns nd nexits ngoto nret rret",
                    "c28_nd : node",
                    "c28_nexits : list node",
                    "c28_ngoto : labelmap",
                    "c28_nret : node",
                    "c28_rret : option reg",
                    "c28_s : state",
                    "c28_ns : node",
                    "c28_s' : state",
                    "c28_INCR : state_incr s s'",
                    "c28_TR : eq (transl_stmt map (Sblock stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c28_WF : map_valid map s",
                    "c28_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c28_TR : eq (transl_stmt map (Sblock stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c28_TR : eq (transl_stmt map stmt nd (cons nd nexits) ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c28_TR : eq (transl_stmt map stmt nd (cons nd nexits) ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sexit n) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c29_goal : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret",
                    "c29_nd : node",
                    "c29_nexits : list node",
                    "c29_ngoto : labelmap",
                    "c29_nret : node",
                    "c29_rret : option reg",
                    "c29_s : state",
                    "c29_ns : node",
                    "c29_s' : state",
                    "c29_INCR : state_incr s s'",
                    "c29_TR : eq (transl_stmt map (Sexit n) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c29_WF : map_valid map s",
                    "c29_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c29_TR : eq (transl_stmt map (Sexit n) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c29_TR : eq (transl_exit nexits n s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c29_TR : eq (transl_exit nexits n s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sswitch e) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sswitch e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c30_goal : tr_stmt (st_code s') map (Sswitch e) ns nd nexits ngoto nret rret",
                    "c30_nd : node",
                    "c30_nexits : list node",
                    "c30_ngoto : labelmap",
                    "c30_nret : node",
                    "c30_rret : option reg",
                    "c30_s : state",
                    "c30_ns : node",
                    "c30_s' : state",
                    "c30_INCR : state_incr s s'",
                    "c30_TR : eq (transl_stmt map (Sswitch e) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c30_WF : map_valid map s",
                    "c30_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c30_TR : eq (transl_stmt map (Sswitch e) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c30_TR : eq (transl_exitexpr map e nexits s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c30_TR : eq (transl_exitexpr map e nexits s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sreturn o) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sreturn o) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c31_goal : tr_stmt (st_code s') map (Sreturn o) ns nd nexits ngoto nret rret",
                    "c31_nd : node",
                    "c31_nexits : list node",
                    "c31_ngoto : labelmap",
                    "c31_nret : node",
                    "c31_rret : option reg",
                    "c31_s : state",
                    "c31_ns : node",
                    "c31_s' : state",
                    "c31_INCR : state_incr s s'",
                    "c31_TR : eq (transl_stmt map (Sreturn o) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c31_WF : map_valid map s",
                    "c31_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c31_TR : eq (transl_stmt map (Sreturn o) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c31_TR : eq\n  (match o with\n   | Some a =>\n       match rret with\n       | Some r => transl_expr map a r nret\n       | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n       end\n   | None => ret nret\n   end s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c31_TR : eq\n  (match o with\n   | Some a =>\n       match rret with\n       | Some r => transl_expr map a r nret\n       | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n       end\n   | None => ret nret\n   end s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Slabel l stmt) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c32_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c32_nd : node",
                    "c32_nexits : list node",
                    "c32_ngoto : labelmap",
                    "c32_nret : node",
                    "c32_rret : option reg",
                    "c32_s : state",
                    "c32_ns : node",
                    "c32_s' : state",
                    "c32_INCR : state_incr s s'",
                    "c32_TR : eq (transl_stmt map (Slabel l stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c32_WF : map_valid map s",
                    "c32_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c32_TR : eq (transl_stmt map (Slabel l stmt) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c32_TR : eq\n  (bind (transl_stmt map stmt nd nexits ngoto nret rret)\n     (fun ns : node =>\n      match PTree.get l ngoto with\n      | Some n =>\n          bind\n            (handle_error (update_instr n (Inop ns))\n               (error\n                  (cons (Errors.MSG \"Multiply-defined label \")\n                     (cons (Errors.CTX l) nil))))\n            (fun _ : unit => ret ns)\n      | None => error (Errors.msg \"RTLgen: unbound label\")\n      end) s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c32_TR : eq\n  (bind (transl_stmt map stmt nd nexits ngoto nret rret)\n     (fun ns : node =>\n      match PTree.get l ngoto with\n      | Some n =>\n          bind\n            (handle_error (update_instr n (Inop ns))\n               (error\n                  (cons (Errors.MSG \"Multiply-defined label \")\n                     (cons (Errors.CTX l) nil))))\n            (fun _ : unit => ret ns)\n      | None => error (Errors.msg \"RTLgen: unbound label\")\n      end) s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c32_EQ0 : eq\n  (match PTree.get l ngoto with\n   | Some n =>\n       bind\n         (handle_error (update_instr n (Inop x))\n            (error\n               (cons (Errors.MSG \"Multiply-defined label \")\n                  (cons (Errors.CTX l) nil)))) (fun _ : unit => ret x)\n   | None => error (Errors.msg \"RTLgen: unbound label\")\n   end s0) (RTLgen.OK ns s' INCR1)",
                    "c32_EQ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c32_INCR1 : state_incr s0 s'",
                    "c32_INCR0 : state_incr s s0",
                    "c32_s0 : state",
                    "c32_x : node"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map (Sgoto l) nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c33_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c33_nd : node",
                    "c33_nexits : list node",
                    "c33_ngoto : labelmap",
                    "c33_nret : node",
                    "c33_rret : option reg",
                    "c33_s : state",
                    "c33_ns : node",
                    "c33_s' : state",
                    "c33_INCR : state_incr s s'",
                    "c33_TR : eq (transl_stmt map (Sgoto l) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c33_WF : map_valid map s",
                    "c33_OK : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c33_TR : eq (transl_stmt map (Sgoto l) nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c33_TR : eq\n  (match PTree.get l ngoto with\n   | Some n => ret n\n   | None =>\n       error\n         (cons (Errors.MSG \"Undefined defined label \")\n            (cons (Errors.CTX l) nil))\n   end s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "try ( monadInv _i ) .",
                "tactic_sig_no_out_arg": "try ( monadInv _i ) .",
                "tactic_args": [
                    "c33_TR : eq\n  (match PTree.get l ngoto with\n   | Some n => ret n\n   | None =>\n       error\n         (cons (Errors.MSG \"Undefined defined label \")\n            (cons (Errors.CTX l) nil))\n   end s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c19_goal : tr_stmt (st_code s') map Sskip ns ns nexits ngoto nret rret"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "revert _i .",
                "tactic_sig_no_out_arg": "revert _i .",
                "tactic_args": [
                    "c20_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c20_EQ : eq (find_var map i s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c34_goal : forall _ : eq (find_var map i s) (RTLgen.OK x s0 INCR0),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "_global_find_var : forall (_ : mapping) (_ : ident), mon reg"
                ],
                "tactic_res": [
                    "c35_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "case_eq ( map_vars _i ) !i .",
                "tactic_sig_no_out_arg": "case_eq ( map_vars _i ) !i .",
                "tactic_args": [
                    "c35_goal : forall\n  _ : eq\n        (match PTree.get i (map_vars map) with\n         | Some r => ret r\n         | None =>\n             error\n               (cons (Errors.MSG \"RTLgen: unbound variable \")\n                  (cons (Errors.CTX i) nil))\n         end s) (RTLgen.OK x s0 INCR0),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c36_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c37_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c36_goal : forall (r : reg) (_ : eq (PTree.get i (map_vars map)) (Some r))\n  (_ : eq (ret r s) (RTLgen.OK x s0 INCR0)),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c38_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c38_r : reg",
                    "c38_H : eq (PTree.get i (map_vars map)) (Some r)",
                    "c38_EQ : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c38_EQ : eq (ret r s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": [
                    "c38_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c38_INCR : state_incr s0 s'",
                    "c38_WF : map_valid map s0",
                    "c38_OK : return_reg_ok s0 map rret",
                    "c38_INCR0 : state_incr s0 s0"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c37_goal : forall (_ : eq (PTree.get i (map_vars map)) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"RTLgen: unbound variable \")\n               (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)),\ntr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c39_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c39_H : eq (PTree.get i (map_vars map)) None",
                    "c39_EQ : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c39_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "c39_EQ : eq\n  (error\n     (cons (Errors.MSG \"RTLgen: unbound variable \")\n        (cons (Errors.CTX i) nil)) s) (RTLgen.OK x s0 INCR0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c38_goal : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret",
                    "_global_tr_Sassign : forall (c : code) (map : mapping) (id : positive) \n         (a : expr) (ns nd : node) (nexits : list node) \n         (ngoto : labelmap) (nret : node) (rret : option reg) \n         (r : reg) (_ : eq (PTree.get id (map_vars map)) (Some r))\n         (_ : tr_expr c map nil a ns nd r (Some id)),\n       tr_stmt c map (Sassign id a) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c40_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c41_goal : tr_expr (st_code s') map nil e ns nd x (Some i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : eq (PTree.get i (map_vars map)) (Some ?r)",
                    "c38_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c4_i : ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c41_goal : tr_expr (st_code s') map nil e ns nd x (Some i)",
                    "_global_transl_expr_assign_charact : forall (id : ident) (a : expr) (map : mapping) \n         (rd : reg) (nd : node) (s : state) (ns : node) \n         (s' : state) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : reg_map_ok map rd (Some id)),\n       tr_expr (st_code s') map nil a ns nd rd (Some id)"
                ],
                "tactic_res": [
                    "c42_goal : eq (transl_expr map e x nd ?s) (RTLgen.OK ns s' ?INCR)",
                    "c43_goal : map_valid map s0",
                    "c44_goal : reg_map_ok map x (Some i)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c42_goal : eq (transl_expr map e x nd ?s) (RTLgen.OK ns s' ?INCR)",
                    "c20_EQ0 : eq (transl_expr map e x nd s0) (RTLgen.OK ns s' INCR1)",
                    "c20_x : reg",
                    "c20_s' : state",
                    "c20_ns : node",
                    "c20_nd : node",
                    "c4_e : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c43_goal : map_valid map s0",
                    "c38_WF : map_valid map s0",
                    "c20_s0 : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c44_goal : reg_map_ok map x (Some i)"
                ],
                "tactic_res": [
                    "c45_goal : eq (PTree.get i (map_vars map)) (Some x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c45_goal : eq (PTree.get i (map_vars map)) (Some x)",
                    "c38_H : eq (PTree.get i (map_vars map)) (Some x)",
                    "c20_x : reg",
                    "c4_i : ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c21_goal : tr_stmt (st_code s') map (Sstore m a e e0) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c46_goal : tr_exprlist (st_code s') map nil e ns ?n1 x",
                    "c47_goal : tr_expr (st_code s') map x e0 x2 x1 x0 None",
                    "c48_goal : eq (PTree.get ?n2 (st_code s')) (Some (Istore m a ?rl ?rd nd))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c48_goal : eq (PTree.get ?n2 (st_code s')) (Some (Istore m a ?rl ?rd nd))",
                    "c21_EQ0 : eq (add_instr (Istore m a x x0 nd) s1) (RTLgen.OK x1 s2 INCR4)",
                    "c21_s' : state",
                    "c21_nd : node",
                    "c5_a : addressing",
                    "c5_m : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c46_goal : tr_exprlist (st_code s') map nil e ns ?n1 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c49_goal : eq (transl_exprlist map e x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c50_goal : map_valid map s3",
                    "c51_goal : target_regs_ok map nil e x",
                    "c52_goal : regs_valid nil s3",
                    "c53_goal : regs_valid x s3"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c49_goal : eq (transl_exprlist map e x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c21_EQ4 : eq (transl_exprlist map e x x2 s3) (RTLgen.OK ns s' INCR7)",
                    "c21_x : list reg",
                    "c21_s' : state",
                    "c21_ns : node",
                    "c5_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c50_goal : map_valid map s3",
                    "c21_s3 : state",
                    "c21_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c51_goal : target_regs_ok map nil e x",
                    "c21_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c21_x : list reg",
                    "c21_WF : map_valid map s",
                    "c5_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c52_goal : regs_valid nil s3",
                    "c21_s3 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c53_goal : regs_valid x s3",
                    "c21_INCR9 : state_incr s0 s3",
                    "c21_s3 : state",
                    "c21_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c21_x : list reg",
                    "c21_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c47_goal : tr_expr (st_code s') map x e0 x2 x1 x0 None",
                    "_global_tr_expr_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (a : expr) \n         (ns nd : node) (rd : reg) (dst : option ident)\n         (_ : tr_expr (st_code s1) map pr a ns nd rd dst),\n       tr_expr (st_code s2) map pr a ns nd rd dst",
                    "c21_s3 : state"
                ],
                "tactic_res": [
                    "c54_goal : state_incr s3 s'",
                    "c55_goal : tr_expr (st_code s3) map x e0 x2 x1 x0 None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : state_incr s3 s'",
                    "c21_s3 : state",
                    "c21_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c55_goal : tr_expr (st_code s3) map x e0 x2 x1 x0 None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c56_goal : eq (transl_expr map e0 x0 x1 ?s) (RTLgen.OK x2 s3 ?INCR)",
                    "c57_goal : map_valid map s2",
                    "c58_goal : target_reg_ok map x e0 x0",
                    "c59_goal : regs_valid x s2",
                    "c60_goal : reg_valid x0 s2"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c56_goal : eq (transl_expr map e0 x0 x1 ?s) (RTLgen.OK x2 s3 ?INCR)",
                    "c21_EQ2 : eq (transl_expr map e0 x0 x1 s2) (RTLgen.OK x2 s3 INCR6)",
                    "c21_s3 : state",
                    "c21_x2 : node",
                    "c21_x1 : node",
                    "c21_x0 : reg",
                    "c5_e0 : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c57_goal : map_valid map s2",
                    "c21_s2 : state",
                    "c21_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c58_goal : target_reg_ok map x e0 x0",
                    "c21_EQ1 : eq (alloc_reg map e0 s0) (RTLgen.OK x0 s1 INCR2)",
                    "c21_x0 : reg",
                    "c21_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c21_x : list reg",
                    "c21_WF : map_valid map s",
                    "c5_e0 : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c59_goal : regs_valid x s2",
                    "c21_s2 : state",
                    "c21_EQ : eq (alloc_regs map e s) (RTLgen.OK x s0 INCR0)",
                    "c21_x : list reg",
                    "c21_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c60_goal : reg_valid x0 s2",
                    "c21_s2 : state",
                    "c21_EQ1 : eq (alloc_reg map e0 s0) (RTLgen.OK x0 s1 INCR2)",
                    "c21_x0 : reg",
                    "c21_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ b | id ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ b | id ] .",
                "tactic_args": [
                    "c22_goal : tr_stmt (st_code s') map (Scall o s s0 e) ns nd nexits ngoto nret rret",
                    "c6_s0 : sum expr ident",
                    "c22_OK : return_reg_ok s1 map rret",
                    "c22_WF : map_valid map s1",
                    "c22_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (alloc_optreg map o)\n               (fun r : reg =>\n                bind (add_instr (Icall s (inl rf) rargs r nd))\n                  (fun n1 : node =>\n                   bind (transl_exprlist map e rargs n1)\n                     (fun n2 : node => transl_expr map b rf n2)))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (alloc_optreg map o)\n            (fun r : reg =>\n             bind (add_instr (Icall s (inr id) rargs r nd))\n               (fun n1 : node => transl_exprlist map e rargs n1)))\n   end s1) (RTLgen.OK ns s' INCR)",
                    "c22_s' : state",
                    "c22_ns : node",
                    "c22_rret : option reg",
                    "c22_nret : node",
                    "c22_ngoto : labelmap",
                    "c22_nexits : list node",
                    "c22_nd : node",
                    "c6_e : exprlist",
                    "c6_s : signature",
                    "c6_o : option ident",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c61_goal : tr_stmt (st_code s') map (Scall o s (inl b) e) ns nd nexits ngoto nret\n  rret",
                    "c61_TR : eq\n  (bind (alloc_reg map b)\n     (fun rf : reg =>\n      bind (alloc_regs map e)\n        (fun rargs : list reg =>\n         bind (alloc_optreg map o)\n           (fun r : reg =>\n            bind (add_instr (Icall s (inl rf) rargs r nd))\n              (fun n1 : node =>\n               bind (transl_exprlist map e rargs n1)\n                 (fun n2 : node => transl_expr map b rf n2))))) s1)\n  (RTLgen.OK ns s' INCR)",
                    "c61_b : expr",
                    "c62_goal : tr_stmt (st_code s') map (Scall o s (inr id) e) ns nd nexits ngoto nret\n  rret",
                    "c62_TR : eq\n  (bind (alloc_regs map e)\n     (fun rargs : list reg =>\n      bind (alloc_optreg map o)\n        (fun r : reg =>\n         bind (add_instr (Icall s (inr id) rargs r nd))\n           (fun n1 : node => transl_exprlist map e rargs n1))) s1)\n  (RTLgen.OK ns s' INCR)",
                    "c62_id : ident"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c61_TR : eq\n  (bind (alloc_reg map b)\n     (fun rf : reg =>\n      bind (alloc_regs map e)\n        (fun rargs : list reg =>\n         bind (alloc_optreg map o)\n           (fun r : reg =>\n            bind (add_instr (Icall s (inl rf) rargs r nd))\n              (fun n1 : node =>\n               bind (transl_exprlist map e rargs n1)\n                 (fun n2 : node => transl_expr map b rf n2))))) s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c61_EQ5 : eq (transl_expr map b x x3 s5) (RTLgen.OK ns s' INCR9)",
                    "c61_EQ3 : eq (transl_exprlist map e x0 x2 s4) (RTLgen.OK x3 s5 INCR8)",
                    "c61_INCR9 : state_incr s5 s'",
                    "c61_INCR8 : state_incr s4 s5",
                    "c61_s5 : state",
                    "c61_x3 : node",
                    "c61_EQ2 : eq (add_instr (Icall s (inl x) x0 x1 nd) s3) (RTLgen.OK x2 s4 INCR6)",
                    "c61_INCR7 : state_incr s4 s'",
                    "c61_INCR6 : state_incr s3 s4",
                    "c61_s4 : state",
                    "c61_x2 : node",
                    "c61_EQ0 : eq (alloc_optreg map o s2) (RTLgen.OK x1 s3 INCR4)",
                    "c61_INCR5 : state_incr s3 s'",
                    "c61_INCR4 : state_incr s2 s3",
                    "c61_s3 : state",
                    "c61_x1 : reg",
                    "c61_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c61_INCR3 : state_incr s2 s'",
                    "c61_INCR2 : state_incr s0 s2",
                    "c61_s2 : state",
                    "c61_x0 : list reg",
                    "c61_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c61_INCR1 : state_incr s0 s'",
                    "c61_INCR0 : state_incr s1 s0",
                    "c61_s0 : state",
                    "c61_x : reg"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c62_TR : eq\n  (bind (alloc_regs map e)\n     (fun rargs : list reg =>\n      bind (alloc_optreg map o)\n        (fun r : reg =>\n         bind (add_instr (Icall s (inr id) rargs r nd))\n           (fun n1 : node => transl_exprlist map e rargs n1))) s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c62_EQ3 : eq (transl_exprlist map e x x1 s3) (RTLgen.OK ns s' INCR5)",
                    "c62_EQ0 : eq (add_instr (Icall s (inr id) x x0 nd) s2) (RTLgen.OK x1 s3 INCR4)",
                    "c62_INCR5 : state_incr s3 s'",
                    "c62_INCR4 : state_incr s2 s3",
                    "c62_s3 : state",
                    "c62_x1 : node",
                    "c62_EQ1 : eq (alloc_optreg map o s0) (RTLgen.OK x0 s2 INCR2)",
                    "c62_INCR3 : state_incr s2 s'",
                    "c62_INCR2 : state_incr s0 s2",
                    "c62_s2 : state",
                    "c62_x0 : reg",
                    "c62_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c62_INCR1 : state_incr s0 s'",
                    "c62_INCR0 : state_incr s1 s0",
                    "c62_s0 : state",
                    "c62_x : list reg"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c61_goal : tr_stmt (st_code s') map (Scall o s (inl b) e) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c63_goal : tr_expr (st_code s') map nil b ns ?n1 x None",
                    "c64_goal : tr_exprlist (st_code s') map (cons x nil) e x3 x2 x0",
                    "c65_goal : eq (PTree.get ?n2 (st_code s'))\n  (Some (Icall s (inl ?rf) ?rargs ?rd nd))",
                    "c66_goal : reg_map_ok map x1 o"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c65_goal : eq (PTree.get ?n2 (st_code s'))\n  (Some (Icall s (inl ?rf) ?rargs ?rd nd))",
                    "c61_EQ2 : eq (add_instr (Icall s (inl x) x0 x1 nd) s3) (RTLgen.OK x2 s4 INCR6)",
                    "c22_s' : state",
                    "c22_nd : node",
                    "c6_s : signature"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c63_goal : tr_expr (st_code s') map nil b ns ?n1 x None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c67_goal : eq (transl_expr map b x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c68_goal : map_valid map s5",
                    "c69_goal : target_reg_ok map nil b x",
                    "c70_goal : regs_valid nil s5",
                    "c71_goal : reg_valid x s5"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c67_goal : eq (transl_expr map b x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c61_EQ5 : eq (transl_expr map b x x3 s5) (RTLgen.OK ns s' INCR9)",
                    "c61_x : reg",
                    "c22_s' : state",
                    "c22_ns : node",
                    "c61_b : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c68_goal : map_valid map s5",
                    "c61_s5 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c69_goal : target_reg_ok map nil b x",
                    "c61_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c61_x : reg",
                    "c22_WF : map_valid map s1",
                    "c61_b : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c70_goal : regs_valid nil s5",
                    "c61_s5 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c71_goal : reg_valid x s5",
                    "c61_INCR12 : state_incr s0 s5",
                    "c61_s5 : state",
                    "c61_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c61_x : reg",
                    "c22_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c64_goal : tr_exprlist (st_code s') map (cons x nil) e x3 x2 x0",
                    "_global_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (al : exprlist) \n         (ns nd : node) (rl : list reg)\n         (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\n       tr_exprlist (st_code s2) map pr al ns nd rl",
                    "c61_s5 : state"
                ],
                "tactic_res": [
                    "c72_goal : state_incr s5 s'",
                    "c73_goal : tr_exprlist (st_code s5) map (cons x nil) e x3 x2 x0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c72_goal : state_incr s5 s'",
                    "c61_s5 : state",
                    "c22_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c73_goal : tr_exprlist (st_code s5) map (cons x nil) e x3 x2 x0",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c74_goal : eq (transl_exprlist map e x0 x2 ?s) (RTLgen.OK x3 s5 ?INCR)",
                    "c75_goal : map_valid map s4",
                    "c76_goal : target_regs_ok map (cons x nil) e x0",
                    "c77_goal : regs_valid (cons x nil) s4",
                    "c78_goal : regs_valid x0 s4"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c74_goal : eq (transl_exprlist map e x0 x2 ?s) (RTLgen.OK x3 s5 ?INCR)",
                    "c61_EQ3 : eq (transl_exprlist map e x0 x2 s4) (RTLgen.OK x3 s5 INCR8)",
                    "c61_s5 : state",
                    "c61_x3 : node",
                    "c61_x2 : node",
                    "c61_x0 : list reg",
                    "c6_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c75_goal : map_valid map s4",
                    "c61_s4 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) .",
                "tactic_args": [
                    "c76_goal : target_regs_ok map (cons x nil) e x0",
                    "_global_alloc_regs_target_ok : forall (map : mapping) (al : exprlist) (pr : list reg) \n         (s1 : state) (rl : list reg) (s2 : state) \n         (i : state_incr s1 s2) (_ : map_valid map s1) \n         (_ : regs_valid pr s1)\n         (_ : eq (alloc_regs map al s1) (RTLgen.OK rl s2 i)),\n       target_regs_ok map pr al rl",
                    "c22_s1 : state",
                    "c61_s0 : state"
                ],
                "tactic_res": [
                    "c79_goal : map_valid map s0",
                    "c80_goal : regs_valid (cons x nil) s0",
                    "c81_goal : eq (alloc_regs map e s0) (RTLgen.OK x0 ?s2 ?i)"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c79_goal : map_valid map s0",
                    "c61_s0 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c81_goal : eq (alloc_regs map e s0) (RTLgen.OK x0 ?s2 ?i)",
                    "c61_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c61_x0 : list reg",
                    "c61_s0 : state",
                    "c6_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c80_goal : regs_valid (cons x nil) s0",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c82_goal : reg_valid x s0",
                    "c83_goal : regs_valid nil s0"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c82_goal : reg_valid x s0",
                    "c61_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c61_s0 : state",
                    "c61_x : reg",
                    "c22_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c83_goal : regs_valid nil s0",
                    "c61_s0 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c77_goal : regs_valid (cons x nil) s4",
                    "_global_regs_valid_incr : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n         (_ : regs_valid rl s1), regs_valid rl s2",
                    "c61_s0 : state"
                ],
                "tactic_res": [
                    "c84_goal : state_incr s0 s4",
                    "c85_goal : regs_valid (cons x nil) s0"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c84_goal : state_incr s0 s4",
                    "c61_INCR15 : state_incr s0 s4",
                    "c61_s4 : state",
                    "c61_s0 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c85_goal : regs_valid (cons x nil) s0",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c86_goal : reg_valid x s0",
                    "c87_goal : regs_valid nil s0"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c86_goal : reg_valid x s0",
                    "c61_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c61_s0 : state",
                    "c61_x : reg",
                    "c22_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c87_goal : regs_valid nil s0",
                    "c61_s0 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c78_goal : regs_valid x0 s4",
                    "_global_regs_valid_incr : forall (s1 s2 : state) (rl : list reg) (_ : state_incr s1 s2)\n         (_ : regs_valid rl s1), regs_valid rl s2",
                    "c61_s2 : state"
                ],
                "tactic_res": [
                    "c88_goal : state_incr s2 s4",
                    "c89_goal : regs_valid x0 s2"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c88_goal : state_incr s2 s4",
                    "c61_INCR14 : state_incr s2 s4",
                    "c61_s4 : state",
                    "c61_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c89_goal : regs_valid x0 s2",
                    "c61_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c61_s2 : state",
                    "c61_x0 : list reg",
                    "c22_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) .",
                "tactic_args": [
                    "c66_goal : reg_map_ok map x1 o",
                    "_global_alloc_optreg_map_ok : forall (map : mapping) (optid : option ident) \n         (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2)\n         (_ : map_valid map s1)\n         (_ : eq (alloc_optreg map optid s1) (RTLgen.OK r s2 i)),\n       reg_map_ok map r optid",
                    "c22_s1 : state",
                    "c61_s2 : state"
                ],
                "tactic_res": [
                    "c90_goal : map_valid map s2",
                    "c91_goal : eq (alloc_optreg map o s2) (RTLgen.OK x1 ?s2 ?i)"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c90_goal : map_valid map s2",
                    "c61_s2 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c91_goal : eq (alloc_optreg map o s2) (RTLgen.OK x1 ?s2 ?i)",
                    "c61_EQ0 : eq (alloc_optreg map o s2) (RTLgen.OK x1 s3 INCR4)",
                    "c61_x1 : reg",
                    "c61_s2 : state",
                    "c6_o : option ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c62_goal : tr_stmt (st_code s') map (Scall o s (inr id) e) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c92_goal : tr_exprlist (st_code s') map nil e ns x1 x",
                    "c93_goal : eq (PTree.get ?n2 (st_code s')) (Some (Icall s (inr id) ?rargs ?rd nd))",
                    "c94_goal : reg_map_ok map x0 o"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c93_goal : eq (PTree.get ?n2 (st_code s')) (Some (Icall s (inr id) ?rargs ?rd nd))",
                    "c62_EQ0 : eq (add_instr (Icall s (inr id) x x0 nd) s2) (RTLgen.OK x1 s3 INCR4)",
                    "c22_s' : state",
                    "c22_nd : node",
                    "c62_id : ident",
                    "c6_s : signature"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c92_goal : tr_exprlist (st_code s') map nil e ns x1 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c95_goal : eq (transl_exprlist map e x x1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c96_goal : map_valid map s3",
                    "c97_goal : target_regs_ok map nil e x",
                    "c98_goal : regs_valid nil s3",
                    "c99_goal : regs_valid x s3"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c95_goal : eq (transl_exprlist map e x x1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c62_EQ3 : eq (transl_exprlist map e x x1 s3) (RTLgen.OK ns s' INCR5)",
                    "c62_x1 : node",
                    "c62_x : list reg",
                    "c22_s' : state",
                    "c22_ns : node",
                    "c6_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c96_goal : map_valid map s3",
                    "c62_s3 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c97_goal : target_regs_ok map nil e x",
                    "c62_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c62_x : list reg",
                    "c22_WF : map_valid map s1",
                    "c6_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c98_goal : regs_valid nil s3",
                    "c62_s3 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c99_goal : regs_valid x s3",
                    "c62_INCR6 : state_incr s0 s3",
                    "c62_s3 : state",
                    "c62_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c62_x : list reg",
                    "c22_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) .",
                "tactic_args": [
                    "c94_goal : reg_map_ok map x0 o",
                    "_global_alloc_optreg_map_ok : forall (map : mapping) (optid : option ident) \n         (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2)\n         (_ : map_valid map s1)\n         (_ : eq (alloc_optreg map optid s1) (RTLgen.OK r s2 i)),\n       reg_map_ok map r optid",
                    "c22_s1 : state",
                    "c62_s0 : state"
                ],
                "tactic_res": [
                    "c100_goal : map_valid map s0",
                    "c101_goal : eq (alloc_optreg map o s0) (RTLgen.OK x0 ?s2 ?i)"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c100_goal : map_valid map s0",
                    "c62_s0 : state",
                    "c22_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c101_goal : eq (alloc_optreg map o s0) (RTLgen.OK x0 ?s2 ?i)",
                    "c62_EQ1 : eq (alloc_optreg map o s0) (RTLgen.OK x0 s2 INCR2)",
                    "c62_x0 : reg",
                    "c62_s0 : state",
                    "c6_o : option ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ b | id ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ b | id ] .",
                "tactic_args": [
                    "c23_goal : tr_stmt (st_code s') map (Stailcall s s0 e) ns nd nexits ngoto nret\n  rret",
                    "c7_s0 : sum expr ident",
                    "c23_OK : return_reg_ok s1 map rret",
                    "c23_WF : map_valid map s1",
                    "c23_TR : eq\n  (match s0 with\n   | inl b =>\n       bind (alloc_reg map b)\n         (fun rf : reg =>\n          bind (alloc_regs map e)\n            (fun rargs : list reg =>\n             bind (add_instr (Itailcall s (inl rf) rargs))\n               (fun n1 : node =>\n                bind (transl_exprlist map e rargs n1)\n                  (fun n2 : node => transl_expr map b rf n2))))\n   | inr id =>\n       bind (alloc_regs map e)\n         (fun rargs : list reg =>\n          bind (add_instr (Itailcall s (inr id) rargs))\n            (fun n1 : node => transl_exprlist map e rargs n1))\n   end s1) (RTLgen.OK ns s' INCR)",
                    "c23_s' : state",
                    "c23_ns : node",
                    "c23_rret : option reg",
                    "c23_nret : node",
                    "c23_ngoto : labelmap",
                    "c23_nexits : list node",
                    "c23_nd : node",
                    "c7_e : exprlist",
                    "c7_s : signature",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c102_goal : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto\n  nret rret",
                    "c102_TR : eq\n  (bind (alloc_reg map b)\n     (fun rf : reg =>\n      bind (alloc_regs map e)\n        (fun rargs : list reg =>\n         bind (add_instr (Itailcall s (inl rf) rargs))\n           (fun n1 : node =>\n            bind (transl_exprlist map e rargs n1)\n              (fun n2 : node => transl_expr map b rf n2)))) s1)\n  (RTLgen.OK ns s' INCR)",
                    "c102_b : expr",
                    "c103_goal : tr_stmt (st_code s') map (Stailcall s (inr id) e) ns nd nexits ngoto\n  nret rret",
                    "c103_TR : eq\n  (bind (alloc_regs map e)\n     (fun rargs : list reg =>\n      bind (add_instr (Itailcall s (inr id) rargs))\n        (fun n1 : node => transl_exprlist map e rargs n1)) s1)\n  (RTLgen.OK ns s' INCR)",
                    "c103_id : ident"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c102_TR : eq\n  (bind (alloc_reg map b)\n     (fun rf : reg =>\n      bind (alloc_regs map e)\n        (fun rargs : list reg =>\n         bind (add_instr (Itailcall s (inl rf) rargs))\n           (fun n1 : node =>\n            bind (transl_exprlist map e rargs n1)\n              (fun n2 : node => transl_expr map b rf n2)))) s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c102_EQ4 : eq (transl_expr map b x x2 s4) (RTLgen.OK ns s' INCR7)",
                    "c102_EQ2 : eq (transl_exprlist map e x0 x1 s3) (RTLgen.OK x2 s4 INCR6)",
                    "c102_INCR7 : state_incr s4 s'",
                    "c102_INCR6 : state_incr s3 s4",
                    "c102_s4 : state",
                    "c102_x2 : node",
                    "c102_EQ0 : eq (add_instr (Itailcall s (inl x) x0) s2) (RTLgen.OK x1 s3 INCR4)",
                    "c102_INCR5 : state_incr s3 s'",
                    "c102_INCR4 : state_incr s2 s3",
                    "c102_s3 : state",
                    "c102_x1 : node",
                    "c102_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c102_INCR3 : state_incr s2 s'",
                    "c102_INCR2 : state_incr s0 s2",
                    "c102_s2 : state",
                    "c102_x0 : list reg",
                    "c102_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c102_INCR1 : state_incr s0 s'",
                    "c102_INCR0 : state_incr s1 s0",
                    "c102_s0 : state",
                    "c102_x : reg"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c103_TR : eq\n  (bind (alloc_regs map e)\n     (fun rargs : list reg =>\n      bind (add_instr (Itailcall s (inr id) rargs))\n        (fun n1 : node => transl_exprlist map e rargs n1)) s1)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c103_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c103_EQ1 : eq (add_instr (Itailcall s (inr id) x) s0) (RTLgen.OK x0 s2 INCR2)",
                    "c103_INCR3 : state_incr s2 s'",
                    "c103_INCR2 : state_incr s0 s2",
                    "c103_s2 : state",
                    "c103_x0 : node",
                    "c103_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c103_INCR1 : state_incr s0 s'",
                    "c103_INCR0 : state_incr s1 s0",
                    "c103_s0 : state",
                    "c103_x : list reg"
                ]
            },
            {
                "tactic_sig": "assert ( RV : regs_valid ( _i :: nil ) _i ) .",
                "tactic_sig_no_out_arg": "assert ( RV : regs_valid ( _i :: nil ) _i ) .",
                "tactic_args": [
                    "c102_goal : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto\n  nret rret",
                    "c102_x : reg",
                    "c102_s0 : state"
                ],
                "tactic_res": [
                    "c104_goal : regs_valid (cons x nil) s0",
                    "c105_goal : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto\n  nret rret",
                    "c105_RV : regs_valid (cons x nil) s0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c104_goal : regs_valid (cons x nil) s0",
                    "_global_regs_valid_cons : forall (r1 : reg) (rl : list reg) (s : state) \n         (_ : reg_valid r1 s) (_ : regs_valid rl s),\n       regs_valid (cons r1 rl) s"
                ],
                "tactic_res": [
                    "c106_goal : reg_valid x s0",
                    "c107_goal : regs_valid nil s0"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c106_goal : reg_valid x s0",
                    "c102_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c102_s0 : state",
                    "c102_x : reg",
                    "c23_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c107_goal : regs_valid nil s0",
                    "c102_s0 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c105_goal : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c108_goal : tr_expr (st_code s') map nil b ns ?n1 x None",
                    "c109_goal : tr_exprlist (st_code s') map (cons x nil) e x2 x1 x0",
                    "c110_goal : eq (PTree.get ?n2 (st_code s')) (Some (Itailcall s (inl ?rf) ?rargs))"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c110_goal : eq (PTree.get ?n2 (st_code s')) (Some (Itailcall s (inl ?rf) ?rargs))",
                    "c102_EQ0 : eq (add_instr (Itailcall s (inl x) x0) s2) (RTLgen.OK x1 s3 INCR4)",
                    "c102_INCR5 : state_incr s3 s'",
                    "c23_s' : state",
                    "c7_s : signature"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c108_goal : tr_expr (st_code s') map nil b ns ?n1 x None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c111_goal : eq (transl_expr map b x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c112_goal : map_valid map s4",
                    "c113_goal : target_reg_ok map nil b x",
                    "c114_goal : regs_valid nil s4",
                    "c115_goal : reg_valid x s4"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c111_goal : eq (transl_expr map b x ?n1 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c102_EQ4 : eq (transl_expr map b x x2 s4) (RTLgen.OK ns s' INCR7)",
                    "c102_x : reg",
                    "c23_s' : state",
                    "c23_ns : node",
                    "c102_b : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c112_goal : map_valid map s4",
                    "c102_s4 : state",
                    "c23_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c113_goal : target_reg_ok map nil b x",
                    "c102_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c102_x : reg",
                    "c23_WF : map_valid map s1",
                    "c102_b : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c114_goal : regs_valid nil s4",
                    "c102_s4 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c115_goal : reg_valid x s4",
                    "c102_INCR9 : state_incr s0 s4",
                    "c102_s4 : state",
                    "c102_EQ : eq (alloc_reg map b s1) (RTLgen.OK x s0 INCR0)",
                    "c102_x : reg",
                    "c23_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c109_goal : tr_exprlist (st_code s') map (cons x nil) e x2 x1 x0",
                    "_global_tr_exprlist_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (pr : list reg) (al : exprlist) \n         (ns nd : node) (rl : list reg)\n         (_ : tr_exprlist (st_code s1) map pr al ns nd rl),\n       tr_exprlist (st_code s2) map pr al ns nd rl",
                    "c102_s4 : state"
                ],
                "tactic_res": [
                    "c116_goal : state_incr s4 s'",
                    "c117_goal : tr_exprlist (st_code s4) map (cons x nil) e x2 x1 x0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c116_goal : state_incr s4 s'",
                    "c102_s4 : state",
                    "c23_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c117_goal : tr_exprlist (st_code s4) map (cons x nil) e x2 x1 x0",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c118_goal : eq (transl_exprlist map e x0 x1 ?s) (RTLgen.OK x2 s4 ?INCR)",
                    "c119_goal : map_valid map s3",
                    "c120_goal : target_regs_ok map (cons x nil) e x0",
                    "c121_goal : regs_valid (cons x nil) s3",
                    "c122_goal : regs_valid x0 s3"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c118_goal : eq (transl_exprlist map e x0 x1 ?s) (RTLgen.OK x2 s4 ?INCR)",
                    "c102_EQ2 : eq (transl_exprlist map e x0 x1 s3) (RTLgen.OK x2 s4 INCR6)",
                    "c102_s4 : state",
                    "c102_x2 : node",
                    "c102_x1 : node",
                    "c102_x0 : list reg",
                    "c7_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c119_goal : map_valid map s3",
                    "c102_s3 : state",
                    "c23_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c120_goal : target_regs_ok map (cons x nil) e x0",
                    "c105_RV : regs_valid (cons x nil) s0",
                    "c102_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c102_x0 : list reg",
                    "c102_x : reg",
                    "c23_WF : map_valid map s1",
                    "c7_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c121_goal : regs_valid (cons x nil) s3",
                    "c105_RV : regs_valid (cons x nil) s0",
                    "c102_s3 : state",
                    "c102_x : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c122_goal : regs_valid x0 s3",
                    "c102_s3 : state",
                    "c102_EQ1 : eq (alloc_regs map e s0) (RTLgen.OK x0 s2 INCR2)",
                    "c102_x0 : list reg",
                    "c23_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c103_goal : tr_stmt (st_code s') map (Stailcall s (inr id) e) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c123_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "c124_goal : eq (PTree.get ?n2 (st_code s')) (Some (Itailcall s (inr id) ?rargs))"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c124_goal : eq (PTree.get ?n2 (st_code s')) (Some (Itailcall s (inr id) ?rargs))",
                    "c103_EQ1 : eq (add_instr (Itailcall s (inr id) x) s0) (RTLgen.OK x0 s2 INCR2)",
                    "c23_s' : state",
                    "c103_id : ident",
                    "c7_s : signature"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c123_goal : tr_exprlist (st_code s') map nil e ns x0 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c125_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c126_goal : map_valid map s2",
                    "c127_goal : target_regs_ok map nil e x",
                    "c128_goal : regs_valid nil s2",
                    "c129_goal : regs_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c125_goal : eq (transl_exprlist map e x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c103_EQ2 : eq (transl_exprlist map e x x0 s2) (RTLgen.OK ns s' INCR3)",
                    "c103_x0 : node",
                    "c103_x : list reg",
                    "c23_s' : state",
                    "c23_ns : node",
                    "c7_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c126_goal : map_valid map s2",
                    "c103_s2 : state",
                    "c23_WF : map_valid map s1",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c127_goal : target_regs_ok map nil e x",
                    "c103_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c103_x : list reg",
                    "c23_WF : map_valid map s1",
                    "c7_e : exprlist",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c128_goal : regs_valid nil s2",
                    "c103_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c129_goal : regs_valid x s2",
                    "c103_s2 : state",
                    "c103_EQ : eq (alloc_regs map e s1) (RTLgen.OK x s0 INCR0)",
                    "c103_x : list reg",
                    "c23_WF : map_valid map s1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c24_goal : tr_stmt (st_code s') map (Sbuiltin b e l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c130_goal : tr_exprlist (st_code s') map nil\n  (exprlist_of_expr_list (params_of_builtin_args l)) ns \n  ?n1 ?rargs",
                    "c131_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (convert_builtin_args l ?rargs) ?res' nd))",
                    "c132_goal : tr_builtin_res map b x0"
                ]
            },
            {
                "tactic_sig": "eauto 4 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 4 with rtlg .",
                "tactic_args": [
                    "c131_goal : eq (PTree.get ?n1 (st_code s'))\n  (Some (Ibuiltin e (convert_builtin_args l ?rargs) ?res' nd))",
                    "c24_EQ0 : eq (add_instr (Ibuiltin e (convert_builtin_args l x) x0 nd) s1)\n  (RTLgen.OK x1 s2 INCR4)",
                    "c24_s' : state",
                    "c24_nd : node",
                    "c8_l : list (builtin_arg expr)",
                    "c8_e : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c130_goal : tr_exprlist (st_code s') map nil\n  (exprlist_of_expr_list (params_of_builtin_args l)) ns x1 x",
                    "_global_transl_exprlist_charact : forall (al : exprlist) (map : mapping) (rl : list reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_exprlist map al rl nd s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_regs_ok map pr al rl)\n         (_ : regs_valid pr s) (_ : regs_valid rl s),\n       tr_exprlist (st_code s') map pr al ns nd rl"
                ],
                "tactic_res": [
                    "c133_goal : eq\n  (transl_exprlist map\n     (exprlist_of_expr_list (params_of_builtin_args l)) x x1 \n     ?s) (RTLgen.OK ns s' ?INCR)",
                    "c134_goal : map_valid map s2",
                    "c135_goal : target_regs_ok map nil\n  (exprlist_of_expr_list (params_of_builtin_args l)) x",
                    "c136_goal : regs_valid nil s2",
                    "c137_goal : regs_valid x s2"
                ]
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c133_goal : eq\n  (transl_exprlist map\n     (exprlist_of_expr_list (params_of_builtin_args l)) x x1 \n     ?s) (RTLgen.OK ns s' ?INCR)",
                    "c24_EQ3 : eq\n  (transl_exprlist map\n     (exprlist_of_expr_list (params_of_builtin_args l)) x x1 s2)\n  (RTLgen.OK ns s' INCR5)",
                    "c24_x1 : node",
                    "c24_x : list reg",
                    "c24_s' : state",
                    "c24_ns : node",
                    "c8_l : list (builtin_arg expr)",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c134_goal : map_valid map s2",
                    "c24_s2 : state",
                    "c24_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c135_goal : target_regs_ok map nil\n  (exprlist_of_expr_list (params_of_builtin_args l)) x",
                    "c24_EQ : eq\n  (alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s)\n  (RTLgen.OK x s0 INCR0)",
                    "c24_x : list reg",
                    "c24_WF : map_valid map s",
                    "c8_l : list (builtin_arg expr)",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c136_goal : regs_valid nil s2",
                    "c24_s2 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto 3 with rtlg .",
                "tactic_sig_no_out_arg": "eauto 3 with rtlg .",
                "tactic_args": [
                    "c137_goal : regs_valid x s2",
                    "c24_INCR6 : state_incr s0 s2",
                    "c24_s2 : state",
                    "c24_EQ : eq\n  (alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s)\n  (RTLgen.OK x s0 INCR0)",
                    "c24_x : list reg",
                    "c24_WF : map_valid map s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c132_goal : tr_builtin_res map b x0",
                    "_global_convert_builtin_res_charact : forall (map : mapping) (oty : xtype) (res0 : builtin_res ident)\n         (s : state) (res' : builtin_res reg) (s' : state)\n         (INCR : state_incr s s')\n         (_ : eq (convert_builtin_res map oty res0 s)\n                (RTLgen.OK res' s' INCR)) (_ : map_valid map s),\n       tr_builtin_res map res0 res'"
                ],
                "tactic_res": [
                    "c138_goal : eq (convert_builtin_res map ?oty b ?s) (RTLgen.OK x0 ?s' ?INCR)",
                    "c139_goal : map_valid map s0"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c138_goal : eq (convert_builtin_res map ?oty b ?s) (RTLgen.OK x0 ?s' ?INCR)",
                    "c24_EQ1 : eq (convert_builtin_res map (sig_res (ef_sig e)) b s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c24_x0 : builtin_res reg",
                    "c8_b : builtin_res ident",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c139_goal : map_valid map s0",
                    "c24_s0 : state",
                    "c24_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c25_goal : tr_stmt (st_code s') map (Sseq stmt1 stmt2) ns nd nexits ngoto nret\n  rret"
                ],
                "tactic_res": [
                    "c140_goal : tr_stmt (st_code s') map stmt2 ?n nd nexits ngoto nret rret",
                    "c141_goal : tr_stmt (st_code s') map stmt1 ns x nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c140_goal : tr_stmt (st_code s') map stmt2 ?n nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : stmt) (ns nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c25_s0 : state"
                ],
                "tactic_res": [
                    "c142_goal : state_incr s0 s'",
                    "c143_goal : tr_stmt (st_code s0) map stmt2 ?n nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c142_goal : state_incr s0 s'",
                    "c25_s0 : state",
                    "c25_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c143_goal : tr_stmt (st_code s0) map stmt2 ?n nd nexits ngoto nret rret",
                    "c9_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c144_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?n s0 ?INCR)",
                    "c145_goal : map_valid map s",
                    "c146_goal : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c144_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?n s0 ?INCR)",
                    "c25_EQ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c25_s0 : state",
                    "c25_rret : option reg",
                    "c25_nret : node",
                    "c25_ngoto : labelmap",
                    "c25_nexits : list node",
                    "c25_nd : node",
                    "c9_stmt2 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c145_goal : map_valid map s",
                    "c25_WF : map_valid map s",
                    "c25_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c146_goal : return_reg_ok s map rret",
                    "c25_OK : return_reg_ok s map rret",
                    "c25_s : state",
                    "c25_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c141_goal : tr_stmt (st_code s') map stmt1 ns x nexits ngoto nret rret",
                    "c9_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c147_goal : eq (transl_stmt map stmt1 x nexits ngoto nret rret ?s)\n  (RTLgen.OK ns s' ?INCR)",
                    "c148_goal : map_valid map s0",
                    "c149_goal : return_reg_ok s0 map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c147_goal : eq (transl_stmt map stmt1 x nexits ngoto nret rret ?s)\n  (RTLgen.OK ns s' ?INCR)",
                    "c25_EQ0 : eq (transl_stmt map stmt1 x nexits ngoto nret rret s0)\n  (RTLgen.OK ns s' INCR1)",
                    "c25_x : node",
                    "c25_s' : state",
                    "c25_ns : node",
                    "c25_rret : option reg",
                    "c25_nret : node",
                    "c25_ngoto : labelmap",
                    "c25_nexits : list node",
                    "c9_stmt1 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c148_goal : map_valid map s0",
                    "c25_s0 : state",
                    "c25_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c149_goal : return_reg_ok s0 map rret",
                    "c25_s0 : state",
                    "c25_OK : return_reg_ok s map rret",
                    "c25_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( more_likely _i _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( more_likely _i _i _i ) .",
                "tactic_args": [
                    "c26_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret",
                    "c10_c : condexpr",
                    "c10_stmt1 : CminorSel\\.stmt",
                    "c10_stmt2 : CminorSel\\.stmt",
                    "c26_OK : return_reg_ok s map rret",
                    "c26_WF : map_valid map s",
                    "c26_TR : eq\n  ((if more_likely c stmt1 stmt2\n    then\n     bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n       (fun nfalse : node =>\n        bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n          (fun ntrue : node => transl_condexpr map c ntrue nfalse))\n    else\n     bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n       (fun ntrue : node =>\n        bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n          (fun nfalse : node => transl_condexpr map c ntrue nfalse))) s)\n  (RTLgen.OK ns s' INCR)",
                    "c26_s' : state",
                    "c26_ns : node",
                    "c26_rret : option reg",
                    "c26_nret : node",
                    "c26_ngoto : labelmap",
                    "c26_nexits : list node",
                    "c26_nd : node",
                    "c10_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret",
                    "c10_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c150_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret",
                    "c150_TR : eq\n  (bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n     (fun nfalse : node =>\n      bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n        (fun ntrue : node => transl_condexpr map c ntrue nfalse)) s)\n  (RTLgen.OK ns s' INCR)",
                    "c151_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret",
                    "c151_TR : eq\n  (bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n     (fun ntrue : node =>\n      bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n        (fun nfalse : node => transl_condexpr map c ntrue nfalse)) s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c150_TR : eq\n  (bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n     (fun nfalse : node =>\n      bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n        (fun ntrue : node => transl_condexpr map c ntrue nfalse)) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c150_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c150_EQ1 : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c150_INCR3 : state_incr s1 s'",
                    "c150_INCR2 : state_incr s0 s1",
                    "c150_s1 : state",
                    "c150_x0 : node",
                    "c150_EQ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c150_INCR1 : state_incr s0 s'",
                    "c150_INCR0 : state_incr s s0",
                    "c150_s0 : state",
                    "c150_x : node"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c151_TR : eq\n  (bind (transl_stmt map stmt1 nd nexits ngoto nret rret)\n     (fun ntrue : node =>\n      bind (transl_stmt map stmt2 nd nexits ngoto nret rret)\n        (fun nfalse : node => transl_condexpr map c ntrue nfalse)) s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c151_EQ2 : eq (transl_condexpr map c x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c151_EQ1 : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c151_INCR3 : state_incr s1 s'",
                    "c151_INCR2 : state_incr s0 s1",
                    "c151_s1 : state",
                    "c151_x0 : node",
                    "c151_EQ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c151_INCR1 : state_incr s0 s'",
                    "c151_INCR0 : state_incr s s0",
                    "c151_s0 : state",
                    "c151_x : node"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c150_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c152_goal : tr_stmt (st_code s') map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "c153_goal : tr_stmt (st_code s') map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "c154_goal : tr_condition (st_code s') map nil c ns x0 x"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c152_goal : tr_stmt (st_code s') map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : stmt) (ns nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c150_s1 : state"
                ],
                "tactic_res": [
                    "c155_goal : state_incr s1 s'",
                    "c156_goal : tr_stmt (st_code s1) map stmt1 ?ntrue nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c155_goal : state_incr s1 s'",
                    "c150_s1 : state",
                    "c26_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c156_goal : tr_stmt (st_code s1) map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "c10_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c157_goal : eq (transl_stmt map stmt1 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?ntrue s1 ?INCR)",
                    "c158_goal : map_valid map s0",
                    "c159_goal : return_reg_ok s0 map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c157_goal : eq (transl_stmt map stmt1 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?ntrue s1 ?INCR)",
                    "c150_EQ1 : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c150_s1 : state",
                    "c26_rret : option reg",
                    "c26_nret : node",
                    "c26_ngoto : labelmap",
                    "c26_nexits : list node",
                    "c26_nd : node",
                    "c10_stmt1 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c158_goal : map_valid map s0",
                    "c150_s0 : state",
                    "c26_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c159_goal : return_reg_ok s0 map rret",
                    "c150_s0 : state",
                    "c26_OK : return_reg_ok s map rret",
                    "c26_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c153_goal : tr_stmt (st_code s') map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : stmt) (ns nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c150_s0 : state"
                ],
                "tactic_res": [
                    "c160_goal : state_incr s0 s'",
                    "c161_goal : tr_stmt (st_code s0) map stmt2 ?nfalse nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c160_goal : state_incr s0 s'",
                    "c150_INCR1 : state_incr s0 s'",
                    "c150_s0 : state",
                    "c26_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c161_goal : tr_stmt (st_code s0) map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "c10_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c162_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nfalse s0 ?INCR)",
                    "c163_goal : map_valid map s",
                    "c164_goal : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c162_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nfalse s0 ?INCR)",
                    "c150_EQ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c150_s0 : state",
                    "c26_rret : option reg",
                    "c26_nret : node",
                    "c26_ngoto : labelmap",
                    "c26_nexits : list node",
                    "c26_nd : node",
                    "c10_stmt2 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c163_goal : map_valid map s",
                    "c26_WF : map_valid map s",
                    "c26_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c164_goal : return_reg_ok s map rret",
                    "c26_OK : return_reg_ok s map rret",
                    "c26_s : state",
                    "c26_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c154_goal : tr_condition (st_code s') map nil c ns x0 x",
                    "_global_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node)\n         (s : state) (ns : node) (s' : state) (pr : list reg)\n         (INCR : state_incr s s')\n         (_ : eq (transl_condexpr map a ntrue nfalse s)\n                (RTLgen.OK ns s' INCR)) (_ : map_valid map s)\n         (_ : regs_valid pr s),\n       tr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c165_goal : eq (transl_condexpr map c x0 x ?s) (RTLgen.OK ns s' ?INCR)",
                    "c166_goal : map_valid map s1",
                    "c167_goal : regs_valid nil s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c165_goal : eq (transl_condexpr map c x0 x ?s) (RTLgen.OK ns s' ?INCR)",
                    "c150_EQ2 : eq (transl_condexpr map c x0 x s1) (RTLgen.OK ns s' INCR3)",
                    "c150_x0 : node",
                    "c150_x : node",
                    "c26_s' : state",
                    "c26_ns : node",
                    "c10_c : condexpr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c166_goal : map_valid map s1",
                    "c150_s1 : state",
                    "c26_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c167_goal : regs_valid nil s1",
                    "c150_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c151_goal : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto\n  nret rret"
                ],
                "tactic_res": [
                    "c168_goal : tr_stmt (st_code s') map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "c169_goal : tr_stmt (st_code s') map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "c170_goal : tr_condition (st_code s') map nil c ns x x0"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c168_goal : tr_stmt (st_code s') map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : stmt) (ns nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c151_s0 : state"
                ],
                "tactic_res": [
                    "c171_goal : state_incr s0 s'",
                    "c172_goal : tr_stmt (st_code s0) map stmt1 ?ntrue nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c171_goal : state_incr s0 s'",
                    "c151_INCR1 : state_incr s0 s'",
                    "c151_s0 : state",
                    "c26_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c172_goal : tr_stmt (st_code s0) map stmt1 ?ntrue nd nexits ngoto nret rret",
                    "c10_IHstmt1 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt1 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c173_goal : eq (transl_stmt map stmt1 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?ntrue s0 ?INCR)",
                    "c174_goal : map_valid map s",
                    "c175_goal : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c173_goal : eq (transl_stmt map stmt1 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?ntrue s0 ?INCR)",
                    "c151_EQ : eq (transl_stmt map stmt1 nd nexits ngoto nret rret s)\n  (RTLgen.OK x s0 INCR0)",
                    "c151_s0 : state",
                    "c26_rret : option reg",
                    "c26_nret : node",
                    "c26_ngoto : labelmap",
                    "c26_nexits : list node",
                    "c26_nd : node",
                    "c10_stmt1 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c174_goal : map_valid map s",
                    "c26_WF : map_valid map s",
                    "c26_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c175_goal : return_reg_ok s map rret",
                    "c26_OK : return_reg_ok s map rret",
                    "c26_s : state",
                    "c26_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c169_goal : tr_stmt (st_code s') map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : stmt) (ns nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c151_s1 : state"
                ],
                "tactic_res": [
                    "c176_goal : state_incr s1 s'",
                    "c177_goal : tr_stmt (st_code s1) map stmt2 ?nfalse nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c176_goal : state_incr s1 s'",
                    "c151_s1 : state",
                    "c26_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c177_goal : tr_stmt (st_code s1) map stmt2 ?nfalse nd nexits ngoto nret rret",
                    "c10_IHstmt2 : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt2 ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c178_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nfalse s1 ?INCR)",
                    "c179_goal : map_valid map s0",
                    "c180_goal : return_reg_ok s0 map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c178_goal : eq (transl_stmt map stmt2 nd nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nfalse s1 ?INCR)",
                    "c151_EQ1 : eq (transl_stmt map stmt2 nd nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c151_s1 : state",
                    "c26_rret : option reg",
                    "c26_nret : node",
                    "c26_ngoto : labelmap",
                    "c26_nexits : list node",
                    "c26_nd : node",
                    "c10_stmt2 : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c179_goal : map_valid map s0",
                    "c151_s0 : state",
                    "c26_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c180_goal : return_reg_ok s0 map rret",
                    "c151_s0 : state",
                    "c26_OK : return_reg_ok s map rret",
                    "c26_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c170_goal : tr_condition (st_code s') map nil c ns x x0",
                    "_global_transl_condexpr_charact : forall (a : condexpr) (map : mapping) (ntrue nfalse : node)\n         (s : state) (ns : node) (s' : state) (pr : list reg)\n         (INCR : state_incr s s')\n         (_ : eq (transl_condexpr map a ntrue nfalse s)\n                (RTLgen.OK ns s' INCR)) (_ : map_valid map s)\n         (_ : regs_valid pr s),\n       tr_condition (st_code s') map pr a ns ntrue nfalse"
                ],
                "tactic_res": [
                    "c181_goal : eq (transl_condexpr map c x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c182_goal : map_valid map s1",
                    "c183_goal : regs_valid nil s1"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c181_goal : eq (transl_condexpr map c x x0 ?s) (RTLgen.OK ns s' ?INCR)",
                    "c151_EQ2 : eq (transl_condexpr map c x x0 s1) (RTLgen.OK ns s' INCR3)",
                    "c151_x0 : node",
                    "c151_x : node",
                    "c26_s' : state",
                    "c26_ns : node",
                    "c10_c : condexpr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c182_goal : map_valid map s1",
                    "c151_s1 : state",
                    "c26_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c183_goal : regs_valid nil s1",
                    "c151_s1 : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c27_goal : tr_stmt (st_code s') map (Sloop stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c184_goal : tr_stmt (st_code s') map stmt ?nloop ?nend nexits ngoto nret rret",
                    "c185_goal : eq (PTree.get ns (st_code s')) (Some (Inop x0))",
                    "c186_goal : eq (PTree.get x (st_code s')) (Some (Inop x0))"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c184_goal : tr_stmt (st_code s') map stmt ?nloop ?nend nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : CminorSel.stmt) (ns nd : node)\n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c27_s1 : state"
                ],
                "tactic_res": [
                    "c187_goal : state_incr s1 s'",
                    "c188_goal : tr_stmt (st_code s1) map stmt ?nloop ?nend nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c187_goal : state_incr s1 s'",
                    "c27_INCR3 : state_incr s1 s'",
                    "c27_s1 : state",
                    "c27_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c188_goal : tr_stmt (st_code s1) map stmt ?nloop ?nend nexits ngoto nret rret",
                    "c11_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c189_goal : eq (transl_stmt map stmt ?nend nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nloop s1 ?INCR)",
                    "c190_goal : map_valid map s0",
                    "c191_goal : return_reg_ok s0 map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c189_goal : eq (transl_stmt map stmt ?nend nexits ngoto nret rret ?s)\n  (RTLgen.OK ?nloop s1 ?INCR)",
                    "c27_EQ1 : eq (transl_stmt map stmt x nexits ngoto nret rret s0)\n  (RTLgen.OK x0 s1 INCR2)",
                    "c27_s1 : state",
                    "c27_rret : option reg",
                    "c27_nret : node",
                    "c27_ngoto : labelmap",
                    "c27_nexits : list node",
                    "c2_stmt : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c190_goal : map_valid map s0",
                    "c27_s0 : state",
                    "c27_WF : map_valid map s",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c191_goal : return_reg_ok s0 map rret",
                    "c27_s0 : state",
                    "c27_OK : return_reg_ok s map rret",
                    "c27_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c185_goal : eq (PTree.get ns (st_code s')) (Some (Inop x0))",
                    "c27_EQ3 : eq (add_instr (Inop x0) s2) (RTLgen.OK ns s' INCR5)",
                    "c27_x0 : node",
                    "c27_s' : state",
                    "c27_ns : node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c186_goal : eq (PTree.get x (st_code s')) (Some (Inop x0))",
                    "c27_EQ0 : eq (update_instr x (Inop x0) s1) (RTLgen.OK x1 s2 INCR4)",
                    "c27_x0 : node",
                    "c27_x : node",
                    "c27_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c28_goal : tr_stmt (st_code s') map (Sblock stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c192_goal : tr_stmt (st_code s') map stmt ns nd (cons nd nexits) ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c192_goal : tr_stmt (st_code s') map stmt ns nd (cons nd nexits) ngoto nret rret",
                    "c12_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c193_goal : eq (transl_stmt map stmt nd (cons nd nexits) ngoto nret rret ?s)\n  (RTLgen.OK ns s' ?INCR)",
                    "c194_goal : map_valid map s",
                    "c195_goal : return_reg_ok s map rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c193_goal : eq (transl_stmt map stmt nd (cons nd nexits) ngoto nret rret ?s)\n  (RTLgen.OK ns s' ?INCR)",
                    "c28_TR : eq (transl_stmt map stmt nd (cons nd nexits) ngoto nret rret s)\n  (RTLgen.OK ns s' INCR)",
                    "c28_s' : state",
                    "c28_ns : node",
                    "c28_rret : option reg",
                    "c28_nret : node",
                    "c28_ngoto : labelmap",
                    "c28_nexits : list node",
                    "c28_nd : node",
                    "c2_stmt : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c194_goal : map_valid map s",
                    "c28_WF : map_valid map s",
                    "c28_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c195_goal : return_reg_ok s map rret",
                    "c28_OK : return_reg_ok s map rret",
                    "c28_s : state",
                    "c28_rret : option reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit transl_exit_charact .",
                "tactic_sig_no_out_arg": "exploit transl_exit_charact .",
                "tactic_args": [
                    "c29_goal : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c196_goal : eq (transl_exit ?Goal3 ?Goal4 ?Goal5) (RTLgen.OK ?Goal6 ?Goal7 ?Goal8)",
                    "c197_goal : forall\n  _ : and (eq (nth_error ?Goal3 ?Goal4) (Some ?Goal6))\n        (eq ?Goal7 ?Goal5),\ntr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c196_goal : eq (transl_exit ?Goal3 ?Goal4 ?Goal5) (RTLgen.OK ?Goal6 ?Goal7 ?Goal8)",
                    "c29_TR : eq (transl_exit nexits n s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c197_goal : forall _ : and (eq (nth_error nexits n) (Some ns)) (eq s' s),\ntr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c198_goal : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret",
                    "c198_A : eq (nth_error nexits n) (Some ns)",
                    "c198_B : eq s' s"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c198_goal : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c199_goal : eq (nth_error nexits n) (Some ns)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c199_goal : eq (nth_error nexits n) (Some ns)",
                    "c198_A : eq (nth_error nexits n) (Some ns)",
                    "c29_ns : node",
                    "c29_nexits : list node",
                    "c13_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c30_goal : tr_stmt (st_code s') map (Sswitch e) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c200_goal : tr_exitexpr (st_code s') map e ns nexits"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c200_goal : tr_exitexpr (st_code s') map e ns nexits",
                    "_global_transl_exitexpr_charact : forall (nexits : list node) (a : exitexpr) \n         (map : mapping) (s : state) (ns : node) (s' : state)\n         (INCR : state_incr s s')\n         (_ : eq (transl_exitexpr map a nexits s) (RTLgen.OK ns s' INCR))\n         (_ : map_valid map s), tr_exitexpr (st_code s') map a ns nexits"
                ],
                "tactic_res": [
                    "c201_goal : eq (transl_exitexpr map e nexits ?s) (RTLgen.OK ns s' ?INCR)",
                    "c202_goal : map_valid map s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c201_goal : eq (transl_exitexpr map e nexits ?s) (RTLgen.OK ns s' ?INCR)",
                    "c30_TR : eq (transl_exitexpr map e nexits s) (RTLgen.OK ns s' INCR)",
                    "c30_s' : state",
                    "c30_ns : node",
                    "c30_nexits : list node",
                    "c14_e : exitexpr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c202_goal : map_valid map s",
                    "c30_WF : map_valid map s",
                    "c30_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c31_goal : tr_stmt (st_code s') map (Sreturn o) ns nd nexits ngoto nret rret",
                    "c15_o : option expr",
                    "c31_OK : return_reg_ok s map rret",
                    "c31_WF : map_valid map s",
                    "c31_TR : eq\n  (match o with\n   | Some a =>\n       match rret with\n       | Some r => transl_expr map a r nret\n       | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n       end\n   | None => ret nret\n   end s) (RTLgen.OK ns s' INCR)",
                    "c31_s' : state",
                    "c31_ns : node",
                    "c31_rret : option reg",
                    "c31_nret : node",
                    "c31_ngoto : labelmap",
                    "c31_nexits : list node",
                    "c31_nd : node",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c203_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  rret",
                    "c203_TR : eq\n  (match rret with\n   | Some r => transl_expr map e r nret\n   | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n   end s) (RTLgen.OK ns s' INCR)",
                    "c203_e : expr",
                    "c204_goal : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto nret rret",
                    "c204_TR : eq (ret nret s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c203_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  rret",
                    "c31_rret : option reg",
                    "c31_OK : return_reg_ok s map rret",
                    "c31_WF : map_valid map s",
                    "c203_TR : eq\n  (match rret with\n   | Some r => transl_expr map e r nret\n   | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n   end s) (RTLgen.OK ns s' INCR)",
                    "c31_s' : state",
                    "c31_ns : node",
                    "c31_nret : node",
                    "c31_ngoto : labelmap",
                    "c31_nexits : list node",
                    "c31_nd : node",
                    "c203_e : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": [
                    "c205_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  (Some r)",
                    "c205_OK : return_reg_ok s map (Some r)",
                    "c205_TR : eq (transl_expr map e r nret s) (RTLgen.OK ns s' INCR)",
                    "c205_r : reg",
                    "c206_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  None",
                    "c206_OK : return_reg_ok s map None",
                    "c206_TR : eq (error (Errors.msg \"RTLgen: type mismatch on return\") s)\n  (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c205_TR : eq (transl_expr map e r nret s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c205_H0 : eq (transl_expr map e r nret s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c206_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  None",
                    "c206_TR : eq (error (Errors.msg \"RTLgen: type mismatch on return\") s)\n  (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c205_OK : return_reg_ok s map (Some r)"
                ],
                "tactic_res": [
                    "c205_H4 : reg_valid r s",
                    "c205_H1 : not (reg_in_map map r)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c205_goal : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret\n  (Some r)"
                ],
                "tactic_res": [
                    "c207_goal : tr_expr (st_code s') map nil e ns nret r None"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c207_goal : tr_expr (st_code s') map nil e ns nret r None",
                    "_global_transl_expr_charact : forall (a : expr) (map : mapping) (rd : reg) \n         (nd : node) (s : state) (ns : node) (s' : state) \n         (pr : list reg) (INCR : state_incr s s')\n         (_ : eq (transl_expr map a rd nd s) (OK ns s' INCR))\n         (_ : map_valid map s) (_ : target_reg_ok map pr a rd)\n         (_ : regs_valid pr s) (_ : reg_valid rd s),\n       tr_expr (st_code s') map pr a ns nd rd None"
                ],
                "tactic_res": [
                    "c208_goal : eq (transl_expr map e r nret ?s) (OK ns s' ?INCR)",
                    "c209_goal : map_valid map s",
                    "c210_goal : target_reg_ok map nil e r",
                    "c211_goal : regs_valid nil s",
                    "c212_goal : reg_valid r s"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c208_goal : eq (transl_expr map e r nret ?s) (OK ns s' ?INCR)",
                    "c205_H0 : eq (transl_expr map e r nret s) (RTLgen.OK ns s' INCR)",
                    "c31_s' : state",
                    "c31_ns : node",
                    "c205_r : reg",
                    "c31_nret : node",
                    "c203_e : expr",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c209_goal : map_valid map s",
                    "c31_WF : map_valid map s",
                    "c31_s : state",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c211_goal : regs_valid nil s",
                    "c31_s : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c212_goal : reg_valid r s",
                    "c205_H4 : reg_valid r s",
                    "c31_s : state",
                    "c205_r : reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c210_goal : target_reg_ok map nil e r"
                ],
                "tactic_res": [
                    "c213_goal : not (reg_in_map map r)",
                    "c214_goal : not (In r nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c213_goal : not (reg_in_map map r)",
                    "c205_H1 : not (reg_in_map map r)",
                    "c205_r : reg",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c214_goal : not (In r nil)"
                ],
                "tactic_res": [
                    "c215_goal : not False"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c215_goal : not False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c204_goal : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto nret rret",
                    "c204_TR : eq (ret nret s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c216_goal : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto ns rret",
                    "c216_INCR : state_incr s' s'",
                    "c216_WF : map_valid map s'",
                    "c216_OK : return_reg_ok s' map rret"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c216_goal : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto ns rret"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c32_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c32_EQ0 : eq\n  (match PTree.get l ngoto with\n   | Some n =>\n       bind\n         (handle_error (update_instr n (Inop x))\n            (error\n               (cons (Errors.MSG \"Multiply-defined label \")\n                  (cons (Errors.CTX l) nil)))) (fun _ : unit => ret x)\n   | None => error (Errors.msg \"RTLgen: unbound label\")\n   end s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c217_goal : forall\n  _ : eq\n        (match PTree.get l ngoto with\n         | Some n =>\n             bind\n               (handle_error (update_instr n (Inop x))\n                  (error\n                     (cons (Errors.MSG \"Multiply-defined label \")\n                        (cons (Errors.CTX l) nil))))\n               (fun _ : unit => ret x)\n         | None => error (Errors.msg \"RTLgen: unbound label\")\n         end s0) (RTLgen.OK ns s' INCR1),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c32_EQ0 : eq\n  (match PTree.get l ngoto with\n   | Some n =>\n       bind\n         (handle_error (update_instr n (Inop x))\n            (error\n               (cons (Errors.MSG \"Multiply-defined label \")\n                  (cons (Errors.CTX l) nil)))) (fun _ : unit => ret x)\n   | None => error (Errors.msg \"RTLgen: unbound label\")\n   end s0) (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case_eq ( ngoto!l ) .",
                "tactic_sig_no_out_arg": "case_eq ( ngoto!l ) .",
                "tactic_args": [
                    "c217_goal : forall\n  _ : eq\n        (match PTree.get l ngoto with\n         | Some n =>\n             bind\n               (handle_error (update_instr n (Inop x))\n                  (error\n                     (cons (Errors.MSG \"Multiply-defined label \")\n                        (cons (Errors.CTX l) nil))))\n               (fun _ : unit => ret x)\n         | None => error (Errors.msg \"RTLgen: unbound label\")\n         end s0) (RTLgen.OK ns s' INCR1),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c218_goal : forall (n : node) (_ : eq (PTree.get l ngoto) (Some n))\n  (_ : eq\n         (bind\n            (handle_error (update_instr n (Inop x))\n               (error\n                  (cons (Errors.MSG \"Multiply-defined label \")\n                     (cons (Errors.CTX l) nil))))\n            (fun _ : unit => ret x) s0) (RTLgen.OK ns s' INCR1)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c219_goal : forall (_ : eq (PTree.get l ngoto) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound label\") s0)\n         (RTLgen.OK ns s' INCR1)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c218_goal : forall (n : node) (_ : eq (PTree.get l ngoto) (Some n))\n  (_ : eq\n         (bind\n            (handle_error (update_instr n (Inop x))\n               (error\n                  (cons (Errors.MSG \"Multiply-defined label \")\n                     (cons (Errors.CTX l) nil))))\n            (fun _ : unit => ret x) s0) (RTLgen.OK ns s' INCR1)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c220_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c220_n : node",
                    "c220_H : eq (PTree.get l ngoto) (Some n)",
                    "c220_EQ0 : eq\n  (bind\n     (handle_error (update_instr n (Inop x))\n        (error\n           (cons (Errors.MSG \"Multiply-defined label \")\n              (cons (Errors.CTX l) nil)))) (fun _ : unit => ret x) s0)\n  (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c220_EQ0 : eq\n  (bind\n     (handle_error (update_instr n (Inop x))\n        (error\n           (cons (Errors.MSG \"Multiply-defined label \")\n              (cons (Errors.CTX l) nil)))) (fun _ : unit => ret x) s0)\n  (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": [
                    "c220_INCR3 : state_incr s' s'",
                    "c220_EQ1 : eq\n  (handle_error (update_instr n (Inop ns))\n     (error\n        (cons (Errors.MSG \"Multiply-defined label \")\n           (cons (Errors.CTX l) nil))) s0) (RTLgen.OK x0 s' INCR2)",
                    "c220_INCR2 : state_incr s0 s'",
                    "c220_x0 : unit",
                    "c220_EQ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s0 INCR0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c219_goal : forall (_ : eq (PTree.get l ngoto) None)\n  (_ : eq (error (Errors.msg \"RTLgen: unbound label\") s0)\n         (RTLgen.OK ns s' INCR1)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c221_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c221_H : eq (PTree.get l ngoto) None",
                    "c221_EQ0 : eq (error (Errors.msg \"RTLgen: unbound label\") s0)\n  (RTLgen.OK ns s' INCR1)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c221_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c221_EQ0 : eq (error (Errors.msg \"RTLgen: unbound label\") s0)\n  (RTLgen.OK ns s' INCR1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c220_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c220_EQ1 : eq\n  (handle_error (update_instr n (Inop ns))\n     (error\n        (cons (Errors.MSG \"Multiply-defined label \")\n           (cons (Errors.CTX l) nil))) s0) (RTLgen.OK x0 s' INCR2)"
                ],
                "tactic_res": [
                    "c222_goal : forall\n  _ : eq\n        (handle_error (update_instr n (Inop ns))\n           (error\n              (cons (Errors.MSG \"Multiply-defined label \")\n                 (cons (Errors.CTX l) nil))) s0)\n        (RTLgen.OK x0 s' INCR2),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c220_EQ1 : eq\n  (handle_error (update_instr n (Inop ns))\n     (error\n        (cons (Errors.MSG \"Multiply-defined label \")\n           (cons (Errors.CTX l) nil))) s0) (RTLgen.OK x0 s' INCR2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c222_goal : forall\n  _ : eq\n        (handle_error (update_instr n (Inop ns))\n           (error\n              (cons (Errors.MSG \"Multiply-defined label \")\n                 (cons (Errors.CTX l) nil))) s0)\n        (RTLgen.OK x0 s' INCR2),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "_global_handle_error : forall (_ : mon ?A) (_ : mon ?A), mon ?A\nwhere\n?A : [map : mapping\n      l : Cminor.label\n      stmt : stmt\n      IHstmt : forall (nd : node) (nexits : list node) \n                 (ngoto : labelmap) (nret : node) \n                 (rret : option reg) (s : state) (ns : node) \n                 (s' : state) (INCR : state_incr s s')\n                 (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n                        (OK ns s' INCR)) (_ : map_valid map s)\n                 (_ : return_reg_ok s map rret),\n               tr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret\n      nd : node\n      nexits : list node\n      ngoto : labelmap\n      nret : node\n      rret : option reg\n      s : state\n      ns : node\n      s' : state\n      INCR : state_incr s s'\n      WF : map_valid map s\n      OK : return_reg_ok s map rret\n      s0 : state\n      INCR0 : state_incr s s0\n      INCR1 : state_incr s0 s'\n      EQ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n             (RTLgen.OK ns s0 INCR0)\n      n : node\n      H : eq (PTree.get l ngoto) (Some n)\n      x0 : unit\n      INCR2 : state_incr s0 s'\n      INCR3 : state_incr s' s' |- Type]"
                ],
                "tactic_res": [
                    "c223_goal : forall\n  _ : eq\n        match update_instr n (Inop ns) s0 with\n        | Error _ =>\n            error\n              (cons (Errors.MSG \"Multiply-defined label \")\n                 (cons (Errors.CTX l) nil)) s0\n        | OK a s' i => RTLgen.OK a s' i\n        end (RTLgen.OK x0 s' INCR2),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "case_eq ( update_instr _i ( Inop _i ) _i ) .",
                "tactic_sig_no_out_arg": "case_eq ( update_instr _i ( Inop _i ) _i ) .",
                "tactic_args": [
                    "c223_goal : forall\n  _ : eq\n        match update_instr n (Inop ns) s0 with\n        | Error _ =>\n            error\n              (cons (Errors.MSG \"Multiply-defined label \")\n                 (cons (Errors.CTX l) nil)) s0\n        | OK a s' i => RTLgen.OK a s' i\n        end (RTLgen.OK x0 s' INCR2),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c220_n : node",
                    "c32_ns : node",
                    "c32_s0 : state"
                ],
                "tactic_res": [
                    "c224_goal : forall (e : Errors.errmsg)\n  (_ : eq (update_instr n (Inop ns) s0) (Error e))\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"Multiply-defined label \")\n               (cons (Errors.CTX l) nil)) s0) (RTLgen.OK x0 s' INCR2)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c225_goal : forall (u : unit) (s'0 : state) (s : state_incr s0 s'0)\n  (_ : eq (update_instr n (Inop ns) s0) (RTLgen.OK u s'0 s))\n  (_ : eq (RTLgen.OK u s'0 s) (RTLgen.OK x0 s' INCR2)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c224_goal : forall (e : Errors.errmsg)\n  (_ : eq (update_instr n (Inop ns) s0) (Error e))\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"Multiply-defined label \")\n               (cons (Errors.CTX l) nil)) s0) (RTLgen.OK x0 s' INCR2)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c226_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c226_e : Errors\\.errmsg",
                    "c226_H0 : eq (update_instr n (Inop ns) s0) (Error e)",
                    "c226_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"Multiply-defined label \")\n        (cons (Errors.CTX l) nil)) s0) (RTLgen.OK x0 s' INCR2)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c226_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c226_EQ1 : eq\n  (error\n     (cons (Errors.MSG \"Multiply-defined label \")\n        (cons (Errors.CTX l) nil)) s0) (RTLgen.OK x0 s' INCR2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c225_goal : forall (u : unit) (s'0 : state) (s : state_incr s0 s'0)\n  (_ : eq (update_instr n (Inop ns) s0) (RTLgen.OK u s'0 s))\n  (_ : eq (RTLgen.OK u s'0 s) (RTLgen.OK x0 s' INCR2)),\ntr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c227_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret",
                    "c227_u : unit",
                    "c227_s'0 : state",
                    "c227_s1 : state_incr s0 s'0",
                    "c227_H0 : eq (update_instr n (Inop ns) s0) (RTLgen.OK u s'0 s1)",
                    "c227_EQ1 : eq (RTLgen.OK u s'0 s1) (RTLgen.OK x0 s' INCR2)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c227_EQ1 : eq (RTLgen.OK u s'0 s1) (RTLgen.OK x0 s' INCR2)"
                ],
                "tactic_res": [
                    "c227_H0 : eq (update_instr n (Inop ns) s0) (RTLgen.OK x0 s' s1)",
                    "c227_s1 : state_incr s0 s'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c227_goal : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c228_goal : eq (PTree.get l ngoto) (Some ?n)",
                    "c229_goal : eq (PTree.get n (st_code s')) (Some (Inop ns))",
                    "c230_goal : tr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c228_goal : eq (PTree.get l ngoto) (Some ?n)",
                    "c220_H : eq (PTree.get l ngoto) (Some n)",
                    "c32_ngoto : labelmap",
                    "c16_l : Cminor\\.label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c229_goal : eq (PTree.get n (st_code s')) (Some (Inop ns))",
                    "c227_H0 : eq (update_instr n (Inop ns) s0) (RTLgen.OK x0 s' s1)",
                    "c220_n : node",
                    "c32_s' : state",
                    "c32_ns : node"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with _i .",
                "tactic_sig_no_out_arg": "eapply _i with _i .",
                "tactic_args": [
                    "c230_goal : tr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "_global_tr_stmt_incr : forall (s1 s2 : state) (_ : state_incr s1 s2) \n         (map : mapping) (s : CminorSel.stmt) (ns nd : node)\n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg)\n         (_ : tr_stmt (st_code s1) map s ns nd nexits ngoto nret rret),\n       tr_stmt (st_code s2) map s ns nd nexits ngoto nret rret",
                    "c32_s0 : state"
                ],
                "tactic_res": [
                    "c231_goal : state_incr s0 s'",
                    "c232_goal : tr_stmt (st_code s0) map stmt ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c231_goal : state_incr s0 s'",
                    "c32_s0 : state",
                    "c32_s' : state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c232_goal : tr_stmt (st_code s0) map stmt ns nd nexits ngoto nret rret",
                    "c220_EQ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n  (RTLgen.OK ns s0 INCR0)",
                    "c32_s0 : state",
                    "c32_OK : return_reg_ok s map rret",
                    "c32_WF : map_valid map s",
                    "c32_ns : node",
                    "c32_rret : option reg",
                    "c32_nret : node",
                    "c32_ngoto : labelmap",
                    "c32_nexits : list node",
                    "c32_nd : node",
                    "c16_IHstmt : forall (nd : node) (nexits : list node) (ngoto : labelmap)\n  (nret : node) (rret : option reg) (s : state) (ns : node)\n  (s' : state) (INCR : state_incr s s')\n  (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n         (OK ns s' INCR)) (_ : map_valid map s)\n  (_ : return_reg_ok s map rret),\ntr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret",
                    "c2_stmt : CminorSel\\.stmt",
                    "c2_map : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c33_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c33_TR : eq\n  (match PTree.get l ngoto with\n   | Some n => ret n\n   | None =>\n       error\n         (cons (Errors.MSG \"Undefined defined label \")\n            (cons (Errors.CTX l) nil))\n   end s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c233_goal : forall\n  _ : eq\n        (match PTree.get l ngoto with\n         | Some n => ret n\n         | None =>\n             error\n               (cons (Errors.MSG \"Undefined defined label \")\n                  (cons (Errors.CTX l) nil))\n         end s) (RTLgen.OK ns s' INCR),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c33_TR : eq\n  (match PTree.get l ngoto with\n   | Some n => ret n\n   | None =>\n       error\n         (cons (Errors.MSG \"Undefined defined label \")\n            (cons (Errors.CTX l) nil))\n   end s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case_eq ( ngoto!l ) .",
                "tactic_sig_no_out_arg": "case_eq ( ngoto!l ) .",
                "tactic_args": [
                    "c233_goal : forall\n  _ : eq\n        (match PTree.get l ngoto with\n         | Some n => ret n\n         | None =>\n             error\n               (cons (Errors.MSG \"Undefined defined label \")\n                  (cons (Errors.CTX l) nil))\n         end s) (RTLgen.OK ns s' INCR),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c234_goal : forall (n : node) (_ : eq (PTree.get l ngoto) (Some n))\n  (_ : eq (ret n s) (RTLgen.OK ns s' INCR)),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c235_goal : forall (_ : eq (PTree.get l ngoto) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"Undefined defined label \")\n               (cons (Errors.CTX l) nil)) s) (RTLgen.OK ns s' INCR)),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c234_goal : forall (n : node) (_ : eq (PTree.get l ngoto) (Some n))\n  (_ : eq (ret n s) (RTLgen.OK ns s' INCR)),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c236_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c236_n : node",
                    "c236_H : eq (PTree.get l ngoto) (Some n)",
                    "c236_TR : eq (ret n s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c236_TR : eq (ret n s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": [
                    "c236_H : eq (PTree.get l ngoto) (Some ns)",
                    "c236_INCR : state_incr s' s'",
                    "c236_WF : map_valid map s'",
                    "c236_OK : return_reg_ok s' map rret"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c235_goal : forall (_ : eq (PTree.get l ngoto) None)\n  (_ : eq\n         (error\n            (cons (Errors.MSG \"Undefined defined label \")\n               (cons (Errors.CTX l) nil)) s) (RTLgen.OK ns s' INCR)),\ntr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c237_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c237_H : eq (PTree.get l ngoto) None",
                    "c237_TR : eq\n  (error\n     (cons (Errors.MSG \"Undefined defined label \")\n        (cons (Errors.CTX l) nil)) s) (RTLgen.OK ns s' INCR)"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c237_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret",
                    "c237_TR : eq\n  (error\n     (cons (Errors.MSG \"Undefined defined label \")\n        (cons (Errors.CTX l) nil)) s) (RTLgen.OK ns s' INCR)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c236_goal : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c238_goal : eq (PTree.get l ngoto) (Some ns)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c238_goal : eq (PTree.get l ngoto) (Some ns)",
                    "c236_H : eq (PTree.get l ngoto) (Some ns)",
                    "c33_ns : node",
                    "c33_ngoto : labelmap",
                    "c17_l : Cminor\\.label"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transl_function_charact",
        "proof": [
            {
                "tactic_sig": "Lemma transl_function_charact : forall f tf , transl_function f = Errors.OK tf -> tr_function f tf .",
                "tactic_sig_no_out_arg": "Lemma transl_function_charact : forall f tf , transl_function f = Errors.OK tf -> tr_function f tf .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (f : CminorSel.function) (tf : function)\n  (_ : eq (transl_function f) (Errors.OK tf)), tr_function f tf"
                ]
            },
            {
                "tactic_sig": "intros until _o .",
                "tactic_sig_no_out_arg": "intros until tf .",
                "tactic_args": [
                    "c1_goal : forall (f : CminorSel.function) (tf : function)\n  (_ : eq (transl_function f) (Errors.OK tf)), tr_function f tf"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (transl_function f) (Errors.OK tf), tr_function f tf",
                    "c2_tf : function",
                    "c2_f : CminorSel\\.function"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (transl_function f) (Errors.OK tf), tr_function f tf",
                    "_global_transl_function : forall _ : CminorSel.function, Errors.res function"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : eq\n        match transl_fun f init_state with\n        | Error msg => Errors.Error msg\n        | OK (pair nentry rparams) s _ =>\n            Errors.OK\n              {|\n                fn_sig := CminorSel.fn_sig f;\n                fn_params := rparams;\n                fn_stacksize := fn_stackspace f;\n                fn_code := st_code s;\n                fn_entrypoint := nentry\n              |}\n        end (Errors.OK tf), tr_function f tf"
                ]
            },
            {
                "tactic_sig": "caseEq ( transl_fun _i init_state ) .",
                "tactic_sig_no_out_arg": "caseEq ( transl_fun _i init_state ) .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : eq\n        match transl_fun f init_state with\n        | Error msg => Errors.Error msg\n        | OK (pair nentry rparams) s _ =>\n            Errors.OK\n              {|\n                fn_sig := CminorSel.fn_sig f;\n                fn_params := rparams;\n                fn_stacksize := fn_stackspace f;\n                fn_code := st_code s;\n                fn_entrypoint := nentry\n              |}\n        end (Errors.OK tf), tr_function f tf",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": [
                    "c4_goal : forall (e : Errors.errmsg) (_ : eq (transl_fun f init_state) (Error e))\n  (_ : eq (Errors.Error e) (Errors.OK tf)), tr_function f tf",
                    "c5_goal : forall (p : prod node (list reg)) (s' : state)\n  (s : state_incr init_state s')\n  (_ : eq (transl_fun f init_state) (OK p s' s))\n  (_ : eq\n         (let (nentry, rparams) := p in\n          Errors.OK\n            {|\n              fn_sig := CminorSel.fn_sig f;\n              fn_params := rparams;\n              fn_stacksize := fn_stackspace f;\n              fn_code := st_code s';\n              fn_entrypoint := nentry\n            |}) (Errors.OK tf)), tr_function f tf"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : forall (e : Errors.errmsg) (_ : eq (transl_fun f init_state) (Error e))\n  (_ : eq (Errors.Error e) (Errors.OK tf)), tr_function f tf"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ nentry rparams ] sfinal INCR TR E .",
                "tactic_args": [
                    "c5_goal : forall (p : prod node (list reg)) (s' : state)\n  (s : state_incr init_state s')\n  (_ : eq (transl_fun f init_state) (OK p s' s))\n  (_ : eq\n         (let (nentry, rparams) := p in\n          Errors.OK\n            {|\n              fn_sig := CminorSel.fn_sig f;\n              fn_params := rparams;\n              fn_stacksize := fn_stackspace f;\n              fn_code := st_code s';\n              fn_entrypoint := nentry\n            |}) (Errors.OK tf)), tr_function f tf"
                ],
                "tactic_res": [
                    "c6_goal : tr_function f tf",
                    "c6_nentry : node",
                    "c6_rparams : list reg",
                    "c6_sfinal : state",
                    "c6_INCR : state_incr init_state sfinal",
                    "c6_TR : eq (transl_fun f init_state) (OK (pair nentry rparams) sfinal INCR)",
                    "c6_E : eq\n  (Errors.OK\n     {|\n       fn_sig := CminorSel.fn_sig f;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f;\n       fn_code := st_code sfinal;\n       fn_entrypoint := nentry\n     |}) (Errors.OK tf)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : tr_function f tf",
                    "c6_E : eq\n  (Errors.OK\n     {|\n       fn_sig := CminorSel.fn_sig f;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f;\n       fn_code := st_code sfinal;\n       fn_entrypoint := nentry\n     |}) (Errors.OK tf)"
                ],
                "tactic_res": [
                    "c7_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c6_TR : eq (transl_fun f init_state) (OK (pair nentry rparams) sfinal INCR)"
                ],
                "tactic_res": [
                    "c7_INCR11 : state_incr sfinal sfinal",
                    "c7_EQ4 : eq\n  (transl_stmt x3 (fn_body f) x5 nil x x5\n     (ret_reg (CminorSel.fn_sig f) x4) s3) (OK nentry sfinal INCR10)",
                    "c7_INCR10 : state_incr s3 sfinal",
                    "c7_EQ3 : eq (add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2)\n  (OK x5 s3 INCR8)",
                    "c7_INCR9 : state_incr s3 sfinal",
                    "c7_INCR8 : state_incr s2 s3",
                    "c7_s3 : state",
                    "c7_x5 : node",
                    "c7_EQ2 : eq (new_reg s1) (OK x4 s2 INCR6)",
                    "c7_INCR7 : state_incr s2 sfinal",
                    "c7_INCR6 : state_incr s1 s2",
                    "c7_s2 : state",
                    "c7_x4 : reg",
                    "c7_EQ0 : eq (add_vars x1 (fn_vars f) s0) (OK (pair x2 x3) s1 INCR4)",
                    "c7_INCR5 : state_incr s1 sfinal",
                    "c7_INCR4 : state_incr s0 s1",
                    "c7_s1 : state",
                    "c7_x3 : mapping",
                    "c7_x2 : list reg",
                    "c7_EQ1 : eq (add_vars init_mapping (CminorSel.fn_params f) s)\n  (OK (pair rparams x1) s0 INCR2)",
                    "c7_INCR3 : state_incr s0 sfinal",
                    "c7_INCR2 : state_incr s s0",
                    "c7_s0 : state",
                    "c7_x1 : mapping",
                    "c7_EQ : eq (reserve_labels (fn_body f) (PTree.empty node) init_state)\n  (OK x s INCR0)",
                    "c7_INCR1 : state_incr s sfinal",
                    "c7_INCR0 : state_incr init_state s",
                    "c7_s : state",
                    "c7_x : labelmap"
                ]
            },
            {
                "tactic_sig": "exploit add_vars_valid .",
                "tactic_sig_no_out_arg": "exploit add_vars_valid .",
                "tactic_args": [
                    "c7_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ],
                "tactic_res": [
                    "c8_goal : eq (add_vars ?Goal2 ?Goal ?Goal0)\n  (OK (pair ?Goal4 ?Goal3) ?Goal1 ?Goal5)",
                    "c9_goal : map_valid init_mapping s",
                    "c10_goal : forall _ : and (regs_valid rparams s0) (map_valid x1 s0),\ntr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c8_goal : eq (add_vars ?Goal2 ?Goal ?Goal0)\n  (OK (pair ?Goal4 ?Goal3) ?Goal1 ?Goal5)",
                    "c7_EQ1 : eq (add_vars init_mapping (CminorSel.fn_params f) s)\n  (OK (pair rparams x1) s0 INCR2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : map_valid init_mapping s",
                    "_global_init_mapping_valid : forall s : state, map_valid init_mapping s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c10_goal : forall _ : and (regs_valid rparams s0) (map_valid x1 s0),\ntr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ],
                "tactic_res": [
                    "c11_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}",
                    "c11_A : regs_valid rparams s0",
                    "c11_B : map_valid x1 s0"
                ]
            },
            {
                "tactic_sig": "exploit add_vars_valid .",
                "tactic_sig_no_out_arg": "exploit add_vars_valid .",
                "tactic_args": [
                    "c11_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ],
                "tactic_res": [
                    "c12_goal : eq (add_vars ?Goal2 ?Goal ?Goal0)\n  (OK (pair ?Goal4 ?Goal3) ?Goal1 ?Goal5)",
                    "c13_goal : map_valid x1 s0",
                    "c14_goal : forall _ : and (regs_valid x2 s1) (map_valid x3 s1),\ntr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c12_goal : eq (add_vars ?Goal2 ?Goal ?Goal0)\n  (OK (pair ?Goal4 ?Goal3) ?Goal1 ?Goal5)",
                    "c7_EQ0 : eq (add_vars x1 (fn_vars f) s0) (OK (pair x2 x3) s1 INCR4)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : map_valid x1 s0",
                    "c11_B : map_valid x1 s0",
                    "c7_s0 : state",
                    "c7_x1 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ C D ] .",
                "tactic_args": [
                    "c14_goal : forall _ : and (regs_valid x2 s1) (map_valid x3 s1),\ntr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}"
                ],
                "tactic_res": [
                    "c15_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}",
                    "c15_C : regs_valid x2 s1",
                    "c15_D : map_valid x3 s1"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c15_goal : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}",
                    "_global_tr_function_intro : forall (f : CminorSel.function) (code : code) \n         (rparams : list reg) (map1 : mapping) (s0 s1 : state)\n         (i1 : state_incr s0 s1) (rvars : list reg) \n         (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2)\n         (nentry : node) (ngoto : labelmap) (nret : node) \n         (rret : reg) (orret : option reg)\n         (_ : eq (add_vars init_mapping (CminorSel.fn_params f) s0)\n                (OK (pair rparams map1) s1 i1))\n         (_ : eq (add_vars map1 (fn_vars f) s1) (OK (pair rvars map2) s2 i2))\n         (_ : eq orret (ret_reg (CminorSel.fn_sig f) rret))\n         (_ : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret)\n         (_ : eq (PTree.get nret code) (Some (Ireturn orret))),\n       tr_function f\n         {|\n           fn_sig := CminorSel.fn_sig f;\n           fn_params := rparams;\n           fn_stacksize := fn_stackspace f;\n           fn_code := code;\n           fn_entrypoint := nentry\n         |}"
                ],
                "tactic_res": [
                    "c16_goal : eq (add_vars init_mapping (CminorSel.fn_params f) ?s0)\n  (OK (pair rparams ?map1) ?s1 ?i1)",
                    "c17_goal : eq (add_vars x1 (fn_vars f) s0) (OK (pair ?rvars ?map2) ?s2 ?i2)",
                    "c18_goal : eq ?orret (ret_reg (CminorSel.fn_sig f) ?rret)",
                    "c19_goal : tr_stmt (st_code sfinal) x3 (fn_body f) nentry x5 nil \n  ?ngoto x5 (ret_reg (CminorSel.fn_sig f) x4)",
                    "c20_goal : eq (PTree.get ?nret (st_code sfinal)) (Some (Ireturn ?orret))"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c16_goal : eq (add_vars init_mapping (CminorSel.fn_params f) ?s0)\n  (OK (pair rparams ?map1) ?s1 ?i1)",
                    "c7_EQ1 : eq (add_vars init_mapping (CminorSel.fn_params f) s)\n  (OK (pair rparams x1) s0 INCR2)",
                    "c6_rparams : list reg",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c17_goal : eq (add_vars x1 (fn_vars f) s0) (OK (pair ?rvars ?map2) ?s2 ?i2)",
                    "c7_EQ0 : eq (add_vars x1 (fn_vars f) s0) (OK (pair x2 x3) s1 INCR4)",
                    "c7_s0 : state",
                    "c7_x1 : mapping",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c18_goal : eq ?orret (ret_reg (CminorSel.fn_sig f) ?rret)",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c20_goal : eq (PTree.get ?nret (st_code sfinal))\n  (Some (Ireturn (ret_reg (CminorSel.fn_sig f) ?rret)))",
                    "c7_EQ3 : eq (add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2)\n  (OK x5 s3 INCR8)",
                    "c6_sfinal : state",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c19_goal : tr_stmt (st_code sfinal) x3 (fn_body f) nentry x5 nil \n  ?ngoto x5 (ret_reg (CminorSel.fn_sig f) x4)",
                    "_global_transl_stmt_charact : forall (map : mapping) (stmt : stmt) (nd : node) \n         (nexits : list node) (ngoto : labelmap) (nret : node)\n         (rret : option reg) (s : state) (ns : node) \n         (s' : state) (INCR : state_incr s s')\n         (_ : eq (transl_stmt map stmt nd nexits ngoto nret rret s)\n                (OK ns s' INCR)) (_ : map_valid map s)\n         (_ : return_reg_ok s map rret),\n       tr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret"
                ],
                "tactic_res": [
                    "c21_goal : eq\n  (transl_stmt x3 (fn_body f) x5 nil ?ngoto x5\n     (ret_reg (CminorSel.fn_sig f) x4) ?s) (OK nentry sfinal ?INCR)",
                    "c22_goal : map_valid x3 s3",
                    "c23_goal : return_reg_ok s3 x3 (ret_reg (CminorSel.fn_sig f) x4)"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c21_goal : eq\n  (transl_stmt x3 (fn_body f) x5 nil ?ngoto x5\n     (ret_reg (CminorSel.fn_sig f) x4) ?s) (OK nentry sfinal ?INCR)",
                    "c7_EQ4 : eq\n  (transl_stmt x3 (fn_body f) x5 nil x x5\n     (ret_reg (CminorSel.fn_sig f) x4) s3) (OK nentry sfinal INCR10)",
                    "c7_x5 : node",
                    "c7_x4 : reg",
                    "c7_x3 : mapping",
                    "c6_sfinal : state",
                    "c6_nentry : node",
                    "c2_f : CminorSel\\.function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c22_goal : map_valid x3 s3",
                    "c15_D : map_valid x3 s1",
                    "c7_s3 : state",
                    "c7_x3 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c23_goal : return_reg_ok s3 x3 (ret_reg (CminorSel.fn_sig f) x4)",
                    "_global_ret_reg : forall (_ : signature) (_ : reg), option reg"
                ],
                "tactic_res": [
                    "c24_goal : return_reg_ok s3 x3\n  (if xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid\n   then None\n   else Some x4)"
                ]
            },
            {
                "tactic_sig": "destruct ( xtype_eq ( sig_res ( CminorSel.fn_sig _i ) ) Xvoid ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( xtype_eq ( sig_res ( CminorSel.fn_sig _i ) ) Xvoid ) .",
                "tactic_args": [
                    "c24_goal : return_reg_ok s3 x3\n  (if xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid\n   then None\n   else Some x4)",
                    "c2_f : CminorSel\\.function",
                    "c15_D : map_valid x3 s1",
                    "c15_C : regs_valid x2 s1",
                    "c11_B : map_valid x1 s0",
                    "c11_A : regs_valid rparams s0",
                    "c7_INCR11 : state_incr sfinal sfinal",
                    "c7_EQ4 : eq\n  (transl_stmt x3 (fn_body f) x5 nil x x5\n     (ret_reg (CminorSel.fn_sig f) x4) s3) (OK nentry sfinal INCR10)",
                    "c7_EQ3 : eq (add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2)\n  (OK x5 s3 INCR8)",
                    "c7_INCR9 : state_incr s3 sfinal",
                    "c7_s3 : state",
                    "c7_EQ2 : eq (new_reg s1) (OK x4 s2 INCR6)",
                    "c7_INCR7 : state_incr s2 sfinal",
                    "c7_x4 : reg",
                    "c7_EQ0 : eq (add_vars x1 (fn_vars f) s0) (OK (pair x2 x3) s1 INCR4)",
                    "c7_INCR5 : state_incr s1 sfinal",
                    "c7_x3 : mapping",
                    "c7_EQ1 : eq (add_vars init_mapping (CminorSel.fn_params f) s)\n  (OK (pair rparams x1) s0 INCR2)",
                    "c7_INCR3 : state_incr s0 sfinal",
                    "c7_EQ : eq (reserve_labels (fn_body f) (PTree.empty node) init_state)\n  (OK x s INCR0)",
                    "c7_INCR1 : state_incr s sfinal",
                    "c6_INCR : state_incr init_state sfinal"
                ],
                "tactic_res": [
                    "c25_goal : return_reg_ok s3 x3 None",
                    "c25_e : eq (sig_res (CminorSel.fn_sig f)) Xvoid",
                    "c26_goal : return_reg_ok s3 x3 (Some x4)",
                    "c26_n : not (eq (sig_res (CminorSel.fn_sig f)) Xvoid)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c25_goal : return_reg_ok s3 x3 None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c26_goal : return_reg_ok s3 x3 (Some x4)"
                ],
                "tactic_res": [
                    "c27_goal : not (reg_in_map x3 x4)",
                    "c28_goal : reg_valid x4 s3"
                ]
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c27_goal : not (reg_in_map x3 x4)",
                    "c15_D : map_valid x3 s1",
                    "c7_EQ2 : eq (new_reg s1) (OK x4 s2 INCR6)",
                    "c7_x4 : reg",
                    "c7_x3 : mapping"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with rtlg .",
                "tactic_sig_no_out_arg": "eauto with rtlg .",
                "tactic_args": [
                    "c28_goal : reg_valid x4 s3",
                    "c7_s3 : state",
                    "c7_EQ2 : eq (new_reg s1) (OK x4 s2 INCR6)",
                    "c7_x4 : reg"
                ],
                "tactic_res": []
            }
        ]
    }
]