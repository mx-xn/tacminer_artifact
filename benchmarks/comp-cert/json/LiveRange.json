[
    {
        "lemma_name": "transf_program_match",
        "proof": [
            {
                "tactic_sig": "Lemma transf_program_match : forall p tp , transf_program p = OK tp -> match_prog p tp .",
                "tactic_sig_no_out_arg": "Lemma transf_program_match : forall p tp , transf_program p = OK tp -> match_prog p tp .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p tp : program) (_ : eq (transf_program p) (OK tp)),\nmatch_prog p tp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (p tp : program) (_ : eq (transf_program p) (OK tp)),\nmatch_prog p tp"
                ],
                "tactic_res": [
                    "c2_goal : match_prog p tp",
                    "c2_p : program",
                    "c2_tp : program",
                    "c2_H : eq (transf_program p) (OK tp)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c2_goal : match_prog p tp",
                    "_global_match_transform_partial_program : forall (transf_fun : forall _ : unit, res ?B)\n         (p0 : AST.program unit unit) (tp0 : AST.program ?B unit)\n         (_ : eq (transform_partial_program transf_fun p0) (OK tp0)),\n       match_program\n         (fun (_ : AST.program unit unit) (f : unit) (tf : ?B) =>\n          eq (transf_fun f) (OK tf)) eq p0 tp0\nwhere\n?B : [p : program  tp : program  H : eq (transf_program p) (OK tp) |- Type]"
                ],
                "tactic_res": [
                    "c3_goal : eq (transform_partial_program transf_fundef p) (OK tp)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c3_goal : eq (transform_partial_program transf_fundef p) (OK tp)",
                    "c2_H : eq (transf_program p) (OK tp)",
                    "c2_p : program",
                    "c2_tp : program"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "diff_same",
        "proof": [
            {
                "tactic_sig": "Remark diff_same : forall s , diff s s = nil .",
                "tactic_sig_no_out_arg": "Remark diff_same : forall s , diff s s = nil .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall s : avail, eq (diff s s) nil"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro s .",
                "tactic_args": [
                    "c1_goal : forall s : avail, eq (diff s s) nil"
                ],
                "tactic_res": [
                    "c2_goal : eq (diff s s) nil",
                    "c2_s : avail"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v i ] _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v i ] _i ] .",
                "tactic_args": [
                    "c2_goal : eq (diff s s) nil",
                    "c2_s : avail",
                    "c2_s : avail"
                ],
                "tactic_res": [
                    "c3_goal : eq (diff nil nil) nil",
                    "c4_goal : eq (diff (cons (pair v i) s) (cons (pair v i) s)) nil",
                    "c4_IHs : eq (diff s s) nil",
                    "c4_s : list (prod ident debuginfo)",
                    "c4_i : debuginfo",
                    "c4_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (diff nil nil) nil"
                ],
                "tactic_res": [
                    "c5_goal : eq nil nil"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (diff (cons (pair v i) s) (cons (pair v i) s)) nil"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  match Pos.compare v v with\n  | Eq =>\n      if eq_debuginfo i i then diff s s else cons (pair v i) (diff s s)\n  | Lt => cons (pair v i) (diff s (cons (pair v i) s))\n  | Gt =>\n      (fix diff2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => cons (pair v i) s\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then diff s s2'\n                 else cons (pair v i) (diff s s2')\n             | Lt => cons (pair v i) (diff s s2)\n             | Gt => diff2 s2'\n             end\n         end) s\n  end nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq\n  match Pos.compare v v with\n  | Eq =>\n      if eq_debuginfo i i then diff s s else cons (pair v i) (diff s s)\n  | Lt => cons (pair v i) (diff s (cons (pair v i) s))\n  | Gt =>\n      (fix diff2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => cons (pair v i) s\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then diff s s2'\n                 else cons (pair v i) (diff s s2')\n             | Lt => cons (pair v i) (diff s s2)\n             | Gt => diff2 s2'\n             end\n         end) s\n  end nil",
                    "_global_Pos.compare_refl : forall x : positive, eq (Pos.compare x x) Eq"
                ],
                "tactic_res": [
                    "c7_goal : eq (if eq_debuginfo i i then diff s s else cons (pair v i) (diff s s))\n  nil"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (if eq_debuginfo i i then diff s s else cons (pair v i) (diff s s))\n  nil",
                    "_global_dec_eq_true : forall (A : Type)\n         (dec_eq : forall x y : A, sumbool (eq x y) (not (eq x y)))\n         (B : Type) (x : A) (ifso ifnot : B),\n       eq (if dec_eq x x then ifso else ifnot) ifso"
                ],
                "tactic_res": [
                    "c8_goal : eq (diff s s) nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (diff s s) nil",
                    "c4_IHs : eq (diff s s) nil",
                    "c4_s : list (prod ident debuginfo)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "delta_state_same",
        "proof": [
            {
                "tactic_sig": "Remark delta_state_same : forall s , delta_state s s = ( nil , nil ) .",
                "tactic_sig_no_out_arg": "Remark delta_state_same : forall s , delta_state s s = ( nil , nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall s : option avail, eq (delta_state s s) (pair nil nil)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro s .",
                "tactic_args": [
                    "c1_goal : forall s : option avail, eq (delta_state s s) (pair nil nil)"
                ],
                "tactic_res": [
                    "c2_goal : eq (delta_state s s) (pair nil nil)",
                    "c2_s : option avail"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : eq (delta_state s s) (pair nil nil)",
                    "c2_s : option avail"
                ],
                "tactic_res": [
                    "c3_goal : eq (delta_state (Some a) (Some a)) (pair nil nil)",
                    "c3_a : avail",
                    "c4_goal : eq (delta_state None None) (pair nil nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (delta_state (Some a) (Some a)) (pair nil nil)"
                ],
                "tactic_res": [
                    "c5_goal : eq (pair (diff a a) (diff a a)) (pair nil nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (delta_state None None) (pair nil nil)"
                ],
                "tactic_res": [
                    "c6_goal : eq (pair nil nil) (pair nil nil)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c5_goal : eq (pair (diff a a) (diff a a)) (pair nil nil)",
                    "_global_diff_same : forall s : avail, eq (diff s s) nil"
                ],
                "tactic_res": [
                    "c7_goal : eq (pair nil nil) (pair nil nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (pair nil nil) (pair nil nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (pair nil nil) (pair nil nil)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_code_match",
        "proof": [
            {
                "tactic_sig": "Lemma transf_code_match : forall lm c before , match_code c ( transf_code lm before c ) .",
                "tactic_sig_no_out_arg": "Lemma transf_code_match : forall lm c before , match_code c ( transf_code lm before c ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lm : labelmap) (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros lm .",
                "tactic_args": [
                    "c1_goal : forall (lm : labelmap) (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)"
                ],
                "tactic_res": [
                    "c2_goal : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)",
                    "c2_lm : labelmap"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros c .",
                "tactic_args": [
                    "c2_goal : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)"
                ],
                "tactic_res": [
                    "c3_goal : forall before : option avail, match_code c (transf_code lm before c)",
                    "c3_c : code"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : forall before : option avail, match_code c (transf_code lm before c)",
                    "c3_c : code",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)",
                    "c2_lm : labelmap"
                ],
                "tactic_res": [
                    "c4_goal : forall before : option avail,\nmatch_code nil (transf_code lm before nil)",
                    "c5_goal : forall before : option avail,\nmatch_code (cons i c) (transf_code lm before (cons i c))",
                    "c5_c : list instruction",
                    "c5_i : instruction"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros before .",
                "tactic_args": [
                    "c4_goal : forall before : option avail,\nmatch_code nil (transf_code lm before nil)"
                ],
                "tactic_res": [
                    "c6_goal : match_code nil (transf_code lm before nil)",
                    "c6_before : option avail"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : match_code nil (transf_code lm before nil)"
                ],
                "tactic_res": [
                    "c7_goal : match_code nil nil"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros before .",
                "tactic_args": [
                    "c5_goal : forall before : option avail,\nmatch_code (cons i c) (transf_code lm before (cons i c))"
                ],
                "tactic_res": [
                    "c8_goal : match_code (cons i c) (transf_code lm before (cons i c))",
                    "c8_before : option avail"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : match_code (cons i c) (transf_code lm before (cons i c))"
                ],
                "tactic_res": [
                    "c9_goal : match_code (cons i c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | cons (Llabel lbl2) c' =>\n          cons (Lgoto lbl1)\n            (cons (Llabel lbl2)\n               (add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')))\n      | _ =>\n          cons i\n            (add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c)\n                  c))\n      end\n  | _ =>\n      cons i\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c))\n  end"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : match_code nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( DEFAULT : forall _i after , match_code ( _i :: _i ) ( _i :: add_delta_ranges _i after ( transf_code _i after _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( DEFAULT : forall _i after , match_code ( _i :: _i ) ( _i :: add_delta_ranges _i after ( transf_code _i after _i ) ) ) .",
                "tactic_args": [
                    "c9_goal : match_code (cons i c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | cons (Llabel lbl2) c' =>\n          cons (Lgoto lbl1)\n            (cons (Llabel lbl2)\n               (add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')))\n      | _ =>\n          cons i\n            (add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c)\n                  c))\n      end\n  | _ =>\n      cons i\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c))\n  end",
                    "c8_before : option avail",
                    "c5_i : instruction",
                    "c5_c : list instruction",
                    "c5_i : instruction",
                    "c8_before : option avail",
                    "c2_lm : labelmap",
                    "c5_c : list instruction"
                ],
                "tactic_res": [
                    "c10_goal : forall before after : option avail,\nmatch_code (cons i c)\n  (cons i (add_delta_ranges before after (transf_code lm after c)))",
                    "c11_goal : match_code (cons i c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | cons (Llabel lbl2) c' =>\n          cons (Lgoto lbl1)\n            (cons (Llabel lbl2)\n               (add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')))\n      | _ =>\n          cons i\n            (add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c)\n                  c))\n      end\n  | _ =>\n      cons i\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c))\n  end",
                    "c11_DEFAULT : forall before after : option avail,\nmatch_code (cons i c)\n  (cons i (add_delta_ranges before after (transf_code lm after c)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall before after : option avail,\nmatch_code (cons i c)\n  (cons i (add_delta_ranges before after (transf_code lm after c)))"
                ],
                "tactic_res": [
                    "c12_goal : match_code (cons i c)\n  (cons i (add_delta_ranges before0 after (transf_code lm after c)))",
                    "c12_before0 : option avail",
                    "c12_after : option avail"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : match_code (cons i c)\n  (cons i (add_delta_ranges before0 after (transf_code lm after c)))"
                ],
                "tactic_res": [
                    "c13_goal : match_code c (transf_code lm after c)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : match_code c (transf_code lm after c)",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o | _o _o _o | _o _o _o _o | _o _o | _o _o | _o _o _o _o | _o _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c11_goal : match_code (cons i c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | cons (Llabel lbl2) c' =>\n          cons (Lgoto lbl1)\n            (cons (Llabel lbl2)\n               (add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')))\n      | _ =>\n          cons i\n            (add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c)\n                  c))\n      end\n  | _ =>\n      cons i\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c))\n  end",
                    "c5_i : instruction",
                    "c11_DEFAULT : forall before after : option avail,\nmatch_code (cons i c)\n  (cons i (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)",
                    "c2_lm : labelmap"
                ],
                "tactic_res": [
                    "c14_goal : match_code (cons (Lgetstack s z t m) c)\n  (cons (Lgetstack s z t m)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lgetstack s z t m))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lgetstack s z t m))) c) c)))",
                    "c14_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgetstack s z t m) c)\n  (cons (Lgetstack s z t m)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c14_m : mreg",
                    "c14_t : typ",
                    "c14_z : Z",
                    "c14_s : slot",
                    "c15_goal : match_code (cons (Lsetstack m s z t) c)\n  (cons (Lsetstack m s z t)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lsetstack m s z t))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lsetstack m s z t))) c) c)))",
                    "c15_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lsetstack m s z t) c)\n  (cons (Lsetstack m s z t)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c15_t : typ",
                    "c15_z : Z",
                    "c15_s : slot",
                    "c15_m : mreg",
                    "c16_goal : match_code (cons (Lop o l m) c)\n  (cons (Lop o l m)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lop o l m))) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lop o l m)))\n              c) c)))",
                    "c16_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lop o l m) c)\n  (cons (Lop o l m)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c16_m : mreg",
                    "c16_l : list mreg",
                    "c16_o : operation",
                    "c17_goal : match_code (cons (Lload m a l m0) c)\n  (cons (Lload m a l m0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lload m a l m0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lload m a l m0))) c) c)))",
                    "c17_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lload m a l m0) c)\n  (cons (Lload m a l m0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c17_m0 : mreg",
                    "c17_l : list mreg",
                    "c17_a : addressing",
                    "c17_m : memory_chunk",
                    "c18_goal : match_code (cons (Lstore m a l m0) c)\n  (cons (Lstore m a l m0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lstore m a l m0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lstore m a l m0))) c) c)))",
                    "c18_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lstore m a l m0) c)\n  (cons (Lstore m a l m0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c18_m0 : mreg",
                    "c18_l : list mreg",
                    "c18_a : addressing",
                    "c18_m : memory_chunk",
                    "c19_goal : match_code (cons (Lcall s s0) c)\n  (cons (Lcall s s0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lcall s s0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lcall s s0))) c) c)))",
                    "c19_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lcall s s0) c)\n  (cons (Lcall s s0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c19_s0 : sum mreg ident",
                    "c19_s : signature",
                    "c20_goal : match_code (cons (Ltailcall s s0) c)\n  (cons (Ltailcall s s0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Ltailcall s s0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Ltailcall s s0))) c) c)))",
                    "c20_DEFAULT : forall before after : option avail,\nmatch_code (cons (Ltailcall s s0) c)\n  (cons (Ltailcall s s0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c20_s0 : sum mreg ident",
                    "c20_s : signature",
                    "c21_goal : match_code (cons (Lbuiltin e l b) c)\n  (cons (Lbuiltin e l b)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lbuiltin e l b))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lbuiltin e l b))) c) c)))",
                    "c21_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lbuiltin e l b) c)\n  (cons (Lbuiltin e l b)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c21_b : builtin_res mreg",
                    "c21_l : list (builtin_arg loc)",
                    "c21_e : external_function",
                    "c22_goal : match_code (cons (Llabel l) c)\n  (cons (Llabel l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Llabel l))) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Llabel l)))\n              c) c)))",
                    "c22_DEFAULT : forall before after : option avail,\nmatch_code (cons (Llabel l) c)\n  (cons (Llabel l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c22_l : label",
                    "c23_goal : match_code (cons (Lgoto l) c)\n  match c with\n  | cons (Llabel lbl2) c' =>\n      cons (Lgoto l)\n        (cons (Llabel lbl2)\n           (add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c')))\n  | _ =>\n      cons (Lgoto l)\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c)\n           (transf_code lm\n              (skip_debug_setvar lm\n                 (snd (transfer lm before (Lgoto l))) c) c))\n  end",
                    "c23_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) c)\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c23_l : label",
                    "c24_goal : match_code (cons (Lcond c0 l l0) c)\n  (cons (Lcond c0 l l0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lcond c0 l l0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lcond c0 l l0))) c) c)))",
                    "c24_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lcond c0 l l0) c)\n  (cons (Lcond c0 l l0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c24_l0 : label",
                    "c24_l : list mreg",
                    "c24_c0 : condition",
                    "c25_goal : match_code (cons (Ljumptable m l) c)\n  (cons (Ljumptable m l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Ljumptable m l))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Ljumptable m l))) c) c)))",
                    "c25_DEFAULT : forall before after : option avail,\nmatch_code (cons (Ljumptable m l) c)\n  (cons (Ljumptable m l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c25_l : list label",
                    "c25_m : mreg",
                    "c26_goal : match_code (cons Lreturn c)\n  (cons Lreturn\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before Lreturn)) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before Lreturn)) c)\n           c)))",
                    "c26_DEFAULT : forall before after : option avail,\nmatch_code (cons Lreturn c)\n  (cons Lreturn\n     (add_delta_ranges before after (transf_code lm after c)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : match_code (cons (Lgetstack s z t m) c)\n  (cons (Lgetstack s z t m)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lgetstack s z t m))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lgetstack s z t m))) c) c)))",
                    "c14_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgetstack s z t m) c)\n  (cons (Lgetstack s z t m)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c14_m : mreg",
                    "c14_t : typ",
                    "c14_z : Z",
                    "c14_s : slot",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : match_code (cons (Lsetstack m s z t) c)\n  (cons (Lsetstack m s z t)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lsetstack m s z t))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lsetstack m s z t))) c) c)))",
                    "c15_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lsetstack m s z t) c)\n  (cons (Lsetstack m s z t)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c15_t : typ",
                    "c15_z : Z",
                    "c15_s : slot",
                    "c15_m : mreg",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : match_code (cons (Lop o l m) c)\n  (cons (Lop o l m)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lop o l m))) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lop o l m)))\n              c) c)))",
                    "c16_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lop o l m) c)\n  (cons (Lop o l m)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c16_m : mreg",
                    "c16_l : list mreg",
                    "c16_o : operation",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : match_code (cons (Lload m a l m0) c)\n  (cons (Lload m a l m0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lload m a l m0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lload m a l m0))) c) c)))",
                    "c17_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lload m a l m0) c)\n  (cons (Lload m a l m0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c17_m0 : mreg",
                    "c17_l : list mreg",
                    "c17_a : addressing",
                    "c17_m : memory_chunk",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : match_code (cons (Lstore m a l m0) c)\n  (cons (Lstore m a l m0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lstore m a l m0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lstore m a l m0))) c) c)))",
                    "c18_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lstore m a l m0) c)\n  (cons (Lstore m a l m0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c18_m0 : mreg",
                    "c18_l : list mreg",
                    "c18_a : addressing",
                    "c18_m : memory_chunk",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : match_code (cons (Lcall s s0) c)\n  (cons (Lcall s s0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lcall s s0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lcall s s0))) c) c)))",
                    "c19_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lcall s s0) c)\n  (cons (Lcall s s0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c19_s0 : sum mreg ident",
                    "c19_s : signature",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : match_code (cons (Ltailcall s s0) c)\n  (cons (Ltailcall s s0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Ltailcall s s0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Ltailcall s s0))) c) c)))",
                    "c20_DEFAULT : forall before after : option avail,\nmatch_code (cons (Ltailcall s s0) c)\n  (cons (Ltailcall s s0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c20_s0 : sum mreg ident",
                    "c20_s : signature",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : match_code (cons (Lbuiltin e l b) c)\n  (cons (Lbuiltin e l b)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lbuiltin e l b))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lbuiltin e l b))) c) c)))",
                    "c21_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lbuiltin e l b) c)\n  (cons (Lbuiltin e l b)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c21_b : builtin_res mreg",
                    "c21_l : list (builtin_arg loc)",
                    "c21_e : external_function",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : match_code (cons (Llabel l) c)\n  (cons (Llabel l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Llabel l))) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Llabel l)))\n              c) c)))",
                    "c22_DEFAULT : forall before after : option avail,\nmatch_code (cons (Llabel l) c)\n  (cons (Llabel l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c22_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : match_code (cons (Lcond c0 l l0) c)\n  (cons (Lcond c0 l l0)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Lcond c0 l l0))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Lcond c0 l l0))) c) c)))",
                    "c24_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lcond c0 l l0) c)\n  (cons (Lcond c0 l l0)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c24_l0 : label",
                    "c24_l : list mreg",
                    "c24_c0 : condition",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : match_code (cons (Ljumptable m l) c)\n  (cons (Ljumptable m l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm\n           (snd (transfer lm before (Ljumptable m l))) c)\n        (transf_code lm\n           (skip_debug_setvar lm\n              (snd (transfer lm before (Ljumptable m l))) c) c)))",
                    "c25_DEFAULT : forall before after : option avail,\nmatch_code (cons (Ljumptable m l) c)\n  (cons (Ljumptable m l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c25_l : list label",
                    "c25_m : mreg",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : match_code (cons Lreturn c)\n  (cons Lreturn\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before Lreturn)) c)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before Lreturn)) c)\n           c)))",
                    "c26_DEFAULT : forall before after : option avail,\nmatch_code (cons Lreturn c)\n  (cons Lreturn\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c23_goal : match_code (cons (Lgoto l) c)\n  match c with\n  | cons (Llabel lbl2) c' =>\n      cons (Lgoto l)\n        (cons (Llabel lbl2)\n           (add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c')))\n  | _ =>\n      cons (Lgoto l)\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c)\n           (transf_code lm\n              (skip_debug_setvar lm\n                 (snd (transfer lm before (Lgoto l))) c) c))\n  end",
                    "c5_c : list instruction",
                    "c23_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) c)\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after c)))",
                    "c8_before : option avail",
                    "c23_l : label",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)",
                    "c2_lm : labelmap"
                ],
                "tactic_res": [
                    "c27_goal : match_code (cons (Lgoto l) nil)\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) nil)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              nil) nil)))",
                    "c27_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) nil)\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after nil)))",
                    "c28_goal : match_code (cons (Lgoto l) (cons i c))\n  match i with\n  | Llabel lbl2 =>\n      cons (Lgoto l)\n        (cons (Llabel lbl2)\n           (add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c)))\n  | _ =>\n      cons (Lgoto l)\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons i c))\n           (transf_code lm\n              (skip_debug_setvar lm\n                 (snd (transfer lm before (Lgoto l))) \n                 (cons i c)) (cons i c)))\n  end",
                    "c28_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons i c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after (cons i c))))",
                    "c28_i : instruction"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : match_code (cons (Lgoto l) nil)\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) nil)\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              nil) nil)))",
                    "c27_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) nil)\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after nil)))",
                    "c8_before : option avail",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o | _o _o _o | _o _o _o _o | _o _o | _o _o | _o _o _o _o | _o _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c28_goal : match_code (cons (Lgoto l) (cons i c))\n  match i with\n  | Llabel lbl2 =>\n      cons (Lgoto l)\n        (cons (Llabel lbl2)\n           (add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c)))\n  | _ =>\n      cons (Lgoto l)\n        (add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons i c))\n           (transf_code lm\n              (skip_debug_setvar lm\n                 (snd (transfer lm before (Lgoto l))) \n                 (cons i c)) (cons i c)))\n  end",
                    "c28_i : instruction",
                    "c28_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons i c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after (transf_code lm after (cons i c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c23_l : label",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)",
                    "c2_lm : labelmap"
                ],
                "tactic_res": [
                    "c29_goal : match_code (cons (Lgoto l) (cons (Lgetstack s z t m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lgetstack s z t m) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lgetstack s z t m) c))\n           (cons (Lgetstack s z t m) c))))",
                    "c29_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lgetstack s z t m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lgetstack s z t m) c))))",
                    "c29_m : mreg",
                    "c29_t : typ",
                    "c29_z : Z",
                    "c29_s : slot",
                    "c30_goal : match_code (cons (Lgoto l) (cons (Lsetstack m s z t) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lsetstack m s z t) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lsetstack m s z t) c))\n           (cons (Lsetstack m s z t) c))))",
                    "c30_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lsetstack m s z t) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lsetstack m s z t) c))))",
                    "c30_t : typ",
                    "c30_z : Z",
                    "c30_s : slot",
                    "c30_m : mreg",
                    "c31_goal : match_code (cons (Lgoto l) (cons (Lop o l0 m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lop o l0 m) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lop o l0 m) c)) (cons (Lop o l0 m) c))))",
                    "c31_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lop o l0 m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lop o l0 m) c))))",
                    "c31_m : mreg",
                    "c31_l0 : list mreg",
                    "c31_o : operation",
                    "c32_goal : match_code (cons (Lgoto l) (cons (Lload m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lload m a l0 m0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lload m a l0 m0) c)) (cons (Lload m a l0 m0) c))))",
                    "c32_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lload m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lload m a l0 m0) c))))",
                    "c32_m0 : mreg",
                    "c32_l0 : list mreg",
                    "c32_a : addressing",
                    "c32_m : memory_chunk",
                    "c33_goal : match_code (cons (Lgoto l) (cons (Lstore m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lstore m a l0 m0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lstore m a l0 m0) c)) (cons (Lstore m a l0 m0) c))))",
                    "c33_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lstore m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lstore m a l0 m0) c))))",
                    "c33_m0 : mreg",
                    "c33_l0 : list mreg",
                    "c33_a : addressing",
                    "c33_m : memory_chunk",
                    "c34_goal : match_code (cons (Lgoto l) (cons (Lcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lcall s s0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lcall s s0) c)) (cons (Lcall s s0) c))))",
                    "c34_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lcall s s0) c))))",
                    "c34_s0 : sum mreg ident",
                    "c34_s : signature",
                    "c35_goal : match_code (cons (Lgoto l) (cons (Ltailcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Ltailcall s s0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Ltailcall s s0) c)) (cons (Ltailcall s s0) c))))",
                    "c35_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Ltailcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Ltailcall s s0) c))))",
                    "c35_s0 : sum mreg ident",
                    "c35_s : signature",
                    "c36_goal : match_code (cons (Lgoto l) (cons (Lbuiltin e l0 b) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lbuiltin e l0 b) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lbuiltin e l0 b) c)) (cons (Lbuiltin e l0 b) c))))",
                    "c36_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lbuiltin e l0 b) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lbuiltin e l0 b) c))))",
                    "c36_b : builtin_res mreg",
                    "c36_l0 : list (builtin_arg loc)",
                    "c36_e : external_function",
                    "c37_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l)\n     (cons (Llabel l0)\n        (add_delta_ranges before (get_label l0 lm)\n           (transf_code lm (get_label l0 lm) c))))",
                    "c37_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Llabel l0) c))))",
                    "c37_l0 : label",
                    "c38_goal : match_code (cons (Lgoto l) (cons (Lgoto l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lgoto l0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lgoto l0) c)) (cons (Lgoto l0) c))))",
                    "c38_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lgoto l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lgoto l0) c))))",
                    "c38_l0 : label",
                    "c39_goal : match_code (cons (Lgoto l) (cons (Lcond c0 l0 l1) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lcond c0 l0 l1) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lcond c0 l0 l1) c)) (cons (Lcond c0 l0 l1) c))))",
                    "c39_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lcond c0 l0 l1) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lcond c0 l0 l1) c))))",
                    "c39_l1 : label",
                    "c39_l0 : list mreg",
                    "c39_c0 : condition",
                    "c40_goal : match_code (cons (Lgoto l) (cons (Ljumptable m l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Ljumptable m l0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Ljumptable m l0) c)) (cons (Ljumptable m l0) c))))",
                    "c40_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Ljumptable m l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Ljumptable m l0) c))))",
                    "c40_l0 : list label",
                    "c40_m : mreg",
                    "c41_goal : match_code (cons (Lgoto l) (cons Lreturn c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons Lreturn c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons Lreturn c)) (cons Lreturn c))))",
                    "c41_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons Lreturn c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons Lreturn c))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : match_code (cons (Lgoto l) (cons (Lgetstack s z t m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lgetstack s z t m) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lgetstack s z t m) c))\n           (cons (Lgetstack s z t m) c))))",
                    "c29_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lgetstack s z t m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lgetstack s z t m) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c29_m : mreg",
                    "c29_t : typ",
                    "c29_z : Z",
                    "c29_s : slot",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : match_code (cons (Lgoto l) (cons (Lsetstack m s z t) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lsetstack m s z t) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lsetstack m s z t) c))\n           (cons (Lsetstack m s z t) c))))",
                    "c30_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lsetstack m s z t) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lsetstack m s z t) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c30_t : typ",
                    "c30_z : Z",
                    "c30_s : slot",
                    "c30_m : mreg",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : match_code (cons (Lgoto l) (cons (Lop o l0 m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lop o l0 m) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lop o l0 m) c)) (cons (Lop o l0 m) c))))",
                    "c31_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lop o l0 m) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lop o l0 m) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c31_m : mreg",
                    "c31_l0 : list mreg",
                    "c31_o : operation",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : match_code (cons (Lgoto l) (cons (Lload m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lload m a l0 m0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lload m a l0 m0) c)) (cons (Lload m a l0 m0) c))))",
                    "c32_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lload m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lload m a l0 m0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c32_m0 : mreg",
                    "c32_l0 : list mreg",
                    "c32_a : addressing",
                    "c32_m : memory_chunk",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : match_code (cons (Lgoto l) (cons (Lstore m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lstore m a l0 m0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lstore m a l0 m0) c)) (cons (Lstore m a l0 m0) c))))",
                    "c33_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lstore m a l0 m0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lstore m a l0 m0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c33_m0 : mreg",
                    "c33_l0 : list mreg",
                    "c33_a : addressing",
                    "c33_m : memory_chunk",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : match_code (cons (Lgoto l) (cons (Lcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lcall s s0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lcall s s0) c)) (cons (Lcall s s0) c))))",
                    "c34_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lcall s s0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c34_s0 : sum mreg ident",
                    "c34_s : signature",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : match_code (cons (Lgoto l) (cons (Ltailcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Ltailcall s s0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Ltailcall s s0) c)) (cons (Ltailcall s s0) c))))",
                    "c35_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Ltailcall s s0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Ltailcall s s0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c35_s0 : sum mreg ident",
                    "c35_s : signature",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : match_code (cons (Lgoto l) (cons (Lbuiltin e l0 b) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lbuiltin e l0 b) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lbuiltin e l0 b) c)) (cons (Lbuiltin e l0 b) c))))",
                    "c36_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lbuiltin e l0 b) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lbuiltin e l0 b) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c36_b : builtin_res mreg",
                    "c36_l0 : list (builtin_arg loc)",
                    "c36_e : external_function",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : match_code (cons (Lgoto l) (cons (Lgoto l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lgoto l0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lgoto l0) c)) (cons (Lgoto l0) c))))",
                    "c38_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lgoto l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lgoto l0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c23_l : label",
                    "c38_l0 : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : match_code (cons (Lgoto l) (cons (Lcond c0 l0 l1) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Lcond c0 l0 l1) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Lcond c0 l0 l1) c)) (cons (Lcond c0 l0 l1) c))))",
                    "c39_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Lcond c0 l0 l1) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Lcond c0 l0 l1) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c39_l1 : label",
                    "c39_l0 : list mreg",
                    "c39_c0 : condition",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : match_code (cons (Lgoto l) (cons (Ljumptable m l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons (Ljumptable m l0) c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons (Ljumptable m l0) c)) (cons (Ljumptable m l0) c))))",
                    "c40_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons (Ljumptable m l0) c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons (Ljumptable m l0) c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c40_l0 : list label",
                    "c40_m : mreg",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : match_code (cons (Lgoto l) (cons Lreturn c))\n  (cons (Lgoto l)\n     (add_delta_ranges before\n        (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n           (cons Lreturn c))\n        (transf_code lm\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (cons Lreturn c)) (cons Lreturn c))))",
                    "c41_DEFAULT : forall before after : option avail,\nmatch_code (cons (Lgoto l) (cons Lreturn c))\n  (cons (Lgoto l)\n     (add_delta_ranges before after\n        (transf_code lm after (cons Lreturn c))))",
                    "c8_before : option avail",
                    "c5_c : list instruction",
                    "c23_l : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( after := get_label _i _i ) .",
                "tactic_sig_no_out_arg": "set ( after := get_label _i _i ) .",
                "tactic_args": [
                    "c37_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l)\n     (cons (Llabel l0)\n        (add_delta_ranges before (get_label l0 lm)\n           (transf_code lm (get_label l0 lm) c))))",
                    "c37_l0 : label",
                    "c2_lm : labelmap"
                ],
                "tactic_res": [
                    "c42_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l)\n     (cons (Llabel l0)\n        (add_delta_ranges before after (transf_code lm after c))))",
                    "c42_after : option avail"
                ]
            },
            {
                "tactic_sig": "set ( c1 := Llabel _i :: add_delta_ranges _i _i ( transf_code _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "set ( c1 := Llabel _i :: add_delta_ranges _i _i ( transf_code _i _i _i ) ) .",
                "tactic_args": [
                    "c42_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l)\n     (cons (Llabel l0)\n        (add_delta_ranges before after (transf_code lm after c))))",
                    "c37_l0 : label",
                    "c8_before : option avail",
                    "c42_after : option avail",
                    "c2_lm : labelmap",
                    "c42_after : option avail",
                    "c5_c : list instruction"
                ],
                "tactic_res": [
                    "c43_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c)) (cons (Lgoto l) c1)",
                    "c43_c1 : list instruction"
                ]
            },
            {
                "tactic_sig": "replace _i with ( add_delta_ranges _i _i _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( add_delta_ranges _i _i _i ) .",
                "tactic_args": [
                    "c43_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c)) (cons (Lgoto l) c1)",
                    "c43_c1 : list instruction",
                    "c8_before : option avail",
                    "c8_before : option avail",
                    "c43_c1 : list instruction"
                ],
                "tactic_res": [
                    "c44_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l) (add_delta_ranges before before c1))",
                    "c45_goal : eq (add_delta_ranges before before c1) c1"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c44_goal : match_code (cons (Lgoto l) (cons (Llabel l0) c))\n  (cons (Lgoto l) (add_delta_ranges before before c1))"
                ],
                "tactic_res": [
                    "c46_goal : match_code (cons (Llabel l0) c) c1"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c46_goal : match_code (cons (Llabel l0) c) c1"
                ],
                "tactic_res": [
                    "c47_goal : match_code c (transf_code lm after c)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c47_goal : match_code c (transf_code lm after c)",
                    "c2_REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c45_goal : eq (add_delta_ranges before before c1) c1",
                    "_global_add_delta_ranges : forall (_ : option avail) (_ : option avail) (_ : code), code"
                ],
                "tactic_res": [
                    "c48_goal : eq\n  (let (killed, born) := delta_state before before in\n   fold_right add_end_range (fold_right add_start_range c1 born) killed)\n  c1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c48_goal : eq\n  (let (killed, born) := delta_state before before in\n   fold_right add_end_range (fold_right add_start_range c1 born) killed)\n  c1",
                    "_global_delta_state_same : forall s : option avail, eq (delta_state s s) (pair nil nil)"
                ],
                "tactic_res": [
                    "c49_goal : eq (fold_right add_end_range (fold_right add_start_range c1 nil) nil)\n  c1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c49_goal : eq (fold_right add_end_range (fold_right add_start_range c1 nil) nil)\n  c1",
                    "c43_c1 : list instruction"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_function_match",
        "proof": [
            {
                "tactic_sig": "Lemma transf_function_match : forall f tf , transf_function f = OK tf -> match_function f tf .",
                "tactic_sig_no_out_arg": "Lemma transf_function_match : forall f tf , transf_function f = OK tf -> match_function f tf .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (f tf : function) (_ : eq (transf_function f) (OK tf)),\nmatch_function f tf"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (f tf : function) (_ : eq (transf_function f) (OK tf)),\nmatch_function f tf",
                    "_global_transf_function : forall _ : function, res function"
                ],
                "tactic_res": [
                    "c2_goal : forall (f tf : function)\n  (_ : eq\n         match ana_function f with\n         | Some lm =>\n             OK\n               {|\n                 fn_sig := fn_sig f;\n                 fn_stacksize := fn_stacksize f;\n                 fn_code := transf_code lm (Some top) (fn_code f)\n               |}\n         | None => Error (msg \"Debugvar: analysis diverges\")\n         end (OK tf)), match_function f tf"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (f tf : function)\n  (_ : eq\n         match ana_function f with\n         | Some lm =>\n             OK\n               {|\n                 fn_sig := fn_sig f;\n                 fn_stacksize := fn_stacksize f;\n                 fn_code := transf_code lm (Some top) (fn_code f)\n               |}\n         | None => Error (msg \"Debugvar: analysis diverges\")\n         end (OK tf)), match_function f tf"
                ],
                "tactic_res": [
                    "c3_goal : match_function f tf",
                    "c3_f : function",
                    "c3_tf : function",
                    "c3_H : eq\n  match ana_function f with\n  | Some lm =>\n      OK\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := transf_code lm (Some top) (fn_code f)\n        |}\n  | None => Error (msg \"Debugvar: analysis diverges\")\n  end (OK tf)"
                ]
            },
            {
                "tactic_sig": "destruct ( ana_function _i ) as [ lm| ] .",
                "tactic_sig_no_out_arg": "destruct ( ana_function _i ) as [ lm| ] .",
                "tactic_args": [
                    "c3_goal : match_function f tf",
                    "c3_f : function",
                    "c3_H : eq\n  match ana_function f with\n  | Some lm =>\n      OK\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := transf_code lm (Some top) (fn_code f)\n        |}\n  | None => Error (msg \"Debugvar: analysis diverges\")\n  end (OK tf)",
                    "c3_tf : function"
                ],
                "tactic_res": [
                    "c4_goal : match_function f tf",
                    "c4_H : eq\n  (OK\n     {|\n       fn_sig := fn_sig f;\n       fn_stacksize := fn_stacksize f;\n       fn_code := transf_code lm (Some top) (fn_code f)\n     |}) (OK tf)",
                    "c4_lm : labelmap",
                    "c5_goal : match_function f tf",
                    "c5_H : eq (Error (msg \"Debugvar: analysis diverges\")) (OK tf)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c4_goal : match_function f tf",
                    "c4_H : eq\n  (OK\n     {|\n       fn_sig := fn_sig f;\n       fn_stacksize := fn_stacksize f;\n       fn_code := transf_code lm (Some top) (fn_code f)\n     |}) (OK tf)"
                ],
                "tactic_res": [
                    "c6_goal : match_function f\n  {|\n    fn_sig := fn_sig f;\n    fn_stacksize := fn_stacksize f;\n    fn_code := transf_code lm (Some top) (fn_code f)\n  |}"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : match_function f tf",
                    "c5_H : eq (Error (msg \"Debugvar: analysis diverges\")) (OK tf)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : match_function f\n  {|\n    fn_sig := fn_sig f;\n    fn_stacksize := fn_stacksize f;\n    fn_code := transf_code lm (Some top) (fn_code f)\n  |}"
                ],
                "tactic_res": [
                    "c7_goal : match_code (fn_code f) (transf_code lm (Some top) (fn_code f))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : match_code (fn_code f) (transf_code lm (Some top) (fn_code f))",
                    "_global_transf_code_match : forall (lm : labelmap) (c : code) (before : option avail),\n       match_code c (transf_code lm before c)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_label_add_delta_ranges",
        "proof": [
            {
                "tactic_sig": "Remark find_label_add_delta_ranges : forall lbl c before after , find_label lbl ( add_delta_ranges before after c ) = find_label lbl c .",
                "tactic_sig_no_out_arg": "Remark find_label_add_delta_ranges : forall lbl c before after , find_label lbl ( add_delta_ranges before after c ) = find_label lbl c .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lbl : label) (c : code) (before after : option avail),\neq (find_label lbl (add_delta_ranges before after c))\n  (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (lbl : label) (c : code) (before after : option avail),\neq (find_label lbl (add_delta_ranges before after c))\n  (find_label lbl c)"
                ],
                "tactic_res": [
                    "c2_goal : eq (find_label lbl (add_delta_ranges before after c))\n  (find_label lbl c)",
                    "c2_lbl : label",
                    "c2_c : code",
                    "c2_before : option avail",
                    "c2_after : option avail"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : eq (find_label lbl (add_delta_ranges before after c))\n  (find_label lbl c)",
                    "_global_add_delta_ranges : forall (_ : option avail) (_ : option avail) (_ : code), code"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (find_label lbl\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born)\n        killed)) (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "destruct ( delta_state _i _i ) as [ killed born ] .",
                "tactic_sig_no_out_arg": "destruct ( delta_state _i _i ) as [ killed born ] .",
                "tactic_args": [
                    "c3_goal : eq\n  (find_label lbl\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born)\n        killed)) (find_label lbl c)",
                    "c2_before : option avail",
                    "c2_after : option avail",
                    "c2_c : code",
                    "c2_lbl : label"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born)\n        killed)) (find_label lbl c)",
                    "c4_born : avail",
                    "c4_killed : avail"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v i ] l ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v i ] l ] .",
                "tactic_args": [
                    "c4_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born)\n        killed)) (find_label lbl c)",
                    "c4_killed : avail"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) nil))\n  (find_label lbl c)",
                    "c6_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born)\n        (cons (pair v i) l))) (find_label lbl c)",
                    "c6_IHl : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) l))\n  (find_label lbl c)",
                    "c6_l : list (prod ident debuginfo)",
                    "c6_i : debuginfo",
                    "c6_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) nil))\n  (find_label lbl c)"
                ],
                "tactic_res": [
                    "c7_goal : eq (find_label lbl (fold_right add_start_range c born))\n  (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born)\n        (cons (pair v i) l))) (find_label lbl c)"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) l))\n  (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) l))\n  (find_label lbl c)",
                    "c6_IHl : eq\n  (find_label lbl\n     (fold_right add_end_range (fold_right add_start_range c born) l))\n  (find_label lbl c)",
                    "c4_born : avail",
                    "c6_l : list (prod ident debuginfo)",
                    "c2_c : code",
                    "c2_lbl : label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction _i as [ | [ v i ] l ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v i ] l ] .",
                "tactic_args": [
                    "c7_goal : eq (find_label lbl (fold_right add_start_range c born))\n  (find_label lbl c)",
                    "c4_born : avail"
                ],
                "tactic_res": [
                    "c9_goal : eq (find_label lbl (fold_right add_start_range c nil))\n  (find_label lbl c)",
                    "c10_goal : eq (find_label lbl (fold_right add_start_range c (cons (pair v i) l)))\n  (find_label lbl c)",
                    "c10_IHl : eq (find_label lbl (fold_right add_start_range c l)) (find_label lbl c)",
                    "c10_l : list (prod ident debuginfo)",
                    "c10_i : debuginfo",
                    "c10_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : eq (find_label lbl (fold_right add_start_range c nil))\n  (find_label lbl c)"
                ],
                "tactic_res": [
                    "c11_goal : eq (find_label lbl c) (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq (find_label lbl c) (find_label lbl c)",
                    "c2_c : code",
                    "c2_lbl : label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : eq (find_label lbl (fold_right add_start_range c (cons (pair v i) l)))\n  (find_label lbl c)"
                ],
                "tactic_res": [
                    "c12_goal : eq (find_label lbl (fold_right add_start_range c l)) (find_label lbl c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq (find_label lbl (fold_right add_start_range c l)) (find_label lbl c)",
                    "c10_IHl : eq (find_label lbl (fold_right add_start_range c l)) (find_label lbl c)",
                    "c10_l : list (prod ident debuginfo)",
                    "c2_c : code",
                    "c2_lbl : label"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_label_match_rec",
        "proof": [
            {
                "tactic_sig": "Lemma find_label_match_rec : forall lbl c' c tc , match_code c tc -> find_label lbl c = Some c' -> exists before after tc' , find_label lbl tc = Some ( add_delta_ranges before after tc' ) /\\ match_code c' tc' .",
                "tactic_sig_no_out_arg": "Lemma find_label_match_rec : forall lbl c' c tc , match_code c tc -> find_label lbl c = Some c' -> exists before after tc' , find_label lbl tc = Some ( add_delta_ranges before after tc' ) /\\ match_code c' tc' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (lbl : label) (c' c tc : code) (_ : match_code c tc)\n  (_ : eq (find_label lbl c) (Some c')),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl tc)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (lbl : label) (c' c tc : code) (_ : match_code c tc)\n  (_ : eq (find_label lbl c) (Some c')),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl tc)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : eq (find_label lbl nil) (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl nil)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c2_c' : code",
                    "c2_lbl : label",
                    "c3_goal : forall _ : eq (find_label lbl (cons i c)) (Some c'),\nex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (find_label lbl\n                 (cons i (add_delta_ranges before after c'0)))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "c3_IHmatch_code : forall _ : eq (find_label lbl c) (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c3_H : match_code c c'0",
                    "c3_c'0 : code",
                    "c3_c : code",
                    "c3_after : option avail",
                    "c3_before : option avail",
                    "c3_i : instruction",
                    "c3_c' : code",
                    "c3_lbl : label"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : eq (find_label lbl nil) (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl nil)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : eq None (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and (eq None (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : eq None (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and (eq None (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c5_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and (eq None (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c5_H : eq None (Some c')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (find_label lbl (cons i c)) (Some c'),\nex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (find_label lbl\n                 (cons i (add_delta_ranges before after c'0)))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : eq (if is_label lbl i then Some c else find_label lbl c)\n        (Some c'),\nex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (if is_label lbl i\n               then Some (add_delta_ranges before after c'0)\n               else find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : eq (if is_label lbl i then Some c else find_label lbl c)\n        (Some c'),\nex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (if is_label lbl i\n               then Some (add_delta_ranges before after c'0)\n               else find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c7_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (if is_label lbl i\n               then Some (add_delta_ranges before after c'0)\n               else find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "c7_H0 : eq (if is_label lbl i then Some c else find_label lbl c) (Some c')"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and (eq None (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( is_label _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( is_label _i _i ) .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq\n              (if is_label lbl i\n               then Some (add_delta_ranges before after c'0)\n               else find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "c3_lbl : label",
                    "c3_i : instruction",
                    "c7_H0 : eq (if is_label lbl i then Some c else find_label lbl c) (Some c')",
                    "c3_IHmatch_code : forall _ : eq (find_label lbl c) (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c3_H : match_code c c'0",
                    "c3_c'0 : code",
                    "c3_before : option avail",
                    "c3_after : option avail",
                    "c3_c' : code"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (Some (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "c8_H0 : eq (Some c) (Some c')",
                    "c9_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "c9_H0 : eq (find_label lbl c) (Some c')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_H0 : eq (Some c) (Some c')"
                ],
                "tactic_res": [
                    "c8_H : match_code c' c'0",
                    "c8_IHmatch_code : forall _ : eq (find_label lbl c') (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (Some (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c10_goal : ex\n  (fun after0 : option avail =>\n   ex\n     (fun tc' : code =>\n      and\n        (eq (Some (add_delta_ranges before after c'0))\n           (Some (add_delta_ranges ?before after0 tc')))\n        (match_code c' tc')))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c10_goal : ex\n  (fun after0 : option avail =>\n   ex\n     (fun tc' : code =>\n      and\n        (eq (Some (add_delta_ranges before after c'0))\n           (Some (add_delta_ranges ?before after0 tc')))\n        (match_code c' tc')))"
                ],
                "tactic_res": [
                    "c11_goal : ex\n  (fun tc' : code =>\n   and\n     (eq (Some (add_delta_ranges before after c'0))\n        (Some (add_delta_ranges ?before ?after tc')))\n     (match_code c' tc'))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c11_goal : ex\n  (fun tc' : code =>\n   and\n     (eq (Some (add_delta_ranges before after c'0))\n        (Some (add_delta_ranges ?before ?after tc')))\n     (match_code c' tc'))"
                ],
                "tactic_res": [
                    "c12_goal : and\n  (eq (Some (add_delta_ranges before after c'0))\n     (Some (add_delta_ranges ?before ?after ?tc')))\n  (match_code c' ?tc')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : and\n  (eq (Some (add_delta_ranges before after c'0))\n     (Some (add_delta_ranges ?before ?after ?tc')))\n  (match_code c' ?tc')",
                    "c8_H : match_code c' c'0",
                    "c3_c'0 : code",
                    "c3_before : option avail",
                    "c3_after : option avail",
                    "c3_c' : code"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun before0 : option avail =>\n   ex\n     (fun after0 : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl (add_delta_ranges before after c'0))\n              (Some (add_delta_ranges before0 after0 tc')))\n           (match_code c' tc'))))",
                    "_global_find_label_add_delta_ranges : forall (lbl : label) (c : code) (before after : option avail),\n       eq (find_label lbl (add_delta_ranges before after c))\n         (find_label lbl c)"
                ],
                "tactic_res": [
                    "c13_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c9_H0 : eq (find_label lbl c) (Some c')",
                    "c3_IHmatch_code : forall _ : eq (find_label lbl c) (Some c'),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc' : code =>\n         and\n           (eq (find_label lbl c'0)\n              (Some (add_delta_ranges before after tc')))\n           (match_code c' tc'))))",
                    "c3_c'0 : code",
                    "c3_c' : code",
                    "c3_lbl : label"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_label_match",
        "proof": [
            {
                "tactic_sig": "Lemma find_label_match : forall f tf lbl c , match_function f tf -> find_label lbl f. ( fn_code ) = Some c -> exists before after tc , find_label lbl tf. ( fn_code ) = Some ( add_delta_ranges before after tc ) /\\ match_code c tc .",
                "tactic_sig_no_out_arg": "Lemma find_label_match : forall f tf lbl c , match_function f tf -> find_label lbl f. ( fn_code ) = Some c -> exists before after tc , find_label lbl tf. ( fn_code ) = Some ( add_delta_ranges before after tc ) /\\ match_code c tc .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (f tf : function) (lbl : label) (c : code)\n  (_ : match_function f tf)\n  (_ : eq (find_label lbl (fn_code f)) (Some c)),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq (find_label lbl (fn_code tf))\n              (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (f tf : function) (lbl : label) (c : code)\n  (_ : match_function f tf)\n  (_ : eq (find_label lbl (fn_code f)) (Some c)),\nex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq (find_label lbl (fn_code tf))\n              (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq (find_label lbl (fn_code tf))\n              (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))",
                    "c2_f : function",
                    "c2_tf : function",
                    "c2_lbl : label",
                    "c2_c : code",
                    "c2_H : match_function f tf",
                    "c2_H0 : eq (find_label lbl (fn_code f)) (Some c)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq (find_label lbl (fn_code tf))\n              (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))",
                    "c2_H : match_function f tf"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq\n              (find_label lbl\n                 (fn_code\n                    {|\n                      fn_sig := fn_sig f;\n                      fn_stacksize := fn_stacksize f;\n                      fn_code := c0\n                    |})) (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))",
                    "c3_H1 : match_code (fn_code f) c0",
                    "c3_c0 : code"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun before : option avail =>\n   ex\n     (fun after : option avail =>\n      ex\n        (fun tc : code =>\n         and\n           (eq\n              (find_label lbl\n                 (fn_code\n                    {|\n                      fn_sig := fn_sig f;\n                      fn_stacksize := fn_stacksize f;\n                      fn_code := c0\n                    |})) (Some (add_delta_ranges before after tc)))\n           (match_code c tc))))",
                    "_global_find_label_match_rec : forall (lbl : label) (c' c tc : code) (_ : match_code c tc)\n         (_ : eq (find_label lbl c) (Some c')),\n       ex\n         (fun before : option avail =>\n          ex\n            (fun after : option avail =>\n             ex\n               (fun tc' : code =>\n                and\n                  (eq (find_label lbl tc)\n                     (Some (add_delta_ranges before after tc')))\n                  (match_code c' tc'))))"
                ],
                "tactic_res": [
                    "c4_goal : match_code ?c\n  (fn_code\n     {|\n       fn_sig := fn_sig f;\n       fn_stacksize := fn_stacksize f;\n       fn_code := c0\n     |})",
                    "c5_goal : eq (find_label lbl (fn_code f)) (Some c)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : match_code ?c\n  (fn_code\n     {|\n       fn_sig := fn_sig f;\n       fn_stacksize := fn_stacksize f;\n       fn_code := c0\n     |})",
                    "c3_H1 : match_code (fn_code f) c0",
                    "c3_c0 : code",
                    "c2_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c5_goal : eq (find_label lbl (fn_code f)) (Some c)",
                    "c2_H0 : eq (find_label lbl (fn_code f)) (Some c)",
                    "c2_c : code",
                    "c2_lbl : label",
                    "c2_f : function"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "set_state_1",
        "proof": [
            {
                "tactic_sig": "Lemma set_state_1 : forall v i s , In ( v , i ) ( set_state v i s ) .",
                "tactic_sig_no_out_arg": "Lemma set_state_1 : forall v i s , In ( v , i ) ( set_state v i s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail),\nIn (pair v i) (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros v i s .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail),\nIn (pair v i) (set_state v i s)"
                ],
                "tactic_res": [
                    "c2_goal : In (pair v i) (set_state v i s)",
                    "c2_v : ident",
                    "c2_i : debuginfo",
                    "c2_s : avail"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v' i' ] _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v' i' ] _i ] .",
                "tactic_args": [
                    "c2_goal : In (pair v i) (set_state v i s)",
                    "c2_s : avail",
                    "c2_s : avail"
                ],
                "tactic_res": [
                    "c3_goal : In (pair v i) (set_state v i nil)",
                    "c4_goal : In (pair v i) (set_state v i (cons (pair v' i') s))",
                    "c4_IHs : In (pair v i) (set_state v i s)",
                    "c4_s : list (prod ident debuginfo)",
                    "c4_i' : debuginfo",
                    "c4_v' : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : In (pair v i) (set_state v i nil)"
                ],
                "tactic_res": [
                    "c5_goal : or (eq (pair v i) (pair v i)) False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : In (pair v i) (set_state v i (cons (pair v' i') s))"
                ],
                "tactic_res": [
                    "c6_goal : In (pair v i)\n  match Pos.compare v v' with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v' i') s)\n  | Gt => cons (pair v' i') (set_state v i s)\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : or (eq (pair v i) (pair v i)) False",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare _i _i ) as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare _i _i ) .",
                "tactic_args": [
                    "c6_goal : In (pair v i)\n  match Pos.compare v v' with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v' i') s)\n  | Gt => cons (pair v' i') (set_state v i s)\n  end",
                    "c2_v : ident",
                    "c4_v' : ident",
                    "c4_IHs : In (pair v i) (set_state v i s)",
                    "c4_s : list (prod ident debuginfo)",
                    "c4_i' : debuginfo",
                    "c2_i : debuginfo"
                ],
                "tactic_res": [
                    "c7_goal : In (pair v i) (cons (pair v i) s)",
                    "c8_goal : In (pair v i) (cons (pair v i) (cons (pair v' i') s))",
                    "c9_goal : In (pair v i) (cons (pair v' i') (set_state v i s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : In (pair v i) (cons (pair v i) s)"
                ],
                "tactic_res": [
                    "c10_goal : or (eq (pair v i) (pair v i)) (In (pair v i) s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : or (eq (pair v i) (pair v i)) (In (pair v i) s)",
                    "c4_s : list (prod ident debuginfo)",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : In (pair v i) (cons (pair v i) (cons (pair v' i') s))"
                ],
                "tactic_res": [
                    "c11_goal : or (eq (pair v i) (pair v i))\n  (or (eq (pair v' i') (pair v i)) (In (pair v i) s))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : or (eq (pair v i) (pair v i))\n  (or (eq (pair v' i') (pair v i)) (In (pair v i) s))",
                    "c4_s : list (prod ident debuginfo)",
                    "c4_i' : debuginfo",
                    "c4_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : In (pair v i) (cons (pair v' i') (set_state v i s))"
                ],
                "tactic_res": [
                    "c12_goal : or (eq (pair v' i') (pair v i)) (In (pair v i) (set_state v i s))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : or (eq (pair v' i') (pair v i)) (In (pair v i) (set_state v i s))",
                    "c4_IHs : In (pair v i) (set_state v i s)",
                    "c4_s : list (prod ident debuginfo)",
                    "c4_i' : debuginfo",
                    "c4_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "set_state_2",
        "proof": [
            {
                "tactic_sig": "Lemma set_state_2 : forall v i v' i' s , v' <> v -> In ( v' , i' ) s -> In ( v' , i' ) ( set_state v i s ) .",
                "tactic_sig_no_out_arg": "Lemma set_state_2 : forall v i v' i' s , v' <> v -> In ( v' , i' ) s -> In ( v' , i' ) ( set_state v i s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo)\n  (s : list (prod ident debuginfo)) (_ : not (eq v' v))\n  (_ : In (pair v' i') s), In (pair v' i') (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros v i v' i' s .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo)\n  (s : list (prod ident debuginfo)) (_ : not (eq v' v))\n  (_ : In (pair v' i') s), In (pair v' i') (set_state v i s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_v : ident",
                    "c2_i : debuginfo",
                    "c2_v' : ident",
                    "c2_i' : debuginfo",
                    "c2_s : list (prod ident debuginfo)"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v1 i1 ] _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v1 i1 ] _i ] .",
                "tactic_args": [
                    "c2_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_s : list (prod ident debuginfo)"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') nil),\nIn (pair v' i') (set_state v i nil)",
                    "c4_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') (cons (pair v1 i1) s)),\nIn (pair v' i') (set_state v i (cons (pair v1 i1) s))",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') nil),\nIn (pair v' i') (set_state v i nil)"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : not (eq v' v)) (_ : False),\nor (eq (pair v i) (pair v' i')) False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (_ : not (eq v' v)) (_ : False),\nor (eq (pair v i) (pair v' i')) False"
                ],
                "tactic_res": [
                    "c6_goal : or (eq (pair v i) (pair v' i')) False",
                    "c6_H : not (eq v' v)",
                    "c6_H0 : False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') (cons (pair v1 i1) s)),\nIn (pair v' i') (set_state v i (cons (pair v1 i1) s))"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : not (eq v' v))\n  (_ : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)),\nIn (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v1 i1) s)\n  | Gt => cons (pair v1 i1) (set_state v i s)\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (_ : not (eq v' v))\n  (_ : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)),\nIn (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v1 i1) s)\n  | Gt => cons (pair v1 i1) (set_state v i s)\n  end"
                ],
                "tactic_res": [
                    "c8_goal : In (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v1 i1) s)\n  | Gt => cons (pair v1 i1) (set_state v i s)\n  end",
                    "c8_H : not (eq v' v)",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c6_goal : or (eq (pair v i) (pair v' i')) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c8_goal : In (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v1 i1) s)\n  | Gt => cons (pair v1 i1) (set_state v i s)\n  end",
                    "c2_v : ident",
                    "c4_v1 : ident",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo"
                ],
                "tactic_res": [
                    "c9_goal : In (pair v' i') (cons (pair v i) s)",
                    "c9_H1 : eq v v1",
                    "c10_goal : In (pair v' i') (cons (pair v i) (cons (pair v1 i1) s))",
                    "c10_H1 : Pos.lt v v1",
                    "c11_goal : In (pair v' i') (cons (pair v1 i1) (set_state v i s))",
                    "c11_H1 : Pos.lt v1 v"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : In (pair v' i') (cons (pair v i) s)"
                ],
                "tactic_res": [
                    "c12_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : In (pair v' i') (cons (pair v i) (cons (pair v1 i1) s))"
                ],
                "tactic_res": [
                    "c13_goal : or (eq (pair v i) (pair v' i'))\n  (or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : In (pair v' i') (cons (pair v1 i1) (set_state v i s))"
                ],
                "tactic_res": [
                    "c14_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_v1 : ident",
                    "c9_H1 : eq v v1"
                ],
                "tactic_res": [
                    "c12_H0 : or (eq (pair v i1) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c12_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c12_H0 : or (eq (pair v i1) (pair v' i')) (In (pair v' i') s)",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": [
                    "c15_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c15_H0 : eq (pair v i1) (pair v' i')",
                    "c16_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c16_H0 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c15_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c16_H0 : In (pair v' i') s",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : or (eq (pair v i) (pair v' i'))\n  (or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s))",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c14_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c11_H1 : Pos.lt v1 v",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": [
                    "c17_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c17_H0 : eq (pair v1 i1) (pair v' i')",
                    "c18_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c18_H0 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c17_H0 : eq (pair v1 i1) (pair v' i')",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c18_H0 : In (pair v' i') s",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (set_state v i s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "set_state_3",
        "proof": [
            {
                "tactic_sig": "Lemma set_state_3 : forall v i v' i' s , wf_avail s -> In ( v' , i' ) ( set_state v i s ) -> ( v' = v /\\ i' = i ) \\/ ( v' <> v /\\ In ( v' , i' ) s ) .",
                "tactic_sig_no_out_arg": "Lemma set_state_3 : forall v i v' i' s , wf_avail s -> In ( v' , i' ) ( set_state v i s ) -> ( v' = v /\\ i' = i ) \\/ ( v' <> v /\\ In ( v' , i' ) s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo)\n  (s : avail) (_ : wf_avail s) (_ : In (pair v' i') (set_state v i s)),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo)\n  (s : avail) (_ : wf_avail s) (_ : In (pair v' i') (set_state v i s)),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : In (pair v' i') (set_state v i nil),\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v)) (In (pair v' i') nil))",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident",
                    "c3_goal : forall _ : In (pair v' i') (set_state v i (cons (pair v0 i0) s)),\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v)) (In (pair v' i') (cons (pair v0 i0) s)))",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : In (pair v' i') (set_state v i nil),\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v)) (In (pair v' i') nil))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : or (eq (pair v i) (pair v' i')) False,\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) False)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : or (eq (pair v i) (pair v' i')) False,\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) False)"
                ],
                "tactic_res": [
                    "c5_goal : or (and (eq v' v) (eq i' i)) (and (not (eq v' v)) False)",
                    "c5_H : or (eq (pair v i) (pair v' i')) False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : In (pair v' i') (set_state v i (cons (pair v0 i0) s)),\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v)) (In (pair v' i') (cons (pair v0 i0) s)))"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : In (pair v' i')\n        match Pos.compare v v0 with\n        | Eq => cons (pair v i) s\n        | Lt => cons (pair v i) (cons (pair v0 i0) s)\n        | Gt => cons (pair v0 i0) (set_state v i s)\n        end,\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : In (pair v' i')\n        match Pos.compare v v0 with\n        | Eq => cons (pair v i) s\n        | Lt => cons (pair v i) (cons (pair v0 i0) s)\n        | Gt => cons (pair v0 i0) (set_state v i s)\n        end,\nor (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))"
                ],
                "tactic_res": [
                    "c7_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c7_H1 : In (pair v' i')\n  match Pos.compare v v0 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v0 i0) s)\n  | Gt => cons (pair v0 i0) (set_state v i s)\n  end"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "c5_goal : or (and (eq v' v) (eq i' i)) (and (not (eq v' v)) False)",
                    "c5_H : or (eq (pair v i) (pair v' i')) False",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_i : debuginfo",
                    "c2_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c7_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c3_v : ident",
                    "c3_v0 : ident",
                    "c7_H1 : In (pair v' i')\n  match Pos.compare v v0 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v0 i0) s)\n  | Gt => cons (pair v0 i0) (set_state v i s)\n  end",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c8_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c8_H2 : eq v v0",
                    "c8_H1 : In (pair v' i') (cons (pair v i) s)",
                    "c9_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c9_H2 : Pos.lt v v0",
                    "c9_H1 : In (pair v' i') (cons (pair v i) (cons (pair v0 i0) s))",
                    "c10_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c10_H2 : Pos.lt v0 v",
                    "c10_H1 : In (pair v' i') (cons (pair v0 i0) (set_state v i s))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c8_H1 : In (pair v' i') (cons (pair v i) s)"
                ],
                "tactic_res": [
                    "c8_H1 : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c9_H1 : In (pair v' i') (cons (pair v i) (cons (pair v0 i0) s))"
                ],
                "tactic_res": [
                    "c9_H1 : or (eq (pair v i) (pair v' i'))\n  (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c10_H1 : In (pair v' i') (cons (pair v0 i0) (set_state v i s))"
                ],
                "tactic_res": [
                    "c10_H1 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') (set_state v i s))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c8_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c3_v0 : ident",
                    "c8_H2 : eq v v0"
                ],
                "tactic_res": [
                    "c11_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))",
                    "c11_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c11_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))",
                    "c8_H1 : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c11_H : avail_above v s",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_i0 : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c12_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))",
                    "c12_H1 : eq (pair v i) (pair v' i')",
                    "c13_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))",
                    "c13_H1 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))",
                    "c12_H1 : eq (pair v i) (pair v' i')"
                ],
                "tactic_res": [
                    "c14_goal : or (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v'))\n     (or (eq (pair v' i0) (pair v' i')) (In (pair v' i') s)))",
                    "c14_IHwf_avail : forall _ : In (pair v' i') (set_state v' i' s),\nor (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v')) (In (pair v' i') s))",
                    "c14_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : or (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v'))\n     (or (eq (pair v' i0) (pair v' i')) (In (pair v' i') s)))",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_i0 : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c13_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)))"
                ],
                "tactic_res": [
                    "c15_goal : and (not (eq v' v))\n  (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c15_goal : and (not (eq v' v))\n  (or (eq (pair v i0) (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c16_goal : not (eq v' v)",
                    "c17_goal : or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c18_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c19_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c19_goal : Plt v v'",
                    "c11_H : avail_above v s"
                ],
                "tactic_res": [
                    "c20_goal : In (pair v' ?i') s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : In (pair v' ?i') s",
                    "c13_H1 : In (pair v' i') s",
                    "c3_s : avail",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : or (eq (pair v i0) (pair v' i')) (In (pair v' i') s)",
                    "c13_H1 : In (pair v' i') s",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_i0 : debuginfo",
                    "c3_v' : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c9_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c9_H1 : or (eq (pair v i) (pair v' i'))\n  (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s))",
                    "c9_H2 : Pos.lt v v0",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c21_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c21_H1 : eq (pair v i) (pair v' i')",
                    "c22_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c22_H1 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c21_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c21_H1 : eq (pair v i) (pair v' i')"
                ],
                "tactic_res": [
                    "c23_goal : or (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v'))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c23_IHwf_avail : forall _ : In (pair v' i') (set_state v' i' s),\nor (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v')) (In (pair v' i') s))",
                    "c23_H2 : Pos.lt v' v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : or (and (eq v' v') (eq i' i'))\n  (and (not (eq v' v'))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c22_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c22_H1 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)",
                    "c9_H2 : Pos.lt v v0",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c24_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c24_H1 : eq (pair v0 i0) (pair v' i')",
                    "c25_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c25_H1 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c24_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c24_H1 : eq (pair v0 i0) (pair v' i')"
                ],
                "tactic_res": [
                    "c26_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)))",
                    "c26_H2 : Pos.lt v v'",
                    "c26_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c26_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)))"
                ],
                "tactic_res": [
                    "c27_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c27_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c28_goal : not (eq v' v)",
                    "c29_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c30_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c31_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : Plt v v'",
                    "c26_H2 : Pos.lt v v'",
                    "c3_v' : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c25_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))"
                ],
                "tactic_res": [
                    "c32_goal : and (not (eq v' v))\n  (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c32_goal : and (not (eq v' v))\n  (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c33_goal : not (eq v' v)",
                    "c34_goal : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)",
                    "c25_H1 : In (pair v' i') s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c33_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c35_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c35_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c36_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c36_goal : Plt v v'",
                    "_global_Plt_trans : forall (x y z : positive) (_ : Plt x y) (_ : Plt y z), Plt x z",
                    "c3_v0 : ident"
                ],
                "tactic_res": [
                    "c37_goal : Plt v v0",
                    "c38_goal : Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c37_goal : Plt v v0",
                    "c9_H2 : Pos.lt v v0",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c38_goal : Plt v0 v'",
                    "c25_H1 : In (pair v' i') s",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c10_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c10_H1 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') (set_state v i s))",
                    "c10_H2 : Pos.lt v0 v",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c39_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c39_H1 : eq (pair v0 i0) (pair v' i')",
                    "c40_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c40_H1 : In (pair v' i') (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c39_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c39_H1 : eq (pair v0 i0) (pair v' i')"
                ],
                "tactic_res": [
                    "c41_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)))",
                    "c41_H2 : Pos.lt v' v",
                    "c41_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c41_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)))"
                ],
                "tactic_res": [
                    "c42_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c42_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c43_goal : not (eq v' v)",
                    "c44_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c44_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c43_goal : not (eq v' v)",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c45_goal : Plt v' v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c45_goal : Plt v' v",
                    "c41_H2 : Pos.lt v' v",
                    "c3_v' : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ A | [ A B ] ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ A | [ A B ] ] .",
                "tactic_args": [
                    "c40_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (set_state v i s),\nor (and (eq v' v) (eq i' i)) (and (not (eq v' v)) (In (pair v' i') s))",
                    "c10_H2 : Pos.lt v0 v",
                    "c40_H1 : In (pair v' i') (set_state v i s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c46_goal : In (pair v' i') (set_state v i s)",
                    "c47_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c47_A : and (eq v' v) (eq i' i)",
                    "c48_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c48_B : In (pair v' i') s",
                    "c48_A : not (eq v' v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : In (pair v' i') (set_state v i s)",
                    "c40_H1 : In (pair v' i') (set_state v i s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c47_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c47_A : and (eq v' v) (eq i' i)",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c48_goal : or (and (eq v' v) (eq i' i))\n  (and (not (eq v' v))\n     (or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)))",
                    "c48_B : In (pair v' i') s",
                    "c48_A : not (eq v' v)",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wf_set_state",
        "proof": [
            {
                "tactic_sig": "Lemma wf_set_state : forall v i s , wf_avail s -> wf_avail ( set_state v i s ) .",
                "tactic_sig_no_out_arg": "Lemma wf_set_state : forall v i s , wf_avail s -> wf_avail ( set_state v i s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail) (_ : wf_avail s),\nwf_avail (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail) (_ : wf_avail s),\nwf_avail (set_state v i s)"
                ],
                "tactic_res": [
                    "c2_goal : wf_avail (set_state v i nil)",
                    "c2_i : debuginfo",
                    "c2_v : ident",
                    "c3_goal : wf_avail (set_state v i (cons (pair v0 i0) s))",
                    "c3_IHwf_avail : wf_avail (set_state v i s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wf_avail (set_state v i nil)"
                ],
                "tactic_res": [
                    "c4_goal : wf_avail (cons (pair v i) nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : wf_avail (set_state v i (cons (pair v0 i0) s))"
                ],
                "tactic_res": [
                    "c5_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v0 i0) s)\n  | Gt => cons (pair v0 i0) (set_state v i s)\n  end"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : wf_avail (cons (pair v i) nil)"
                ],
                "tactic_res": [
                    "c6_goal : avail_above v nil",
                    "c7_goal : wf_avail nil"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : avail_above v nil"
                ],
                "tactic_res": [
                    "c8_goal : forall (v' : ident) (i' : debuginfo) (_ : In (pair v' i') nil),\nPlt v v'"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : forall (v' : ident) (i' : debuginfo) (_ : In (pair v' i') nil),\nPlt v v'"
                ],
                "tactic_res": [
                    "c9_goal : forall (v' : ident) (_ : debuginfo) (_ : False), Plt v v'"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c9_goal : forall (v' : ident) (_ : debuginfo) (_ : False), Plt v v'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c5_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq => cons (pair v i) s\n  | Lt => cons (pair v i) (cons (pair v0 i0) s)\n  | Gt => cons (pair v0 i0) (set_state v i s)\n  end",
                    "c3_v : ident",
                    "c3_v0 : ident",
                    "c3_IHwf_avail : wf_avail (set_state v i s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c10_goal : wf_avail (cons (pair v i) s)",
                    "c10_H1 : eq v v0",
                    "c11_goal : wf_avail (cons (pair v i) (cons (pair v0 i0) s))",
                    "c11_H1 : Pos.lt v v0",
                    "c12_goal : wf_avail (cons (pair v0 i0) (set_state v i s))",
                    "c12_H1 : Pos.lt v0 v"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_v0 : ident",
                    "c10_H1 : eq v v0"
                ],
                "tactic_res": [
                    "c10_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : wf_avail (cons (pair v i) s)"
                ],
                "tactic_res": [
                    "c13_goal : avail_above v s",
                    "c14_goal : wf_avail s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : avail_above v s",
                    "c10_H : avail_above v s",
                    "c3_s : avail",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : wf_avail s",
                    "c3_H0 : wf_avail s",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c11_goal : wf_avail (cons (pair v i) (cons (pair v0 i0) s))"
                ],
                "tactic_res": [
                    "c15_goal : avail_above v (cons (pair v0 i0) s)",
                    "c16_goal : wf_avail (cons (pair v0 i0) s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c15_goal : avail_above v (cons (pair v0 i0) s)"
                ],
                "tactic_res": [
                    "c17_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (cons (pair v0 i0) s)), Plt v v'"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (cons (pair v0 i0) s)), Plt v v'"
                ],
                "tactic_res": [
                    "c18_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)), \nPlt v v'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c18_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)), \nPlt v v'"
                ],
                "tactic_res": [
                    "c19_goal : Plt v v'",
                    "c19_v' : ident",
                    "c19_i' : debuginfo",
                    "c19_H2 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c19_goal : Plt v v'",
                    "c19_H2 : or (eq (pair v0 i0) (pair v' i')) (In (pair v' i') s)",
                    "c19_v' : ident",
                    "c11_H1 : Pos.lt v v0",
                    "c3_IHwf_avail : wf_avail (set_state v i s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c20_goal : Plt v v'",
                    "c20_H2 : eq (pair v0 i0) (pair v' i')",
                    "c21_goal : Plt v v'",
                    "c21_H2 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c20_H2 : eq (pair v0 i0) (pair v' i')"
                ],
                "tactic_res": [
                    "c20_H1 : Pos.lt v v'",
                    "c20_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Plt v v'",
                    "c20_H1 : Pos.lt v v'",
                    "c19_v' : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c21_goal : Plt v v'",
                    "_global_Plt_trans : forall (x y z : positive) (_ : Plt x y) (_ : Plt y z), Plt x z",
                    "c3_v0 : ident"
                ],
                "tactic_res": [
                    "c22_goal : Plt v v0",
                    "c23_goal : Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : Plt v v0",
                    "c11_H1 : Pos.lt v v0",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : Plt v0 v'",
                    "c21_H2 : In (pair v' i') s",
                    "c19_v' : ident",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : wf_avail (cons (pair v0 i0) s)"
                ],
                "tactic_res": [
                    "c24_goal : avail_above v0 s",
                    "c25_goal : wf_avail s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : avail_above v0 s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_v0 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : wf_avail s",
                    "c3_H0 : wf_avail s",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c12_goal : wf_avail (cons (pair v0 i0) (set_state v i s))"
                ],
                "tactic_res": [
                    "c26_goal : avail_above v0 (set_state v i s)",
                    "c27_goal : wf_avail (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c26_goal : avail_above v0 (set_state v i s)"
                ],
                "tactic_res": [
                    "c28_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (set_state v i s)), Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c28_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (set_state v i s)), Plt v0 v'"
                ],
                "tactic_res": [
                    "c29_goal : Plt v0 v'",
                    "c29_v' : ident",
                    "c29_i' : debuginfo",
                    "c29_H2 : In (pair v' i') (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "exploit set_state_3 .",
                "tactic_sig_no_out_arg": "exploit set_state_3 .",
                "tactic_args": [
                    "c29_goal : Plt v0 v'"
                ],
                "tactic_res": [
                    "c30_goal : wf_avail ?Goal4",
                    "c31_goal : In (pair ?Goal2 ?Goal3) (set_state ?Goal0 ?Goal1 s)",
                    "c32_goal : forall\n  _ : or (and (eq v' v) (eq i' i))\n        (and (not (eq v' v)) (In (pair v' i') s)), \nPlt v0 v'"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c30_goal : wf_avail ?Goal4",
                    "c3_H0 : wf_avail s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : In (pair ?Goal2 ?Goal3) (set_state ?Goal0 ?Goal1 s)",
                    "c29_H2 : In (pair v' i') (set_state v i s)",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ [ _o _o ] | [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ [ A B ] | [ A B ] ] .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : or (and (eq v' v) (eq i' i))\n        (and (not (eq v' v)) (In (pair v' i') s)), \nPlt v0 v'"
                ],
                "tactic_res": [
                    "c33_goal : Plt v0 v'",
                    "c34_A : not (eq v' v)",
                    "c34_B : In (pair v' i') s",
                    "c34_goal : Plt v0 v'",
                    "c33_A : eq v' v",
                    "c33_B : eq i' i"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c33_goal : Plt v0 v'",
                    "c29_v' : ident",
                    "c29_i' : debuginfo",
                    "c33_B : eq i' i",
                    "c33_A : eq v' v"
                ],
                "tactic_res": [
                    "c35_goal : Plt v0 v",
                    "c35_H2 : In (pair v i) (set_state v i s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c35_goal : Plt v0 v",
                    "c12_H1 : Pos.lt v0 v",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c34_goal : Plt v0 v'",
                    "c34_B : In (pair v' i') s",
                    "c29_v' : ident",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : wf_avail (set_state v i s)",
                    "c3_IHwf_avail : wf_avail (set_state v i s)",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "remove_state_1",
        "proof": [
            {
                "tactic_sig": "Lemma remove_state_1 : forall v i s , wf_avail s -> ~ In ( v , i ) ( remove_state v s ) .",
                "tactic_sig_no_out_arg": "Lemma remove_state_1 : forall v i s , wf_avail s -> ~ In ( v , i ) ( remove_state v s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail) (_ : wf_avail s),\nnot (In (pair v i) (remove_state v s))"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s : avail) (_ : wf_avail s),\nnot (In (pair v i) (remove_state v s))"
                ],
                "tactic_res": [
                    "c2_goal : not (In (pair v i) (remove_state v nil))",
                    "c2_i : debuginfo",
                    "c2_v : ident",
                    "c3_goal : not (In (pair v i) (remove_state v (cons (pair v0 i0) s)))",
                    "c3_IHwf_avail : not (In (pair v i) (remove_state v s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : not (In (pair v i) (remove_state v nil))"
                ],
                "tactic_res": [
                    "c4_goal : not False"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c4_goal : not False"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : False, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall _ : False, False"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H : False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : not (In (pair v i) (remove_state v (cons (pair v0 i0) s)))"
                ],
                "tactic_res": [
                    "c7_goal : not\n  (In (pair v i)\n     match Pos.compare v v0 with\n     | Eq => s\n     | Lt => cons (pair v0 i0) s\n     | Gt => cons (pair v0 i0) (remove_state v s)\n     end)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : not\n  (In (pair v i)\n     match Pos.compare v v0 with\n     | Eq => s\n     | Lt => cons (pair v0 i0) s\n     | Gt => cons (pair v0 i0) (remove_state v s)\n     end)"
                ],
                "tactic_res": [
                    "c8_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v v0 with\n        | Eq => s\n        | Lt => cons (pair v0 i0) s\n        | Gt => cons (pair v0 i0) (remove_state v s)\n        end, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v v0 with\n        | Eq => s\n        | Lt => cons (pair v0 i0) s\n        | Gt => cons (pair v0 i0) (remove_state v s)\n        end, False"
                ],
                "tactic_res": [
                    "c9_goal : False",
                    "c9_H1 : In (pair v i)\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i0) s\n  | Gt => cons (pair v0 i0) (remove_state v s)\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : False",
                    "c6_H : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c9_goal : False",
                    "c3_v : ident",
                    "c3_v0 : ident",
                    "c9_H1 : In (pair v i)\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i0) s\n  | Gt => cons (pair v0 i0) (remove_state v s)\n  end",
                    "c3_IHwf_avail : not (In (pair v i) (remove_state v s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s"
                ],
                "tactic_res": [
                    "c10_goal : False",
                    "c10_H2 : eq v v0",
                    "c10_H1 : In (pair v i) s",
                    "c11_goal : False",
                    "c11_H2 : Pos.lt v v0",
                    "c11_H1 : In (pair v i) (cons (pair v0 i0) s)",
                    "c12_goal : False",
                    "c12_H2 : Pos.lt v0 v",
                    "c12_H1 : In (pair v i) (cons (pair v0 i0) (remove_state v s))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_v0 : ident",
                    "c10_H2 : eq v v0"
                ],
                "tactic_res": [
                    "c10_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "elim ( Plt_strict _i ) .",
                "tactic_sig_no_out_arg": "elim ( Plt_strict _i ) .",
                "tactic_args": [
                    "c10_goal : False",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c13_goal : Plt v v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : Plt v v",
                    "c10_H1 : In (pair v i) s",
                    "c10_H : avail_above v s",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c11_goal : False",
                    "c11_H1 : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)",
                    "c11_H2 : Pos.lt v v0",
                    "c3_IHwf_avail : not (In (pair v i) (remove_state v s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s"
                ],
                "tactic_res": [
                    "c14_goal : False",
                    "c14_H1 : eq (pair v0 i0) (pair v i)",
                    "c15_goal : False",
                    "c15_H1 : In (pair v i) s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_H1 : eq (pair v0 i0) (pair v i)"
                ],
                "tactic_res": [
                    "c14_H2 : Pos.lt v v",
                    "c14_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "elim ( Plt_strict _i ) .",
                "tactic_sig_no_out_arg": "elim ( Plt_strict _i ) .",
                "tactic_args": [
                    "c14_goal : False",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c16_goal : Plt v v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : Plt v v",
                    "c14_H2 : Pos.lt v v",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim ( Plt_strict _i ) .",
                "tactic_sig_no_out_arg": "elim ( Plt_strict _i ) .",
                "tactic_args": [
                    "c15_goal : False",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c17_goal : Plt v v"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c17_goal : Plt v v",
                    "_global_Plt_trans : forall (x y z : positive) (_ : Plt x y) (_ : Plt y z), Plt x z",
                    "c3_v0 : ident"
                ],
                "tactic_res": [
                    "c18_goal : Plt v v0",
                    "c19_goal : Plt v0 v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : Plt v v0",
                    "c11_H2 : Pos.lt v v0",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : Plt v0 v",
                    "c15_H1 : In (pair v i) s",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c12_goal : False",
                    "c12_H1 : or (eq (pair v0 i0) (pair v i)) (In (pair v i) (remove_state v s))",
                    "c12_H2 : Pos.lt v0 v",
                    "c3_IHwf_avail : not (In (pair v i) (remove_state v s))",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s"
                ],
                "tactic_res": [
                    "c20_goal : False",
                    "c20_H1 : eq (pair v0 i0) (pair v i)",
                    "c21_goal : False",
                    "c21_H1 : In (pair v i) (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c20_H1 : eq (pair v0 i0) (pair v i)"
                ],
                "tactic_res": [
                    "c20_H2 : Pos.lt v v",
                    "c20_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "elim ( Plt_strict _i ) .",
                "tactic_sig_no_out_arg": "elim ( Plt_strict _i ) .",
                "tactic_args": [
                    "c20_goal : False",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c22_goal : Plt v v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : Plt v v",
                    "c20_H2 : Pos.lt v v",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c21_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "remove_state_2",
        "proof": [
            {
                "tactic_sig": "Lemma remove_state_2 : forall v v' i' s , v' <> v -> In ( v' , i' ) s -> In ( v' , i' ) ( remove_state v s ) .",
                "tactic_sig_no_out_arg": "Lemma remove_state_2 : forall v v' i' s , v' <> v -> In ( v' , i' ) s -> In ( v' , i' ) ( remove_state v s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v v' : ident) (i' : debuginfo)\n  (s : list (prod ident debuginfo)) (_ : not (eq v' v))\n  (_ : In (pair v' i') s), In (pair v' i') (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros v v' i' s .",
                "tactic_args": [
                    "c1_goal : forall (v v' : ident) (i' : debuginfo)\n  (s : list (prod ident debuginfo)) (_ : not (eq v' v))\n  (_ : In (pair v' i') s), In (pair v' i') (remove_state v s)"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_v : ident",
                    "c2_v' : ident",
                    "c2_i' : debuginfo",
                    "c2_s : list (prod ident debuginfo)"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v1 i1 ] _i ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v1 i1 ] _i ] .",
                "tactic_args": [
                    "c2_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_s : list (prod ident debuginfo)"
                ],
                "tactic_res": [
                    "c3_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') nil),\nIn (pair v' i') (remove_state v nil)",
                    "c4_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') (cons (pair v1 i1) s)),\nIn (pair v' i') (remove_state v (cons (pair v1 i1) s))",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') nil),\nIn (pair v' i') (remove_state v nil)"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : not (eq v' v)) (_ : False), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (_ : not (eq v' v)) (_ : False), False"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H : not (eq v' v)",
                    "c6_H0 : False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (_ : not (eq v' v)) (_ : In (pair v' i') (cons (pair v1 i1) s)),\nIn (pair v' i') (remove_state v (cons (pair v1 i1) s))"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : not (eq v' v))\n  (_ : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)),\nIn (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => s\n  | Lt => cons (pair v1 i1) s\n  | Gt => cons (pair v1 i1) (remove_state v s)\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (_ : not (eq v' v))\n  (_ : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)),\nIn (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => s\n  | Lt => cons (pair v1 i1) s\n  | Gt => cons (pair v1 i1) (remove_state v s)\n  end"
                ],
                "tactic_res": [
                    "c8_goal : In (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => s\n  | Lt => cons (pair v1 i1) s\n  | Gt => cons (pair v1 i1) (remove_state v s)\n  end",
                    "c8_H : not (eq v' v)",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : False",
                    "c6_H0 : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c8_goal : In (pair v' i')\n  match Pos.compare v v1 with\n  | Eq => s\n  | Lt => cons (pair v1 i1) s\n  | Gt => cons (pair v1 i1) (remove_state v s)\n  end",
                    "c2_v : ident",
                    "c4_v1 : ident",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c2_i' : debuginfo",
                    "c2_v' : ident"
                ],
                "tactic_res": [
                    "c9_goal : In (pair v' i') s",
                    "c9_H1 : eq v v1",
                    "c10_goal : In (pair v' i') (cons (pair v1 i1) s)",
                    "c10_H1 : Pos.lt v v1",
                    "c11_goal : In (pair v' i') (cons (pair v1 i1) (remove_state v s))",
                    "c11_H1 : Pos.lt v1 v"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : In (pair v' i') (cons (pair v1 i1) s)"
                ],
                "tactic_res": [
                    "c12_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : In (pair v' i') (cons (pair v1 i1) (remove_state v s))"
                ],
                "tactic_res": [
                    "c13_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_v1 : ident",
                    "c9_H1 : eq v v1"
                ],
                "tactic_res": [
                    "c9_H0 : or (eq (pair v i1) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c9_goal : In (pair v' i') s",
                    "c9_H0 : or (eq (pair v i1) (pair v' i')) (In (pair v' i') s)",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_i' : debuginfo",
                    "c2_v' : ident"
                ],
                "tactic_res": [
                    "c14_goal : In (pair v' i') s",
                    "c14_H0 : eq (pair v i1) (pair v' i')",
                    "c15_goal : In (pair v' i') s",
                    "c15_H0 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c14_goal : In (pair v' i') s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : In (pair v' i') s",
                    "c15_H0 : In (pair v' i') s",
                    "c2_s : list (prod ident debuginfo)",
                    "c2_i' : debuginfo",
                    "c2_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c13_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c8_H0 : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') s)",
                    "c11_H1 : Pos.lt v1 v",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v : ident",
                    "c2_v' : ident"
                ],
                "tactic_res": [
                    "c16_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c16_H0 : eq (pair v1 i1) (pair v' i')",
                    "c17_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c17_H0 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c16_H0 : eq (pair v1 i1) (pair v' i')",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v : ident",
                    "c2_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : or (eq (pair v1 i1) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c17_H0 : In (pair v' i') s",
                    "c8_H : not (eq v' v)",
                    "c4_IHs : forall (_ : not (eq v' v)) (_ : In (pair v' i') s),\nIn (pair v' i') (remove_state v s)",
                    "c2_s : list (prod ident debuginfo)",
                    "c4_i1 : debuginfo",
                    "c4_v1 : ident",
                    "c2_i' : debuginfo",
                    "c2_v : ident",
                    "c2_v' : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "remove_state_3",
        "proof": [
            {
                "tactic_sig": "Lemma remove_state_3 : forall v v' i' s , wf_avail s -> In ( v' , i' ) ( remove_state v s ) -> v' <> v /\\ In ( v' , i' ) s .",
                "tactic_sig_no_out_arg": "Lemma remove_state_3 : forall v v' i' s , wf_avail s -> In ( v' , i' ) ( remove_state v s ) -> v' <> v /\\ In ( v' , i' ) s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v v' : ident) (i' : debuginfo) (s : avail) \n  (_ : wf_avail s) (_ : In (pair v' i') (remove_state v s)),\nand (not (eq v' v)) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v v' : ident) (i' : debuginfo) (s : avail) \n  (_ : wf_avail s) (_ : In (pair v' i') (remove_state v s)),\nand (not (eq v' v)) (In (pair v' i') s)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : In (pair v' i') (remove_state v nil),\nand (not (eq v' v)) (In (pair v' i') nil)",
                    "c2_i' : debuginfo",
                    "c2_v' : ident",
                    "c2_v : ident",
                    "c3_goal : forall _ : In (pair v' i') (remove_state v (cons (pair v0 i) s)),\nand (not (eq v' v)) (In (pair v' i') (cons (pair v0 i) s))",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (remove_state v s),\nand (not (eq v' v)) (In (pair v' i') s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : In (pair v' i') (remove_state v nil),\nand (not (eq v' v)) (In (pair v' i') nil)"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : False, and (not (eq v' v)) False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : False, and (not (eq v' v)) False"
                ],
                "tactic_res": [
                    "c5_goal : and (not (eq v' v)) False",
                    "c5_H : False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : In (pair v' i') (remove_state v (cons (pair v0 i) s)),\nand (not (eq v' v)) (In (pair v' i') (cons (pair v0 i) s))"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : In (pair v' i')\n        match Pos.compare v v0 with\n        | Eq => s\n        | Lt => cons (pair v0 i) s\n        | Gt => cons (pair v0 i) (remove_state v s)\n        end,\nand (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : In (pair v' i')\n        match Pos.compare v v0 with\n        | Eq => s\n        | Lt => cons (pair v0 i) s\n        | Gt => cons (pair v0 i) (remove_state v s)\n        end,\nand (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c7_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c7_H1 : In (pair v' i')\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i) s\n  | Gt => cons (pair v0 i) (remove_state v s)\n  end"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "c5_goal : and (not (eq v' v)) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c7_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c3_v : ident",
                    "c3_v0 : ident",
                    "c7_H1 : In (pair v' i')\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i) s\n  | Gt => cons (pair v0 i) (remove_state v s)\n  end",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (remove_state v s),\nand (not (eq v' v)) (In (pair v' i') s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": [
                    "c8_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c8_H2 : eq v v0",
                    "c8_H1 : In (pair v' i') s",
                    "c9_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c9_H2 : Pos.lt v v0",
                    "c9_H1 : In (pair v' i') (cons (pair v0 i) s)",
                    "c10_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c10_H2 : Pos.lt v0 v",
                    "c10_H1 : In (pair v' i') (cons (pair v0 i) (remove_state v s))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c8_H1 : In (pair v' i') s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c9_H1 : In (pair v' i') (cons (pair v0 i) s)"
                ],
                "tactic_res": [
                    "c9_H1 : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c10_H1 : In (pair v' i') (cons (pair v0 i) (remove_state v s))"
                ],
                "tactic_res": [
                    "c10_H1 : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') (remove_state v s))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c8_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c3_v0 : ident",
                    "c8_H2 : eq v v0"
                ],
                "tactic_res": [
                    "c11_goal : and (not (eq v' v))\n  (or (eq (pair v i) (pair v' i')) (In (pair v' i') s))",
                    "c11_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c11_goal : and (not (eq v' v))\n  (or (eq (pair v i) (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c12_goal : not (eq v' v)",
                    "c13_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : or (eq (pair v i) (pair v' i')) (In (pair v' i') s)",
                    "c8_H1 : In (pair v' i') s",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_i : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c14_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c15_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : Plt v v'",
                    "c8_H1 : In (pair v' i') s",
                    "c11_H : avail_above v s",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c9_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c9_H1 : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s)",
                    "c9_H2 : Pos.lt v v0",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (remove_state v s),\nand (not (eq v' v)) (In (pair v' i') s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": [
                    "c16_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c16_H1 : eq (pair v0 i) (pair v' i')",
                    "c17_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c17_H1 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c16_H1 : eq (pair v0 i) (pair v' i')"
                ],
                "tactic_res": [
                    "c18_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))",
                    "c18_H2 : Pos.lt v v'",
                    "c18_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c18_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c19_goal : not (eq v' v)",
                    "c20_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c21_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c22_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : Plt v v'",
                    "c18_H2 : Pos.lt v v'",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c17_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c23_goal : not (eq v' v)",
                    "c24_goal : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s)",
                    "c17_H1 : In (pair v' i') s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : not (eq v' v)",
                    "_global_not_eq_sym : forall (A : Type) (x y : A) (_ : not (eq x y)), not (eq y x)"
                ],
                "tactic_res": [
                    "c25_goal : not (eq v v')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : not (eq v v')",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c26_goal : Plt v v'"
                ]
            },
            {
                "tactic_sig": "apply _i with _i .",
                "tactic_sig_no_out_arg": "apply _i with _i .",
                "tactic_args": [
                    "c26_goal : Plt v v'",
                    "_global_Plt_trans : forall (x y z : positive) (_ : Plt x y) (_ : Plt y z), Plt x z",
                    "c3_v0 : ident"
                ],
                "tactic_res": [
                    "c27_goal : Plt v v0",
                    "c28_goal : Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : Plt v v0",
                    "c9_H2 : Pos.lt v v0",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : Plt v0 v'",
                    "c17_H1 : In (pair v' i') s",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c10_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c10_H1 : or (eq (pair v0 i) (pair v' i')) (In (pair v' i') (remove_state v s))",
                    "c10_H2 : Pos.lt v0 v",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (remove_state v s),\nand (not (eq v' v)) (In (pair v' i') s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": [
                    "c29_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c29_H1 : eq (pair v0 i) (pair v' i')",
                    "c30_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c30_H1 : In (pair v' i') (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c29_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c29_H1 : eq (pair v0 i) (pair v' i')"
                ],
                "tactic_res": [
                    "c31_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))",
                    "c31_H2 : Pos.lt v' v",
                    "c31_H : avail_above v' s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c31_goal : and (not (eq v' v))\n  (or (eq (pair v' i') (pair v' i')) (In (pair v' i') s))"
                ],
                "tactic_res": [
                    "c32_goal : not (eq v' v)",
                    "c33_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : or (eq (pair v' i') (pair v' i')) (In (pair v' i') s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : not (eq v' v)",
                    "_global_Plt_ne : forall (x y : positive) (_ : Plt x y), not (eq x y)"
                ],
                "tactic_res": [
                    "c34_goal : Plt v' v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Plt v' v",
                    "c31_H2 : Pos.lt v' v",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ A B ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ A B ] .",
                "tactic_args": [
                    "c30_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c3_IHwf_avail : forall _ : In (pair v' i') (remove_state v s),\nand (not (eq v' v)) (In (pair v' i') s)",
                    "c10_H2 : Pos.lt v0 v",
                    "c30_H1 : In (pair v' i') (remove_state v s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": [
                    "c35_goal : In (pair v' i') (remove_state v s)",
                    "c36_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c36_B : In (pair v' i') s",
                    "c36_A : not (eq v' v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : In (pair v' i') (remove_state v s)",
                    "c30_H1 : In (pair v' i') (remove_state v s)",
                    "c3_s : avail",
                    "c3_i' : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : and (not (eq v' v))\n  (or (eq (pair v0 i) (pair v' i')) (In (pair v' i') s))",
                    "c36_B : In (pair v' i') s",
                    "c36_A : not (eq v' v)",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_i' : debuginfo",
                    "c3_v : ident",
                    "c3_v' : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wf_remove_state",
        "proof": [
            {
                "tactic_sig": "Lemma wf_remove_state : forall v s , wf_avail s -> wf_avail ( remove_state v s ) .",
                "tactic_sig_no_out_arg": "Lemma wf_remove_state : forall v s , wf_avail s -> wf_avail ( remove_state v s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (s : avail) (_ : wf_avail s),\nwf_avail (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (s : avail) (_ : wf_avail s),\nwf_avail (remove_state v s)"
                ],
                "tactic_res": [
                    "c2_goal : wf_avail (remove_state v nil)",
                    "c2_v : ident",
                    "c3_goal : wf_avail (remove_state v (cons (pair v0 i) s))",
                    "c3_IHwf_avail : wf_avail (remove_state v s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v0 : ident",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wf_avail (remove_state v nil)"
                ],
                "tactic_res": [
                    "c4_goal : wf_avail nil"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : wf_avail (remove_state v (cons (pair v0 i) s))"
                ],
                "tactic_res": [
                    "c5_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i) s\n  | Gt => cons (pair v0 i) (remove_state v s)\n  end"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c5_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq => s\n  | Lt => cons (pair v0 i) s\n  | Gt => cons (pair v0 i) (remove_state v s)\n  end",
                    "c3_v : ident",
                    "c3_v0 : ident",
                    "c3_IHwf_avail : wf_avail (remove_state v s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c6_goal : wf_avail s",
                    "c6_H1 : eq v v0",
                    "c7_goal : wf_avail (cons (pair v0 i) s)",
                    "c7_H1 : Pos.lt v v0",
                    "c8_goal : wf_avail (cons (pair v0 i) (remove_state v s))",
                    "c8_H1 : Pos.lt v0 v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : wf_avail s",
                    "c3_H0 : wf_avail s",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : wf_avail (cons (pair v0 i) s)"
                ],
                "tactic_res": [
                    "c9_goal : avail_above v0 s",
                    "c10_goal : wf_avail s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : avail_above v0 s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_v0 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : wf_avail s",
                    "c3_H0 : wf_avail s",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c8_goal : wf_avail (cons (pair v0 i) (remove_state v s))"
                ],
                "tactic_res": [
                    "c11_goal : avail_above v0 (remove_state v s)",
                    "c12_goal : wf_avail (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : wf_avail (remove_state v s)",
                    "c3_IHwf_avail : wf_avail (remove_state v s)",
                    "c3_s : avail",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : avail_above v0 (remove_state v s)"
                ],
                "tactic_res": [
                    "c13_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (remove_state v s)), Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c13_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (remove_state v s)), Plt v0 v'"
                ],
                "tactic_res": [
                    "c14_goal : Plt v0 v'",
                    "c14_v' : ident",
                    "c14_i' : debuginfo",
                    "c14_H2 : In (pair v' i') (remove_state v s)"
                ]
            },
            {
                "tactic_sig": "exploit remove_state_3 .",
                "tactic_sig_no_out_arg": "exploit remove_state_3 .",
                "tactic_args": [
                    "c14_goal : Plt v0 v'"
                ],
                "tactic_res": [
                    "c15_goal : wf_avail ?Goal2",
                    "c16_goal : In (pair ?Goal0 ?Goal1) (remove_state ?Goal s)",
                    "c17_goal : forall _ : and (not (eq v' v)) (In (pair v' i') s), Plt v0 v'"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c15_goal : wf_avail ?Goal2",
                    "c3_H0 : wf_avail s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c16_goal : In (pair ?Goal0 ?Goal1) (remove_state ?Goal s)",
                    "c14_H2 : In (pair v' i') (remove_state v s)",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c17_goal : forall _ : and (not (eq v' v)) (In (pair v' i') s), Plt v0 v'"
                ],
                "tactic_res": [
                    "c18_goal : Plt v0 v'",
                    "c18_A : not (eq v' v)",
                    "c18_B : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : Plt v0 v'",
                    "c18_B : In (pair v' i') s",
                    "c14_v' : ident",
                    "c3_H : avail_above v0 s",
                    "c3_v0 : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wf_filter",
        "proof": [
            {
                "tactic_sig": "Lemma wf_filter : forall pred s , wf_avail s -> wf_avail ( List.filter pred s ) .",
                "tactic_sig_no_out_arg": "Lemma wf_filter : forall pred s , wf_avail s -> wf_avail ( List.filter pred s ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (pred : forall _ : prod ident debuginfo, bool) \n  (s : avail) (_ : wf_avail s), wf_avail (filter pred s)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (pred : forall _ : prod ident debuginfo, bool) \n  (s : avail) (_ : wf_avail s), wf_avail (filter pred s)"
                ],
                "tactic_res": [
                    "c2_goal : wf_avail (filter pred nil)",
                    "c2_pred : forall _ : prod ident debuginfo, bool",
                    "c3_goal : wf_avail (filter pred (cons (pair v i) s))",
                    "c3_IHwf_avail : wf_avail (filter pred s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident",
                    "c3_pred : forall _ : prod ident debuginfo, bool"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wf_avail (filter pred nil)"
                ],
                "tactic_res": [
                    "c4_goal : wf_avail nil"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : wf_avail (filter pred (cons (pair v i) s))"
                ],
                "tactic_res": [
                    "c5_goal : wf_avail\n  (if pred (pair v i)\n   then cons (pair v i) (filter pred s)\n   else filter pred s)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i ( _i , _i ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( _i ( _i , _i ) ) eqn : P .",
                "tactic_args": [
                    "c5_goal : wf_avail\n  (if pred (pair v i)\n   then cons (pair v i) (filter pred s)\n   else filter pred s)",
                    "c3_pred : forall _ : prod ident debuginfo, bool",
                    "c3_v : ident",
                    "c3_i : debuginfo",
                    "c3_IHwf_avail : wf_avail (filter pred s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_s : avail"
                ],
                "tactic_res": [
                    "c6_goal : wf_avail (cons (pair v i) (filter pred s))",
                    "c6_P : eq (pred (pair v i)) true",
                    "c7_goal : wf_avail (filter pred s)",
                    "c7_P : eq (pred (pair v i)) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : wf_avail (filter pred s)",
                    "c3_IHwf_avail : wf_avail (filter pred s)",
                    "c3_s : avail",
                    "c3_pred : forall _ : prod ident debuginfo, bool"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : wf_avail (cons (pair v i) (filter pred s))"
                ],
                "tactic_res": [
                    "c8_goal : avail_above v (filter pred s)",
                    "c9_goal : wf_avail (filter pred s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : wf_avail (filter pred s)",
                    "c3_IHwf_avail : wf_avail (filter pred s)",
                    "c3_s : avail",
                    "c3_pred : forall _ : prod ident debuginfo, bool"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c8_goal : avail_above v (filter pred s)"
                ],
                "tactic_res": [
                    "c10_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (filter pred s)), Plt v v'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (v' : ident) (i' : debuginfo)\n  (_ : In (pair v' i') (filter pred s)), Plt v v'"
                ],
                "tactic_res": [
                    "c11_goal : Plt v v'",
                    "c11_v' : ident",
                    "c11_i' : debuginfo",
                    "c11_H1 : In (pair v' i') (filter pred s)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_filter_In : forall (A : Type) (f : forall _ : A, bool) (x : A) (l : list A),\n       iff (In x (filter f l)) (and (In x l) (eq (f x) true))",
                    "c11_H1 : In (pair v' i') (filter pred s)"
                ],
                "tactic_res": [
                    "c11_H1 : and (In (pair v' i') s) (eq (pred (pair v' i')) true)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c11_H1 : and (In (pair v' i') s) (eq (pred (pair v' i')) true)",
                    "c11_v' : ident",
                    "c6_P : eq (pred (pair v i)) true",
                    "c3_IHwf_avail : wf_avail (filter pred s)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c11_H2 : eq (pred (pair v' i')) true",
                    "c11_H1 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : Plt v v'",
                    "c11_H1 : In (pair v' i') s",
                    "c11_v' : ident",
                    "c3_H : avail_above v s",
                    "c3_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "join_1",
        "proof": [
            {
                "tactic_sig": "Lemma join_1 : forall v i s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> In ( v , i ) s1 -> In ( v , i ) s2 -> In ( v , i ) ( join s1 s2 ) .",
                "tactic_sig_no_out_arg": "Lemma join_1 : forall v i s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> In ( v , i ) s1 -> In ( v , i ) s2 -> In ( v , i ) ( join s1 s2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s1 : avail) (_ : wf_avail s1)\n  (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s1)\n  (_ : In (pair v i) s2), In (pair v i) (join s1 s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s1 : avail) (_ : wf_avail s1)\n  (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s1)\n  (_ : In (pair v i) s2), In (pair v i) (join s1 s2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) nil)\n  (_ : In (pair v i) s2), In (pair v i) (join nil s2)",
                    "c2_i : debuginfo",
                    "c2_v : ident",
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i) (cons (pair v0 i0) s)) (_ : In (pair v i) s2),\nIn (pair v i) (join (cons (pair v0 i0) s) s2)",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) nil)\n  (_ : In (pair v i) s2), In (pair v i) (join nil s2)"
                ],
                "tactic_res": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : False)\n  (_ : In (pair v i) s2), False"
                ]
            },
            {
                "tactic_sig": "try tauto .",
                "tactic_sig_no_out_arg": "try tauto .",
                "tactic_args": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : False)\n  (_ : In (pair v i) s2), False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i) (cons (pair v0 i0) s)) (_ : In (pair v i) s2),\nIn (pair v i) (join (cons (pair v0 i0) s) s2)"
                ],
                "tactic_res": [
                    "c5_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s2),\nIn (pair v i)\n  ((fix join2 (s0 : avail) : avail :=\n      match s0 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s0\n          | Gt => join2 s2'\n          end\n      end) s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c5_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s2),\nIn (pair v i)\n  ((fix join2 (s0 : avail) : avail :=\n      match s0 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s0\n          | Gt => join2 s2'\n          end\n      end) s2)"
                ],
                "tactic_res": [
                    "c6_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) nil), In (pair v i) nil",
                    "c7_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) (cons (pair v1 i1) s0)),\nIn (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c7_v1 : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) nil), In (pair v i) nil"
                ],
                "tactic_res": [
                    "c8_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : False), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros I1 I2 .",
                "tactic_args": [
                    "c8_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : False), False"
                ],
                "tactic_res": [
                    "c9_goal : False",
                    "c9_I1 : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)",
                    "c9_I2 : False"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : False",
                    "c9_I2 : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) (cons (pair v1 i1) s0)),\nIn (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end"
                ],
                "tactic_res": [
                    "c10_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)),\nIn (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros I1 I2 .",
                "tactic_args": [
                    "c10_goal : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)),\nIn (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end"
                ],
                "tactic_res": [
                    "c11_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c11_I1 : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)",
                    "c11_I2 : or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [  _o _o | _o _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "c11_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c11_I1 : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)",
                    "c11_I2 : or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c7_v1 : ident",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c12_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c12_H4 : eq (pair v1 i1) (pair v i)",
                    "c12_H3 : eq (pair v0 i0) (pair v i)",
                    "c13_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c13_H4 : In (pair v i) s0",
                    "c13_H3 : eq (pair v0 i0) (pair v i)",
                    "c14_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c14_H4 : eq (pair v1 i1) (pair v i)",
                    "c14_H3 : In (pair v i) s",
                    "c15_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c12_H3 : eq (pair v0 i0) (pair v i)"
                ],
                "tactic_res": [
                    "c16_goal : In (pair v i)\n  match Pos.compare v v1 with\n  | Eq =>\n      if eq_debuginfo i i1\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c16_IHwf_avail0 : forall (_ : or (eq (pair v i) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c16_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : In (pair v i)\n  match Pos.compare v v1 with\n  | Eq =>\n      if eq_debuginfo i i1\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c12_H4 : eq (pair v1 i1) (pair v i)"
                ],
                "tactic_res": [
                    "c17_goal : In (pair v i)\n  match Pos.compare v v with\n  | Eq =>\n      if eq_debuginfo i i\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v i) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c17_H1 : avail_above v s0"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c17_goal : In (pair v i)\n  match Pos.compare v v with\n  | Eq =>\n      if eq_debuginfo i i\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v i) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "_global_Pos.compare_refl : forall x : positive, eq (Pos.compare x x) Eq"
                ],
                "tactic_res": [
                    "c18_goal : In (pair v i)\n  (if eq_debuginfo i i then cons (pair v i) (join s s0) else join s s0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : In (pair v i)\n  (if eq_debuginfo i i then cons (pair v i) (join s s0) else join s s0)",
                    "_global_dec_eq_true : forall (A : Type)\n         (dec_eq : forall x y : A, sumbool (eq x y) (not (eq x y)))\n         (B : Type) (x : A) (ifso ifnot : B),\n       eq (if dec_eq x x then ifso else ifnot) ifso"
                ],
                "tactic_res": [
                    "c19_goal : In (pair v i) (cons (pair v i) (join s s0))"
                ]
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c19_goal : In (pair v i) (cons (pair v i) (join s s0))",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c13_H3 : eq (pair v0 i0) (pair v i)"
                ],
                "tactic_res": [
                    "c20_goal : In (pair v i)\n  match Pos.compare v v1 with\n  | Eq =>\n      if eq_debuginfo i i1\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c20_IHwf_avail0 : forall (_ : or (eq (pair v i) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c20_H : avail_above v s"
                ]
            },
            {
                "tactic_sig": "assert ( L : Plt _i _i ) by eauto .",
                "tactic_sig_no_out_arg": "assert ( L : Plt _i _i ) by eauto .",
                "tactic_args": [
                    "c7_v1 : ident",
                    "c3_v : ident",
                    "c13_H4 : In (pair v i) s0",
                    "c20_IHwf_avail0 : forall (_ : or (eq (pair v i) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c20_H : avail_above v s",
                    "c3_s : avail",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c20_L : Plt v1 v"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Pos.compare_gt_iff : forall x y : positive, iff (eq (Pos.compare x y) Gt) (Pos.lt y x)",
                    "c20_L : Plt v1 v"
                ],
                "tactic_res": [
                    "c20_L : eq (Pos.compare v v1) Gt"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : In (pair v i)\n  match Pos.compare v v1 with\n  | Eq =>\n      if eq_debuginfo i i1\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c20_L : eq (Pos.compare v v1) Gt"
                ],
                "tactic_res": [
                    "c21_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c13_H4 : In (pair v i) s0",
                    "c20_IHwf_avail0 : forall (_ : or (eq (pair v i) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c14_H4 : eq (pair v1 i1) (pair v i)"
                ],
                "tactic_res": [
                    "c22_goal : In (pair v i)\n  match Pos.compare v0 v with\n  | Eq =>\n      if eq_debuginfo i0 i\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v i) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c22_H1 : avail_above v s0"
                ]
            },
            {
                "tactic_sig": "assert ( L : Plt _i _i ) by eauto .",
                "tactic_sig_no_out_arg": "assert ( L : Plt _i _i ) by eauto .",
                "tactic_args": [
                    "c3_v0 : ident",
                    "c3_v : ident",
                    "c14_H3 : In (pair v i) s",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c22_H1 : avail_above v s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c22_L : Plt v0 v"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "_global_Pos.compare_lt_iff : forall p q : positive, iff (eq (Pos.compare p q) Lt) (Pos.lt p q)",
                    "c22_L : Plt v0 v"
                ],
                "tactic_res": [
                    "c22_L : eq (Pos.compare v0 v) Lt"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : In (pair v i)\n  match Pos.compare v0 v with\n  | Eq =>\n      if eq_debuginfo i0 i\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v i) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c22_L : eq (Pos.compare v0 v) Lt"
                ],
                "tactic_res": [
                    "c23_goal : In (pair v i) (join s (cons (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : In (pair v i) (join s (cons (pair v i) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)"
                ],
                "tactic_res": [
                    "c24_goal : wf_avail (cons (pair v i) s0)",
                    "c25_goal : In (pair v i) s",
                    "c26_goal : In (pair v i) (cons (pair v i) s0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c24_goal : wf_avail (cons (pair v i) s0)"
                ],
                "tactic_res": [
                    "c27_goal : avail_above v s0",
                    "c28_goal : wf_avail s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : avail_above v s0",
                    "c22_H1 : avail_above v s0",
                    "c7_s0 : avail",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : wf_avail s0",
                    "c7_H2 : wf_avail s0",
                    "c7_s0 : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : In (pair v i) s",
                    "c14_H3 : In (pair v i) s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c26_goal : In (pair v i) (cons (pair v i) s0)",
                    "c7_s0 : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare _i _i ) as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare _i _i ) .",
                "tactic_args": [
                    "c15_goal : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c3_v0 : ident",
                    "c7_v1 : ident",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c29_goal : In (pair v i)\n  (if eq_debuginfo i0 i1\n   then cons (pair v0 i0) (join s s0)\n   else join s s0)",
                    "c30_goal : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c31_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)"
                ]
            },
            {
                "tactic_sig": "destruct ( eq_debuginfo _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( eq_debuginfo _i _i ) .",
                "tactic_args": [
                    "c29_goal : In (pair v i)\n  (if eq_debuginfo i0 i1\n   then cons (pair v0 i0) (join s s0)\n   else join s s0)",
                    "c3_i0 : debuginfo",
                    "c7_i1 : debuginfo",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c32_goal : In (pair v i) (cons (pair v0 i0) (join s s0))",
                    "c32_e : eq i0 i1",
                    "c33_goal : In (pair v i) (join s s0)",
                    "c33_n : not (eq i0 i1)"
                ]
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c32_goal : In (pair v i) (cons (pair v0 i0) (join s s0))",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s",
                    "c7_H2 : wf_avail s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c33_goal : In (pair v i) (join s s0)",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s",
                    "c7_H2 : wf_avail s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c30_goal : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) s)\n  (_ : In (pair v i) s2), In (pair v i) (join s s2)"
                ],
                "tactic_res": [
                    "c34_goal : wf_avail (cons (pair v1 i1) s0)",
                    "c35_goal : In (pair v i) s",
                    "c36_goal : In (pair v i) (cons (pair v1 i1) s0)"
                ]
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c35_goal : In (pair v i) s",
                    "c15_H3 : In (pair v i) s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with coqlib .",
                "tactic_sig_no_out_arg": "auto with coqlib .",
                "tactic_args": [
                    "c36_goal : In (pair v i) (cons (pair v1 i1) s0)",
                    "c15_H4 : In (pair v i) s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c7_v1 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c34_goal : wf_avail (cons (pair v1 i1) s0)"
                ],
                "tactic_res": [
                    "c37_goal : avail_above v1 s0",
                    "c38_goal : wf_avail s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : avail_above v1 s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_v1 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : wf_avail s0",
                    "c7_H2 : wf_avail s0",
                    "c7_s0 : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c31_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c15_H4 : In (pair v i) s0",
                    "c15_H3 : In (pair v i) s",
                    "c7_IHwf_avail0 : forall (_ : or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (_ : In (pair v i) s0),\nIn (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "join_2",
        "proof": [
            {
                "tactic_sig": "Lemma join_2 : forall v i s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> In ( v , i ) ( join s1 s2 ) -> In ( v , i ) s1 /\\ In ( v , i ) s2 .",
                "tactic_sig_no_out_arg": "Lemma join_2 : forall v i s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> In ( v , i ) ( join s1 s2 ) -> In ( v , i ) s1 /\\ In ( v , i ) s2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s1 : avail) (_ : wf_avail s1)\n  (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s1 s2)),\nand (In (pair v i) s1) (In (pair v i) s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v : ident) (i : debuginfo) (s1 : avail) (_ : wf_avail s1)\n  (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s1 s2)),\nand (In (pair v i) s1) (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join nil s2)),\nand (In (pair v i) nil) (In (pair v i) s2)",
                    "c2_i : debuginfo",
                    "c2_v : ident",
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i) (join (cons (pair v0 i0) s) s2)),\nand (In (pair v i) (cons (pair v0 i0) s)) (In (pair v i) s2)",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join nil s2)),\nand (In (pair v i) nil) (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : False),\nand False (In (pair v i) s2)"
                ]
            },
            {
                "tactic_sig": "try tauto .",
                "tactic_sig_no_out_arg": "try tauto .",
                "tactic_args": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2) (_ : False),\nand False (In (pair v i) s2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i) (join (cons (pair v0 i0) s) s2)),\nand (In (pair v i) (cons (pair v0 i0) s)) (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c5_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i)\n         ((fix join2 (s0 : avail) : avail :=\n             match s0 with\n             | nil => nil\n             | cons (pair v2 i2) s2' =>\n                 match Pos.compare v0 v2 with\n                 | Eq =>\n                     if eq_debuginfo i0 i2\n                     then cons (pair v0 i0) (join s s2')\n                     else join s s2'\n                 | Lt => join s s0\n                 | Gt => join2 s2'\n                 end\n             end) s2)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c5_goal : forall (s2 : avail) (_ : wf_avail s2)\n  (_ : In (pair v i)\n         ((fix join2 (s0 : avail) : avail :=\n             match s0 with\n             | nil => nil\n             | cons (pair v2 i2) s2' =>\n                 match Pos.compare v0 v2 with\n                 | Eq =>\n                     if eq_debuginfo i0 i2\n                     then cons (pair v0 i0) (join s s2')\n                     else join s s2'\n                 | Lt => join s s0\n                 | Gt => join2 s2'\n                 end\n             end) s2)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : In (pair v i) nil,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) nil)",
                    "c7_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v0 v1 with\n        | Eq =>\n            if eq_debuginfo i0 i1\n            then cons (pair v0 i0) (join s s0)\n            else join s s0\n        | Lt => join s (cons (pair v1 i1) s0)\n        | Gt =>\n            (fix join2 (s2 : avail) : avail :=\n               match s2 with\n               | nil => nil\n               | cons (pair v2 i2) s2' =>\n                   match Pos.compare v0 v2 with\n                   | Eq =>\n                       if eq_debuginfo i0 i2\n                       then cons (pair v0 i0) (join s s2')\n                       else join s s2'\n                   | Lt => join s s2\n                   | Gt => join2 s2'\n                   end\n               end) s0\n        end,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) (cons (pair v1 i1) s0))",
                    "c7_IHwf_avail0 : forall\n  _ : In (pair v i)\n        ((fix join2 (s2 : avail) : avail :=\n            match s2 with\n            | nil => nil\n            | cons (pair v2 i2) s2' =>\n                match Pos.compare v0 v2 with\n                | Eq =>\n                    if eq_debuginfo i0 i2\n                    then cons (pair v0 i0) (join s s2')\n                    else join s s2'\n                | Lt => join s s2\n                | Gt => join2 s2'\n                end\n            end) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c7_v1 : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall _ : In (pair v i) nil,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) nil)"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : False,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)) False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros I .",
                "tactic_args": [
                    "c8_goal : forall _ : False,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)) False"
                ],
                "tactic_res": [
                    "c9_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)) False",
                    "c9_I : False"
                ]
            },
            {
                "tactic_sig": "try tauto .",
                "tactic_sig_no_out_arg": "try tauto .",
                "tactic_args": [
                    "c9_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s)) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v0 v1 with\n        | Eq =>\n            if eq_debuginfo i0 i1\n            then cons (pair v0 i0) (join s s0)\n            else join s s0\n        | Lt => join s (cons (pair v1 i1) s0)\n        | Gt =>\n            (fix join2 (s2 : avail) : avail :=\n               match s2 with\n               | nil => nil\n               | cons (pair v2 i2) s2' =>\n                   match Pos.compare v0 v2 with\n                   | Eq =>\n                       if eq_debuginfo i0 i2\n                       then cons (pair v0 i0) (join s s2')\n                       else join s s2'\n                   | Lt => join s s2\n                   | Gt => join2 s2'\n                   end\n               end) s0\n        end,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) (cons (pair v1 i1) s0))"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v0 v1 with\n        | Eq =>\n            if eq_debuginfo i0 i1\n            then cons (pair v0 i0) (join s s0)\n            else join s s0\n        | Lt => join s (cons (pair v1 i1) s0)\n        | Gt =>\n            (fix join2 (s2 : avail) : avail :=\n               match s2 with\n               | nil => nil\n               | cons (pair v2 i2) s2' =>\n                   match Pos.compare v0 v2 with\n                   | Eq =>\n                       if eq_debuginfo i0 i2\n                       then cons (pair v0 i0) (join s s2')\n                       else join s s2'\n                   | Lt => join s s2\n                   | Gt => join2 s2'\n                   end\n               end) s0\n        end,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros I .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : In (pair v i)\n        match Pos.compare v0 v1 with\n        | Eq =>\n            if eq_debuginfo i0 i1\n            then cons (pair v0 i0) (join s s0)\n            else join s s0\n        | Lt => join s (cons (pair v1 i1) s0)\n        | Gt =>\n            (fix join2 (s2 : avail) : avail :=\n               match s2 with\n               | nil => nil\n               | cons (pair v2 i2) s2' =>\n                   match Pos.compare v0 v2 with\n                   | Eq =>\n                       if eq_debuginfo i0 i2\n                       then cons (pair v0 i0) (join s s2')\n                       else join s s2'\n                   | Lt => join s s2\n                   | Gt => join2 s2'\n                   end\n               end) s0\n        end,\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": [
                    "c11_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c11_I : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end"
                ]
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o _o | _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c11_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c3_v0 : ident",
                    "c7_v1 : ident",
                    "c11_I : In (pair v i)\n  match Pos.compare v0 v1 with\n  | Eq =>\n      if eq_debuginfo i0 i1\n      then cons (pair v0 i0) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v1 i1) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v0 v2 with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then cons (pair v0 i0) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c7_IHwf_avail0 : forall\n  _ : In (pair v i)\n        ((fix join2 (s2 : avail) : avail :=\n            match s2 with\n            | nil => nil\n            | cons (pair v2 i2) s2' =>\n                match Pos.compare v0 v2 with\n                | Eq =>\n                    if eq_debuginfo i0 i2\n                    then cons (pair v0 i0) (join s s2')\n                    else join s s2'\n                | Lt => join s s2\n                | Gt => join2 s2'\n                end\n            end) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s0)",
                    "c7_H2 : wf_avail s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c12_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c12_H3 : eq v0 v1",
                    "c12_I : In (pair v i)\n  (if eq_debuginfo i0 i1\n   then cons (pair v0 i0) (join s s0)\n   else join s s0)",
                    "c13_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c13_H3 : Pos.lt v0 v1",
                    "c13_I : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c14_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c14_H3 : Pos.lt v1 v0",
                    "c14_I : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c12_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c7_v1 : ident",
                    "c12_H3 : eq v0 v1"
                ],
                "tactic_res": [
                    "c15_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c15_H1 : avail_above v0 s0"
                ]
            },
            {
                "tactic_sig": "destruct ( eq_debuginfo _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( eq_debuginfo _i _i ) .",
                "tactic_args": [
                    "c15_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c3_i0 : debuginfo",
                    "c7_i1 : debuginfo",
                    "c12_I : In (pair v i)\n  (if eq_debuginfo i0 i1\n   then cons (pair v0 i0) (join s s0)\n   else join s s0)",
                    "c7_IHwf_avail0 : forall\n  _ : In (pair v i)\n        ((fix join2 (s2 : avail) : avail :=\n            match s2 with\n            | nil => nil\n            | cons (pair v2 i2) s2' =>\n                match Pos.compare v0 v2 with\n                | Eq =>\n                    if eq_debuginfo i0 i2\n                    then cons (pair v0 i0) (join s s2')\n                    else join s s2'\n                | Lt => join s s2\n                | Gt => join2 s2'\n                end\n            end) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s0)",
                    "c7_H2 : wf_avail s0",
                    "c15_H1 : avail_above v0 s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c16_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c16_I : In (pair v i) (cons (pair v0 i0) (join s s0))",
                    "c16_e : eq i0 i1",
                    "c17_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c17_I : In (pair v i) (join s s0)",
                    "c17_n : not (eq i0 i1)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c16_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c7_i1 : debuginfo",
                    "c16_e : eq i0 i1"
                ],
                "tactic_res": [
                    "c18_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c18_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))",
                    "c16_I : In (pair v i) (cons (pair v0 i0) (join s s0))",
                    "c7_IHwf_avail0 : forall\n  _ : In (pair v i)\n        ((fix join2 (s2 : avail) : avail :=\n            match s2 with\n            | nil => nil\n            | cons (pair v2 i2) s2' =>\n                match Pos.compare v0 v2 with\n                | Eq =>\n                    if eq_debuginfo i0 i2\n                    then cons (pair v0 i0) (join s s2')\n                    else join s s2'\n                | Lt => join s s2\n                | Gt => join2 s2'\n                end\n            end) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s0)",
                    "c7_H2 : wf_avail s0",
                    "c15_H1 : avail_above v0 s0",
                    "c7_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v0 s",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c19_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))",
                    "c19_H3 : eq (pair v0 i0) (pair v i)",
                    "c20_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))",
                    "c20_H3 : In (pair v i) (join s s0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))",
                    "c19_H3 : eq (pair v0 i0) (pair v i)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c20_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c21_goal : wf_avail ?Goal2",
                    "c22_goal : In (pair v i) (join s s0)",
                    "c23_goal : forall _ : and (In (pair v i) s) (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c21_goal : wf_avail ?Goal2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c22_goal : In (pair v i) (join s s0)",
                    "c20_H3 : In (pair v i) (join s s0)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c23_goal : forall _ : and (In (pair v i) s) (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c17_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)"
                ],
                "tactic_res": [
                    "c24_goal : wf_avail ?Goal1",
                    "c25_goal : In (pair v i) (join s s0)",
                    "c26_goal : forall _ : and (In (pair v i) s) (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : wf_avail ?Goal1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : In (pair v i) (join s s0)",
                    "c17_I : In (pair v i) (join s s0)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c26_goal : forall _ : and (In (pair v i) s) (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v0 i1) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( _i ( ( _i , _i ) :: _i ) ) .",
                "tactic_sig_no_out_arg": "exploit ( _i ( ( _i , _i ) :: _i ) ) .",
                "tactic_args": [
                    "c13_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2) (_ : In (pair v i) (join s s2)),\nand (In (pair v i) s) (In (pair v i) s2)",
                    "c7_v1 : ident",
                    "c7_i1 : debuginfo",
                    "c7_s0 : avail"
                ],
                "tactic_res": [
                    "c27_goal : wf_avail (cons (pair v1 i1) s0)",
                    "c28_goal : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c29_goal : forall _ : and (In (pair v i) s) (In (pair v i) (cons (pair v1 i1) s0)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c13_I : In (pair v i) (join s (cons (pair v1 i1) s0))",
                    "c7_s0 : avail",
                    "c7_i1 : debuginfo",
                    "c7_v1 : ident",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c27_goal : wf_avail (cons (pair v1 i1) s0)"
                ],
                "tactic_res": [
                    "c30_goal : avail_above v1 s0",
                    "c31_goal : wf_avail s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : avail_above v1 s0",
                    "c7_H1 : avail_above v1 s0",
                    "c7_s0 : avail",
                    "c7_v1 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : wf_avail s0",
                    "c7_H2 : wf_avail s0",
                    "c7_s0 : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : forall _ : and (In (pair v i) s) (In (pair v i) (cons (pair v1 i1) s0)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": [
                    "c32_goal : forall\n  _ : and (In (pair v i) s)\n        (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : and (In (pair v i) s)\n        (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0)),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "c14_goal : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))",
                    "c7_IHwf_avail0 : forall\n  _ : In (pair v i)\n        ((fix join2 (s2 : avail) : avail :=\n            match s2 with\n            | nil => nil\n            | cons (pair v2 i2) s2' =>\n                match Pos.compare v0 v2 with\n                | Eq =>\n                    if eq_debuginfo i0 i2\n                    then cons (pair v0 i0) (join s s2')\n                    else join s s2'\n                | Lt => join s s2\n                | Gt => join2 s2'\n                end\n            end) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (In (pair v i) s0)"
                ],
                "tactic_res": [
                    "c33_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c34_goal : forall\n  _ : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n        (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c14_I : In (pair v i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v0 v2 with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then cons (pair v0 i0) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c7_s0 : avail",
                    "c3_s : avail",
                    "c3_i0 : debuginfo",
                    "c3_v0 : ident",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c34_goal : forall\n  _ : and (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n        (In (pair v i) s0),\nand (or (eq (pair v0 i0) (pair v i)) (In (pair v i) s))\n  (or (eq (pair v1 i1) (pair v i)) (In (pair v i) s0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wf_join",
        "proof": [
            {
                "tactic_sig": "Lemma wf_join : forall s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> wf_avail ( join s1 s2 ) .",
                "tactic_sig_no_out_arg": "Lemma wf_join : forall s1 , wf_avail s1 -> forall s2 , wf_avail s2 -> wf_avail ( join s1 s2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 : avail) (_ : wf_avail s1) (s2 : avail) (_ : wf_avail s2),\nwf_avail (join s1 s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (s1 : avail) (_ : wf_avail s1) (s2 : avail) (_ : wf_avail s2),\nwf_avail (join s1 s2)"
                ],
                "tactic_res": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join nil s2)",
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2),\nwf_avail (join (cons (pair v i) s) s2)",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_s : avail",
                    "c3_i : debuginfo",
                    "c3_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join nil s2)"
                ],
                "tactic_res": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2), wf_avail nil"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c4_goal : forall (s2 : avail) (_ : wf_avail s2), wf_avail nil"
                ],
                "tactic_res": [
                    "c5_goal : wf_avail nil",
                    "c6_goal : wf_avail nil",
                    "c6_IHwf_avail : wf_avail nil",
                    "c6_H0 : wf_avail s",
                    "c6_H : avail_above v s",
                    "c6_s : avail",
                    "c6_i : debuginfo",
                    "c6_v : ident"
                ]
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c5_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c6_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (s2 : avail) (_ : wf_avail s2),\nwf_avail (join (cons (pair v i) s) s2)"
                ],
                "tactic_res": [
                    "c7_goal : forall (s2 : avail) (_ : wf_avail s2),\nwf_avail\n  ((fix join2 (s0 : avail) : avail :=\n      match s0 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s0\n          | Gt => join2 s2'\n          end\n      end) s2)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c7_goal : forall (s2 : avail) (_ : wf_avail s2),\nwf_avail\n  ((fix join2 (s0 : avail) : avail :=\n      match s0 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s0\n          | Gt => join2 s2'\n          end\n      end) s2)"
                ],
                "tactic_res": [
                    "c8_goal : wf_avail nil",
                    "c9_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq =>\n      if eq_debuginfo i i0\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v0 i0) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c9_IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c9_H2 : wf_avail s0",
                    "c9_H1 : avail_above v0 s0",
                    "c9_s0 : avail",
                    "c9_i0 : debuginfo",
                    "c9_v0 : ident"
                ]
            },
            {
                "tactic_sig": "try constructor .",
                "tactic_sig_no_out_arg": "try constructor .",
                "tactic_args": [
                    "c8_goal : wf_avail nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Pos.compare_spec _i _i ) as [  _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Pos.compare_spec _i _i ) .",
                "tactic_args": [
                    "c9_goal : wf_avail\n  match Pos.compare v v0 with\n  | Eq =>\n      if eq_debuginfo i i0\n      then cons (pair v i) (join s s0)\n      else join s s0\n  | Lt => join s (cons (pair v0 i0) s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | cons (pair v2 i2) s2' =>\n             match Pos.compare v v2 with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then cons (pair v i) (join s s2')\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end",
                    "c3_v : ident",
                    "c9_v0 : ident",
                    "c9_IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c9_H2 : wf_avail s0",
                    "c9_H1 : avail_above v0 s0",
                    "c9_s0 : avail",
                    "c9_i0 : debuginfo",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_s : avail",
                    "c3_i : debuginfo"
                ],
                "tactic_res": [
                    "c10_goal : wf_avail\n  (if eq_debuginfo i i0 then cons (pair v i) (join s s0) else join s s0)",
                    "c10_H3 : eq v v0",
                    "c11_goal : wf_avail (join s (cons (pair v0 i0) s0))",
                    "c11_H3 : Pos.lt v v0",
                    "c12_goal : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c12_H3 : Pos.lt v0 v"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c9_v0 : ident",
                    "c10_H3 : eq v v0"
                ],
                "tactic_res": [
                    "c10_H1 : avail_above v s0"
                ]
            },
            {
                "tactic_sig": "destruct ( eq_debuginfo _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( eq_debuginfo _i _i ) .",
                "tactic_args": [
                    "c10_goal : wf_avail\n  (if eq_debuginfo i i0 then cons (pair v i) (join s s0) else join s s0)",
                    "c3_i : debuginfo",
                    "c9_i0 : debuginfo",
                    "c9_IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c9_H2 : wf_avail s0",
                    "c10_H1 : avail_above v s0",
                    "c9_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_s : avail",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c13_goal : wf_avail (cons (pair v i) (join s s0))",
                    "c13_e : eq i i0",
                    "c14_goal : wf_avail (join s s0)",
                    "c14_n : not (eq i i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : wf_avail (join s s0)",
                    "c9_H2 : wf_avail s0",
                    "c9_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c13_goal : wf_avail (cons (pair v i) (join s s0))"
                ],
                "tactic_res": [
                    "c15_goal : avail_above v (join s s0)",
                    "c16_goal : wf_avail (join s s0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : wf_avail (join s s0)",
                    "c9_H2 : wf_avail s0",
                    "c9_s0 : avail",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c15_goal : avail_above v (join s s0)"
                ],
                "tactic_res": [
                    "c17_goal : forall (v' : ident) (i' : debuginfo) (_ : In (pair v' i') (join s s0)),\nPlt v v'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall (v' : ident) (i' : debuginfo) (_ : In (pair v' i') (join s s0)),\nPlt v v'"
                ],
                "tactic_res": [
                    "c18_goal : Plt v v'",
                    "c18_v' : ident",
                    "c18_i' : debuginfo",
                    "c18_H3 : In (pair v' i') (join s s0)"
                ]
            },
            {
                "tactic_sig": "apply _i in _i .",
                "tactic_sig_no_out_arg": "apply _i in _i .",
                "tactic_args": [
                    "c18_goal : Plt v v'",
                    "_global_join_2 : forall (v : ident) (i : debuginfo) (s1 : avail) \n         (_ : wf_avail s1) (s2 : avail) (_ : wf_avail s2)\n         (_ : In (pair v i) (join s1 s2)),\n       and (In (pair v i) s1) (In (pair v i) s2)",
                    "c18_H3 : In (pair v' i') (join s s0)"
                ],
                "tactic_res": [
                    "c19_goal : Plt v v'",
                    "c19_H3 : and (In (pair v' i') s) (In (pair v' i') s0)",
                    "c20_goal : wf_avail s",
                    "c21_goal : wf_avail s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : wf_avail s",
                    "c3_H0 : wf_avail s",
                    "c3_s : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : wf_avail s0",
                    "c9_H2 : wf_avail s0",
                    "c9_s0 : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c19_H3 : and (In (pair v' i') s) (In (pair v' i') s0)",
                    "c18_v' : ident",
                    "c13_e : eq i i0",
                    "c9_IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c9_H2 : wf_avail s0",
                    "c10_H1 : avail_above v s0",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)",
                    "c3_H0 : wf_avail s",
                    "c3_H : avail_above v s",
                    "c3_v : ident"
                ],
                "tactic_res": [
                    "c19_H4 : In (pair v' i') s0",
                    "c19_H3 : In (pair v' i') s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : Plt v v'",
                    "c18_v' : ident",
                    "c3_v : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : wf_avail (join s (cons (pair v0 i0) s0))",
                    "c3_IHwf_avail : forall (s2 : avail) (_ : wf_avail s2), wf_avail (join s s2)"
                ],
                "tactic_res": [
                    "c22_goal : wf_avail (cons (pair v0 i0) s0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c22_goal : wf_avail (cons (pair v0 i0) s0)"
                ],
                "tactic_res": [
                    "c23_goal : avail_above v0 s0",
                    "c24_goal : wf_avail s0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : avail_above v0 s0",
                    "c9_H1 : avail_above v0 s0",
                    "c9_s0 : avail",
                    "c9_v0 : ident"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : wf_avail s0",
                    "c9_H2 : wf_avail s0",
                    "c9_s0 : avail"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)",
                    "c9_IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | cons (pair v2 i2) s2' =>\n          match Pos.compare v v2 with\n          | Eq =>\n              if eq_debuginfo i i2\n              then cons (pair v i) (join s s2')\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "symbols_preserved",
        "proof": [
            {
                "tactic_sig": "Lemma symbols_preserved : forall ( s : ident ) , Genv.find_symbol tge s = Genv.find_symbol ge s .",
                "tactic_sig_no_out_arg": "Lemma symbols_preserved : forall ( s : ident ) , Genv.find_symbol tge s = Genv.find_symbol ge s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)",
                    "c2_s : ident"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)",
                    "_global_Genv.find_symbol_match : forall (match_fundef : forall (_ : unit) (_ : ?F1) (_ : ?F2), Prop)\n         (match_varinfo : forall (_ : ?V1) (_ : ?V2), Prop) \n         (ctx : unit) (p : AST.program ?F1 ?V1) (tp : AST.program ?F2 ?V2)\n         (_ : match_program_gen match_fundef match_varinfo ctx p tp)\n         (s : ident),\n       eq (Genv.find_symbol (Genv.globalenv tp) s)\n         (Genv.find_symbol (Genv.globalenv p) s)\nwhere\n?F1 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit |- Type]\n?V1 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit |- Type]\n?F2 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit |- Type]\n?V2 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit |- Type]",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "functions_translated",
        "proof": [
            {
                "tactic_sig": "Lemma functions_translated : forall ( v : val ) ( f : fundef ) , Genv.find_funct ge v = Some f -> exists tf , Genv.find_funct tge v = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_sig_no_out_arg": "Lemma functions_translated : forall ( v : val ) ( f : fundef ) , Genv.find_funct ge v = Some f -> exists tf , Genv.find_funct tge v = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : val) (f : fundef) (_ : eq (Genv.find_funct ge v) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge v) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v : val) (f : fundef) (_ : eq (Genv.find_funct ge v) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge v) (Some tf))\n     (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge v) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c2_v : val",
                    "c2_f : fundef",
                    "c2_H : eq (Genv.find_funct ge v) (Some f)"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge v) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "_global_Genv.find_funct_transf_partial : forall\n         (_ : match_program\n                (fun (_ : AST.program unit unit) (f0 : unit) (tf : ?B) =>\n                 eq (?transf f0) (OK tf)) eq ?p ?tp) \n         (v0 : val) (f0 : unit)\n         (_ : eq (Genv.find_funct (Genv.globalenv ?p) v0) (Some f0)),\n       ex\n         (fun tf : ?B =>\n          and (eq (Genv.find_funct (Genv.globalenv ?tp) v0) (Some tf))\n            (eq (?transf f0) (OK tf)))\nwhere\n?B : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      v : val\n      f : fundef\n      H : eq (Genv.find_funct ge v) (Some f) |- Type]\n?transf : [prog : program\n           tprog : program\n           TRANSF : match_prog prog tprog\n           ge := Genv.globalenv prog : Genv.t fundef unit\n           tge := Genv.globalenv tprog : Genv.t fundef unit\n           v : val\n           f : fundef\n           H : eq (Genv.find_funct ge v) (Some f) |- \n          forall _ : unit, res ?B]\n?p : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      v : val\n      f : fundef\n      H : eq (Genv.find_funct ge v) (Some f) |- AST.program unit unit]\n?tp : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       v : val\n       f : fundef\n       H : eq (Genv.find_funct ge v) (Some f) |- AST.program ?B unit]",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c3_goal : eq (Genv.find_funct (Genv.globalenv prog) v) (Some f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (Genv.find_funct (Genv.globalenv prog) v) (Some f)",
                    "c2_H : eq (Genv.find_funct ge v) (Some f)",
                    "c2_f : fundef",
                    "c2_v : val",
                    "c1_prog : program"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "function_ptr_translated",
        "proof": [
            {
                "tactic_sig": "Lemma function_ptr_translated : forall ( b : block ) ( f : fundef ) , Genv.find_funct_ptr ge b = Some f -> exists tf , Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_sig_no_out_arg": "Lemma function_ptr_translated : forall ( b : block ) ( f : fundef ) , Genv.find_funct_ptr ge b = Some f -> exists tf , Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : block) (f : fundef)\n  (_ : eq (Genv.find_funct_ptr ge b) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : block) (f : fundef)\n  (_ : eq (Genv.find_funct_ptr ge b) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c2_b : block",
                    "c2_f : fundef",
                    "c2_H : eq (Genv.find_funct_ptr ge b) (Some f)"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "_global_Genv.find_funct_ptr_transf_partial : forall\n         (_ : match_program\n                (fun (_ : AST.program unit unit) (f0 : unit) (tf : ?B) =>\n                 eq (?transf f0) (OK tf)) eq ?p ?tp) \n         (b0 : block) (f0 : unit)\n         (_ : eq (Genv.find_funct_ptr (Genv.globalenv ?p) b0) (Some f0)),\n       ex\n         (fun tf : ?B =>\n          and (eq (Genv.find_funct_ptr (Genv.globalenv ?tp) b0) (Some tf))\n            (eq (?transf f0) (OK tf)))\nwhere\n?B : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      b : block\n      f : fundef\n      H : eq (Genv.find_funct_ptr ge b) (Some f) |- Type]\n?transf : [prog : program\n           tprog : program\n           TRANSF : match_prog prog tprog\n           ge := Genv.globalenv prog : Genv.t fundef unit\n           tge := Genv.globalenv tprog : Genv.t fundef unit\n           b : block\n           f : fundef\n           H : eq (Genv.find_funct_ptr ge b) (Some f)\n          |- forall _ : unit, res ?B]\n?p : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      b : block\n      f : fundef\n      H : eq (Genv.find_funct_ptr ge b) (Some f) |- \n     AST.program unit unit]\n?tp : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       b : block\n       f : fundef\n       H : eq (Genv.find_funct_ptr ge b) (Some f) |- \n      AST.program ?B unit]",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c3_goal : eq (Genv.find_funct_ptr (Genv.globalenv prog) b) (Some f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (Genv.find_funct_ptr (Genv.globalenv prog) b) (Some f)",
                    "c2_H : eq (Genv.find_funct_ptr ge b) (Some f)",
                    "c2_f : fundef",
                    "c2_b : block",
                    "c1_prog : program"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sig_preserved",
        "proof": [
            {
                "tactic_sig": "Lemma sig_preserved : forall f tf , transf_fundef f = OK tf -> funsig tf = funsig f .",
                "tactic_sig_no_out_arg": "Lemma sig_preserved : forall f tf , transf_fundef f = OK tf -> funsig tf = funsig f .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (f tf : fundef) (_ : eq (transf_fundef f) (OK tf)),\neq (funsig tf) (funsig f)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall (f tf : fundef) (_ : eq (transf_fundef f) (OK tf)),\neq (funsig tf) (funsig f)",
                    "_global_transf_fundef : forall _ : fundef, res fundef",
                    "_global_transf_partial_fundef : forall (A B : Type) (_ : forall _ : A, res B) (_ : AST.fundef A),\n       res (AST.fundef B)"
                ],
                "tactic_res": [
                    "c2_goal : forall (f tf : fundef)\n  (_ : eq\n         match f with\n         | Internal f0 =>\n             bind (transf_function f0)\n               (fun f' : function => OK (Internal f'))\n         | External ef => OK (External ef)\n         end (OK tf)), eq (funsig tf) (funsig f)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (f tf : fundef)\n  (_ : eq\n         match f with\n         | Internal f0 =>\n             bind (transf_function f0)\n               (fun f' : function => OK (Internal f'))\n         | External ef => OK (External ef)\n         end (OK tf)), eq (funsig tf) (funsig f)"
                ],
                "tactic_res": [
                    "c3_goal : eq (funsig tf) (funsig f)",
                    "c3_f : fundef",
                    "c3_tf : fundef",
                    "c3_H : eq\n  match f with\n  | Internal f =>\n      bind (transf_function f) (fun f' : function => OK (Internal f'))\n  | External ef => OK (External ef)\n  end (OK tf)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : eq (funsig tf) (funsig f)",
                    "c3_f : fundef",
                    "c3_H : eq\n  match f with\n  | Internal f =>\n      bind (transf_function f) (fun f' : function => OK (Internal f'))\n  | External ef => OK (External ef)\n  end (OK tf)",
                    "c3_tf : fundef",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c4_goal : eq (funsig tf) (funsig (Internal f))",
                    "c4_H : eq (bind (transf_function f) (fun f' : function => OK (Internal f')))\n  (OK tf)",
                    "c4_f : function",
                    "c5_goal : eq (funsig tf) (funsig (External e))",
                    "c5_H : eq (OK (External e)) (OK tf)",
                    "c5_e : external_function"
                ]
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c4_goal : eq (funsig tf) (funsig (Internal f))",
                    "c4_H : eq (bind (transf_function f) (fun f' : function => OK (Internal f')))\n  (OK tf)"
                ],
                "tactic_res": [
                    "c6_goal : eq (funsig (Internal x)) (funsig (Internal f))",
                    "c6_EQ : eq (transf_function f) (OK x)",
                    "c6_x : function"
                ]
            },
            {
                "tactic_sig": "exploit transf_function_match .",
                "tactic_sig_no_out_arg": "exploit transf_function_match .",
                "tactic_args": [
                    "c6_goal : eq (funsig (Internal x)) (funsig (Internal f))"
                ],
                "tactic_res": [
                    "c7_goal : eq (transf_function ?Goal0) (OK ?Goal1)",
                    "c8_goal : forall _ : match_function f x,\neq (funsig (Internal x)) (funsig (Internal f))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (transf_function ?Goal0) (OK ?Goal1)",
                    "c6_EQ : eq (transf_function f) (OK x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros M .",
                "tactic_args": [
                    "c8_goal : forall _ : match_function f x,\neq (funsig (Internal x)) (funsig (Internal f))"
                ],
                "tactic_res": [
                    "c9_goal : eq (funsig (Internal x)) (funsig (Internal f))",
                    "c9_M : match_function f x"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : eq (funsig (Internal x)) (funsig (Internal f))",
                    "c9_M : match_function f x"
                ],
                "tactic_res": [
                    "c10_goal : eq\n  (funsig\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})) (funsig (Internal f))",
                    "c10_H : match_code (fn_code f) c",
                    "c10_EQ : eq (transf_function f)\n  (OK\n     {|\n       fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n     |})",
                    "c10_c : code"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq\n  (funsig\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})) (funsig (Internal f))",
                    "c10_c : code",
                    "c4_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : eq (funsig tf) (funsig (External e))",
                    "c5_H : eq (OK (External e)) (OK tf)"
                ],
                "tactic_res": [
                    "c11_goal : eq (funsig (External e)) (funsig (External e))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c11_goal : eq (funsig (External e)) (funsig (External e))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "find_function_translated",
        "proof": [
            {
                "tactic_sig": "Lemma find_function_translated : forall ros ls f , find_function ge ros ls = Some f -> exists tf , find_function tge ros ls = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_sig_no_out_arg": "Lemma find_function_translated : forall ros ls f , find_function ge ros ls = Some f -> exists tf , find_function tge ros ls = Some tf /\\ transf_fundef f = OK tf .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (ros : sum mreg ident) (ls : locset) (f : fundef)\n  (_ : eq (find_function ge ros ls) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (find_function tge ros ls) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (ros : sum mreg ident) (ls : locset) (f : fundef)\n  (_ : eq (find_function ge ros ls) (Some f)),\nex\n  (fun tf : fundef =>\n   and (eq (find_function tge ros ls) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "_global_find_function : forall (_ : genv) (_ : sum mreg ident) (_ : locset), option fundef"
                ],
                "tactic_res": [
                    "c2_goal : forall (ros : sum mreg ident) (ls : locset) (f : fundef)\n  (_ : eq\n         match ros with\n         | inl r => Genv.find_funct ge (ls (R r))\n         | inr symb =>\n             match Genv.find_symbol ge symb with\n             | Some b => Genv.find_funct_ptr ge b\n             | None => None\n             end\n         end (Some f)),\nex\n  (fun tf : fundef =>\n   and\n     (eq\n        match ros with\n        | inl r => Genv.find_funct tge (ls (R r))\n        | inr symb =>\n            match Genv.find_symbol tge symb with\n            | Some b => Genv.find_funct_ptr tge b\n            | None => None\n            end\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (ros : sum mreg ident) (ls : locset) (f : fundef)\n  (_ : eq\n         match ros with\n         | inl r => Genv.find_funct ge (ls (R r))\n         | inr symb =>\n             match Genv.find_symbol ge symb with\n             | Some b => Genv.find_funct_ptr ge b\n             | None => None\n             end\n         end (Some f)),\nex\n  (fun tf : fundef =>\n   and\n     (eq\n        match ros with\n        | inl r => Genv.find_funct tge (ls (R r))\n        | inr symb =>\n            match Genv.find_symbol tge symb with\n            | Some b => Genv.find_funct_ptr tge b\n            | None => None\n            end\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match ros with\n        | inl r => Genv.find_funct tge (ls (R r))\n        | inr symb =>\n            match Genv.find_symbol tge symb with\n            | Some b => Genv.find_funct_ptr tge b\n            | None => None\n            end\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "c3_ros : sum mreg ident",
                    "c3_ls : locset",
                    "c3_f : fundef",
                    "c3_H : eq\n  match ros with\n  | inl r => Genv.find_funct ge (ls (R r))\n  | inr symb =>\n      match Genv.find_symbol ge symb with\n      | Some b => Genv.find_funct_ptr ge b\n      | None => None\n      end\n  end (Some f)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match ros with\n        | inl r => Genv.find_funct tge (ls (R r))\n        | inr symb =>\n            match Genv.find_symbol tge symb with\n            | Some b => Genv.find_funct_ptr tge b\n            | None => None\n            end\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "c3_ros : sum mreg ident",
                    "c3_H : eq\n  match ros with\n  | inl r => Genv.find_funct ge (ls (R r))\n  | inr symb =>\n      match Genv.find_symbol ge symb with\n      | Some b => Genv.find_funct_ptr ge b\n      | None => None\n      end\n  end (Some f)",
                    "c3_f : fundef",
                    "c3_ls : locset",
                    "c1_tge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c4_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge (ls (R m))) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c4_H : eq (Genv.find_funct ge (ls (R m))) (Some f)",
                    "c4_m : mreg",
                    "c5_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match Genv.find_symbol tge i with\n        | Some b => Genv.find_funct_ptr tge b\n        | None => None\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "c5_H : eq\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr ge b\n  | None => None\n  end (Some f)",
                    "c5_i : ident"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct tge (ls (R m))) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "_global_functions_translated : forall (v : val) (f : fundef) (_ : eq (Genv.find_funct ge v) (Some f)),\n       ex\n         (fun tf : fundef =>\n          and (eq (Genv.find_funct tge v) (Some tf))\n            (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": [
                    "c6_goal : eq (Genv.find_funct ge (ls (R m))) (Some f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (Genv.find_funct ge (ls (R m))) (Some f)",
                    "c4_H : eq (Genv.find_funct ge (ls (R m))) (Some f)",
                    "c3_f : fundef",
                    "c3_ls : locset",
                    "c4_m : mreg",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match Genv.find_symbol tge i with\n        | Some b => Genv.find_funct_ptr tge b\n        | None => None\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "_global_symbols_preserved : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": [
                    "c7_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match Genv.find_symbol ge i with\n        | Some b => Genv.find_funct_ptr tge b\n        | None => None\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Genv.find_symbol _i _i ) as [  _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Genv.find_symbol _i _i ) .",
                "tactic_args": [
                    "c7_goal : ex\n  (fun tf : fundef =>\n   and\n     (eq\n        match Genv.find_symbol ge i with\n        | Some b => Genv.find_funct_ptr tge b\n        | None => None\n        end (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "c1_ge : Genv.t fundef unit",
                    "c5_i : ident",
                    "c5_H : eq\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr ge b\n  | None => None\n  end (Some f)",
                    "c3_f : fundef",
                    "c3_ls : locset",
                    "c1_tge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "c8_H : eq (Genv.find_funct_ptr ge b) (Some f)",
                    "c8_b : block",
                    "c9_goal : ex\n  (fun tf : fundef =>\n   and (eq None (Some tf)) (eq (transf_fundef f) (OK tf)))",
                    "c9_H : eq None (Some f)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun tf : fundef =>\n   and (eq (Genv.find_funct_ptr tge b) (Some tf))\n     (eq (transf_fundef f) (OK tf)))",
                    "_global_function_ptr_translated : forall (b : block) (f : fundef)\n         (_ : eq (Genv.find_funct_ptr ge b) (Some f)),\n       ex\n         (fun tf : fundef =>\n          and (eq (Genv.find_funct_ptr tge b) (Some tf))\n            (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": [
                    "c10_goal : eq (Genv.find_funct_ptr ge b) (Some f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Genv.find_funct_ptr ge b) (Some f)",
                    "c8_H : eq (Genv.find_funct_ptr ge b) (Some f)",
                    "c8_b : block",
                    "c3_f : fundef",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c9_goal : ex\n  (fun tf : fundef =>\n   and (eq None (Some tf)) (eq (transf_fundef f) (OK tf)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "can_eval_safe_arg",
        "proof": [
            {
                "tactic_sig": "Lemma can_eval_safe_arg : forall ( rs : locset ) sp m ( a : builtin_arg loc ) , safe_builtin_arg a -> exists v , eval_builtin_arg tge rs sp m a v .",
                "tactic_sig_no_out_arg": "Lemma can_eval_safe_arg : forall ( rs : locset ) sp m ( a : builtin_arg loc ) , safe_builtin_arg a -> exists v , eval_builtin_arg tge rs sp m a v .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (rs : locset) (sp : val) (m : Mem.mem) (a : builtin_arg loc)\n  (_ : safe_builtin_arg a),\nex (fun v : val => eval_builtin_arg tge rs sp m a v)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros rs sp m a .",
                "tactic_args": [
                    "c1_goal : forall (rs : locset) (sp : val) (m : Mem.mem) (a : builtin_arg loc)\n  (_ : safe_builtin_arg a),\nex (fun v : val => eval_builtin_arg tge rs sp m a v)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : safe_builtin_arg a,\nex (fun v : val => eval_builtin_arg tge rs sp m a v)",
                    "c2_rs : locset",
                    "c2_sp : val",
                    "c2_m : Mem\\.mem",
                    "c2_a : builtin_arg loc"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall _ : safe_builtin_arg a,\nex (fun v : val => eval_builtin_arg tge rs sp m a v)",
                    "c2_a : builtin_arg loc"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : safe_builtin_arg (BA x),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)",
                    "c3_x : loc",
                    "c4_goal : forall _ : safe_builtin_arg (BA_int n),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)",
                    "c4_n : Int\\.int",
                    "c5_goal : forall _ : safe_builtin_arg (BA_long n),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)",
                    "c5_n : Int64\\.int",
                    "c6_goal : forall _ : safe_builtin_arg (BA_float f),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)",
                    "c6_f : float",
                    "c7_goal : forall _ : safe_builtin_arg (BA_single f),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)",
                    "c7_f : float32",
                    "c8_goal : forall _ : safe_builtin_arg (BA_loadstack chunk ofs),\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)",
                    "c8_ofs : Ptrofs\\.int",
                    "c8_chunk : memory_chunk",
                    "c9_goal : forall _ : safe_builtin_arg (BA_addrstack ofs),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)",
                    "c9_ofs : Ptrofs\\.int",
                    "c10_goal : forall _ : safe_builtin_arg (BA_loadglobal chunk id ofs),\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)",
                    "c10_ofs : Ptrofs\\.int",
                    "c10_id : ident",
                    "c10_chunk : memory_chunk",
                    "c11_goal : forall _ : safe_builtin_arg (BA_addrglobal id ofs),\nex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)",
                    "c11_ofs : Ptrofs\\.int",
                    "c11_id : ident",
                    "c12_goal : forall _ : safe_builtin_arg (BA_splitlong a1 a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)",
                    "c12_IHa2 : forall _ : safe_builtin_arg a2,\nex (fun v : val => eval_builtin_arg tge rs sp m a2 v)",
                    "c12_IHa1 : forall _ : safe_builtin_arg a1,\nex (fun v : val => eval_builtin_arg tge rs sp m a1 v)",
                    "c12_a2 : builtin_arg loc",
                    "c12_a1 : builtin_arg loc",
                    "c13_goal : forall _ : safe_builtin_arg (BA_addptr a1 a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)",
                    "c13_IHa2 : forall _ : safe_builtin_arg a2,\nex (fun v : val => eval_builtin_arg tge rs sp m a2 v)",
                    "c13_IHa1 : forall _ : safe_builtin_arg a1,\nex (fun v : val => eval_builtin_arg tge rs sp m a1 v)",
                    "c13_a2 : builtin_arg loc",
                    "c13_a1 : builtin_arg loc"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : safe_builtin_arg (BA x),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)"
                ],
                "tactic_res": [
                    "c15_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)",
                    "c15_H : True"
                ]
            },
            {
                "tactic_sig": "try ( econstructor ; now eauto with barg ) .",
                "tactic_sig_no_out_arg": "try ( econstructor ; now eauto with barg ) .",
                "tactic_args": [
                    "c15_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA x) v)",
                    "c3_x : loc",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall _ : safe_builtin_arg (BA_int n),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)"
                ],
                "tactic_res": [
                    "c16_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)"
                ],
                "tactic_res": [
                    "c17_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)",
                    "c17_H : True"
                ]
            },
            {
                "tactic_sig": "try ( econstructor ; now eauto with barg ) .",
                "tactic_sig_no_out_arg": "try ( econstructor ; now eauto with barg ) .",
                "tactic_args": [
                    "c17_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_int n) v)",
                    "c4_n : Int\\.int",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall _ : safe_builtin_arg (BA_long n),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c18_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)"
                ],
                "tactic_res": [
                    "c19_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)",
                    "c19_H : True"
                ]
            },
            {
                "tactic_sig": "try ( econstructor ; now eauto with barg ) .",
                "tactic_sig_no_out_arg": "try ( econstructor ; now eauto with barg ) .",
                "tactic_args": [
                    "c19_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_long n) v)",
                    "c5_n : Int64\\.int",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall _ : safe_builtin_arg (BA_float f),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c20_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)"
                ],
                "tactic_res": [
                    "c21_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)",
                    "c21_H : True"
                ]
            },
            {
                "tactic_sig": "try ( econstructor ; now eauto with barg ) .",
                "tactic_sig_no_out_arg": "try ( econstructor ; now eauto with barg ) .",
                "tactic_args": [
                    "c21_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_float f) v)",
                    "c6_f : float",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall _ : safe_builtin_arg (BA_single f),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c22_goal : forall _ : True,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)"
                ],
                "tactic_res": [
                    "c23_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)",
                    "c23_H : True"
                ]
            },
            {
                "tactic_sig": "try ( econstructor ; now eauto with barg ) .",
                "tactic_sig_no_out_arg": "try ( econstructor ; now eauto with barg ) .",
                "tactic_args": [
                    "c23_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_single f) v)",
                    "c7_f : float32",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : forall _ : safe_builtin_arg (BA_loadstack chunk ofs),\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)"
                ],
                "tactic_res": [
                    "c24_goal : forall _ : False,\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c24_goal : forall _ : False,\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)"
                ],
                "tactic_res": [
                    "c25_goal : ex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)",
                    "c25_H : False"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadstack chunk ofs) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : forall _ : safe_builtin_arg (BA_addrstack ofs),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)"
                ],
                "tactic_res": [
                    "c26_goal : forall _ : False,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c26_goal : forall _ : False,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)"
                ],
                "tactic_res": [
                    "c27_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)",
                    "c27_H : False"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c27_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_addrstack ofs) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall _ : safe_builtin_arg (BA_loadglobal chunk id ofs),\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)"
                ],
                "tactic_res": [
                    "c28_goal : forall _ : False,\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c28_goal : forall _ : False,\nex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)"
                ],
                "tactic_res": [
                    "c29_goal : ex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)",
                    "c29_H : False"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c29_goal : ex\n  (fun v : val =>\n   eval_builtin_arg tge rs sp m (BA_loadglobal chunk id ofs) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : forall _ : safe_builtin_arg (BA_addrglobal id ofs),\nex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)"
                ],
                "tactic_res": [
                    "c30_goal : forall _ : False,\nex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c30_goal : forall _ : False,\nex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)"
                ],
                "tactic_res": [
                    "c31_goal : ex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)",
                    "c31_H : False"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c31_goal : ex\n  (fun v : val => eval_builtin_arg tge rs sp m (BA_addrglobal id ofs) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : forall _ : safe_builtin_arg (BA_splitlong a1 a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)"
                ],
                "tactic_res": [
                    "c32_goal : forall _ : and (safe_builtin_arg a1) (safe_builtin_arg a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c32_goal : forall _ : and (safe_builtin_arg a1) (safe_builtin_arg a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)"
                ],
                "tactic_res": [
                    "c33_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)",
                    "c33_H : and (safe_builtin_arg a1) (safe_builtin_arg a2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : forall _ : safe_builtin_arg (BA_addptr a1 a2),\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)"
                ],
                "tactic_res": [
                    "c34_goal : forall _ : False,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c34_goal : forall _ : False,\nex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)"
                ],
                "tactic_res": [
                    "c35_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)",
                    "c35_H : False"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c35_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_addptr a1 a2) v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ S1 S2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ S1 S2 ] .",
                "tactic_args": [
                    "c33_H : and (safe_builtin_arg a1) (safe_builtin_arg a2)",
                    "c12_IHa2 : forall _ : safe_builtin_arg a2,\nex (fun v : val => eval_builtin_arg tge rs sp m a2 v)",
                    "c12_IHa1 : forall _ : safe_builtin_arg a1,\nex (fun v : val => eval_builtin_arg tge rs sp m a1 v)",
                    "c12_a1 : builtin_arg loc",
                    "c12_a2 : builtin_arg loc",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c33_S2 : safe_builtin_arg a2",
                    "c33_S1 : safe_builtin_arg a1"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ v1 E1 ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ v1 E1 ] .",
                "tactic_args": [
                    "c12_IHa1 : forall _ : safe_builtin_arg a1,\nex (fun v : val => eval_builtin_arg tge rs sp m a1 v)",
                    "c33_S1 : safe_builtin_arg a1",
                    "c33_S2 : safe_builtin_arg a2",
                    "c12_IHa2 : forall _ : safe_builtin_arg a2,\nex (fun v : val => eval_builtin_arg tge rs sp m a2 v)",
                    "c12_a1 : builtin_arg loc",
                    "c12_a2 : builtin_arg loc",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c33_E1 : eval_builtin_arg tge rs sp m a1 v1",
                    "c33_v1 : val"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ v2 E2 ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ v2 E2 ] .",
                "tactic_args": [
                    "c12_IHa2 : forall _ : safe_builtin_arg a2,\nex (fun v : val => eval_builtin_arg tge rs sp m a2 v)",
                    "c33_S2 : safe_builtin_arg a2",
                    "c33_E1 : eval_builtin_arg tge rs sp m a1 v1",
                    "c33_S1 : safe_builtin_arg a1",
                    "c12_IHa1 : forall _ : safe_builtin_arg a1,\nex (fun v : val => eval_builtin_arg tge rs sp m a1 v)",
                    "c12_a1 : builtin_arg loc",
                    "c12_a2 : builtin_arg loc",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c33_E2 : eval_builtin_arg tge rs sp m a2 v2",
                    "c33_v2 : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i _i ) .",
                "tactic_args": [
                    "c33_goal : ex (fun v : val => eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v)",
                    "c33_v1 : val",
                    "c33_v2 : val"
                ],
                "tactic_res": [
                    "c36_goal : eval_builtin_arg tge rs sp m (BA_splitlong a1 a2)\n  (Val.longofwords v1 v2)"
                ]
            },
            {
                "tactic_sig": "auto with barg .",
                "tactic_sig_no_out_arg": "auto with barg .",
                "tactic_args": [
                    "c36_goal : eval_builtin_arg tge rs sp m (BA_splitlong a1 a2)\n  (Val.longofwords v1 v2)",
                    "c33_E2 : eval_builtin_arg tge rs sp m a2 v2",
                    "c33_v2 : val",
                    "c33_E1 : eval_builtin_arg tge rs sp m a1 v1",
                    "c33_v1 : val",
                    "c12_a1 : builtin_arg loc",
                    "c12_a2 : builtin_arg loc",
                    "c2_m : Mem\\.mem",
                    "c2_sp : val",
                    "c2_rs : locset",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_add_delta_ranges",
        "proof": [
            {
                "tactic_sig": "Lemma eval_add_delta_ranges : forall s f sp c rs m before after , star step tge ( State s f sp ( add_delta_ranges before after c ) rs m ) E0 ( State s f sp c rs m ) .",
                "tactic_sig_no_out_arg": "Lemma eval_add_delta_ranges : forall s f sp c rs m before after , star step tge ( State s f sp ( add_delta_ranges before after c ) rs m ) E0 ( State s f sp c rs m ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s : list stackframe) (f : function) (sp : val) \n  (c : code) (rs : locset) (m : Mem.mem) (before after : option avail),\nstar step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (s : list stackframe) (f : function) (sp : val) \n  (c : code) (rs : locset) (m : Mem.mem) (before after : option avail),\nstar step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c2_goal : star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m)",
                    "c2_s : list stackframe",
                    "c2_f : function",
                    "c2_sp : val",
                    "c2_c : code",
                    "c2_rs : locset",
                    "c2_m : Mem\\.mem",
                    "c2_before : option avail",
                    "c2_after : option avail"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m)",
                    "_global_add_delta_ranges : forall (_ : option avail) (_ : option avail) (_ : code), code"
                ],
                "tactic_res": [
                    "c3_goal : star step tge\n  (State s f sp\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born)\n        killed) rs m) E0 (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "destruct ( delta_state _i _i ) as [ killed born ] .",
                "tactic_sig_no_out_arg": "destruct ( delta_state _i _i ) as [ killed born ] .",
                "tactic_args": [
                    "c3_goal : star step tge\n  (State s f sp\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born)\n        killed) rs m) E0 (State s f sp c rs m)",
                    "c2_before : option avail",
                    "c2_after : option avail",
                    "c2_m : Mem\\.mem",
                    "c2_rs : locset",
                    "c2_c : code",
                    "c2_sp : val",
                    "c2_f : function",
                    "c2_s : list stackframe",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c4_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born)\n        killed) rs m) E0 (State s f sp c rs m)",
                    "c4_born : avail",
                    "c4_killed : avail"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v i ] l ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v i ] l ] .",
                "tactic_args": [
                    "c4_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born)\n        killed) rs m) E0 (State s f sp c rs m)",
                    "c4_killed : avail"
                ],
                "tactic_res": [
                    "c5_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) nil)\n     rs m) E0 (State s f sp c rs m)",
                    "c6_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born)\n        (cons (pair v i) l)) rs m) E0 (State s f sp c rs m)",
                    "c6_IHl : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) l)\n     rs m) E0 (State s f sp c rs m)",
                    "c6_l : list (prod ident debuginfo)",
                    "c6_i : debuginfo",
                    "c6_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) nil)\n     rs m) E0 (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c7_goal : star step tge (State s f sp (fold_right add_start_range c born) rs m)\n  E0 (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born)\n        (cons (pair v i) l)) rs m) E0 (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c8_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 4 v nil) nil BR_none)\n        (fold_right add_end_range (fold_right add_start_range c born) l))\n     rs m) E0 (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | [ v i ] l ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | [ v i ] l ] .",
                "tactic_args": [
                    "c7_goal : star step tge (State s f sp (fold_right add_start_range c born) rs m)\n  E0 (State s f sp c rs m)",
                    "c4_born : avail"
                ],
                "tactic_res": [
                    "c9_goal : star step tge (State s f sp (fold_right add_start_range c nil) rs m) E0\n  (State s f sp c rs m)",
                    "c10_goal : star step tge\n  (State s f sp (fold_right add_start_range c (cons (pair v i) l)) rs m)\n  E0 (State s f sp c rs m)",
                    "c10_IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m)",
                    "c10_l : list (prod ident debuginfo)",
                    "c10_i : debuginfo",
                    "c10_v : ident"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : star step tge (State s f sp (fold_right add_start_range c nil) rs m) E0\n  (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c11_goal : star step tge (State s f sp c rs m) E0 (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : star step tge\n  (State s f sp (fold_right add_start_range c (cons (pair v i) l)) rs m)\n  E0 (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c12_goal : star step tge\n  (State s f sp\n     (cons\n        (Lbuiltin (EF_debug 3 v nil) (cons (proj1_sig i) nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : star step tge (State s f sp c rs m) E0 (State s f sp c rs m)",
                    "_global_star_refl : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s : state), star step ge s E0 s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ a SAFE ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ a SAFE ] .",
                "tactic_args": [
                    "c12_goal : star step tge\n  (State s f sp\n     (cons\n        (Lbuiltin (EF_debug 3 v nil) (cons (proj1_sig i) nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)",
                    "c10_i : debuginfo",
                    "c10_IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m)",
                    "c10_l : list (prod ident debuginfo)",
                    "c10_v : ident",
                    "c2_before : option avail",
                    "c2_after : option avail",
                    "c2_m : Mem\\.mem",
                    "c2_rs : locset",
                    "c2_c : code",
                    "c2_sp : val",
                    "c2_f : function",
                    "c2_s : list stackframe",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c13_goal : star step tge\n  (State s f sp\n     (cons\n        (Lbuiltin (EF_debug 3 v nil)\n           (cons\n              (proj1_sig\n                 (exist (fun a : builtin_arg loc => safe_builtin_arg a)\n                    a SAFE)) nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)",
                    "c13_SAFE : safe_builtin_arg a",
                    "c13_a : builtin_arg loc"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : star step tge\n  (State s f sp\n     (cons\n        (Lbuiltin (EF_debug 3 v nil)\n           (cons\n              (proj1_sig\n                 (exist (fun a : builtin_arg loc => safe_builtin_arg a)\n                    a SAFE)) nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c14_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "exploit can_eval_safe_arg .",
                "tactic_sig_no_out_arg": "exploit can_eval_safe_arg .",
                "tactic_args": [
                    "c14_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c15_goal : safe_builtin_arg ?Goal3",
                    "c16_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         eval_builtin_arg tge ?Goal0 ?Goal1 ?Goal2 ?Goal3 v0),\nstar step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : safe_builtin_arg ?Goal3",
                    "c13_SAFE : safe_builtin_arg a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ v1 E1 ] .",
                "tactic_args": [
                    "c16_goal : forall\n  _ : ex\n        (fun v0 : val => eval_builtin_arg tge ?Goal0 ?Goal1 ?Goal2 a v0),\nstar step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)"
                ],
                "tactic_res": [
                    "c17_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)",
                    "c17_v1 : val",
                    "c17_E1 : eval_builtin_arg tge ?Goal0 ?Goal1 ?Goal2 a v1"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( t2 := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( t2 := _i ) .",
                "tactic_args": [
                    "c17_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) E0\n  (State s f sp c rs m)",
                    "_global_star_step : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       star step ge s1 t s3",
                    "_global_E0 : trace"
                ],
                "tactic_res": [
                    "c18_goal : step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) ?t1 \n  ?s2",
                    "c19_goal : star step tge ?s2 E0 (State s f sp c rs m)",
                    "c20_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c18_goal : step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 3 v nil) (cons a nil) BR_none)\n        (fold_right add_start_range c l)) rs m) ?t1 \n  ?s2"
                ],
                "tactic_res": [
                    "c21_goal : eval_builtin_args tge rs sp m (cons a nil) ?vargs",
                    "c22_goal : external_call (EF_debug 3 v nil) tge (cons v1 nil) m ?t1 ?vres ?m'",
                    "c23_goal : eq ?rs'\n  (Locmap.setres BR_none Vundef\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 3 v nil)) rs))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c21_goal : eval_builtin_args tge rs sp m (cons a nil) ?vargs"
                ],
                "tactic_res": [
                    "c24_goal : eval_builtin_arg tge rs sp m a ?b1",
                    "c25_goal : list_forall2 (eval_builtin_arg tge rs sp m) nil ?bl"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c24_goal : eval_builtin_arg tge rs sp m a ?b1",
                    "c17_E1 : eval_builtin_arg tge ?Goal0 ?Goal1 ?Goal2 a v1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c25_goal : list_forall2 (eval_builtin_arg tge rs sp m) nil ?bl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : external_call (EF_debug 3 v nil) tge (cons v1 nil) m ?t1 ?vres ?m'"
                ],
                "tactic_res": [
                    "c26_goal : extcall_debug_sem tge (cons v1 nil) m ?t1 ?vres ?m'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c26_goal : extcall_debug_sem tge (cons v1 nil) m ?t1 ?vres ?m'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : eq ?rs'\n  (Locmap.setres BR_none Vundef\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 3 v nil)) rs))"
                ],
                "tactic_res": [
                    "c27_goal : eq ?rs' (LTL.undef_regs (destroyed_by_builtin (EF_debug 3 v nil)) rs)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : eq ?rs' (LTL.undef_regs (destroyed_by_builtin (EF_debug 3 v nil)) rs)",
                    "c10_v : ident",
                    "c2_rs : locset"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : star step tge\n  (State s f sp (fold_right add_start_range c l)\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 3 v nil)) rs) m)\n  E0 (State s f sp c rs m)",
                    "c10_IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m)",
                    "c10_l : list (prod ident debuginfo)",
                    "c10_v : ident",
                    "c2_m : Mem\\.mem",
                    "c2_rs : locset",
                    "c2_c : code",
                    "c2_sp : val",
                    "c2_f : function",
                    "c2_s : list stackframe",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( t2 := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( t2 := _i ) .",
                "tactic_args": [
                    "c8_goal : star step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 4 v nil) nil BR_none)\n        (fold_right add_end_range (fold_right add_start_range c born) l))\n     rs m) E0 (State s f sp c rs m)",
                    "_global_star_step : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       star step ge s1 t s3",
                    "_global_E0 : trace"
                ],
                "tactic_res": [
                    "c28_goal : step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 4 v nil) nil BR_none)\n        (fold_right add_end_range (fold_right add_start_range c born) l))\n     rs m) ?t1 ?s2",
                    "c29_goal : star step tge ?s2 E0 (State s f sp c rs m)",
                    "c30_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c28_goal : step tge\n  (State s f sp\n     (cons (Lbuiltin (EF_debug 4 v nil) nil BR_none)\n        (fold_right add_end_range (fold_right add_start_range c born) l))\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c31_goal : eval_builtin_args tge rs sp m nil ?vargs",
                    "c32_goal : external_call (EF_debug 4 v nil) tge nil m ?t1 ?vres ?m'",
                    "c33_goal : eq ?rs'\n  (Locmap.setres BR_none Vundef\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 4 v nil)) rs))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c31_goal : eval_builtin_args tge rs sp m nil ?vargs"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c32_goal : external_call (EF_debug 4 v nil) tge nil m ?t1 ?vres ?m'"
                ],
                "tactic_res": [
                    "c34_goal : extcall_debug_sem tge nil m ?t1 ?vres ?m'"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c34_goal : extcall_debug_sem tge nil m ?t1 ?vres ?m'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c33_goal : eq ?rs'\n  (Locmap.setres BR_none Vundef\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 4 v nil)) rs))"
                ],
                "tactic_res": [
                    "c35_goal : eq ?rs' (LTL.undef_regs (destroyed_by_builtin (EF_debug 4 v nil)) rs)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : eq ?rs' (LTL.undef_regs (destroyed_by_builtin (EF_debug 4 v nil)) rs)",
                    "c6_v : ident",
                    "c2_rs : locset"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) l)\n     (LTL.undef_regs (destroyed_by_builtin (EF_debug 4 v nil)) rs) m)\n  E0 (State s f sp c rs m)",
                    "c6_IHl : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) l)\n     rs m) E0 (State s f sp c rs m)",
                    "c4_born : avail",
                    "c6_l : list (prod ident debuginfo)",
                    "c6_v : ident",
                    "c2_m : Mem\\.mem",
                    "c2_rs : locset",
                    "c2_c : code",
                    "c2_sp : val",
                    "c2_f : function",
                    "c2_s : list stackframe",
                    "c1_tge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c30_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parent_locset_match",
        "proof": [
            {
                "tactic_sig": "Lemma parent_locset_match : forall s ts , list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s .",
                "tactic_sig_no_out_arg": "Lemma parent_locset_match : forall s ts , list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s ts : list stackframe)\n  (_ : list_forall2 match_stackframes s ts),\neq (parent_locset ts) (parent_locset s)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (s ts : list stackframe)\n  (_ : list_forall2 match_stackframes s ts),\neq (parent_locset ts) (parent_locset s)"
                ],
                "tactic_res": [
                    "c2_goal : eq (parent_locset nil) (parent_locset nil)",
                    "c3_goal : eq (parent_locset (cons b1 bl)) (parent_locset (cons a1 al))",
                    "c3_IHlist_forall2 : eq (parent_locset bl) (parent_locset al)",
                    "c3_H0 : list_forall2 match_stackframes al bl",
                    "c3_H : match_stackframes a1 b1",
                    "c3_bl : list stackframe",
                    "c3_b1 : stackframe",
                    "c3_al : list stackframe",
                    "c3_a1 : stackframe"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : eq (parent_locset nil) (parent_locset nil)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Locmap.init Vundef) (Locmap.init Vundef)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (parent_locset (cons b1 bl)) (parent_locset (cons a1 al))"
                ],
                "tactic_res": [
                    "c5_goal : eq match b1 with\n   | Stackframe _ _ ls _ => ls\n   end match a1 with\n       | Stackframe _ _ ls _ => ls\n       end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (Locmap.init Vundef) (Locmap.init Vundef)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : eq match b1 with\n   | Stackframe _ _ ls _ => ls\n   end match a1 with\n       | Stackframe _ _ ls _ => ls\n       end",
                    "c3_H : match_stackframes a1 b1"
                ],
                "tactic_res": [
                    "c6_goal : eq rs rs",
                    "c6_H2 : match_code c tc",
                    "c6_H1 : match_function f tf",
                    "c6_after : option avail",
                    "c6_before : option avail",
                    "c6_tc : code",
                    "c6_tf : function",
                    "c6_c : code",
                    "c6_rs : locset",
                    "c6_sp : val",
                    "c6_f : function"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq rs rs",
                    "c6_rs : locset"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_step_correct",
        "proof": [
            {
                "tactic_sig": "Theorem transf_step_correct : forall s1 t s2 , step ge s1 t s2 -> forall ts1 ( MS : match_states s1 ts1 ) , exists ts2 , plus step tge ts1 t ts2 /\\ match_states s2 ts2 .",
                "tactic_sig_no_out_arg": "Theorem transf_step_correct : forall s1 t s2 , step ge s1 t s2 -> forall ts1 ( MS : match_states s1 ts1 ) , exists ts2 , plus step tge ts1 t ts2 /\\ match_states s2 ts2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (s1 : state) (t : trace) (s2 : state) (_ : step ge s1 t s2)\n  (ts1 : state) (_ : match_states s1 ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2) (match_states s2 ts2))",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (s1 : state) (t : trace) (s2 : state) (_ : step ge s1 t s2)\n  (ts1 : state) (_ : match_states s1 ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2) (match_states s2 ts2))"
                ],
                "tactic_res": [
                    "c2_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lgetstack sl ofs ty dst) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c2_H : eq rs'\n  (Locmap.set (R dst) (rs (S sl ofs ty))\n     (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs))",
                    "c2_rs' : Locmap\\.t",
                    "c2_m : Mem\\.mem",
                    "c2_rs : forall _ : loc, val",
                    "c2_b : list instruction",
                    "c2_dst : mreg",
                    "c2_ty : typ",
                    "c2_ofs : Z",
                    "c2_sl : slot",
                    "c2_sp : val",
                    "c2_f : function",
                    "c2_s : list stackframe",
                    "c3_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lsetstack src sl ofs ty) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c3_H : eq rs'\n  (Locmap.set (S sl ofs ty) (rs (R src))\n     (LTL.undef_regs (destroyed_by_setstack ty) rs))",
                    "c3_rs' : Locmap\\.t",
                    "c3_m : Mem\\.mem",
                    "c3_rs : forall _ : loc, val",
                    "c3_b : list instruction",
                    "c3_ty : typ",
                    "c3_ofs : Z",
                    "c3_sl : slot",
                    "c3_src : mreg",
                    "c3_sp : val",
                    "c3_f : function",
                    "c3_s : list stackframe",
                    "c4_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lop op args res) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c4_H0 : eq rs' (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))",
                    "c4_H : eq (eval_operation ge sp op (LTL.reglist rs args) m) (Some v)",
                    "c4_rs' : Locmap\\.t",
                    "c4_v : val",
                    "c4_m : Mem\\.mem",
                    "c4_rs : LTL\\.locset",
                    "c4_b : list instruction",
                    "c4_res : mreg",
                    "c4_args : list mreg",
                    "c4_op : operation",
                    "c4_sp : val",
                    "c4_f : function",
                    "c4_s : list stackframe",
                    "c5_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lload chunk addr args dst) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c5_H1 : eq rs'\n  (Locmap.set (R dst) v\n     (LTL.undef_regs (destroyed_by_load chunk addr) rs))",
                    "c5_H0 : eq (Mem.loadv chunk m a) (Some v)",
                    "c5_H : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a)",
                    "c5_rs' : Locmap\\.t",
                    "c5_v : val",
                    "c5_a : val",
                    "c5_m : Mem\\.mem",
                    "c5_rs : LTL\\.locset",
                    "c5_b : list instruction",
                    "c5_dst : mreg",
                    "c5_args : list mreg",
                    "c5_addr : addressing",
                    "c5_chunk : memory_chunk",
                    "c5_sp : val",
                    "c5_f : function",
                    "c5_s : list stackframe",
                    "c6_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lstore chunk addr args src) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c6_H1 : eq rs' (LTL.undef_regs (destroyed_by_store chunk addr) rs)",
                    "c6_H0 : eq (Mem.storev chunk m a (rs (R src))) (Some m')",
                    "c6_H : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a)",
                    "c6_rs' : LTL\\.locset",
                    "c6_a : val",
                    "c6_m' : Mem\\.mem",
                    "c6_m : Mem\\.mem",
                    "c6_rs : LTL\\.locset",
                    "c6_b : list instruction",
                    "c6_src : mreg",
                    "c6_args : list mreg",
                    "c6_addr : addressing",
                    "c6_chunk : memory_chunk",
                    "c6_sp : val",
                    "c6_f : function",
                    "c6_s : list stackframe",
                    "c7_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcall sig ros) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c7_H0 : eq sig (funsig f')",
                    "c7_H : eq (find_function ge ros rs) (Some f')",
                    "c7_f' : fundef",
                    "c7_m : Mem\\.mem",
                    "c7_rs : locset",
                    "c7_b : list instruction",
                    "c7_ros : sum mreg ident",
                    "c7_sig : signature",
                    "c7_sp : val",
                    "c7_f : function",
                    "c7_s : list stackframe",
                    "c8_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f (Vptr stk Ptrofs.zero) (cons (Ltailcall sig ros) b)\n            rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate s f' rs' m') ts2))",
                    "c8_H2 : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')",
                    "c8_H1 : eq sig (funsig f')",
                    "c8_H0 : eq (find_function ge ros rs') (Some f')",
                    "c8_H : eq rs' (LTL.return_regs (parent_locset s) rs)",
                    "c8_m' : Mem\\.mem",
                    "c8_f' : fundef",
                    "c8_rs' : LTL\\.locset",
                    "c8_m : Mem\\.mem",
                    "c8_rs : LTL\\.locset",
                    "c8_b : list instruction",
                    "c8_ros : sum mreg ident",
                    "c8_sig : signature",
                    "c8_stk : block",
                    "c8_f : function",
                    "c8_s : list stackframe",
                    "c9_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lbuiltin ef args res) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c9_H1 : eq rs'\n  (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))",
                    "c9_H0 : external_call ef ge vargs m t vres m'",
                    "c9_H : eval_builtin_args ge rs sp m args vargs",
                    "c9_m' : Mem\\.mem",
                    "c9_rs' : Locmap\\.t",
                    "c9_vres : val",
                    "c9_t : trace",
                    "c9_vargs : list val",
                    "c9_b : list instruction",
                    "c9_res : builtin_res mreg",
                    "c9_args : list (builtin_arg loc)",
                    "c9_ef : external_function",
                    "c9_m : Mem\\.mem",
                    "c9_rs : forall _ : loc, val",
                    "c9_sp : val",
                    "c9_f : function",
                    "c9_s : list stackframe",
                    "c10_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Llabel lbl) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs m) ts2))",
                    "c10_m : Mem\\.mem",
                    "c10_rs : locset",
                    "c10_b : list instruction",
                    "c10_lbl : label",
                    "c10_sp : val",
                    "c10_f : function",
                    "c10_s : list stackframe",
                    "c11_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lgoto lbl) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))",
                    "c11_H : eq (find_label lbl (fn_code f)) (Some b')",
                    "c11_b' : code",
                    "c11_m : Mem\\.mem",
                    "c11_rs : locset",
                    "c11_b : list instruction",
                    "c11_lbl : label",
                    "c11_sp : val",
                    "c11_f : function",
                    "c11_s : list stackframe",
                    "c12_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c12_H1 : eq (find_label lbl (fn_code f)) (Some b')",
                    "c12_H0 : eq rs' (LTL.undef_regs (destroyed_by_cond cond) rs)",
                    "c12_H : eq (eval_condition cond (LTL.reglist rs args) m) (Some true)",
                    "c12_b' : code",
                    "c12_rs' : LTL\\.locset",
                    "c12_m : Mem\\.mem",
                    "c12_rs : LTL\\.locset",
                    "c12_b : list instruction",
                    "c12_lbl : label",
                    "c12_args : list mreg",
                    "c12_cond : condition",
                    "c12_sp : val",
                    "c12_f : function",
                    "c12_s : list stackframe",
                    "c13_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c13_H0 : eq rs' (LTL.undef_regs (destroyed_by_cond cond) rs)",
                    "c13_H : eq (eval_condition cond (LTL.reglist rs args) m) (Some false)",
                    "c13_rs' : LTL\\.locset",
                    "c13_m : Mem\\.mem",
                    "c13_rs : LTL\\.locset",
                    "c13_b : list instruction",
                    "c13_lbl : label",
                    "c13_args : list mreg",
                    "c13_cond : condition",
                    "c13_sp : val",
                    "c13_f : function",
                    "c13_s : list stackframe",
                    "c14_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Ljumptable arg tbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c14_H2 : eq rs' (LTL.undef_regs destroyed_by_jumptable rs)",
                    "c14_H1 : eq (find_label lbl (fn_code f)) (Some b')",
                    "c14_H0 : eq (list_nth_z tbl (Int.unsigned n)) (Some lbl)",
                    "c14_H : eq (rs (R arg)) (Vint n)",
                    "c14_rs' : LTL\\.locset",
                    "c14_b' : code",
                    "c14_lbl : label",
                    "c14_n : Int\\.int",
                    "c14_m : Mem\\.mem",
                    "c14_rs : forall _ : loc, val",
                    "c14_b : list instruction",
                    "c14_tbl : list label",
                    "c14_arg : mreg",
                    "c14_sp : val",
                    "c14_f : function",
                    "c14_s : list stackframe",
                    "c15_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f (Vptr stk Ptrofs.zero) (cons Lreturn b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c15_H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')",
                    "c15_m' : Mem\\.mem",
                    "c15_m : Mem\\.mem",
                    "c15_rs : locset",
                    "c15_b : list instruction",
                    "c15_stk : block",
                    "c15_f : function",
                    "c15_s : list stackframe",
                    "c16_goal : forall (ts1 : state)\n  (_ : match_states (Callstate s (Internal f) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f) rs' m') ts2))",
                    "c16_H0 : eq rs' (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs))",
                    "c16_H : eq (Mem.alloc m 0 (fn_stacksize f)) (pair m' stk)",
                    "c16_stk : block",
                    "c16_m' : Mem.mem'",
                    "c16_rs' : LTL\\.locset",
                    "c16_m : Mem\\.mem",
                    "c16_rs : LTL\\.locset",
                    "c16_f : function",
                    "c16_s : list stackframe",
                    "c17_goal : forall (ts1 : state)\n  (_ : match_states (Callstate s (External ef) rs1 m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (Returnstate s rs2 m') ts2))",
                    "c17_H1 : eq rs2\n  (Locmap.setpair (loc_result (ef_sig ef)) res\n     (LTL.undef_caller_save_regs rs1))",
                    "c17_H0 : external_call ef ge args m t res m'",
                    "c17_H : eq args\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef)))",
                    "c17_m' : Mem\\.mem",
                    "c17_t : trace",
                    "c17_m : Mem\\.mem",
                    "c17_rs2 : Locmap\\.t",
                    "c17_rs1 : Locmap\\.t",
                    "c17_res : val",
                    "c17_args : list val",
                    "c17_ef : external_function",
                    "c17_s : list stackframe",
                    "c18_goal : forall (ts1 : state)\n  (_ : match_states (Returnstate (cons (Stackframe f sp rs0 c) s) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c18_m : Mem\\.mem",
                    "c18_rs : locset",
                    "c18_c : code",
                    "c18_rs0 : locset",
                    "c18_sp : val",
                    "c18_f : function",
                    "c18_s : list stackframe"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c2_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lgetstack sl ofs ty dst) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))"
                ],
                "tactic_res": [
                    "c19_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c19_ts1 : state",
                    "c19_MS : match_states (State s f sp (cons (Lgetstack sl ofs ty dst) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c19_MS : match_states (State s f sp (cons (Lgetstack sl ofs ty dst) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c20_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) (rs (S sl ofs ty))\n              (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n        ts2))",
                    "c20_TRC : match_code (cons (Lgetstack sl ofs ty dst) b) tc",
                    "c20_TRF : match_function f tf",
                    "c20_STACKS : list_forall2 match_stackframes s ts",
                    "c20_tc : code",
                    "c20_ts : list stackframe",
                    "c20_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c20_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) (rs (S sl ofs ty))\n              (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n        ts2))",
                    "c20_TRC : match_code (cons (Lgetstack sl ofs ty dst) b) tc"
                ],
                "tactic_res": [
                    "c21_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgetstack sl ofs ty dst)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) (rs (S sl ofs ty))\n              (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n        ts2))",
                    "c21_H2 : match_code b c'",
                    "c21_c' : code",
                    "c21_after : option avail",
                    "c21_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c3_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lsetstack src sl ofs ty) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))"
                ],
                "tactic_res": [
                    "c22_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c22_ts1 : state",
                    "c22_MS : match_states (State s f sp (cons (Lsetstack src sl ofs ty) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c22_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c22_MS : match_states (State s f sp (cons (Lsetstack src sl ofs ty) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c23_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (S sl ofs ty) (rs (R src))\n              (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2))",
                    "c23_TRC : match_code (cons (Lsetstack src sl ofs ty) b) tc",
                    "c23_TRF : match_function f tf",
                    "c23_STACKS : list_forall2 match_stackframes s ts",
                    "c23_tc : code",
                    "c23_ts : list stackframe",
                    "c23_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c23_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (S sl ofs ty) (rs (R src))\n              (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2))",
                    "c23_TRC : match_code (cons (Lsetstack src sl ofs ty) b) tc"
                ],
                "tactic_res": [
                    "c24_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lsetstack src sl ofs ty)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (S sl ofs ty) (rs (R src))\n              (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2))",
                    "c24_H2 : match_code b c'",
                    "c24_c' : code",
                    "c24_after : option avail",
                    "c24_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c4_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lop op args res) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))"
                ],
                "tactic_res": [
                    "c25_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c25_ts1 : state",
                    "c25_MS : match_states (State s f sp (cons (Lop op args res) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c25_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c25_MS : match_states (State s f sp (cons (Lop op args res) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c26_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R res) v\n              (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2))",
                    "c26_TRC : match_code (cons (Lop op args res) b) tc",
                    "c26_TRF : match_function f tf",
                    "c26_STACKS : list_forall2 match_stackframes s ts",
                    "c26_tc : code",
                    "c26_ts : list stackframe",
                    "c26_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c26_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R res) v\n              (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2))",
                    "c26_TRC : match_code (cons (Lop op args res) b) tc"
                ],
                "tactic_res": [
                    "c27_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lop op args res) (add_delta_ranges before after c'))\n           rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R res) v\n              (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2))",
                    "c27_H3 : match_code b c'",
                    "c27_c' : code",
                    "c27_after : option avail",
                    "c27_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c5_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lload chunk addr args dst) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))"
                ],
                "tactic_res": [
                    "c28_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c28_ts1 : state",
                    "c28_MS : match_states (State s f sp (cons (Lload chunk addr args dst) b) rs m)\n  ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c28_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c28_MS : match_states (State s f sp (cons (Lload chunk addr args dst) b) rs m)\n  ts1"
                ],
                "tactic_res": [
                    "c29_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) v\n              (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)\n        ts2))",
                    "c29_TRC : match_code (cons (Lload chunk addr args dst) b) tc",
                    "c29_TRF : match_function f tf",
                    "c29_STACKS : list_forall2 match_stackframes s ts",
                    "c29_tc : code",
                    "c29_ts : list stackframe",
                    "c29_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c29_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) v\n              (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)\n        ts2))",
                    "c29_TRC : match_code (cons (Lload chunk addr args dst) b) tc"
                ],
                "tactic_res": [
                    "c30_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lload chunk addr args dst)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) v\n              (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)\n        ts2))",
                    "c30_H4 : match_code b c'",
                    "c30_c' : code",
                    "c30_after : option avail",
                    "c30_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c6_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f sp (cons (Lstore chunk addr args src) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m') ts2))"
                ],
                "tactic_res": [
                    "c31_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c31_ts1 : state",
                    "c31_MS : match_states (State s f sp (cons (Lstore chunk addr args src) b) rs m)\n  ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c31_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c31_MS : match_states (State s f sp (cons (Lstore chunk addr args src) b) rs m)\n  ts1"
                ],
                "tactic_res": [
                    "c32_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') ts2))",
                    "c32_TRC : match_code (cons (Lstore chunk addr args src) b) tc",
                    "c32_TRF : match_function f tf",
                    "c32_STACKS : list_forall2 match_stackframes s ts",
                    "c32_tc : code",
                    "c32_ts : list stackframe",
                    "c32_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c32_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') ts2))",
                    "c32_TRC : match_code (cons (Lstore chunk addr args src) b) tc"
                ],
                "tactic_res": [
                    "c33_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lstore chunk addr args src)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') ts2))",
                    "c33_H4 : match_code b c'",
                    "c33_c' : code",
                    "c33_after : option avail",
                    "c33_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c7_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcall sig ros) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))"
                ],
                "tactic_res": [
                    "c34_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c34_ts1 : state",
                    "c34_MS : match_states (State s f sp (cons (Lcall sig ros) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c34_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c34_MS : match_states (State s f sp (cons (Lcall sig ros) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c35_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c35_TRC : match_code (cons (Lcall (funsig f') ros) b) tc",
                    "c35_TRF : match_function f tf",
                    "c35_STACKS : list_forall2 match_stackframes s ts",
                    "c35_tc : code",
                    "c35_ts : list stackframe",
                    "c35_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c35_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c35_TRC : match_code (cons (Lcall (funsig f') ros) b) tc"
                ],
                "tactic_res": [
                    "c36_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c36_H3 : match_code b c'",
                    "c36_c' : code",
                    "c36_after : option avail",
                    "c36_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c8_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f (Vptr stk Ptrofs.zero) (cons (Ltailcall sig ros) b)\n            rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate s f' rs' m') ts2))"
                ],
                "tactic_res": [
                    "c37_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate s f' rs' m') ts2))",
                    "c37_ts1 : state",
                    "c37_MS : match_states\n  (State s f (Vptr stk Ptrofs.zero) (cons (Ltailcall sig ros) b) rs m)\n  ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c37_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (Callstate s f' rs' m') ts2))",
                    "c37_MS : match_states\n  (State s f (Vptr stk Ptrofs.zero) (cons (Ltailcall sig ros) b) rs m)\n  ts1"
                ],
                "tactic_res": [
                    "c38_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge (State ts tf (Vptr stk Ptrofs.zero) tc rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c38_TRC : match_code (cons (Ltailcall (funsig f') ros) b) tc",
                    "c38_TRF : match_function f tf",
                    "c38_STACKS : list_forall2 match_stackframes s ts",
                    "c38_tc : code",
                    "c38_ts : list stackframe",
                    "c38_tf : function",
                    "c38_H0 : eq (find_function ge ros (LTL.return_regs (parent_locset s) rs))\n  (Some f')"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c38_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge (State ts tf (Vptr stk Ptrofs.zero) tc rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c38_TRC : match_code (cons (Ltailcall (funsig f') ros) b) tc"
                ],
                "tactic_res": [
                    "c39_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c39_H4 : match_code b c'",
                    "c39_c' : code",
                    "c39_after : option avail",
                    "c39_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c9_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lbuiltin ef args res) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (State s f sp b rs' m') ts2))"
                ],
                "tactic_res": [
                    "c40_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c40_ts1 : state",
                    "c40_MS : match_states (State s f sp (cons (Lbuiltin ef args res) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c40_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (State s f sp b rs' m') ts2))",
                    "c40_MS : match_states (State s f sp (cons (Lbuiltin ef args res) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c41_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) t ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.setres res vres\n              (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') ts2))",
                    "c41_TRC : match_code (cons (Lbuiltin ef args res) b) tc",
                    "c41_TRF : match_function f tf",
                    "c41_STACKS : list_forall2 match_stackframes s ts",
                    "c41_tc : code",
                    "c41_ts : list stackframe",
                    "c41_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c41_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) t ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.setres res vres\n              (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') ts2))",
                    "c41_TRC : match_code (cons (Lbuiltin ef args res) b) tc"
                ],
                "tactic_res": [
                    "c42_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lbuiltin ef args res)\n              (add_delta_ranges before after c')) rs m) t ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.setres res vres\n              (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') ts2))",
                    "c42_H4 : match_code b c'",
                    "c42_c' : code",
                    "c42_after : option avail",
                    "c42_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c10_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Llabel lbl) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs m) ts2))"
                ],
                "tactic_res": [
                    "c43_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs m) ts2))",
                    "c43_ts1 : state",
                    "c43_MS : match_states (State s f sp (cons (Llabel lbl) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c43_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs m) ts2))",
                    "c43_MS : match_states (State s f sp (cons (Llabel lbl) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c44_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (State s f sp b rs m) ts2))",
                    "c44_TRC : match_code (cons (Llabel lbl) b) tc",
                    "c44_TRF : match_function f tf",
                    "c44_STACKS : list_forall2 match_stackframes s ts",
                    "c44_tc : code",
                    "c44_ts : list stackframe",
                    "c44_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c44_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (State s f sp b rs m) ts2))",
                    "c44_TRC : match_code (cons (Llabel lbl) b) tc"
                ],
                "tactic_res": [
                    "c45_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Llabel lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b rs m) ts2))",
                    "c45_H2 : match_code b c'",
                    "c45_c' : code",
                    "c45_after : option avail",
                    "c45_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c11_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lgoto lbl) b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))"
                ],
                "tactic_res": [
                    "c46_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))",
                    "c46_ts1 : state",
                    "c46_MS : match_states (State s f sp (cons (Lgoto lbl) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c46_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))",
                    "c46_MS : match_states (State s f sp (cons (Lgoto lbl) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c47_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))",
                    "c47_TRC : match_code (cons (Lgoto lbl) b) tc",
                    "c47_TRF : match_function f tf",
                    "c47_STACKS : list_forall2 match_stackframes s ts",
                    "c47_tc : code",
                    "c47_ts : list stackframe",
                    "c47_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c47_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states (State s f sp b' rs m) ts2))",
                    "c47_TRC : match_code (cons (Lgoto lbl) b) tc"
                ],
                "tactic_res": [
                    "c48_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))",
                    "c48_H3 : match_code b c'",
                    "c48_c' : code",
                    "c48_after : option avail",
                    "c48_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c12_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))"
                ],
                "tactic_res": [
                    "c49_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c49_ts1 : state",
                    "c49_MS : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c49_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c49_MS : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c50_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c50_TRC : match_code (cons (Lcond cond args lbl) b) tc",
                    "c50_TRF : match_function f tf",
                    "c50_STACKS : list_forall2 match_stackframes s ts",
                    "c50_tc : code",
                    "c50_ts : list stackframe",
                    "c50_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c50_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c50_TRC : match_code (cons (Lcond cond args lbl) b) tc"
                ],
                "tactic_res": [
                    "c51_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c51_H4 : match_code b c'",
                    "c51_c' : code",
                    "c51_after : option avail",
                    "c51_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c13_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))"
                ],
                "tactic_res": [
                    "c52_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c52_ts1 : state",
                    "c52_MS : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c52_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b rs' m) ts2))",
                    "c52_MS : match_states (State s f sp (cons (Lcond cond args lbl) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c53_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c53_TRC : match_code (cons (Lcond cond args lbl) b) tc",
                    "c53_TRF : match_function f tf",
                    "c53_STACKS : list_forall2 match_stackframes s ts",
                    "c53_tc : code",
                    "c53_ts : list stackframe",
                    "c53_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c53_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c53_TRC : match_code (cons (Lcond cond args lbl) b) tc"
                ],
                "tactic_res": [
                    "c54_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c54_H3 : match_code b c'",
                    "c54_c' : code",
                    "c54_after : option avail",
                    "c54_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c14_goal : forall (ts1 : state)\n  (_ : match_states (State s f sp (cons (Ljumptable arg tbl) b) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))"
                ],
                "tactic_res": [
                    "c55_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c55_ts1 : state",
                    "c55_MS : match_states (State s f sp (cons (Ljumptable arg tbl) b) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c55_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp b' rs' m) ts2))",
                    "c55_MS : match_states (State s f sp (cons (Ljumptable arg tbl) b) rs m) ts1"
                ],
                "tactic_res": [
                    "c56_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))",
                    "c56_TRC : match_code (cons (Ljumptable arg tbl) b) tc",
                    "c56_TRF : match_function f tf",
                    "c56_STACKS : list_forall2 match_stackframes s ts",
                    "c56_tc : code",
                    "c56_ts : list stackframe",
                    "c56_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c56_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (State ts tf sp tc rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))",
                    "c56_TRC : match_code (cons (Ljumptable arg tbl) b) tc"
                ],
                "tactic_res": [
                    "c57_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))",
                    "c57_H5 : match_code b c'",
                    "c57_c' : code",
                    "c57_after : option avail",
                    "c57_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c15_goal : forall (ts1 : state)\n  (_ : match_states\n         (State s f (Vptr stk Ptrofs.zero) (cons Lreturn b) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c58_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c58_ts1 : state",
                    "c58_MS : match_states (State s f (Vptr stk Ptrofs.zero) (cons Lreturn b) rs m)\n  ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c58_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c58_MS : match_states (State s f (Vptr stk Ptrofs.zero) (cons Lreturn b) rs m)\n  ts1"
                ],
                "tactic_res": [
                    "c59_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge (State ts tf (Vptr stk Ptrofs.zero) tc rs m) E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c59_TRC : match_code (cons Lreturn b) tc",
                    "c59_TRF : match_function f tf",
                    "c59_STACKS : list_forall2 match_stackframes s ts",
                    "c59_tc : code",
                    "c59_ts : list stackframe",
                    "c59_tf : function"
                ]
            },
            {
                "tactic_sig": "try ( inv _i ) .",
                "tactic_sig_no_out_arg": "try ( inv _i ) .",
                "tactic_args": [
                    "c59_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge (State ts tf (Vptr stk Ptrofs.zero) tc rs m) E0 ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c59_TRC : match_code (cons Lreturn b) tc"
                ],
                "tactic_res": [
                    "c60_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons Lreturn (add_delta_ranges before after c')) rs m) E0\n        ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c60_H3 : match_code b c'",
                    "c60_c' : code",
                    "c60_after : option avail",
                    "c60_before : option avail"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c16_goal : forall (ts1 : state)\n  (_ : match_states (Callstate s (Internal f) rs m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f) rs' m') ts2))"
                ],
                "tactic_res": [
                    "c61_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f) rs' m') ts2))",
                    "c61_ts1 : state",
                    "c61_MS : match_states (Callstate s (Internal f) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c61_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f) rs' m') ts2))",
                    "c61_MS : match_states (Callstate s (Internal f) rs m) ts1"
                ],
                "tactic_res": [
                    "c62_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts tf rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c62_H7 : eq (transf_fundef (Internal f)) (OK tf)",
                    "c62_H6 : list_forall2 match_stackframes s ts",
                    "c62_ts : list stackframe",
                    "c62_tf : fundef"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c17_goal : forall (ts1 : state)\n  (_ : match_states (Callstate s (External ef) rs1 m) ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (Returnstate s rs2 m') ts2))"
                ],
                "tactic_res": [
                    "c63_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (Returnstate s rs2 m') ts2))",
                    "c63_ts1 : state",
                    "c63_MS : match_states (Callstate s (External ef) rs1 m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c63_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 t ts2)\n     (match_states (Returnstate s rs2 m') ts2))",
                    "c63_MS : match_states (Callstate s (External ef) rs1 m) ts1"
                ],
                "tactic_res": [
                    "c64_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts tf rs1 m) t ts2)\n     (match_states\n        (Returnstate s\n           (Locmap.setpair (loc_result (ef_sig ef)) res\n              (LTL.undef_caller_save_regs rs1)) m') ts2))",
                    "c64_H8 : eq (transf_fundef (External ef)) (OK tf)",
                    "c64_H7 : list_forall2 match_stackframes s ts",
                    "c64_ts : list stackframe",
                    "c64_tf : fundef",
                    "c64_H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m'"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ts1 MS .",
                "tactic_args": [
                    "c18_goal : forall (ts1 : state)\n  (_ : match_states (Returnstate (cons (Stackframe f sp rs0 c) s) rs m)\n         ts1),\nex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp c rs m) ts2))"
                ],
                "tactic_res": [
                    "c65_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c65_ts1 : state",
                    "c65_MS : match_states (Returnstate (cons (Stackframe f sp rs0 c) s) rs m) ts1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c65_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge ts1 E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c65_MS : match_states (Returnstate (cons (Stackframe f sp rs0 c) s) rs m) ts1"
                ],
                "tactic_res": [
                    "c66_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Returnstate ts rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c66_H3 : list_forall2 match_stackframes (cons (Stackframe f sp rs0 c) s) ts",
                    "c66_ts : list stackframe"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c21_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgetstack sl ofs ty dst)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) (rs (S sl ofs ty))\n              (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c67_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lgetstack sl ofs ty dst)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c67_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lgetstack sl ofs ty dst)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) \n     ?ts2)"
                ],
                "tactic_res": [
                    "c68_goal : plus step tge\n  (State ts tf sp\n     (cons (Lgetstack sl ofs ty dst) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "c69_goal : match_states\n  (State s f sp b\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c68_goal : plus step tge\n  (State ts tf sp\n     (cons (Lgetstack sl ofs ty dst) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c70_goal : step tge\n  (State ts tf sp\n     (cons (Lgetstack sl ofs ty dst) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2",
                    "c71_goal : star step tge ?s2 ?t2 ?ts2",
                    "c72_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c70_goal : step tge\n  (State ts tf sp\n     (cons (Lgetstack sl ofs ty dst) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c73_goal : eq ?rs'\n  (Locmap.set (R dst) (rs (S sl ofs ty))\n     (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c73_goal : eq ?rs'\n  (Locmap.set (R dst) (rs (S sl ofs ty))\n     (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs))",
                    "c2_rs : forall _ : loc, val",
                    "c2_dst : mreg",
                    "c2_ty : typ",
                    "c2_ofs : Z",
                    "c2_sl : slot"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c71_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c72_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c69_goal : match_states\n  (State s f sp b\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n  (State ts tf sp c'\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)"
                ],
                "tactic_res": [
                    "c74_goal : list_forall2 match_stackframes s ts",
                    "c75_goal : match_function f tf",
                    "c76_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c74_goal : list_forall2 match_stackframes s ts",
                    "c20_STACKS : list_forall2 match_stackframes s ts",
                    "c20_ts : list stackframe",
                    "c2_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c75_goal : match_function f tf",
                    "c20_TRF : match_function f tf",
                    "c20_tf : function",
                    "c2_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c76_goal : match_code b c'",
                    "c21_H2 : match_code b c'",
                    "c21_c' : code",
                    "c2_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c24_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lsetstack src sl ofs ty)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (S sl ofs ty) (rs (R src))\n              (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2))"
                ],
                "tactic_res": [
                    "c77_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lsetstack src sl ofs ty)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c77_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lsetstack src sl ofs ty)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) \n     ?ts2)"
                ],
                "tactic_res": [
                    "c78_goal : plus step tge\n  (State ts tf sp\n     (cons (Lsetstack src sl ofs ty) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "c79_goal : match_states\n  (State s f sp b\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c78_goal : plus step tge\n  (State ts tf sp\n     (cons (Lsetstack src sl ofs ty) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c80_goal : step tge\n  (State ts tf sp\n     (cons (Lsetstack src sl ofs ty) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2",
                    "c81_goal : star step tge ?s2 ?t2 ?ts2",
                    "c82_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c80_goal : step tge\n  (State ts tf sp\n     (cons (Lsetstack src sl ofs ty) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c83_goal : eq ?rs'\n  (Locmap.set (S sl ofs ty) (rs (R src))\n     (LTL.undef_regs (destroyed_by_setstack ty) rs))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c83_goal : eq ?rs'\n  (Locmap.set (S sl ofs ty) (rs (R src))\n     (LTL.undef_regs (destroyed_by_setstack ty) rs))",
                    "c3_rs : forall _ : loc, val",
                    "c3_ty : typ",
                    "c3_ofs : Z",
                    "c3_sl : slot",
                    "c3_src : mreg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c81_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c82_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c79_goal : match_states\n  (State s f sp b\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) m)\n  (State ts tf sp c'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) m)"
                ],
                "tactic_res": [
                    "c84_goal : list_forall2 match_stackframes s ts",
                    "c85_goal : match_function f tf",
                    "c86_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c84_goal : list_forall2 match_stackframes s ts",
                    "c23_STACKS : list_forall2 match_stackframes s ts",
                    "c23_ts : list stackframe",
                    "c3_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c85_goal : match_function f tf",
                    "c23_TRF : match_function f tf",
                    "c23_tf : function",
                    "c3_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c86_goal : match_code b c'",
                    "c24_H2 : match_code b c'",
                    "c24_c' : code",
                    "c3_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c27_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lop op args res) (add_delta_ranges before after c'))\n           rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R res) v\n              (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2))"
                ],
                "tactic_res": [
                    "c87_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lop op args res) (add_delta_ranges before after c')) rs\n        m) E0 ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n        m) ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c87_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lop op args res) (add_delta_ranges before after c')) rs\n        m) E0 ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n        m) ?ts2)"
                ],
                "tactic_res": [
                    "c88_goal : plus step tge\n  (State ts tf sp\n     (cons (Lop op args res) (add_delta_ranges before after c')) rs m)\n  E0 ?ts2",
                    "c89_goal : match_states\n  (State s f sp b\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)\n  (State ts tf sp c'\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c88_goal : plus step tge\n  (State ts tf sp\n     (cons (Lop op args res) (add_delta_ranges before after c')) rs m)\n  E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c90_goal : step tge\n  (State ts tf sp\n     (cons (Lop op args res) (add_delta_ranges before after c')) rs m)\n  ?t1 ?s2",
                    "c91_goal : star step tge ?s2 ?t2 ?ts2",
                    "c92_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c90_goal : step tge\n  (State ts tf sp\n     (cons (Lop op args res) (add_delta_ranges before after c')) rs m)\n  ?t1 ?s2"
                ],
                "tactic_res": [
                    "c93_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m) (Some ?v)",
                    "c94_goal : eq ?rs'\n  (Locmap.set (R res) ?v (LTL.undef_regs (destroyed_by_op op) rs))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c94_goal : eq ?rs'\n  (Locmap.set (R res) ?v (LTL.undef_regs (destroyed_by_op op) rs))",
                    "c4_rs : LTL\\.locset",
                    "c4_res : mreg",
                    "c4_op : operation"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "c93_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m) (Some ?v)",
                    "c4_v : val"
                ],
                "tactic_res": [
                    "c95_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m) (Some v)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c95_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m) (Some v)",
                    "c4_H : eq (eval_operation ge sp op (LTL.reglist rs args) m) (Some v)"
                ],
                "tactic_res": [
                    "c96_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m)\n  (eval_operation ge sp op (LTL.reglist rs args) m)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c96_goal : eq (eval_operation tge sp op (LTL.reglist rs args) m)\n  (eval_operation ge sp op (LTL.reglist rs args) m)",
                    "_global_eval_operation_preserved : forall (F1 F2 V1 V2 : Type) (ge1 : Genv.t F1 V1) \n         (ge2 : Genv.t F2 V2)\n         (_ : forall s : ident,\n              eq (Genv.find_symbol ge2 s) (Genv.find_symbol ge1 s))\n         (sp : val) (op : operation) (vl : list val) \n         (m : Mem.mem),\n       eq (eval_operation ge2 sp op vl m) (eval_operation ge1 sp op vl m)"
                ],
                "tactic_res": [
                    "c97_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ]
            },
            {
                "tactic_sig": "exact symbols_preserved .",
                "tactic_sig_no_out_arg": "exact symbols_preserved .",
                "tactic_args": [
                    "c97_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c91_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)\n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c92_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c89_goal : match_states\n  (State s f sp b\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)\n  (State ts tf sp c'\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)"
                ],
                "tactic_res": [
                    "c98_goal : list_forall2 match_stackframes s ts",
                    "c99_goal : match_function f tf",
                    "c100_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c98_goal : list_forall2 match_stackframes s ts",
                    "c26_STACKS : list_forall2 match_stackframes s ts",
                    "c26_ts : list stackframe",
                    "c4_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c99_goal : match_function f tf",
                    "c26_TRF : match_function f tf",
                    "c26_tf : function",
                    "c4_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c100_goal : match_code b c'",
                    "c27_H3 : match_code b c'",
                    "c27_c' : code",
                    "c4_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c30_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lload chunk addr args dst)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.set (R dst) v\n              (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c101_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lload chunk addr args dst)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R dst) v\n           (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c101_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lload chunk addr args dst)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.set (R dst) v\n           (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) \n     ?ts2)"
                ],
                "tactic_res": [
                    "c102_goal : plus step tge\n  (State ts tf sp\n     (cons (Lload chunk addr args dst)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "c103_goal : match_states\n  (State s f sp b\n     (Locmap.set (R dst) v\n        (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c102_goal : plus step tge\n  (State ts tf sp\n     (cons (Lload chunk addr args dst)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c104_goal : step tge\n  (State ts tf sp\n     (cons (Lload chunk addr args dst)\n        (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2",
                    "c105_goal : star step tge ?s2 ?t2 ?ts2",
                    "c106_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) .",
                "tactic_args": [
                    "c104_goal : step tge\n  (State ts tf sp\n     (cons (Lload chunk addr args dst)\n        (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2",
                    "_global_exec_Lload : forall (ge : genv) (s : list stackframe) (f : function) \n         (sp : val) (chunk : memory_chunk) (addr : addressing)\n         (args : list mreg) (dst : mreg) (b : list instruction)\n         (rs : LTL.locset) (m : Mem.mem) (a v : val) \n         (rs' : Locmap.t)\n         (_ : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a))\n         (_ : eq (Mem.loadv chunk m a) (Some v))\n         (_ : eq rs'\n                (Locmap.set (R dst) v\n                   (LTL.undef_regs (destroyed_by_load chunk addr) rs))),\n       step ge (State s f sp (cons (Lload chunk addr args dst) b) rs m) E0\n         (State s f sp b rs' m)",
                    "c5_a : val",
                    "c5_a : val"
                ],
                "tactic_res": [
                    "c107_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args)) (Some a)",
                    "c108_goal : eq (Mem.loadv chunk m a) (Some ?v)",
                    "c109_goal : eq ?rs'\n  (Locmap.set (R dst) v\n     (LTL.undef_regs (destroyed_by_load chunk addr) rs))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c107_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args)) (Some a)",
                    "c5_H : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a)"
                ],
                "tactic_res": [
                    "c110_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args))\n  (eval_addressing ge sp addr (LTL.reglist rs args))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c110_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args))\n  (eval_addressing ge sp addr (LTL.reglist rs args))",
                    "_global_eval_addressing_preserved : forall (F1 F2 V1 V2 : Type) (ge1 : Genv.t F1 V1) \n         (ge2 : Genv.t F2 V2)\n         (_ : forall s : ident,\n              eq (Genv.find_symbol ge2 s) (Genv.find_symbol ge1 s))\n         (sp : val) (addr : addressing) (vl : list val),\n       eq (eval_addressing ge2 sp addr vl) (eval_addressing ge1 sp addr vl)"
                ],
                "tactic_res": [
                    "c111_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ]
            },
            {
                "tactic_sig": "exact symbols_preserved .",
                "tactic_sig_no_out_arg": "exact symbols_preserved .",
                "tactic_args": [
                    "c111_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c108_goal : eq (Mem.loadv chunk m a) (Some ?v)",
                    "c5_H0 : eq (Mem.loadv chunk m a) (Some v)",
                    "c5_a : val",
                    "c5_m : Mem\\.mem",
                    "c5_chunk : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c109_goal : eq ?rs'\n  (Locmap.set (R dst) v\n     (LTL.undef_regs (destroyed_by_load chunk addr) rs))",
                    "c5_v : val",
                    "c5_rs : LTL\\.locset",
                    "c5_dst : mreg",
                    "c5_addr : addressing",
                    "c5_chunk : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c105_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (Locmap.set (R dst) v\n        (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c106_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c103_goal : match_states\n  (State s f sp b\n     (Locmap.set (R dst) v\n        (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (State ts tf sp c'\n     (Locmap.set (R dst) v\n        (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m)"
                ],
                "tactic_res": [
                    "c112_goal : list_forall2 match_stackframes s ts",
                    "c113_goal : match_function f tf",
                    "c114_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c112_goal : list_forall2 match_stackframes s ts",
                    "c29_STACKS : list_forall2 match_stackframes s ts",
                    "c29_ts : list stackframe",
                    "c5_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c113_goal : match_function f tf",
                    "c29_TRF : match_function f tf",
                    "c29_tf : function",
                    "c5_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c114_goal : match_code b c'",
                    "c30_H4 : match_code b c'",
                    "c30_c' : code",
                    "c5_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c33_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lstore chunk addr args src)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b\n           (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c115_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lstore chunk addr args src)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c115_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lstore chunk addr args src)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (State s f sp b\n        (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') \n     ?ts2)"
                ],
                "tactic_res": [
                    "c116_goal : plus step tge\n  (State ts tf sp\n     (cons (Lstore chunk addr args src)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "c117_goal : match_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n     m') ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c116_goal : plus step tge\n  (State ts tf sp\n     (cons (Lstore chunk addr args src)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c118_goal : step tge\n  (State ts tf sp\n     (cons (Lstore chunk addr args src)\n        (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2",
                    "c119_goal : star step tge ?s2 ?t2 ?ts2",
                    "c120_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "eapply _i with ( _i := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( _i := _i ) .",
                "tactic_args": [
                    "c118_goal : step tge\n  (State ts tf sp\n     (cons (Lstore chunk addr args src)\n        (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2",
                    "_global_exec_Lstore : forall (ge : genv) (s : list stackframe) (f : function) \n         (sp : val) (chunk : memory_chunk) (addr : addressing)\n         (args : list mreg) (src : mreg) (b : list instruction)\n         (rs : LTL.locset) (m m' : Mem.mem) (a : val) \n         (rs' : LTL.locset)\n         (_ : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a))\n         (_ : eq (Mem.storev chunk m a (rs (R src))) (Some m'))\n         (_ : eq rs' (LTL.undef_regs (destroyed_by_store chunk addr) rs)),\n       step ge (State s f sp (cons (Lstore chunk addr args src) b) rs m) E0\n         (State s f sp b rs' m')",
                    "c6_a : val",
                    "c6_a : val"
                ],
                "tactic_res": [
                    "c121_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args)) (Some a)",
                    "c122_goal : eq (Mem.storev chunk m a (rs (R src))) (Some ?m')",
                    "c123_goal : eq ?rs' (LTL.undef_regs (destroyed_by_store chunk addr) rs)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c121_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args)) (Some a)",
                    "c6_H : eq (eval_addressing ge sp addr (LTL.reglist rs args)) (Some a)"
                ],
                "tactic_res": [
                    "c124_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args))\n  (eval_addressing ge sp addr (LTL.reglist rs args))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c124_goal : eq (eval_addressing tge sp addr (LTL.reglist rs args))\n  (eval_addressing ge sp addr (LTL.reglist rs args))",
                    "_global_eval_addressing_preserved : forall (F1 F2 V1 V2 : Type) (ge1 : Genv.t F1 V1) \n         (ge2 : Genv.t F2 V2)\n         (_ : forall s : ident,\n              eq (Genv.find_symbol ge2 s) (Genv.find_symbol ge1 s))\n         (sp : val) (addr : addressing) (vl : list val),\n       eq (eval_addressing ge2 sp addr vl) (eval_addressing ge1 sp addr vl)"
                ],
                "tactic_res": [
                    "c125_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ]
            },
            {
                "tactic_sig": "exact symbols_preserved .",
                "tactic_sig_no_out_arg": "exact symbols_preserved .",
                "tactic_args": [
                    "c125_goal : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c122_goal : eq (Mem.storev chunk m a (rs (R src))) (Some ?m')",
                    "c6_H0 : eq (Mem.storev chunk m a (rs (R src))) (Some m')",
                    "c6_a : val",
                    "c6_m : Mem\\.mem",
                    "c6_rs : LTL\\.locset",
                    "c6_src : mreg",
                    "c6_chunk : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c123_goal : eq ?rs' (LTL.undef_regs (destroyed_by_store chunk addr) rs)",
                    "c6_rs : LTL\\.locset",
                    "c6_addr : addressing",
                    "c6_chunk : memory_chunk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c119_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c120_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c117_goal : match_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n     m')\n  (State ts tf sp c'\n     (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')"
                ],
                "tactic_res": [
                    "c126_goal : list_forall2 match_stackframes s ts",
                    "c127_goal : match_function f tf",
                    "c128_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c126_goal : list_forall2 match_stackframes s ts",
                    "c32_STACKS : list_forall2 match_stackframes s ts",
                    "c32_ts : list stackframe",
                    "c6_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c127_goal : match_function f tf",
                    "c32_TRF : match_function f tf",
                    "c32_tf : function",
                    "c6_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c128_goal : match_code b c'",
                    "c33_H4 : match_code b c'",
                    "c33_c' : code",
                    "c6_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit find_function_translated .",
                "tactic_sig_no_out_arg": "exploit find_function_translated .",
                "tactic_args": [
                    "c36_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))"
                ],
                "tactic_res": [
                    "c129_goal : eq (find_function ge ?Goal10 ?Goal11) (Some ?Goal12)",
                    "c130_goal : forall\n  _ : ex\n        (fun tf0 : fundef =>\n         and (eq (find_function tge ?Goal10 ?Goal11) (Some tf0))\n           (eq (transf_fundef ?Goal12) (OK tf0))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c129_goal : eq (find_function ge ?Goal10 ?Goal11) (Some ?Goal12)",
                    "c7_H : eq (find_function ge ros rs) (Some f')",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( tf' & A & B ) .",
                "tactic_args": [
                    "c130_goal : forall\n  _ : ex\n        (fun tf : fundef =>\n         and (eq (find_function tge ros rs) (Some tf))\n           (eq (transf_fundef f') (OK tf))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))"
                ],
                "tactic_res": [
                    "c131_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))",
                    "c131_tf' : fundef",
                    "c131_A : eq (find_function tge ros rs) (Some tf')",
                    "c131_B : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c131_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n        ts2))"
                ],
                "tactic_res": [
                    "c132_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcall (funsig f') ros)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c132_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcall (funsig f') ros)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n     ?ts2)"
                ],
                "tactic_res": [
                    "c133_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcall (funsig f') ros) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "c134_goal : match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m) ?ts2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c133_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcall (funsig f') ros) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "_global_plus_one : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t : trace) (s2 : state)\n         (_ : step ge s1 t s2), plus step ge s1 t s2"
                ],
                "tactic_res": [
                    "c135_goal : step tge\n  (State ts tf sp\n     (cons (Lcall (funsig f') ros) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c135_goal : step tge\n  (State ts tf sp\n     (cons (Lcall (funsig f') ros) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2"
                ],
                "tactic_res": [
                    "c136_goal : eq (find_function tge ros rs) (Some ?f')",
                    "c137_goal : eq (funsig f') (funsig tf')"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c136_goal : eq (find_function tge ros rs) (Some ?f')",
                    "c131_A : eq (find_function tge ros rs) (Some tf')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c137_goal : eq (funsig f') (funsig tf')"
                ],
                "tactic_res": [
                    "c138_goal : eq (funsig tf') (funsig f')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c138_goal : eq (funsig tf') (funsig f')",
                    "_global_sig_preserved : forall (f tf : fundef) (_ : eq (transf_fundef f) (OK tf)),\n       eq (funsig tf) (funsig f)"
                ],
                "tactic_res": [
                    "c139_goal : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c139_goal : eq (transf_fundef f') (OK tf')",
                    "c131_B : eq (transf_fundef f') (OK tf')",
                    "c131_tf' : fundef",
                    "c7_f' : fundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c134_goal : match_states (Callstate (cons (Stackframe f sp rs b) s) f' rs m)\n  (Callstate\n     (cons (Stackframe tf sp rs (add_delta_ranges before after c')) ts)\n     tf' rs m)"
                ],
                "tactic_res": [
                    "c140_goal : list_forall2 match_stackframes (cons (Stackframe f sp rs b) s)\n  (cons (Stackframe tf sp rs (add_delta_ranges before after c')) ts)",
                    "c141_goal : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c141_goal : eq (transf_fundef f') (OK tf')",
                    "c131_B : eq (transf_fundef f') (OK tf')",
                    "c131_tf' : fundef",
                    "c7_f' : fundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c140_goal : list_forall2 match_stackframes (cons (Stackframe f sp rs b) s)\n  (cons (Stackframe tf sp rs (add_delta_ranges before after c')) ts)"
                ],
                "tactic_res": [
                    "c142_goal : match_stackframes (Stackframe f sp rs b)\n  (Stackframe tf sp rs (add_delta_ranges before after c'))",
                    "c143_goal : list_forall2 match_stackframes s ts"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c143_goal : list_forall2 match_stackframes s ts",
                    "c35_STACKS : list_forall2 match_stackframes s ts",
                    "c35_ts : list stackframe",
                    "c7_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c142_goal : match_stackframes (Stackframe f sp rs b)\n  (Stackframe tf sp rs (add_delta_ranges before after c'))"
                ],
                "tactic_res": [
                    "c144_goal : match_function f tf",
                    "c145_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c144_goal : match_function f tf",
                    "c35_TRF : match_function f tf",
                    "c35_tf : function",
                    "c7_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c145_goal : match_code b c'",
                    "c36_H3 : match_code b c'",
                    "c36_c' : code",
                    "c7_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit find_function_translated .",
                "tactic_sig_no_out_arg": "exploit find_function_translated .",
                "tactic_args": [
                    "c39_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c146_goal : eq (find_function ge ?Goal9 ?Goal10) (Some ?Goal11)",
                    "c147_goal : forall\n  _ : ex\n        (fun tf0 : fundef =>\n         and (eq (find_function tge ?Goal9 ?Goal10) (Some tf0))\n           (eq (transf_fundef ?Goal11) (OK tf0))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c146_goal : eq (find_function ge ?Goal9 ?Goal10) (Some ?Goal11)",
                    "c38_H0 : eq (find_function ge ros (LTL.return_regs (parent_locset s) rs))\n  (Some f')",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( tf' & A & B ) .",
                "tactic_args": [
                    "c147_goal : forall\n  _ : ex\n        (fun tf : fundef =>\n         and\n           (eq\n              (find_function tge ros\n                 (LTL.return_regs (parent_locset s) rs)) \n              (Some tf)) (eq (transf_fundef f') (OK tf))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c148_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c148_tf' : fundef",
                    "c148_A : eq (find_function tge ros (LTL.return_regs (parent_locset s) rs))\n  (Some tf')",
                    "c148_B : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "exploit parent_locset_match .",
                "tactic_sig_no_out_arg": "exploit parent_locset_match .",
                "tactic_args": [
                    "c148_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c149_goal : list_forall2 match_stackframes ?Goal9 ?Goal10",
                    "c150_goal : forall _ : eq (parent_locset ts) (parent_locset s),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c149_goal : list_forall2 match_stackframes ?Goal9 ?Goal10",
                    "c38_STACKS : list_forall2 match_stackframes s ts"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros PLS .",
                "tactic_args": [
                    "c150_goal : forall _ : eq (parent_locset ts) (parent_locset s),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c151_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))",
                    "c151_PLS : eq (parent_locset ts) (parent_locset s)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c151_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons (Ltailcall (funsig f') ros)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c152_goal : and\n  (plus step tge\n     (State ts tf (Vptr stk Ptrofs.zero)\n        (cons (Ltailcall (funsig f') ros)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c152_goal : and\n  (plus step tge\n     (State ts tf (Vptr stk Ptrofs.zero)\n        (cons (Ltailcall (funsig f') ros)\n           (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') \n     ?ts2)"
                ],
                "tactic_res": [
                    "c153_goal : plus step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons (Ltailcall (funsig f') ros)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "c154_goal : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset ts) rs) m')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c153_goal : plus step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons (Ltailcall (funsig f') ros)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "_global_plus_one : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t : trace) (s2 : state)\n         (_ : step ge s1 t s2), plus step ge s1 t s2"
                ],
                "tactic_res": [
                    "c155_goal : step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons (Ltailcall (funsig f') ros)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c155_goal : step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons (Ltailcall (funsig f') ros)\n        (add_delta_ranges before after c')) rs m) E0 \n  ?ts2"
                ],
                "tactic_res": [
                    "c156_goal : eq ?rs' (LTL.return_regs (parent_locset ts) rs)",
                    "c157_goal : eq (find_function tge ros (LTL.return_regs (parent_locset ts) rs))\n  (Some ?f')",
                    "c158_goal : eq (funsig f') (funsig tf')",
                    "c159_goal : eq (Mem.free m stk 0 (fn_stacksize tf)) (Some ?m')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c156_goal : eq ?rs' (LTL.return_regs (parent_locset ts) rs)",
                    "c38_ts : list stackframe",
                    "c8_rs : LTL\\.locset"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c157_goal : eq (find_function tge ros (LTL.return_regs (parent_locset ts) rs))\n  (Some ?f')",
                    "c151_PLS : eq (parent_locset ts) (parent_locset s)"
                ],
                "tactic_res": [
                    "c160_goal : eq (find_function tge ros (LTL.return_regs (parent_locset s) rs))\n  (Some ?f')"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "c160_goal : eq (find_function tge ros (LTL.return_regs (parent_locset s) rs))\n  (Some ?f')",
                    "c148_A : eq (find_function tge ros (LTL.return_regs (parent_locset s) rs))\n  (Some tf')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c158_goal : eq (funsig f') (funsig tf')"
                ],
                "tactic_res": [
                    "c161_goal : eq (funsig tf') (funsig f')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c161_goal : eq (funsig tf') (funsig f')",
                    "_global_sig_preserved : forall (f tf : fundef) (_ : eq (transf_fundef f) (OK tf)),\n       eq (funsig tf) (funsig f)"
                ],
                "tactic_res": [
                    "c162_goal : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c162_goal : eq (transf_fundef f') (OK tf')",
                    "c148_B : eq (transf_fundef f') (OK tf')",
                    "c148_tf' : fundef",
                    "c8_f' : fundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c159_goal : eq (Mem.free m stk 0 (fn_stacksize tf)) (Some ?m')",
                    "c38_TRF : match_function f tf"
                ],
                "tactic_res": [
                    "c163_goal : eq\n  (Mem.free m stk 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}))\n  (Some\n     ?m'@{tf:={|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}})",
                    "c163_H : match_code (fn_code f) c",
                    "c163_c : code"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c163_goal : eq\n  (Mem.free m stk 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}))\n  (Some\n     ?m'@{tf:={|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}})",
                    "c163_c : code",
                    "c8_H2 : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')",
                    "c8_m : Mem\\.mem",
                    "c8_stk : block",
                    "c8_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c154_goal : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset ts) rs) m')",
                    "c151_PLS : eq (parent_locset ts) (parent_locset s)"
                ],
                "tactic_res": [
                    "c164_goal : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset s) rs) m')"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c164_goal : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset s) rs) m')"
                ],
                "tactic_res": [
                    "c165_goal : list_forall2 match_stackframes s ts",
                    "c166_goal : eq (transf_fundef f') (OK tf')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c165_goal : list_forall2 match_stackframes s ts",
                    "c38_STACKS : list_forall2 match_stackframes s ts",
                    "c38_ts : list stackframe",
                    "c8_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c166_goal : eq (transf_fundef f') (OK tf')",
                    "c148_B : eq (transf_fundef f') (OK tf')",
                    "c148_tf' : fundef",
                    "c8_f' : fundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c42_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lbuiltin ef args res)\n              (add_delta_ranges before after c')) rs m) t ts2)\n     (match_states\n        (State s f sp b\n           (Locmap.setres res vres\n              (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') ts2))"
                ],
                "tactic_res": [
                    "c167_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n        rs m) t ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.setres res vres\n           (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c167_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n        rs m) t ?ts2)\n  (match_states\n     (State s f sp b\n        (Locmap.setres res vres\n           (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') \n     ?ts2)"
                ],
                "tactic_res": [
                    "c168_goal : plus step tge\n  (State ts tf sp\n     (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n     rs m) t ?ts2",
                    "c169_goal : match_states\n  (State s f sp b\n     (Locmap.setres res vres\n        (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c168_goal : plus step tge\n  (State ts tf sp\n     (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n     rs m) t ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c170_goal : step tge\n  (State ts tf sp\n     (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2",
                    "c171_goal : star step tge ?s2 ?t2 ?ts2",
                    "c172_goal : eq t (Eapp t E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c170_goal : step tge\n  (State ts tf sp\n     (cons (Lbuiltin ef args res) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c173_goal : eval_builtin_args tge rs sp m args ?vargs",
                    "c174_goal : external_call ef tge vargs m ?t1 ?vres ?m'",
                    "c175_goal : eq ?rs'\n  (Locmap.setres res ?vres\n     (LTL.undef_regs (destroyed_by_builtin ef) rs))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c175_goal : eq ?rs'\n  (Locmap.setres res ?vres\n     (LTL.undef_regs (destroyed_by_builtin ef) rs))",
                    "c9_res : builtin_res mreg",
                    "c9_ef : external_function",
                    "c9_rs : forall _ : loc, val"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i with ( ge1 := _i ) .",
                "tactic_sig_no_out_arg": "eapply _i with ( ge1 := _i ) .",
                "tactic_args": [
                    "c173_goal : eval_builtin_args tge rs sp m args ?vargs",
                    "_global_eval_builtin_args_preserved : forall (A F1 V1 F2 V2 : Type) (ge1 : Genv.t F1 V1)\n         (ge2 : Genv.t F2 V2) (e : forall _ : A, val) \n         (sp : val) (m : Mem.mem)\n         (_ : forall id : ident,\n              eq (Genv.find_symbol ge2 id) (Genv.find_symbol ge1 id))\n         (al : list (builtin_arg A)) (vl : list val)\n         (_ : eval_builtin_args ge1 e sp m al vl),\n       eval_builtin_args ge2 e sp m al vl",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": [
                    "c176_goal : forall id : ident,\neq (Genv.find_symbol tge id) (Genv.find_symbol ge id)",
                    "c177_goal : eval_builtin_args ge rs sp m args ?vargs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c177_goal : eval_builtin_args ge rs sp m args ?vargs",
                    "c9_H : eval_builtin_args ge rs sp m args vargs",
                    "c9_args : list (builtin_arg loc)",
                    "c9_m : Mem\\.mem",
                    "c9_rs : forall _ : loc, val",
                    "c9_sp : val",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact symbols_preserved .",
                "tactic_sig_no_out_arg": "exact symbols_preserved .",
                "tactic_args": [
                    "c176_goal : forall id : ident,\neq (Genv.find_symbol tge id) (Genv.find_symbol ge id)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c174_goal : external_call ef tge vargs m ?t1 ?vres ?m'",
                    "_global_external_call_symbols_preserved : forall (ef : external_function) (ge1 ge2 : Senv.t) \n         (vargs : list val) (m1 : Mem.mem) (t : trace) \n         (vres : val) (m2 : Mem.mem) (_ : Senv.equiv ge1 ge2)\n         (_ : external_call ef ge1 vargs m1 t vres m2),\n       external_call ef ge2 vargs m1 t vres m2"
                ],
                "tactic_res": [
                    "c178_goal : Senv.equiv ge tge",
                    "c179_goal : external_call ef ?ge1 vargs m ?t1 ?vres ?m'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c179_goal : external_call ef ?ge1 vargs m ?t1 ?vres ?m'",
                    "c9_H0 : external_call ef ge vargs m t vres m'",
                    "c9_vargs : list val",
                    "c9_ef : external_function",
                    "c9_m : Mem\\.mem"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c178_goal : Senv.equiv ge tge",
                    "_global_senv_preserved : Senv.equiv ge tge"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c171_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (Locmap.setres res vres\n        (LTL.undef_regs (destroyed_by_builtin ef) rs)) m') \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c172_goal : eq t (Eapp t E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c169_goal : match_states\n  (State s f sp b\n     (Locmap.setres res vres\n        (LTL.undef_regs (destroyed_by_builtin ef) rs)) m')\n  (State ts tf sp c'\n     (Locmap.setres res vres\n        (LTL.undef_regs (destroyed_by_builtin ef) rs)) m')"
                ],
                "tactic_res": [
                    "c180_goal : list_forall2 match_stackframes s ts",
                    "c181_goal : match_function f tf",
                    "c182_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c180_goal : list_forall2 match_stackframes s ts",
                    "c41_STACKS : list_forall2 match_stackframes s ts",
                    "c41_ts : list stackframe",
                    "c9_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c181_goal : match_function f tf",
                    "c41_TRF : match_function f tf",
                    "c41_tf : function",
                    "c9_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c182_goal : match_code b c'",
                    "c42_H4 : match_code b c'",
                    "c42_c' : code",
                    "c9_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c45_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Llabel lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b rs m) ts2))"
                ],
                "tactic_res": [
                    "c183_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) E0\n     ?ts2) (match_states (State s f sp b rs m) ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c183_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) E0\n     ?ts2) (match_states (State s f sp b rs m) ?ts2)"
                ],
                "tactic_res": [
                    "c184_goal : plus step tge\n  (State ts tf sp\n     (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) E0\n  ?ts2",
                    "c185_goal : match_states (State s f sp b rs m) (State ts tf sp c' rs m)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c184_goal : plus step tge\n  (State ts tf sp\n     (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) E0\n  ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c186_goal : step tge\n  (State ts tf sp\n     (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2",
                    "c187_goal : star step tge (State ts tf sp (add_delta_ranges before after c') rs m)\n  ?t2 ?ts2",
                    "c188_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c186_goal : step tge\n  (State ts tf sp\n     (cons (Llabel lbl) (add_delta_ranges before after c')) rs m) \n  ?t1 ?s2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c187_goal : star step tge (State ts tf sp (add_delta_ranges before after c') rs m)\n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c188_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c185_goal : match_states (State s f sp b rs m) (State ts tf sp c' rs m)"
                ],
                "tactic_res": [
                    "c189_goal : list_forall2 match_stackframes s ts",
                    "c190_goal : match_function f tf",
                    "c191_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c189_goal : list_forall2 match_stackframes s ts",
                    "c44_STACKS : list_forall2 match_stackframes s ts",
                    "c44_ts : list stackframe",
                    "c10_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c190_goal : match_function f tf",
                    "c44_TRF : match_function f tf",
                    "c44_tf : function",
                    "c10_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c191_goal : match_code b c'",
                    "c45_H2 : match_code b c'",
                    "c45_c' : code",
                    "c10_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit find_label_match .",
                "tactic_sig_no_out_arg": "exploit find_label_match .",
                "tactic_args": [
                    "c48_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))"
                ],
                "tactic_res": [
                    "c192_goal : match_function ?Goal6 ?Goal7",
                    "c193_goal : eq (find_label ?Goal8 (fn_code ?Goal6)) (Some ?Goal9)",
                    "c194_goal : forall\n  _ : ex\n        (fun before0 : option avail =>\n         ex\n           (fun after0 : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label ?Goal8 (fn_code ?Goal7))\n                    (Some (add_delta_ranges before0 after0 tc)))\n                 (match_code ?Goal9 tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c192_goal : match_function ?Goal6 ?Goal7",
                    "c47_TRF : match_function f tf"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c193_goal : eq (find_label ?Goal6 (fn_code f)) (Some ?Goal7)",
                    "c11_H : eq (find_label lbl (fn_code f)) (Some b')",
                    "c11_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( before' & after' & tc' & A & B ) .",
                "tactic_args": [
                    "c194_goal : forall\n  _ : ex\n        (fun before : option avail =>\n         ex\n           (fun after : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label lbl (fn_code tf))\n                    (Some (add_delta_ranges before after tc)))\n                 (match_code b' tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))"
                ],
                "tactic_res": [
                    "c195_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))",
                    "c195_before' : option avail",
                    "c195_after' : option avail",
                    "c195_tc' : code",
                    "c195_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c195_B : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c195_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m)\n        E0 ts2) (match_states (State s f sp b' rs m) ts2))"
                ],
                "tactic_res": [
                    "c196_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m) E0\n     ?ts2) (match_states (State s f sp b' rs m) ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c196_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lgoto lbl) (add_delta_ranges before after c')) rs m) E0\n     ?ts2) (match_states (State s f sp b' rs m) ?ts2)"
                ],
                "tactic_res": [
                    "c197_goal : plus step tge\n  (State ts tf sp (cons (Lgoto lbl) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "c198_goal : match_states (State s f sp b' rs m) (State ts tf sp tc' rs m)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c197_goal : plus step tge\n  (State ts tf sp (cons (Lgoto lbl) (add_delta_ranges before after c'))\n     rs m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c199_goal : step tge\n  (State ts tf sp (cons (Lgoto lbl) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2",
                    "c200_goal : star step tge ?s2 ?t2 ?ts2",
                    "c201_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c199_goal : step tge\n  (State ts tf sp (cons (Lgoto lbl) (add_delta_ranges before after c'))\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c202_goal : eq (find_label lbl (fn_code tf)) (Some ?b')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c202_goal : eq (find_label lbl (fn_code tf)) (Some ?b')",
                    "c195_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c47_tf : function",
                    "c11_lbl : label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c200_goal : star step tge\n  (State ts tf sp (add_delta_ranges before' after' tc') rs m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c201_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c198_goal : match_states (State s f sp b' rs m) (State ts tf sp tc' rs m)"
                ],
                "tactic_res": [
                    "c203_goal : list_forall2 match_stackframes s ts",
                    "c204_goal : match_function f tf",
                    "c205_goal : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c203_goal : list_forall2 match_stackframes s ts",
                    "c47_STACKS : list_forall2 match_stackframes s ts",
                    "c47_ts : list stackframe",
                    "c11_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c204_goal : match_function f tf",
                    "c47_TRF : match_function f tf",
                    "c47_tf : function",
                    "c11_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c205_goal : match_code b' tc'",
                    "c195_B : match_code b' tc'",
                    "c195_tc' : code",
                    "c11_b' : code"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit find_label_match .",
                "tactic_sig_no_out_arg": "exploit find_label_match .",
                "tactic_args": [
                    "c51_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c206_goal : match_function ?Goal5 ?Goal6",
                    "c207_goal : eq (find_label ?Goal7 (fn_code ?Goal5)) (Some ?Goal8)",
                    "c208_goal : forall\n  _ : ex\n        (fun before0 : option avail =>\n         ex\n           (fun after0 : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label ?Goal7 (fn_code ?Goal6))\n                    (Some (add_delta_ranges before0 after0 tc)))\n                 (match_code ?Goal8 tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c206_goal : match_function ?Goal5 ?Goal6",
                    "c50_TRF : match_function f tf"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c207_goal : eq (find_label ?Goal5 (fn_code f)) (Some ?Goal6)",
                    "c12_H1 : eq (find_label lbl (fn_code f)) (Some b')",
                    "c12_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( before' & after' & tc' & A & B ) .",
                "tactic_args": [
                    "c208_goal : forall\n  _ : ex\n        (fun before : option avail =>\n         ex\n           (fun after : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label lbl (fn_code tf))\n                    (Some (add_delta_ranges before after tc)))\n                 (match_code b' tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c209_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))",
                    "c209_before' : option avail",
                    "c209_after' : option avail",
                    "c209_tc' : code",
                    "c209_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c209_B : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c209_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c210_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcond cond args lbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c210_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcond cond args lbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n     ?ts2)"
                ],
                "tactic_res": [
                    "c211_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "c212_goal : match_states\n  (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c211_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c213_goal : step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2",
                    "c214_goal : star step tge ?s2 ?t2 ?ts2",
                    "c215_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c213_goal : step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2",
                    "_global_exec_Lcond_true : forall (ge : genv) (s : list stackframe) (f : function) \n         (sp : val) (cond : condition) (args : list mreg) \n         (lbl : label) (b : list instruction) (rs : LTL.locset) \n         (m : Mem.mem) (rs' : LTL.locset) (b' : code)\n         (_ : eq (eval_condition cond (LTL.reglist rs args) m) (Some true))\n         (_ : eq rs' (LTL.undef_regs (destroyed_by_cond cond) rs))\n         (_ : eq (find_label lbl (fn_code f)) (Some b')),\n       step ge (State s f sp (cons (Lcond cond args lbl) b) rs m) E0\n         (State s f sp b' rs' m)"
                ],
                "tactic_res": [
                    "c216_goal : eq (eval_condition cond (LTL.reglist rs args) m) (Some true)",
                    "c217_goal : eq ?rs' (LTL.undef_regs (destroyed_by_cond cond) rs)",
                    "c218_goal : eq (find_label lbl (fn_code tf)) (Some ?b')"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c216_goal : eq (eval_condition cond (LTL.reglist rs args) m) (Some true)",
                    "c12_H : eq (eval_condition cond (LTL.reglist rs args) m) (Some true)",
                    "c12_m : Mem\\.mem",
                    "c12_rs : LTL\\.locset",
                    "c12_args : list mreg",
                    "c12_cond : condition"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c217_goal : eq ?rs' (LTL.undef_regs (destroyed_by_cond cond) rs)",
                    "c12_rs : LTL\\.locset",
                    "c12_cond : condition"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c218_goal : eq (find_label lbl (fn_code tf)) (Some ?b')",
                    "c209_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c50_tf : function",
                    "c12_lbl : label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c214_goal : star step tge\n  (State ts tf sp (add_delta_ranges before' after' tc')\n     (LTL.undef_regs (destroyed_by_cond cond) rs) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c215_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c212_goal : match_states\n  (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp tc' (LTL.undef_regs (destroyed_by_cond cond) rs) m)"
                ],
                "tactic_res": [
                    "c219_goal : list_forall2 match_stackframes s ts",
                    "c220_goal : match_function f tf",
                    "c221_goal : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c219_goal : list_forall2 match_stackframes s ts",
                    "c50_STACKS : list_forall2 match_stackframes s ts",
                    "c50_ts : list stackframe",
                    "c12_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c220_goal : match_function f tf",
                    "c50_TRF : match_function f tf",
                    "c50_tf : function",
                    "c12_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c221_goal : match_code b' tc'",
                    "c209_B : match_code b' tc'",
                    "c209_tc' : code",
                    "c12_b' : code"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c54_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Lcond cond args lbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c222_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcond cond args lbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c222_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Lcond cond args lbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n     ?ts2)"
                ],
                "tactic_res": [
                    "c223_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "c224_goal : match_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c223_goal : plus step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c225_goal : step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2",
                    "c226_goal : star step tge ?s2 ?t2 ?ts2",
                    "c227_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c225_goal : step tge\n  (State ts tf sp\n     (cons (Lcond cond args lbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2",
                    "_global_exec_Lcond_false : forall (ge : genv) (s : list stackframe) (f : function) \n         (sp : val) (cond : condition) (args : list mreg) \n         (lbl : label) (b : list instruction) (rs : LTL.locset) \n         (m : Mem.mem) (rs' : LTL.locset)\n         (_ : eq (eval_condition cond (LTL.reglist rs args) m) (Some false))\n         (_ : eq rs' (LTL.undef_regs (destroyed_by_cond cond) rs)),\n       step ge (State s f sp (cons (Lcond cond args lbl) b) rs m) E0\n         (State s f sp b rs' m)"
                ],
                "tactic_res": [
                    "c228_goal : eq (eval_condition cond (LTL.reglist rs args) m) (Some false)",
                    "c229_goal : eq ?rs' (LTL.undef_regs (destroyed_by_cond cond) rs)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c228_goal : eq (eval_condition cond (LTL.reglist rs args) m) (Some false)",
                    "c13_H : eq (eval_condition cond (LTL.reglist rs args) m) (Some false)",
                    "c13_m : Mem\\.mem",
                    "c13_rs : LTL\\.locset",
                    "c13_args : list mreg",
                    "c13_cond : condition"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c229_goal : eq ?rs' (LTL.undef_regs (destroyed_by_cond cond) rs)",
                    "c13_rs : LTL\\.locset",
                    "c13_cond : condition"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c226_goal : star step tge\n  (State ts tf sp (add_delta_ranges before after c')\n     (LTL.undef_regs (destroyed_by_cond cond) rs) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c227_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c224_goal : match_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp c' (LTL.undef_regs (destroyed_by_cond cond) rs) m)"
                ],
                "tactic_res": [
                    "c230_goal : list_forall2 match_stackframes s ts",
                    "c231_goal : match_function f tf",
                    "c232_goal : match_code b c'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c230_goal : list_forall2 match_stackframes s ts",
                    "c53_STACKS : list_forall2 match_stackframes s ts",
                    "c53_ts : list stackframe",
                    "c13_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c231_goal : match_function f tf",
                    "c53_TRF : match_function f tf",
                    "c53_tf : function",
                    "c13_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c232_goal : match_code b c'",
                    "c54_H3 : match_code b c'",
                    "c54_c' : code",
                    "c13_b : list instruction"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit find_label_match .",
                "tactic_sig_no_out_arg": "exploit find_label_match .",
                "tactic_args": [
                    "c57_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c233_goal : match_function ?Goal3 ?Goal4",
                    "c234_goal : eq (find_label ?Goal5 (fn_code ?Goal3)) (Some ?Goal6)",
                    "c235_goal : forall\n  _ : ex\n        (fun before0 : option avail =>\n         ex\n           (fun after0 : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label ?Goal5 (fn_code ?Goal4))\n                    (Some (add_delta_ranges before0 after0 tc)))\n                 (match_code ?Goal6 tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c233_goal : match_function ?Goal3 ?Goal4",
                    "c56_TRF : match_function f tf"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c234_goal : eq (find_label ?Goal3 (fn_code f)) (Some ?Goal4)",
                    "c14_H1 : eq (find_label lbl (fn_code f)) (Some b')",
                    "c14_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( before' & after' & tc' & A & B ) .",
                "tactic_args": [
                    "c235_goal : forall\n  _ : ex\n        (fun before : option avail =>\n         ex\n           (fun after : option avail =>\n            ex\n              (fun tc : code =>\n               and\n                 (eq (find_label lbl (fn_code tf))\n                    (Some (add_delta_ranges before after tc)))\n                 (match_code b' tc)))),\nex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c236_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))",
                    "c236_before' : option avail",
                    "c236_after' : option avail",
                    "c236_tc' : code",
                    "c236_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c236_B : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c236_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf sp\n           (cons (Ljumptable arg tbl)\n              (add_delta_ranges before after c')) rs m) E0 ts2)\n     (match_states\n        (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n        ts2))"
                ],
                "tactic_res": [
                    "c237_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Ljumptable arg tbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c237_goal : and\n  (plus step tge\n     (State ts tf sp\n        (cons (Ljumptable arg tbl) (add_delta_ranges before after c'))\n        rs m) E0 ?ts2)\n  (match_states\n     (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n     ?ts2)"
                ],
                "tactic_res": [
                    "c238_goal : plus step tge\n  (State ts tf sp\n     (cons (Ljumptable arg tbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "c239_goal : match_states\n  (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m) \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c238_goal : plus step tge\n  (State ts tf sp\n     (cons (Ljumptable arg tbl) (add_delta_ranges before after c')) rs\n     m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c240_goal : step tge\n  (State ts tf sp\n     (cons (Ljumptable arg tbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2",
                    "c241_goal : star step tge ?s2 ?t2 ?ts2",
                    "c242_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c240_goal : step tge\n  (State ts tf sp\n     (cons (Ljumptable arg tbl) (add_delta_ranges before after c')) rs\n     m) ?t1 ?s2"
                ],
                "tactic_res": [
                    "c243_goal : eq (rs (R arg)) (Vint ?n)",
                    "c244_goal : eq (list_nth_z tbl (Int.unsigned n)) (Some ?lbl)",
                    "c245_goal : eq (find_label lbl (fn_code tf)) (Some ?b')",
                    "c246_goal : eq ?rs' (LTL.undef_regs destroyed_by_jumptable rs)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c243_goal : eq (rs (R arg)) (Vint ?n)",
                    "c14_H : eq (rs (R arg)) (Vint n)",
                    "c14_rs : forall _ : loc, val",
                    "c14_arg : mreg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c244_goal : eq (list_nth_z tbl (Int.unsigned n)) (Some ?lbl)",
                    "c14_H0 : eq (list_nth_z tbl (Int.unsigned n)) (Some lbl)",
                    "c14_n : Int\\.int",
                    "c14_tbl : list label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c245_goal : eq (find_label lbl (fn_code tf)) (Some ?b')",
                    "c236_A : eq (find_label lbl (fn_code tf))\n  (Some (add_delta_ranges before' after' tc'))",
                    "c56_tf : function",
                    "c14_lbl : label"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c246_goal : eq ?rs' (LTL.undef_regs destroyed_by_jumptable rs)",
                    "c14_rs : forall _ : loc, val"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c241_goal : star step tge\n  (State ts tf sp (add_delta_ranges before' after' tc')\n     (LTL.undef_regs destroyed_by_jumptable rs) m) \n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c242_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c239_goal : match_states\n  (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp tc' (LTL.undef_regs destroyed_by_jumptable rs) m)"
                ],
                "tactic_res": [
                    "c247_goal : list_forall2 match_stackframes s ts",
                    "c248_goal : match_function f tf",
                    "c249_goal : match_code b' tc'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c247_goal : list_forall2 match_stackframes s ts",
                    "c56_STACKS : list_forall2 match_stackframes s ts",
                    "c56_ts : list stackframe",
                    "c14_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c248_goal : match_function f tf",
                    "c56_TRF : match_function f tf",
                    "c56_tf : function",
                    "c14_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c249_goal : match_code b' tc'",
                    "c236_B : match_code b' tc'",
                    "c236_tc' : code",
                    "c14_b' : code"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c60_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (State ts tf (Vptr stk Ptrofs.zero)\n           (cons Lreturn (add_delta_ranges before after c')) rs m) E0\n        ts2)\n     (match_states\n        (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2))"
                ],
                "tactic_res": [
                    "c250_goal : and\n  (plus step tge\n     (State ts tf (Vptr stk Ptrofs.zero)\n        (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (Returnstate s (LTL.return_regs (parent_locset s) rs) m') \n     ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c250_goal : and\n  (plus step tge\n     (State ts tf (Vptr stk Ptrofs.zero)\n        (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n     ?ts2)\n  (match_states\n     (Returnstate s (LTL.return_regs (parent_locset s) rs) m') \n     ?ts2)"
                ],
                "tactic_res": [
                    "c251_goal : plus step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "c252_goal : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset ts) rs) m')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c251_goal : plus step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n  ?ts2",
                    "_global_plus_one : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t : trace) (s2 : state)\n         (_ : step ge s1 t s2), plus step ge s1 t s2"
                ],
                "tactic_res": [
                    "c253_goal : step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n  ?ts2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c253_goal : step tge\n  (State ts tf (Vptr stk Ptrofs.zero)\n     (cons Lreturn (add_delta_ranges before after c')) rs m) E0 \n  ?ts2"
                ],
                "tactic_res": [
                    "c254_goal : eq (Mem.free m stk 0 (fn_stacksize tf)) (Some ?m')"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c254_goal : eq (Mem.free m stk 0 (fn_stacksize tf)) (Some ?m')",
                    "c59_TRF : match_function f tf"
                ],
                "tactic_res": [
                    "c255_goal : eq\n  (Mem.free m stk 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}))\n  (Some\n     ?m'@{tf:={|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}})",
                    "c255_H0 : match_code (fn_code f) c",
                    "c255_c : code"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c255_goal : eq\n  (Mem.free m stk 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}))\n  (Some\n     ?m'@{tf:={|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}})",
                    "c255_c : code",
                    "c15_H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')",
                    "c15_m : Mem\\.mem",
                    "c15_stk : block",
                    "c15_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i _i _i ) .",
                "tactic_args": [
                    "c252_goal : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset ts) rs) m')",
                    "_global_parent_locset_match : forall (s ts : list stackframe)\n         (_ : list_forall2 match_stackframes s ts),\n       eq (parent_locset ts) (parent_locset s)",
                    "_global__ : ?T\nwhere\n?T : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      s : list stackframe\n      f : function\n      stk : block\n      b : list instruction\n      rs : locset\n      m : Mem.mem\n      m' : Mem.mem\n      H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')\n      tf : function\n      ts : list stackframe\n      STACKS : list_forall2 match_stackframes s ts\n      TRF : match_function f tf\n      before : option avail\n      after : option avail\n      c' : code\n      H3 : match_code b c' |- Type]\n?y : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      s : list stackframe\n      f : function\n      stk : block\n      b : list instruction\n      rs : locset\n      m : Mem.mem\n      m' : Mem.mem\n      H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')\n      tf : function\n      ts : list stackframe\n      STACKS : list_forall2 match_stackframes s ts\n      TRF : match_function f tf\n      before : option avail\n      after : option avail\n      c' : code\n      H3 : match_code b c' |- ?T]",
                    "_global__ : ?T\nwhere\n?T : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      s : list stackframe\n      f : function\n      stk : block\n      b : list instruction\n      rs : locset\n      m : Mem.mem\n      m' : Mem.mem\n      H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')\n      tf : function\n      ts : list stackframe\n      STACKS : list_forall2 match_stackframes s ts\n      TRF : match_function f tf\n      before : option avail\n      after : option avail\n      c' : code\n      H3 : match_code b c' |- Type]\n?y : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      s : list stackframe\n      f : function\n      stk : block\n      b : list instruction\n      rs : locset\n      m : Mem.mem\n      m' : Mem.mem\n      H : eq (Mem.free m stk 0 (fn_stacksize f)) (Some m')\n      tf : function\n      ts : list stackframe\n      STACKS : list_forall2 match_stackframes s ts\n      TRF : match_function f tf\n      before : option avail\n      after : option avail\n      c' : code\n      H3 : match_code b c' |- ?T]",
                    "c59_STACKS : list_forall2 match_stackframes s ts"
                ],
                "tactic_res": [
                    "c256_goal : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset s) rs) m')"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c256_goal : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset s) rs) m')"
                ],
                "tactic_res": [
                    "c257_goal : list_forall2 match_stackframes s ts"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c257_goal : list_forall2 match_stackframes s ts",
                    "c59_STACKS : list_forall2 match_stackframes s ts",
                    "c59_ts : list stackframe",
                    "c15_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c62_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts tf rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c62_H7 : eq (transf_fundef (Internal f)) (OK tf)"
                ],
                "tactic_res": [
                    "c258_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (Internal x) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c258_EQ : eq (transf_function f) (OK x)",
                    "c258_x : function"
                ]
            },
            {
                "tactic_sig": "rename _i into tf .",
                "tactic_sig_no_out_arg": "rename _i into tf .",
                "tactic_args": [
                    "c258_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (Internal x) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c258_x : function"
                ],
                "tactic_res": [
                    "c259_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (Internal tf) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c259_EQ : eq (transf_function f) (OK tf)",
                    "c259_tf : function"
                ]
            },
            {
                "tactic_sig": "assert ( MF : match_function _i _i ) by ( apply transf_function_match ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( MF : match_function _i _i ) by ( apply transf_function_match ; auto ) .",
                "tactic_args": [
                    "c16_f : function",
                    "c259_tf : function",
                    "c259_EQ : eq (transf_function f) (OK tf)",
                    "c62_H6 : list_forall2 match_stackframes s ts",
                    "c62_ts : list stackframe",
                    "c16_H : eq (Mem.alloc m 0 (fn_stacksize f)) (pair m' stk)",
                    "c16_stk : block",
                    "c16_m' : Mem.mem'",
                    "c16_m : Mem\\.mem",
                    "c16_rs : LTL\\.locset",
                    "c16_s : list stackframe",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c259_MF : match_function f tf"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c259_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (Internal tf) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c259_MF : match_function f tf"
                ],
                "tactic_res": [
                    "c260_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (Callstate ts\n           (Internal\n              {|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))",
                    "c260_H2 : eq\n  {|\n    fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n  |} tf",
                    "c260_H1 : eq f0 f",
                    "c260_H0 : match_code (fn_code f) c",
                    "c260_c : code",
                    "c260_f0 : function"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c260_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (Callstate ts\n           (Internal\n              {|\n                fn_sig := fn_sig f;\n                fn_stacksize := fn_stacksize f;\n                fn_code := c\n              |}) rs m) E0 ts2)\n     (match_states\n        (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n           (LTL.undef_regs destroyed_at_function_entry\n              (LTL.call_regs rs)) m') ts2))"
                ],
                "tactic_res": [
                    "c261_goal : and\n  (plus step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := c\n           |}) rs m) E0 ?ts2)\n  (match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n        (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs))\n        m') ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c261_goal : and\n  (plus step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := c\n           |}) rs m) E0 ?ts2)\n  (match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n        (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs))\n        m') ?ts2)"
                ],
                "tactic_res": [
                    "c262_goal : plus step tge\n  (Callstate ts\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}) rs m) E0 ?ts2",
                    "c263_goal : match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n     (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n     |} (Vptr stk Ptrofs.zero)\n     (fn_code\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})\n     (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c262_goal : plus step tge\n  (Callstate ts\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}) rs m) E0 ?ts2",
                    "_global_plus_one : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t : trace) (s2 : state)\n         (_ : step ge s1 t s2), plus step ge s1 t s2"
                ],
                "tactic_res": [
                    "c264_goal : step tge\n  (Callstate ts\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}) rs m) E0 ?ts2"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c264_goal : step tge\n  (Callstate ts\n     (Internal\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |}) rs m) E0 ?ts2"
                ],
                "tactic_res": [
                    "c265_goal : eq\n  (Mem.alloc m 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})) (pair ?m' ?stk)",
                    "c266_goal : eq ?rs' (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c265_goal : eq\n  (Mem.alloc m 0\n     (fn_stacksize\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})) (pair ?m' ?stk)"
                ],
                "tactic_res": [
                    "c267_goal : eq (Mem.alloc m 0 (fn_stacksize f)) (pair ?m' ?stk)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c267_goal : eq (Mem.alloc m 0 (fn_stacksize f)) (pair ?m' ?stk)",
                    "c16_H : eq (Mem.alloc m 0 (fn_stacksize f)) (pair m' stk)",
                    "c16_m : Mem\\.mem",
                    "c16_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c266_goal : eq ?rs' (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c263_goal : match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n     (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n     |} (Vptr stk Ptrofs.zero)\n     (fn_code\n        {|\n          fn_sig := fn_sig f;\n          fn_stacksize := fn_stacksize f;\n          fn_code := c\n        |})\n     (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')"
                ],
                "tactic_res": [
                    "c268_goal : list_forall2 match_stackframes s ts",
                    "c269_goal : match_function f\n  {|\n    fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n  |}",
                    "c270_goal : match_code (fn_code f)\n  (fn_code\n     {|\n       fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n     |})"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c268_goal : list_forall2 match_stackframes s ts",
                    "c62_H6 : list_forall2 match_stackframes s ts",
                    "c62_ts : list stackframe",
                    "c16_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c269_goal : match_function f\n  {|\n    fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n  |}",
                    "c260_MF : match_function f\n  {|\n    fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n  |}",
                    "c260_c : code",
                    "c16_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c270_goal : match_code (fn_code f)\n  (fn_code\n     {|\n       fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n     |})",
                    "c260_H0 : match_code (fn_code f) c",
                    "c260_c : code",
                    "c16_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monadInv _i .",
                "tactic_sig_no_out_arg": "monadInv _i .",
                "tactic_args": [
                    "c64_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts tf rs1 m) t ts2)\n     (match_states\n        (Returnstate s\n           (Locmap.setpair (loc_result (ef_sig ef)) res\n              (LTL.undef_caller_save_regs rs1)) m') ts2))",
                    "c64_H8 : eq (transf_fundef (External ef)) (OK tf)"
                ],
                "tactic_res": [
                    "c271_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (External ef) rs1 m) t ts2)\n     (match_states\n        (Returnstate s\n           (Locmap.setpair (loc_result (ef_sig ef)) res\n              (LTL.undef_caller_save_regs rs1)) m') ts2))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c271_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Callstate ts (External ef) rs1 m) t ts2)\n     (match_states\n        (Returnstate s\n           (Locmap.setpair (loc_result (ef_sig ef)) res\n              (LTL.undef_caller_save_regs rs1)) m') ts2))"
                ],
                "tactic_res": [
                    "c272_goal : and (plus step tge (Callstate ts (External ef) rs1 m) t ?ts2)\n  (match_states\n     (Returnstate s\n        (Locmap.setpair (loc_result (ef_sig ef)) res\n           (LTL.undef_caller_save_regs rs1)) m') ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c272_goal : and (plus step tge (Callstate ts (External ef) rs1 m) t ?ts2)\n  (match_states\n     (Returnstate s\n        (Locmap.setpair (loc_result (ef_sig ef)) res\n           (LTL.undef_caller_save_regs rs1)) m') ?ts2)"
                ],
                "tactic_res": [
                    "c273_goal : plus step tge (Callstate ts (External ef) rs1 m) t ?ts2",
                    "c274_goal : match_states\n  (Returnstate s\n     (Locmap.setpair (loc_result (ef_sig ef)) res\n        (LTL.undef_caller_save_regs rs1)) m') ?ts2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c273_goal : plus step tge (Callstate ts (External ef) rs1 m) t ?ts2",
                    "_global_plus_one : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t : trace) (s2 : state)\n         (_ : step ge s1 t s2), plus step ge s1 t s2"
                ],
                "tactic_res": [
                    "c275_goal : step tge (Callstate ts (External ef) rs1 m) t ?ts2"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c275_goal : step tge (Callstate ts (External ef) rs1 m) t ?ts2"
                ],
                "tactic_res": [
                    "c276_goal : eq ?args\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef)))",
                    "c277_goal : external_call ef tge ?args m t ?res ?m'",
                    "c278_goal : eq ?rs2\n  (Locmap.setpair (loc_result (ef_sig ef)) ?res\n     (LTL.undef_caller_save_regs rs1))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c276_goal : eq ?args\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef)))",
                    "c17_rs1 : Locmap\\.t",
                    "c17_ef : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c278_goal : eq ?rs2\n  (Locmap.setpair (loc_result (ef_sig ef)) ?res\n     (LTL.undef_caller_save_regs rs1))",
                    "c17_rs1 : Locmap\\.t",
                    "c17_ef : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c277_goal : external_call ef tge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t ?res ?m'",
                    "_global_external_call_symbols_preserved : forall (ef : external_function) (ge1 ge2 : Senv.t) \n         (vargs : list val) (m1 : Mem.mem) (t : trace) \n         (vres : val) (m2 : Mem.mem) (_ : Senv.equiv ge1 ge2)\n         (_ : external_call ef ge1 vargs m1 t vres m2),\n       external_call ef ge2 vargs m1 t vres m2"
                ],
                "tactic_res": [
                    "c279_goal : Senv.equiv ge tge",
                    "c280_goal : external_call ef ?ge1\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t ?res ?m'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c280_goal : external_call ef ?ge1\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t ?res ?m'",
                    "c64_H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m'",
                    "c17_t : trace",
                    "c17_m : Mem\\.mem",
                    "c17_rs1 : Locmap\\.t",
                    "c17_ef : external_function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c279_goal : Senv.equiv ge tge",
                    "_global_senv_preserved : Senv.equiv ge tge"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c274_goal : match_states\n  (Returnstate s\n     (Locmap.setpair (loc_result (ef_sig ef)) res\n        (LTL.undef_caller_save_regs rs1)) m')\n  (Returnstate ts\n     (Locmap.setpair (loc_result (ef_sig ef)) res\n        (LTL.undef_caller_save_regs rs1)) m')"
                ],
                "tactic_res": [
                    "c281_goal : list_forall2 match_stackframes s ts"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c281_goal : list_forall2 match_stackframes s ts",
                    "c64_H7 : list_forall2 match_stackframes s ts",
                    "c64_ts : list stackframe",
                    "c17_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c66_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Returnstate ts rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c66_H3 : list_forall2 match_stackframes (cons (Stackframe f sp rs0 c) s) ts"
                ],
                "tactic_res": [
                    "c282_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Returnstate (cons b1 bl) rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c282_H4 : list_forall2 match_stackframes s bl",
                    "c282_H1 : match_stackframes (Stackframe f sp rs0 c) b1",
                    "c282_bl : list stackframe",
                    "c282_b1 : stackframe"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c282_goal : ex\n  (fun ts2 : state =>\n   and (plus step tge (Returnstate (cons b1 bl) rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c282_H1 : match_stackframes (Stackframe f sp rs0 c) b1"
                ],
                "tactic_res": [
                    "c283_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (Returnstate\n           (cons\n              (Stackframe tf sp rs0 (add_delta_ranges before after tc))\n              bl) rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))",
                    "c283_H7 : match_code c tc",
                    "c283_H6 : match_function f tf",
                    "c283_after : option avail",
                    "c283_before : option avail",
                    "c283_tc : code",
                    "c283_tf : function"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c283_goal : ex\n  (fun ts2 : state =>\n   and\n     (plus step tge\n        (Returnstate\n           (cons\n              (Stackframe tf sp rs0 (add_delta_ranges before after tc))\n              bl) rs m) E0 ts2)\n     (match_states (State s f sp c rs m) ts2))"
                ],
                "tactic_res": [
                    "c284_goal : and\n  (plus step tge\n     (Returnstate\n        (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc))\n           bl) rs m) E0 ?ts2) (match_states (State s f sp c rs m) ?ts2)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c284_goal : and\n  (plus step tge\n     (Returnstate\n        (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc))\n           bl) rs m) E0 ?ts2) (match_states (State s f sp c rs m) ?ts2)"
                ],
                "tactic_res": [
                    "c285_goal : plus step tge\n  (Returnstate\n     (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc)) bl)\n     rs m) E0 ?ts2",
                    "c286_goal : match_states (State s f sp c rs m) (State bl tf sp tc rs m)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c285_goal : plus step tge\n  (Returnstate\n     (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc)) bl)\n     rs m) E0 ?ts2",
                    "_global_plus_left : forall (genv state : Type)\n         (step : forall (_ : genv) (_ : state) (_ : trace) (_ : state), Prop)\n         (ge : genv) (s1 : state) (t1 : trace) (s2 : state) \n         (t2 : trace) (s3 : state) (t : trace) (_ : step ge s1 t1 s2)\n         (_ : star step ge s2 t2 s3) (_ : eq t (Eapp t1 t2)),\n       plus step ge s1 t s3"
                ],
                "tactic_res": [
                    "c287_goal : step tge\n  (Returnstate\n     (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc)) bl)\n     rs m) ?t1 ?s2",
                    "c288_goal : star step tge (State bl tf sp (add_delta_ranges before after tc) rs m)\n  ?t2 ?ts2",
                    "c289_goal : eq E0 (Eapp E0 E0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c287_goal : step tge\n  (Returnstate\n     (cons (Stackframe tf sp rs0 (add_delta_ranges before after tc)) bl)\n     rs m) ?t1 ?s2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c288_goal : star step tge (State bl tf sp (add_delta_ranges before after tc) rs m)\n  ?t2 ?ts2",
                    "_global_eval_add_delta_ranges : forall (s : list stackframe) (f : function) \n         (sp : val) (c : code) (rs : locset) (m : Mem.mem)\n         (before after : option avail),\n       star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n         (State s f sp c rs m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "traceEq .",
                "tactic_sig_no_out_arg": "traceEq .",
                "tactic_args": [
                    "c289_goal : eq E0 (Eapp E0 E0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c286_goal : match_states (State s f sp c rs m) (State bl tf sp tc rs m)"
                ],
                "tactic_res": [
                    "c290_goal : list_forall2 match_stackframes s bl",
                    "c291_goal : match_function f tf",
                    "c292_goal : match_code c tc"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c290_goal : list_forall2 match_stackframes s bl",
                    "c282_H4 : list_forall2 match_stackframes s bl",
                    "c282_bl : list stackframe",
                    "c18_s : list stackframe"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c291_goal : match_function f tf",
                    "c283_H6 : match_function f tf",
                    "c283_tf : function",
                    "c18_f : function"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c292_goal : match_code c tc",
                    "c283_H7 : match_code c tc",
                    "c283_tc : code",
                    "c18_c : code"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_initial_states",
        "proof": [
            {
                "tactic_sig": "Lemma transf_initial_states : forall st1 , initial_state prog st1 -> exists st2 , initial_state tprog st2 /\\ match_states st1 st2 .",
                "tactic_sig_no_out_arg": "Lemma transf_initial_states : forall st1 , initial_state prog st1 -> exists st2 , initial_state tprog st2 /\\ match_states st1 st2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (st1 : state) (_ : initial_state prog st1),\nex\n  (fun st2 : state =>\n   and (initial_state tprog st2) (match_states st1 st2))",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (st1 : state) (_ : initial_state prog st1),\nex\n  (fun st2 : state =>\n   and (initial_state tprog st2) (match_states st1 st2))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2) (match_states st1 st2))",
                    "c2_st1 : state",
                    "c2_H : initial_state prog st1"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2) (match_states st1 st2))",
                    "c2_H : initial_state prog st1"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))",
                    "c3_H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1",
                    "c3_H3 : eq (funsig f) signature_main",
                    "c3_H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)",
                    "c3_H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)",
                    "c3_H0 : eq (Genv.init_mem prog) (Some m0)",
                    "c3_ge0 : Genv.t fundef unit",
                    "c3_m0 : Mem\\.mem",
                    "c3_f : fundef",
                    "c3_b : block"
                ]
            },
            {
                "tactic_sig": "exploit function_ptr_translated .",
                "tactic_sig_no_out_arg": "exploit function_ptr_translated .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))"
                ],
                "tactic_res": [
                    "c4_goal : eq (Genv.find_funct_ptr ge ?Goal) (Some ?Goal0)",
                    "c5_goal : forall\n  _ : ex\n        (fun tf : fundef =>\n         and (eq (Genv.find_funct_ptr tge b) (Some tf))\n           (eq (transf_fundef f) (OK tf))),\nex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : eq (Genv.find_funct_ptr ge ?Goal) (Some ?Goal0)",
                    "c3_H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)",
                    "c1_ge : Genv.t fundef unit"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ tf [ A B ] ] .",
                "tactic_args": [
                    "c5_goal : forall\n  _ : ex\n        (fun tf : fundef =>\n         and (eq (Genv.find_funct_ptr tge b) (Some tf))\n           (eq (transf_fundef f) (OK tf))),\nex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))"
                ],
                "tactic_res": [
                    "c6_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))",
                    "c6_tf : fundef",
                    "c6_A : eq (Genv.find_funct_ptr tge b) (Some tf)",
                    "c6_B : eq (transf_fundef f) (OK tf)"
                ]
            },
            {
                "tactic_sig": "exists ( Callstate nil _i ( Locmap.init Vundef ) _i ) .",
                "tactic_sig_no_out_arg": "exists ( Callstate nil _i ( Locmap.init Vundef ) _i ) .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun st2 : state =>\n   and (initial_state tprog st2)\n     (match_states (Callstate nil f (Locmap.init Vundef) m0) st2))",
                    "c6_tf : fundef",
                    "c3_m0 : Mem\\.mem"
                ],
                "tactic_res": [
                    "c7_goal : and (initial_state tprog (Callstate nil tf (Locmap.init Vundef) m0))\n  (match_states (Callstate nil f (Locmap.init Vundef) m0)\n     (Callstate nil tf (Locmap.init Vundef) m0))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (initial_state tprog (Callstate nil tf (Locmap.init Vundef) m0))\n  (match_states (Callstate nil f (Locmap.init Vundef) m0)\n     (Callstate nil tf (Locmap.init Vundef) m0))"
                ],
                "tactic_res": [
                    "c8_goal : initial_state tprog (Callstate nil tf (Locmap.init Vundef) m0)",
                    "c9_goal : match_states (Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c8_goal : initial_state tprog (Callstate nil tf (Locmap.init Vundef) m0)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Genv.init_mem tprog) (Some m0)",
                    "c11_goal : eq (Genv.find_symbol (Genv.globalenv tprog) (prog_main tprog))\n  (Some ?b)",
                    "c12_goal : eq (Genv.find_funct_ptr (Genv.globalenv tprog) ?b) (Some tf)",
                    "c13_goal : eq (funsig tf) signature_main"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c12_goal : eq (Genv.find_funct_ptr (Genv.globalenv tprog) ?b) (Some tf)",
                    "c6_A : eq (Genv.find_funct_ptr tge b) (Some tf)",
                    "c6_tf : fundef",
                    "c1_tprog : program"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( _i _i ) .",
                "tactic_sig_no_out_arg": "eapply ( _i _i ) .",
                "tactic_args": [
                    "c10_goal : eq (Genv.init_mem tprog) (Some m0)",
                    "_global_Genv.init_mem_transf_partial : forall\n         (_ : match_program\n                (fun (_ : AST.program unit unit) (f0 : unit) (tf0 : ?B) =>\n                 eq (?transf f0) (OK tf0)) eq ?p ?tp) \n         (m : Mem.mem) (_ : eq (Genv.init_mem ?p) (Some m)),\n       eq (Genv.init_mem ?tp) (Some m)\nwhere\n?B : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      st1 : state\n      H : initial_state prog st1\n      b : block\n      f : fundef\n      m0 : Mem.mem\n      ge0 := Genv.globalenv prog : Genv.t fundef unit\n      H0 : eq (Genv.init_mem prog) (Some m0)\n      H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n      H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n      H3 : eq (funsig f) signature_main\n      H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n      tf : fundef\n      A : eq (Genv.find_funct_ptr tge b) (Some tf)\n      B : eq (transf_fundef f) (OK tf) |- Type]\n?transf : [prog : program\n           tprog : program\n           TRANSF : match_prog prog tprog\n           ge := Genv.globalenv prog : Genv.t fundef unit\n           tge := Genv.globalenv tprog : Genv.t fundef unit\n           st1 : state\n           H : initial_state prog st1\n           b : block\n           f : fundef\n           m0 : Mem.mem\n           ge0 := Genv.globalenv prog : Genv.t fundef unit\n           H0 : eq (Genv.init_mem prog) (Some m0)\n           H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n           H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n           H3 : eq (funsig f) signature_main\n           H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n           tf : fundef\n           A : eq (Genv.find_funct_ptr tge b) (Some tf)\n           B : eq (transf_fundef f) (OK tf) |- forall _ : unit, res ?B]\n?p : [prog : program\n      tprog : program\n      TRANSF : match_prog prog tprog\n      ge := Genv.globalenv prog : Genv.t fundef unit\n      tge := Genv.globalenv tprog : Genv.t fundef unit\n      st1 : state\n      H : initial_state prog st1\n      b : block\n      f : fundef\n      m0 : Mem.mem\n      ge0 := Genv.globalenv prog : Genv.t fundef unit\n      H0 : eq (Genv.init_mem prog) (Some m0)\n      H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n      H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n      H3 : eq (funsig f) signature_main\n      H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n      tf : fundef\n      A : eq (Genv.find_funct_ptr tge b) (Some tf)\n      B : eq (transf_fundef f) (OK tf) |- AST.program unit unit]\n?tp : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       st1 : state\n       H : initial_state prog st1\n       b : block\n       f : fundef\n       m0 : Mem.mem\n       ge0 := Genv.globalenv prog : Genv.t fundef unit\n       H0 : eq (Genv.init_mem prog) (Some m0)\n       H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n       H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n       H3 : eq (funsig f) signature_main\n       H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n       tf : fundef\n       A : eq (Genv.find_funct_ptr tge b) (Some tf)\n       B : eq (transf_fundef f) (OK tf) |- AST.program ?B unit]",
                    "c1_TRANSF : match_prog prog tprog"
                ],
                "tactic_res": [
                    "c14_goal : eq (Genv.init_mem prog) (Some m0)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq (Genv.init_mem prog) (Some m0)",
                    "c3_H0 : eq (Genv.init_mem prog) (Some m0)",
                    "c3_m0 : Mem\\.mem",
                    "c1_prog : program"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite ( _i _i ) , _i .",
                "tactic_args": [
                    "c11_goal : eq (Genv.find_symbol (Genv.globalenv tprog) (prog_main tprog)) (Some b)",
                    "_global_match_program_main : forall _ : match_program ?match_fundef ?match_varinfo ?p1 ?p2,\n       eq (prog_main ?p2) (prog_main ?p1)\nwhere\n?F2 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       st1 : state\n       H : initial_state prog st1\n       b : block\n       f : fundef\n       m0 : Mem.mem\n       ge0 := Genv.globalenv prog : Genv.t fundef unit\n       H0 : eq (Genv.init_mem prog) (Some m0)\n       H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n       H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n       H3 : eq (funsig f) signature_main\n       H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n       tf : fundef\n       A : eq (Genv.find_funct_ptr tge b) (Some tf)\n       B : eq (transf_fundef f) (OK tf) |- Type]\n?V2 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       st1 : state\n       H : initial_state prog st1\n       b : block\n       f : fundef\n       m0 : Mem.mem\n       ge0 := Genv.globalenv prog : Genv.t fundef unit\n       H0 : eq (Genv.init_mem prog) (Some m0)\n       H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n       H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n       H3 : eq (funsig f) signature_main\n       H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n       tf : fundef\n       A : eq (Genv.find_funct_ptr tge b) (Some tf)\n       B : eq (transf_fundef f) (OK tf) |- Type]\n?match_fundef : [prog : program\n                 tprog : program\n                 TRANSF : match_prog prog tprog\n                 ge := Genv.globalenv prog : Genv.t fundef unit\n                 tge := Genv.globalenv tprog : Genv.t fundef unit\n                 st1 : state\n                 H : initial_state prog st1\n                 b : block\n                 f : fundef\n                 m0 : Mem.mem\n                 ge0 := Genv.globalenv prog : Genv.t fundef unit\n                 H0 : eq (Genv.init_mem prog) (Some m0)\n                 H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n                 H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n                 H3 : eq (funsig f) signature_main\n                 H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n                 tf : fundef\n                 A : eq (Genv.find_funct_ptr tge b) (Some tf)\n                 B : eq (transf_fundef f) (OK tf)\n                |- forall (_ : AST.program unit unit) (_ : unit) (_ : ?F2),\n                   Prop]\n?match_varinfo : [prog : program\n                  tprog : program\n                  TRANSF : match_prog prog tprog\n                  ge := Genv.globalenv prog : Genv.t fundef unit\n                  tge := Genv.globalenv tprog : Genv.t fundef unit\n                  st1 : state\n                  H : initial_state prog st1\n                  b : block\n                  f : fundef\n                  m0 : Mem.mem\n                  ge0 := Genv.globalenv prog : Genv.t fundef unit\n                  H0 : eq (Genv.init_mem prog) (Some m0)\n                  H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n                  H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n                  H3 : eq (funsig f) signature_main\n                  H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n                  tf : fundef\n                  A : eq (Genv.find_funct_ptr tge b) (Some tf)\n                  B : eq (transf_fundef f) (OK tf)\n                 |- forall (_ : unit) (_ : ?V2), Prop]\n?p1 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       st1 : state\n       H : initial_state prog st1\n       b : block\n       f : fundef\n       m0 : Mem.mem\n       ge0 := Genv.globalenv prog : Genv.t fundef unit\n       H0 : eq (Genv.init_mem prog) (Some m0)\n       H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n       H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n       H3 : eq (funsig f) signature_main\n       H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n       tf : fundef\n       A : eq (Genv.find_funct_ptr tge b) (Some tf)\n       B : eq (transf_fundef f) (OK tf) |- AST.program unit unit]\n?p2 : [prog : program\n       tprog : program\n       TRANSF : match_prog prog tprog\n       ge := Genv.globalenv prog : Genv.t fundef unit\n       tge := Genv.globalenv tprog : Genv.t fundef unit\n       st1 : state\n       H : initial_state prog st1\n       b : block\n       f : fundef\n       m0 : Mem.mem\n       ge0 := Genv.globalenv prog : Genv.t fundef unit\n       H0 : eq (Genv.init_mem prog) (Some m0)\n       H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)\n       H2 : eq (Genv.find_funct_ptr ge0 b) (Some f)\n       H3 : eq (funsig f) signature_main\n       H4 : eq (Callstate nil f (Locmap.init Vundef) m0) st1\n       tf : fundef\n       A : eq (Genv.find_funct_ptr tge b) (Some tf)\n       B : eq (transf_fundef f) (OK tf) |- AST.program ?F2 ?V2]",
                    "c1_TRANSF : match_prog prog tprog",
                    "_global_symbols_preserved : forall s : ident, eq (Genv.find_symbol tge s) (Genv.find_symbol ge s)"
                ],
                "tactic_res": [
                    "c15_goal : eq (Genv.find_symbol ge (prog_main prog)) (Some b)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : eq (Genv.find_symbol ge (prog_main prog)) (Some b)",
                    "c3_H1 : eq (Genv.find_symbol ge0 (prog_main prog)) (Some b)",
                    "c3_b : block",
                    "c1_ge : Genv.t fundef unit",
                    "c1_prog : program"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c13_goal : eq (funsig tf) signature_main",
                    "c3_H3 : eq (funsig f) signature_main"
                ],
                "tactic_res": [
                    "c16_goal : eq (funsig tf) (funsig f)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eq (funsig tf) (funsig f)",
                    "_global_sig_preserved : forall (f tf : fundef) (_ : eq (transf_fundef f) (OK tf)),\n       eq (funsig tf) (funsig f)"
                ],
                "tactic_res": [
                    "c17_goal : eq (transf_fundef f) (OK tf)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : eq (transf_fundef f) (OK tf)",
                    "c6_B : eq (transf_fundef f) (OK tf)",
                    "c6_tf : fundef",
                    "c3_f : fundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c9_goal : match_states (Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0)"
                ],
                "tactic_res": [
                    "c18_goal : list_forall2 match_stackframes nil nil",
                    "c19_goal : eq (transf_fundef f) (OK tf)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c18_goal : list_forall2 match_stackframes nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : eq (transf_fundef f) (OK tf)",
                    "c6_B : eq (transf_fundef f) (OK tf)",
                    "c6_tf : fundef",
                    "c3_f : fundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_final_states",
        "proof": [
            {
                "tactic_sig": "Lemma transf_final_states : forall st1 st2 r , match_states st1 st2 -> final_state st1 r -> final_state st2 r .",
                "tactic_sig_no_out_arg": "Lemma transf_final_states : forall st1 st2 r , match_states st1 st2 -> final_state st1 r -> final_state st2 r .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (st1 st2 : state) (r : Int.int) (_ : match_states st1 st2)\n  (_ : final_state st1 r), final_state st2 r",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (st1 st2 : state) (r : Int.int) (_ : match_states st1 st2)\n  (_ : final_state st1 r), final_state st2 r"
                ],
                "tactic_res": [
                    "c2_goal : final_state st2 r",
                    "c2_st1 : state",
                    "c2_st2 : state",
                    "c2_r : Int\\.int",
                    "c2_H : match_states st1 st2",
                    "c2_H0 : final_state st1 r"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_H0 : final_state st1 r"
                ],
                "tactic_res": [
                    "c2_H1 : eq (Locmap.getpair (map_rpair R (loc_result signature_main)) rs)\n  (Vint r)",
                    "c2_H : match_states (Returnstate nil rs m) st2",
                    "c2_m : Mem\\.mem",
                    "c2_rs : Locmap\\.t"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : final_state st2 r",
                    "c2_H : match_states (Returnstate nil rs m) st2"
                ],
                "tactic_res": [
                    "c3_goal : final_state (Returnstate ts rs m) r",
                    "c3_H5 : list_forall2 match_stackframes nil ts",
                    "c3_ts : list stackframe"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : final_state (Returnstate ts rs m) r",
                    "c3_H5 : list_forall2 match_stackframes nil ts"
                ],
                "tactic_res": [
                    "c4_goal : final_state (Returnstate nil rs m) r"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "c4_goal : final_state (Returnstate nil rs m) r"
                ],
                "tactic_res": [
                    "c5_goal : eq (Locmap.getpair (map_rpair R (loc_result signature_main)) rs)\n  (Vint r)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c5_goal : eq (Locmap.getpair (map_rpair R (loc_result signature_main)) rs)\n  (Vint r)",
                    "c2_H1 : eq (Locmap.getpair (map_rpair R (loc_result signature_main)) rs)\n  (Vint r)",
                    "c2_rs : Locmap\\.t",
                    "c2_r : Int\\.int"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transf_program_correct",
        "proof": [
            {
                "tactic_sig": "Theorem transf_program_correct : forward_simulation ( semantics prog ) ( semantics tprog ) .",
                "tactic_sig_no_out_arg": "Theorem transf_program_correct : forward_simulation ( semantics prog ) ( semantics tprog ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forward_simulation (semantics prog) (semantics tprog)",
                    "c1_tge : Genv.t fundef unit",
                    "c1_ge : Genv.t fundef unit",
                    "c1_TRANSF : match_prog prog tprog",
                    "c1_tprog : program",
                    "c1_prog : program"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c1_goal : forward_simulation (semantics prog) (semantics tprog)",
                    "_global_forward_simulation_plus : forall (L1 L2 : Smallstep.semantics)\n         (_ : forall id : ident,\n              eq (Senv.public_symbol (symbolenv L2) id)\n                (Senv.public_symbol (symbolenv L1) id))\n         (match_states : forall (_ : Smallstep.state L1)\n                           (_ : Smallstep.state L2), Prop)\n         (_ : forall (s1 : Smallstep.state L1)\n                (_ : Smallstep.initial_state L1 s1),\n              ex\n                (fun s2 : Smallstep.state L2 =>\n                 and (Smallstep.initial_state L2 s2) (match_states s1 s2)))\n         (_ : forall (s1 : Smallstep.state L1) (s2 : Smallstep.state L2)\n                (r : Int.int) (_ : match_states s1 s2)\n                (_ : Smallstep.final_state L1 s1 r),\n              Smallstep.final_state L2 s2 r)\n         (_ : forall (s1 : Smallstep.state L1) (t : trace)\n                (s1' : Smallstep.state L1)\n                (_ : Smallstep.step L1 (globalenv L1) s1 t s1')\n                (s2 : Smallstep.state L2) (_ : match_states s1 s2),\n              ex\n                (fun s2' : Smallstep.state L2 =>\n                 and (plus (Smallstep.step L2) (globalenv L2) s2 t s2')\n                   (match_states s1' s2'))), forward_simulation L1 L2"
                ],
                "tactic_res": [
                    "c2_goal : forall id : ident,\neq (Senv.public_symbol (symbolenv (semantics tprog)) id)\n  (Senv.public_symbol (symbolenv (semantics prog)) id)",
                    "c3_goal : forall (s1 : Smallstep.state (semantics prog))\n  (_ : Smallstep.initial_state (semantics prog) s1),\nex\n  (fun s2 : Smallstep.state (semantics tprog) =>\n   and (Smallstep.initial_state (semantics tprog) s2)\n     (?match_states s1 s2))",
                    "c4_goal : forall (s1 : Smallstep.state (semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : Int.int)\n  (_ : match_states s1 s2)\n  (_ : Smallstep.final_state (semantics prog) s1 r),\nSmallstep.final_state (semantics tprog) s2 r",
                    "c5_goal : forall (s1 : Smallstep.state (semantics prog)) (t : trace)\n  (s1' : Smallstep.state (semantics prog))\n  (_ : Smallstep.step (semantics prog) (globalenv (semantics prog)) s1\n         t s1') (s2 : Smallstep.state (semantics tprog))\n  (_ : match_states s1 s2),\nex\n  (fun s2' : Smallstep.state (semantics tprog) =>\n   and\n     (plus (Smallstep.step (semantics tprog))\n        (globalenv (semantics tprog)) s2 t s2') (match_states s1' s2'))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : forall id : ident,\neq (Senv.public_symbol (symbolenv (semantics tprog)) id)\n  (Senv.public_symbol (symbolenv (semantics prog)) id)",
                    "_global_senv_preserved : Senv.equiv ge tge"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eexact transf_initial_states .",
                "tactic_sig_no_out_arg": "eexact transf_initial_states .",
                "tactic_args": [
                    "c3_goal : forall (s1 : Smallstep.state (semantics prog))\n  (_ : Smallstep.initial_state (semantics prog) s1),\nex\n  (fun s2 : Smallstep.state (semantics tprog) =>\n   and (Smallstep.initial_state (semantics tprog) s2)\n     (?match_states s1 s2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eexact transf_final_states .",
                "tactic_sig_no_out_arg": "eexact transf_final_states .",
                "tactic_args": [
                    "c4_goal : forall (s1 : Smallstep.state (semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : Int.int)\n  (_ : match_states s1 s2)\n  (_ : Smallstep.final_state (semantics prog) s1 r),\nSmallstep.final_state (semantics tprog) s2 r"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eexact transf_step_correct .",
                "tactic_sig_no_out_arg": "eexact transf_step_correct .",
                "tactic_args": [
                    "c5_goal : forall (s1 : Smallstep.state (semantics prog)) (t : trace)\n  (s1' : Smallstep.state (semantics prog))\n  (_ : Smallstep.step (semantics prog) (globalenv (semantics prog)) s1\n         t s1') (s2 : Smallstep.state (semantics tprog))\n  (_ : match_states s1 s2),\nex\n  (fun s2' : Smallstep.state (semantics tprog) =>\n   and\n     (plus (Smallstep.step (semantics tprog))\n        (globalenv (semantics tprog)) s2 t s2') (match_states s1' s2'))"
                ],
                "tactic_res": []
            }
        ]
    }
]