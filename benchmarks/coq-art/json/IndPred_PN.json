[
    {
        "lemma_name": "zero_cons_ord",
        "proof": [
            {
                "tactic_sig": "Theorem zero_cons_ord : forall l : list nat , sorted le l -> sorted le ( cons 0 l ) .",
                "tactic_sig_no_out_arg": "Theorem zero_cons_ord : forall l : list nat , sorted le l -> sorted le ( cons 0 l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list nat) (_ : sorted le l), sorted le (cons 0 l)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list nat) (_ : sorted le l), sorted le (cons 0 l)"
                ],
                "tactic_res": [
                    "c2_goal : sorted le (cons 0 nil)",
                    "c3_goal : sorted le (cons 0 (cons x nil))",
                    "c3_x : nat",
                    "c4_goal : sorted le (cons 0 (cons x (cons y l)))",
                    "c4_IHsorted : sorted le (cons 0 (cons y l))",
                    "c4_H0 : sorted le (cons y l)",
                    "c4_H : le x y",
                    "c4_l : list nat",
                    "c4_y : nat",
                    "c4_x : nat"
                ]
            },
            {
                "tactic_sig": "auto with sorted_base arith .",
                "tactic_sig_no_out_arg": "auto with sorted_base arith .",
                "tactic_args": [
                    "c2_goal : sorted le (cons 0 nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with sorted_base arith .",
                "tactic_sig_no_out_arg": "auto with sorted_base arith .",
                "tactic_args": [
                    "c3_goal : sorted le (cons 0 (cons x nil))",
                    "c3_x : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with sorted_base arith .",
                "tactic_sig_no_out_arg": "auto with sorted_base arith .",
                "tactic_args": [
                    "c4_goal : sorted le (cons 0 (cons x (cons y l)))",
                    "c4_H0 : sorted le (cons y l)",
                    "c4_H : le x y",
                    "c4_l : list nat",
                    "c4_x : nat",
                    "c4_y : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sorted1_inv",
        "proof": [
            {
                "tactic_sig": "Theorem sorted1_inv { A : Type } { le : relation A } { x l } ( H : sorted le ( x :: l ) ) : sorted le l .",
                "tactic_sig_no_out_arg": "Theorem sorted1_inv { A : Type } { le : relation A } { x l } ( H : sorted le ( x :: l ) ) : sorted le l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : sorted le l",
                    "c1_H : sorted le (cons x l)",
                    "c1_l : list A",
                    "c1_x : A",
                    "c1_le : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c1_goal : sorted le l",
                    "c1_H : sorted le (cons x l)"
                ],
                "tactic_res": [
                    "c2_goal : sorted le nil",
                    "c2_H2 : eq nil l",
                    "c2_H1 : eq x0 x",
                    "c2_x0 : A",
                    "c3_goal : sorted le (cons y l0)",
                    "c3_H1 : eq (cons y l0) l",
                    "c3_H0 : eq x0 x",
                    "c3_H3 : sorted le (cons y l0)",
                    "c3_H2 : le x y",
                    "c3_l0 : list A",
                    "c3_y : A",
                    "c3_x0 : A"
                ]
            },
            {
                "tactic_sig": "auto with sorted_base .",
                "tactic_sig_no_out_arg": "auto with sorted_base .",
                "tactic_args": [
                    "c2_goal : sorted le nil",
                    "c1_le : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with sorted_base .",
                "tactic_sig_no_out_arg": "auto with sorted_base .",
                "tactic_args": [
                    "c3_goal : sorted le (cons y l0)",
                    "c3_H3 : sorted le (cons y l0)",
                    "c3_l0 : list A",
                    "c3_y : A",
                    "c1_le : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sorted2_inv",
        "proof": [
            {
                "tactic_sig": "Theorem sorted2_inv { A : Type } { le : relation A } { x y l } ( H : sorted le ( x :: y :: l ) ) : le x y .",
                "tactic_sig_no_out_arg": "Theorem sorted2_inv { A : Type } { le : relation A } { x y l } ( H : sorted le ( x :: y :: l ) ) : le x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : le x y",
                    "c1_H : sorted le (cons x (cons y l))",
                    "c1_l : list A",
                    "c1_y : A",
                    "c1_x : A",
                    "c1_le : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c1_H : sorted le (cons x (cons y l))"
                ],
                "tactic_res": [
                    "c1_H3 : eq l0 l",
                    "c1_H1 : eq y0 y",
                    "c1_H0 : eq x0 x",
                    "c1_H4 : sorted le (cons y l)",
                    "c1_H2 : le x y",
                    "c1_l0 : list A",
                    "c1_y0 : A",
                    "c1_x0 : A"
                ]
            },
            {
                "tactic_sig": "auto with sorted_base .",
                "tactic_sig_no_out_arg": "auto with sorted_base .",
                "tactic_args": [
                    "c1_goal : le x y",
                    "c1_H2 : le x y",
                    "c1_x : A",
                    "c1_y : A",
                    "c1_le : relation A"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "not_sorted_132",
        "proof": [
            {
                "tactic_sig": "Theorem not_sorted_132 : ~ sorted le ( 1 :: 3 :: 2 :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem not_sorted_132 : ~ sorted le ( 1 :: 3 :: 2 :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : not (sorted le (cons 1 (cons 3 (cons 2 nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c1_goal : not (sorted le (cons 1 (cons 3 (cons 2 nil))))"
                ],
                "tactic_res": [
                    "c2_goal : False",
                    "c2_H : sorted le (cons 1 (cons 3 (cons 2 nil)))"
                ]
            },
            {
                "tactic_sig": "generalize ( sorted1_inv _i ) .",
                "tactic_sig_no_out_arg": "generalize ( sorted1_inv _i ) .",
                "tactic_args": [
                    "c2_goal : False",
                    "c2_H : sorted le (cons 1 (cons 3 (cons 2 nil)))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : sorted le (cons 3 (cons 2 nil)), False"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H0 .",
                "tactic_args": [
                    "c3_goal : forall _ : sorted le (cons 3 (cons 2 nil)), False"
                ],
                "tactic_res": [
                    "c4_goal : False",
                    "c4_H0 : sorted le (cons 3 (cons 2 nil))"
                ]
            },
            {
                "tactic_sig": "generalize ( sorted2_inv _i ) .",
                "tactic_sig_no_out_arg": "generalize ( sorted2_inv _i ) .",
                "tactic_args": [
                    "c4_goal : False",
                    "c4_H0 : sorted le (cons 3 (cons 2 nil))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : le 3 2, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c5_goal : forall _ : le 3 2, False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "any_height_inj2",
        "proof": [
            {
                "tactic_sig": "Theorem any_height_inj2 { A : Type } : forall ( n1 n2 : nat ) ( t1 : htree A n1 ) ( t2 : htree A n2 ) , any_height n1 t1 = any_height n2 t2 -> JMeq t1 t2 .",
                "tactic_sig_no_out_arg": "Theorem any_height_inj2 { A : Type } : forall ( n1 n2 : nat ) ( t1 : htree A n1 ) ( t2 : htree A n2 ) , any_height n1 t1 = any_height n2 t2 -> JMeq t1 t2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n1 n2 : nat) (t1 : htree A n1) (t2 : htree A n2)\n  (_ : eq (any_height n1 t1) (any_height n2 t2)), \nJMeq t1 t2",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n1 n2 t1 t2 H .",
                "tactic_args": [
                    "c1_goal : forall (n1 n2 : nat) (t1 : htree A n1) (t2 : htree A n2)\n  (_ : eq (any_height n1 t1) (any_height n2 t2)), \nJMeq t1 t2"
                ],
                "tactic_res": [
                    "c2_goal : JMeq t1 t2",
                    "c2_n1 : nat",
                    "c2_n2 : nat",
                    "c2_t1 : htree A n1",
                    "c2_t2 : htree A n2",
                    "c2_H : eq (any_height n1 t1) (any_height n2 t2)"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c2_goal : JMeq t1 t2",
                    "c2_H : eq (any_height n1 t1) (any_height n2 t2)"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : eq (existT (fun n : nat => htree A n) n1 t1)\n         (existT (fun n : nat => htree A n) n2 t2)) \n  (_ : eq n1 n2), JMeq t1 t2"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H1 H2 .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : eq (existT (fun n : nat => htree A n) n1 t1)\n         (existT (fun n : nat => htree A n) n2 t2)) \n  (_ : eq n1 n2), JMeq t1 t2"
                ],
                "tactic_res": [
                    "c4_goal : JMeq t1 t2",
                    "c4_H1 : eq (existT (fun n : nat => htree A n) n1 t1)\n  (existT (fun n : nat => htree A n) n2 t2)",
                    "c4_H2 : eq n1 n2"
                ]
            },
            {
                "tactic_sig": "dependent rewrite <- _i .",
                "tactic_sig_no_out_arg": "dependent rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : JMeq t1 t2",
                    "c4_H1 : eq (existT (fun n : nat => htree A n) n1 t1)\n  (existT (fun n : nat => htree A n) n2 t2)"
                ],
                "tactic_res": [
                    "c5_goal : JMeq t1 t1"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c5_goal : JMeq t1 t1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "any_height_inj2'",
        "proof": [
            {
                "tactic_sig": "Theorem any_height_inj2' { A : Type } : forall ( n1 n2 : nat ) ( t1 : htree A n1 ) ( t2 : htree A n2 ) , any_height n1 t1 = any_height n2 t2 -> JMeq t1 t2 .",
                "tactic_sig_no_out_arg": "Theorem any_height_inj2' { A : Type } : forall ( n1 n2 : nat ) ( t1 : htree A n1 ) ( t2 : htree A n2 ) , any_height n1 t1 = any_height n2 t2 -> JMeq t1 t2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n1 n2 : nat) (t1 : htree A n1) (t2 : htree A n2)\n  (_ : eq (any_height n1 t1) (any_height n2 t2)), \nJMeq t1 t2",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros n1 n2 t1 t2 H .",
                "tactic_args": [
                    "c1_goal : forall (n1 n2 : nat) (t1 : htree A n1) (t2 : htree A n2)\n  (_ : eq (any_height n1 t1) (any_height n2 t2)), \nJMeq t1 t2"
                ],
                "tactic_res": [
                    "c2_goal : JMeq t1 t2",
                    "c2_n1 : nat",
                    "c2_n2 : nat",
                    "c2_t1 : htree A n1",
                    "c2_t2 : htree A n2",
                    "c2_H : eq (any_height n1 t1) (any_height n2 t2)"
                ]
            },
            {
                "tactic_sig": "change ( match any_height _i _i with | any_height n t => JMeq _i t end ) .",
                "tactic_sig_no_out_arg": "change ( match any_height _i _i with | any_height n t => JMeq _i t end ) .",
                "tactic_args": [
                    "c2_goal : JMeq t1 t2",
                    "c2_n2 : nat",
                    "c2_t2 : htree A n2",
                    "c2_t1 : htree A n1"
                ],
                "tactic_res": [
                    "c3_goal : match any_height n2 t2 with\n| any_height n t => JMeq t1 t\nend"
                ]
            },
            {
                "tactic_sig": "now rewrite <- _i .",
                "tactic_sig_no_out_arg": "now rewrite <- _i .",
                "tactic_args": [
                    "c3_goal : match any_height n2 t2 with\n| any_height n t => JMeq t1 t\nend",
                    "c2_H : eq (any_height n1 t1) (any_height n2 t2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "keep_length",
        "proof": [
            {
                "tactic_sig": "Theorem keep_length : forall ( n : nat ) ( v : t A n ) , length ( vector_to_list n v ) = n .",
                "tactic_sig_no_out_arg": "Theorem keep_length : forall ( n : nat ) ( v : t A n ) , length ( vector_to_list n v ) = n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (v : t A n), eq (length (vector_to_list n v)) n",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n v .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (v : t A n), eq (length (vector_to_list n v)) n"
                ],
                "tactic_res": [
                    "c2_goal : eq (length (vector_to_list n v)) n",
                    "c2_n : nat",
                    "c2_v : t A n"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : eq (length (vector_to_list n v)) n",
                    "c2_v : t A n"
                ],
                "tactic_res": [
                    "c3_goal : eq (length (vector_to_list 0 (nil A))) 0",
                    "c4_goal : eq (length (vector_to_list (S n) (cons A h n v))) (S n)",
                    "c4_IHv : eq (length (vector_to_list n v)) n",
                    "c4_h : A"
                ]
            },
            {
                "tactic_sig": "custom_tac3 .",
                "tactic_sig_no_out_arg": "custom_tac3 .",
                "tactic_args": [
                    "c3_goal : eq (length (vector_to_list 0 (nil A))) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom_tac3 .",
                "tactic_sig_no_out_arg": "custom_tac3 .",
                "tactic_args": [
                    "c4_goal : eq (length (vector_to_list (S n) (cons A h n v))) (S n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Vconseq",
        "proof": [
            {
                "tactic_sig": "Lemma Vconseq : forall ( a : A ) ( n m : nat ) , n = m -> forall ( v : t A n ) ( w : t A m ) , JMeq v w -> JMeq ( cons A a n v ) ( cons A a m w ) .",
                "tactic_sig_no_out_arg": "Lemma Vconseq : forall ( a : A ) ( n m : nat ) , n = m -> forall ( v : t A n ) ( w : t A m ) , JMeq v w -> JMeq ( cons A a n v ) ( cons A a m w ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (a : A) (n m : nat) (_ : eq n m) (v : t A n) \n  (w : t A m) (_ : JMeq v w), JMeq (cons A a n v) (cons A a m w)",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a n m Heq .",
                "tactic_args": [
                    "c1_goal : forall (a : A) (n m : nat) (_ : eq n m) (v : t A n) \n  (w : t A m) (_ : JMeq v w), JMeq (cons A a n v) (cons A a m w)"
                ],
                "tactic_res": [
                    "c2_goal : forall (v : t A n) (w : t A m) (_ : JMeq v w),\nJMeq (cons A a n v) (cons A a m w)",
                    "c2_a : A",
                    "c2_n : nat",
                    "c2_m : nat",
                    "c2_Heq : eq n m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : forall (v : t A n) (w : t A m) (_ : JMeq v w),\nJMeq (cons A a n v) (cons A a m w)",
                    "c2_Heq : eq n m"
                ],
                "tactic_res": [
                    "c3_goal : forall (v w : t A m) (_ : JMeq v w), JMeq (cons A a m v) (cons A a m w)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros v w HJeq .",
                "tactic_args": [
                    "c3_goal : forall (v w : t A m) (_ : JMeq v w), JMeq (cons A a m v) (cons A a m w)"
                ],
                "tactic_res": [
                    "c4_goal : JMeq (cons A a m v) (cons A a m w)",
                    "c4_v : t A m",
                    "c4_w : t A m",
                    "c4_HJeq : JMeq v w"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c4_goal : JMeq (cons A a m v) (cons A a m w)",
                    "c4_HJeq : JMeq v w"
                ],
                "tactic_res": [
                    "c5_goal : JMeq (cons A a m w) (cons A a m w)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : JMeq (cons A a m w) (cons A a m w)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "vect_to_list_and_back",
        "proof": [
            {
                "tactic_sig": "Theorem vect_to_list_and_back : forall n ( v : t A n ) , JMeq v ( list_to_vector ( vector_to_list n v ) ) .",
                "tactic_sig_no_out_arg": "Theorem vect_to_list_and_back : forall n ( v : t A n ) , JMeq v ( list_to_vector ( vector_to_list n v ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (v : t A n),\nJMeq v (list_to_vector (vector_to_list n v))",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n v .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (v : t A n),\nJMeq v (list_to_vector (vector_to_list n v))"
                ],
                "tactic_res": [
                    "c2_goal : JMeq v (list_to_vector (vector_to_list n v))",
                    "c2_n : nat",
                    "c2_v : t A n"
                ]
            },
            {
                "tactic_sig": "induction _i as [ | h _i _i IHv ] .",
                "tactic_sig_no_out_arg": "induction _i as [ | h _i _i IHv ] .",
                "tactic_args": [
                    "c2_goal : JMeq v (list_to_vector (vector_to_list n v))",
                    "c2_v : t A n",
                    "c2_n : nat",
                    "c2_v : t A n"
                ],
                "tactic_res": [
                    "c3_goal : JMeq (nil A) (list_to_vector (vector_to_list 0 (nil A)))",
                    "c4_goal : JMeq (cons A h n v)\n  (list_to_vector (vector_to_list (S n) (cons A h n v)))",
                    "c4_IHv : JMeq v (list_to_vector (vector_to_list n v))",
                    "c4_h : A"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c3_goal : JMeq (nil A) (list_to_vector (vector_to_list 0 (nil A)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : JMeq (cons A h n v)\n  (list_to_vector (vector_to_list (S n) (cons A h n v)))"
                ],
                "tactic_res": [
                    "c5_goal : JMeq (cons A h n v)\n  (cons A h (length (vector_to_list n v))\n     (list_to_vector (vector_to_list n v)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : JMeq (cons A h n v)\n  (cons A h (length (vector_to_list n v))\n     (list_to_vector (vector_to_list n v)))",
                    "_global_Vconseq : forall (a : A) (n m : nat) (_ : eq n m) (v : t A n) \n         (w : t A m) (_ : JMeq v w), JMeq (cons A a n v) (cons A a m w)"
                ],
                "tactic_res": [
                    "c6_goal : eq n (length (vector_to_list n v))",
                    "c7_goal : JMeq v (list_to_vector (vector_to_list n v))"
                ]
            },
            {
                "tactic_sig": "now rewrite keep_length .",
                "tactic_sig_no_out_arg": "now rewrite keep_length .",
                "tactic_args": [
                    "c6_goal : eq n (length (vector_to_list n v))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c7_goal : JMeq v (list_to_vector (vector_to_list n v))",
                    "c4_IHv : JMeq v (list_to_vector (vector_to_list n v))",
                    "c2_v : t A n",
                    "c2_n : nat",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "structured_intro_example1",
        "proof": [
            {
                "tactic_sig": "Theorem structured_intro_example1 : forall A B C : Prop , A /\\ B /\\ C -> A .",
                "tactic_sig_no_out_arg": "Theorem structured_intro_example1 : forall A B C : Prop , A /\\ B /\\ C -> A .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A B C : Prop) (_ : and A (and B C)), A"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros A B C [ Ha [ Hb Hc ] ] .",
                "tactic_args": [
                    "c1_goal : forall (A B C : Prop) (_ : and A (and B C)), A"
                ],
                "tactic_res": [
                    "c2_goal : A",
                    "c2_A : Prop",
                    "c2_B : Prop",
                    "c2_C : Prop",
                    "c2_Ha : A",
                    "c2_Hb : B",
                    "c2_Hc : C"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c2_goal : A",
                    "c2_Ha : A",
                    "c2_A : Prop"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "structured_intro_example2",
        "proof": [
            {
                "tactic_sig": "Theorem structured_intro_example2 : forall A B : Prop , A \\/ B /\\ ( B -> A ) -> A .",
                "tactic_sig_no_out_arg": "Theorem structured_intro_example2 : forall A B : Prop , A \\/ B /\\ ( B -> A ) -> A .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A B : Prop) (_ : or A (and B (forall _ : B, A))), A"
                ]
            },
            {
                "tactic_sig": "intros _o _o [ _o | [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros A B [ Ha | [ Hb Hi ] ] .",
                "tactic_args": [
                    "c1_goal : forall (A B : Prop) (_ : or A (and B (forall _ : B, A))), A"
                ],
                "tactic_res": [
                    "c2_goal : A",
                    "c3_A : Prop",
                    "c3_B : Prop",
                    "c3_Hb : B",
                    "c3_Hi : forall _ : B, A",
                    "c3_goal : A",
                    "c2_A : Prop",
                    "c2_B : Prop",
                    "c2_Ha : A"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c2_goal : A",
                    "c2_Ha : A",
                    "c2_A : Prop"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now apply _i .",
                "tactic_sig_no_out_arg": "now apply _i .",
                "tactic_args": [
                    "c3_goal : A",
                    "c3_Hi : forall _ : B, A"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sum_even",
        "proof": [
            {
                "tactic_sig": "Theorem sum_even : forall n p : nat , even n -> even p -> even ( n + p ) .",
                "tactic_sig_no_out_arg": "Theorem sum_even : forall n p : nat , even n -> even p -> even ( n + p ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n p : nat) (_ : even n) (_ : even p), even (Init.Nat.add n p)"
                ]
            },
            {
                "tactic_sig": "intros _o _o Heven_n .",
                "tactic_sig_no_out_arg": "intros n p Heven_n .",
                "tactic_args": [
                    "c1_goal : forall (n p : nat) (_ : even n) (_ : even p), even (Init.Nat.add n p)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : even p, even (Init.Nat.add n p)",
                    "c2_n : nat",
                    "c2_p : nat",
                    "c2_Heven_n : even n"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : forall _ : even p, even (Init.Nat.add n p)",
                    "c2_Heven_n : even n"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : even p, even (Init.Nat.add 0 p)",
                    "c4_goal : forall _ : even p, even (Init.Nat.add (S (S n)) p)",
                    "c4_IHHeven_n : forall _ : even p, even (Init.Nat.add n p)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c3_goal : forall _ : even p, even (Init.Nat.add 0 p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H0 .",
                "tactic_args": [
                    "c4_goal : forall _ : even p, even (Init.Nat.add (S (S n)) p)"
                ],
                "tactic_res": [
                    "c5_goal : even (Init.Nat.add (S (S n)) p)",
                    "c5_H0 : even p"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : even (Init.Nat.add (S (S n)) p)"
                ],
                "tactic_res": [
                    "c6_goal : even (S (S (Init.Nat.add n p)))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : even (S (S (Init.Nat.add n p)))"
                ],
                "tactic_res": [
                    "c7_goal : even (Init.Nat.add n p)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : even (Init.Nat.add n p)",
                    "c5_H0 : even p",
                    "c4_IHHeven_n : forall _ : even p, even (Init.Nat.add n p)",
                    "c2_p : nat",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lt_le",
        "proof": [
            {
                "tactic_sig": "Theorem lt_le : forall n p : nat , n < p -> n <= p .",
                "tactic_sig_no_out_arg": "Theorem lt_le : forall n p : nat , n < p -> n <= p .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n p : nat) (_ : lt n p), le n p"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n p H .",
                "tactic_args": [
                    "c1_goal : forall (n p : nat) (_ : lt n p), le n p"
                ],
                "tactic_res": [
                    "c2_goal : le n p",
                    "c2_n : nat",
                    "c2_p : nat",
                    "c2_H : lt n p"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : le n p",
                    "c2_H : lt n p"
                ],
                "tactic_res": [
                    "c3_goal : le n (S n)",
                    "c4_goal : le n (S m)",
                    "c4_IHle : le n m",
                    "c4_H : le (S n) m",
                    "c4_m : nat"
                ]
            },
            {
                "tactic_sig": "repeat constructor .",
                "tactic_sig_no_out_arg": "repeat constructor .",
                "tactic_args": [
                    "c3_goal : le n (S n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat constructor .",
                "tactic_sig_no_out_arg": "repeat constructor .",
                "tactic_args": [
                    "c4_goal : le n (S m)"
                ],
                "tactic_res": [
                    "c5_goal : le n m"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c5_goal : le n m",
                    "c4_IHle : le n m",
                    "c2_n : nat",
                    "c4_m : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "pfact3",
        "proof": [
            {
                "tactic_sig": "Theorem pfact3 : Pfact 3 6 .",
                "tactic_sig_no_out_arg": "Theorem pfact3 : Pfact 3 6 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : Pfact 3 6"
                ]
            },
            {
                "tactic_sig": "apply _i with ( n := 3 ) ( v := 2 ) .",
                "tactic_sig_no_out_arg": "apply _i with ( n := 3 ) ( v := 2 ) .",
                "tactic_args": [
                    "c1_goal : Pfact 3 6",
                    "_global_Pfact1 : forall (n v : Z) (_ : not (eq n 0)) (_ : Pfact (Z.sub n 1) v),\n       Pfact n (Z.mul n v)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq 3 0)",
                    "c3_goal : Pfact (Z.sub 3 1) 2"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c2_goal : not (eq 3 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply ( _i 2 1 ) .",
                "tactic_sig_no_out_arg": "apply ( _i 2 1 ) .",
                "tactic_args": [
                    "c3_goal : Pfact (Z.sub 3 1) 2",
                    "_global_Pfact1 : forall (n v : Z) (_ : not (eq n 0)) (_ : Pfact (Z.sub n 1) v),\n       Pfact n (Z.mul n v)"
                ],
                "tactic_res": [
                    "c4_goal : not (eq 2 0)",
                    "c5_goal : Pfact (Z.sub 2 1) 1"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c4_goal : not (eq 2 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply ( _i 1 1 ) .",
                "tactic_sig_no_out_arg": "apply ( _i 1 1 ) .",
                "tactic_args": [
                    "c5_goal : Pfact (Z.sub 2 1) 1",
                    "_global_Pfact1 : forall (n v : Z) (_ : not (eq n 0)) (_ : Pfact (Z.sub n 1) v),\n       Pfact n (Z.mul n v)"
                ],
                "tactic_res": [
                    "c6_goal : not (eq 1 0)",
                    "c7_goal : Pfact (Z.sub 1 1) 1"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : not (eq 1 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Pfact (Z.sub 1 1) 1",
                    "_global_Pfact0 : Pfact 0 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fact_def_pos",
        "proof": [
            {
                "tactic_sig": "Theorem fact_def_pos : forall x y : Z , Pfact x y -> 0 <= x .",
                "tactic_sig_no_out_arg": "Theorem fact_def_pos : forall x y : Z , Pfact x y -> 0 <= x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : Z) (_ : Pfact x y), Z.le 0 x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y H .",
                "tactic_args": [
                    "c1_goal : forall (x y : Z) (_ : Pfact x y), Z.le 0 x"
                ],
                "tactic_res": [
                    "c2_goal : Z.le 0 x",
                    "c2_x : Z",
                    "c2_y : Z",
                    "c2_H : Pfact x y"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c2_goal : Z.le 0 x",
                    "c2_H : Pfact x y"
                ],
                "tactic_res": [
                    "c3_goal : Z.le 0 0",
                    "c4_goal : Z.le 0 n",
                    "c4_IHPfact : Z.le 0 (Z.sub n 1)",
                    "c4_H0 : Pfact (Z.sub n 1) v",
                    "c4_H : not (eq n 0)",
                    "c4_v : Z",
                    "c4_n : Z"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c3_goal : Z.le 0 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c4_goal : Z.le 0 n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Zle_Pfact",
        "proof": [
            {
                "tactic_sig": "Theorem Zle_Pfact : forall x : Z , 0 <= x -> exists y : Z , Pfact x y .",
                "tactic_sig_no_out_arg": "Theorem Zle_Pfact : forall x : Z , 0 <= x -> exists y : Z , Pfact x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : Z) (_ : Z.le 0 x), ex (fun y : Z => Pfact x y)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros x .",
                "tactic_args": [
                    "c1_goal : forall (x : Z) (_ : Z.le 0 x), ex (fun y : Z => Pfact x y)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : Z.le 0 x, ex (fun y : Z => Pfact x y)",
                    "c2_x : Z"
                ]
            },
            {
                "tactic_sig": "induction _i using ( well_founded_ind ( Zwf_well_founded 0 ) ) .",
                "tactic_sig_no_out_arg": "induction _i using ( well_founded_ind ( Zwf_well_founded 0 ) ) .",
                "tactic_args": [
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c2_H : forall (y : Z) (_ : Zwf 0 y x) (_ : Z.le 0 y),\nex (fun y0 : Z => Pfact y y0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Hle .",
                "tactic_args": [
                    "c2_goal : forall _ : Z.le 0 x, ex (fun y : Z => Pfact x y)"
                ],
                "tactic_res": [
                    "c3_goal : ex (fun y : Z => Pfact x y)",
                    "c3_Hle : Z.le 0 x"
                ]
            },
            {
                "tactic_sig": "destruct ( Zle_lt_or_eq _ _ _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Zle_lt_or_eq _ _ _i ) .",
                "tactic_args": [
                    "c3_goal : ex (fun y : Z => Pfact x y)",
                    "c3_Hle : Z.le 0 x",
                    "c2_H : forall (y : Z) (_ : Zwf 0 y x) (_ : Z.le 0 y),\nex (fun y0 : Z => Pfact y y0)",
                    "c2_x : Z"
                ],
                "tactic_res": [
                    "c4_goal : ex (fun y : Z => Pfact x y)",
                    "c4_H0 : Z.lt 0 x",
                    "c5_goal : ex (fun y : Z => Pfact x y)",
                    "c5_H0 : eq 0 x"
                ]
            },
            {
                "tactic_sig": "destruct ( _i ( _i - 1 ) ) as [  | | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i ( _i - 1 ) ) .",
                "tactic_args": [
                    "c4_goal : ex (fun y : Z => Pfact x y)",
                    "c2_H : forall (y : Z) (_ : Zwf 0 y x) (_ : Z.le 0 y),\nex (fun y0 : Z => Pfact y y0)",
                    "c2_x : Z",
                    "c4_H0 : Z.lt 0 x",
                    "c3_Hle : Z.le 0 x"
                ],
                "tactic_res": [
                    "c6_goal : Zwf 0 (Z.sub x 1) x",
                    "c7_goal : Z.le 0 (Z.sub x 1)",
                    "c8_goal : ex (fun y : Z => Pfact x y)",
                    "c8_H1 : Pfact (Z.sub x 1) x0",
                    "c8_x0 : Z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c6_goal : Zwf 0 (Z.sub x 1) x",
                    "_global_Zwf : forall (_ : Z) (_ : Z) (_ : Z), Prop"
                ],
                "tactic_res": [
                    "c9_goal : and (Z.le 0 x) (Z.lt (Z.sub x 1) x)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c9_goal : and (Z.le 0 x) (Z.lt (Z.sub x 1) x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c7_goal : Z.le 0 (Z.sub x 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( _i * _i ) .",
                "tactic_sig_no_out_arg": "exists ( _i * _i ) .",
                "tactic_args": [
                    "c8_goal : ex (fun y : Z => Pfact x y)",
                    "c2_x : Z",
                    "c8_x0 : Z"
                ],
                "tactic_res": [
                    "c10_goal : Pfact x (Z.mul x x0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Pfact x (Z.mul x x0)",
                    "_global_Pfact1 : forall (n v : Z) (_ : not (eq n 0)) (_ : Pfact (Z.sub n 1) v),\n       Pfact n (Z.mul n v)"
                ],
                "tactic_res": [
                    "c11_goal : not (eq x 0)",
                    "c12_goal : Pfact (Z.sub x 1) x0"
                ]
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c11_goal : not (eq x 0)",
                    "c4_H0 : Z.lt 0 x",
                    "c2_x : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with zarith .",
                "tactic_sig_no_out_arg": "auto with zarith .",
                "tactic_args": [
                    "c12_goal : Pfact (Z.sub x 1) x0",
                    "c8_H1 : Pfact (Z.sub x 1) x0",
                    "c8_x0 : Z",
                    "c2_x : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c5_goal : ex (fun y : Z => Pfact x y)",
                    "c2_x : Z",
                    "c5_H0 : eq 0 x"
                ],
                "tactic_res": [
                    "c13_goal : ex (fun y : Z => Pfact 0 y)",
                    "c13_H : forall (y : Z) (_ : Zwf 0 y 0) (_ : Z.le 0 y),\nex (fun y0 : Z => Pfact y y0)",
                    "c13_Hle : Z.le 0 0"
                ]
            },
            {
                "tactic_sig": "exists 1 .",
                "tactic_sig_no_out_arg": "exists 1 .",
                "tactic_args": [
                    "c13_goal : ex (fun y : Z => Pfact 0 y)"
                ],
                "tactic_res": [
                    "c14_goal : Pfact 0 1"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c14_goal : Pfact 0 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "HoareWhileRule",
        "proof": [
            {
                "tactic_sig": "Theorem HoareWhileRule : forall ( P : state -> Prop ) ( b : bExp ) ( i : inst ) ( s s' : state ) , ( forall s1 s2 : state , P s1 -> evalB s1 b = Some true -> exec s1 i s2 -> P s2 ) -> P s -> exec s ( WhileDo b i ) s' -> P s' /\\ evalB s' b = Some false .",
                "tactic_sig_no_out_arg": "Theorem HoareWhileRule : forall ( P : state -> Prop ) ( b : bExp ) ( i : inst ) ( s s' : state ) , ( forall s1 s2 : state , P s1 -> evalB s1 b = Some true -> exec s1 i s2 -> P s2 ) -> P s -> exec s ( WhileDo b i ) s' -> P s' /\\ evalB s' b = Some false .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (P : forall _ : state, Prop) (b : bExp) (i : inst)\n  (s s' : state)\n  (_ : forall (s1 s2 : state) (_ : P s1)\n         (_ : eq (evalB s1 b) (Some true)) (_ : exec s1 i s2), \n       P s2) (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c1_evalB : forall (_ : state) (_ : bExp), option bool",
                    "c1_evalA : forall (_ : state) (_ : aExp), option Z",
                    "c1_update : forall (_ : state) (_ : Var) (_ : Z), option state",
                    "c1_state : Set",
                    "c1_bExp : Set",
                    "c1_aExp : Set",
                    "c1_Var : Set"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros P b i s s' H .",
                "tactic_args": [
                    "c1_goal : forall (P : forall _ : state, Prop) (b : bExp) (i : inst)\n  (s s' : state)\n  (_ : forall (s1 s2 : state) (_ : P s1)\n         (_ : eq (evalB s1 b) (Some true)) (_ : exec s1 i s2), \n       P s2) (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))"
                ],
                "tactic_res": [
                    "c2_goal : forall (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c2_P : forall _ : state, Prop",
                    "c2_b : bExp",
                    "c2_i : inst",
                    "c2_s : state",
                    "c2_s' : state",
                    "c2_H : forall (s1 s2 : state) (_ : P s1) (_ : eq (evalB s1 b) (Some true))\n  (_ : exec s1 i s2), P s2"
                ]
            },
            {
                "tactic_sig": "cut ( forall i' : inst , exec _i i' _i -> i' = WhileDo _i _i -> _i _i -> _i _i /\\ _i _i _i = Some false ) .",
                "tactic_sig_no_out_arg": "cut ( forall i' : inst , exec _i i' _i -> i' = WhileDo _i _i -> _i _i -> _i _i /\\ _i _i _i = Some false ) .",
                "tactic_args": [
                    "c2_goal : forall (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c2_s : state",
                    "c2_s' : state",
                    "c2_b : bExp",
                    "c2_i : inst",
                    "c2_P : forall _ : state, Prop",
                    "c2_s : state",
                    "c2_P : forall _ : state, Prop",
                    "c2_s' : state",
                    "c1_evalB : forall (_ : state) (_ : bExp), option bool",
                    "c2_s' : state",
                    "c2_b : bExp"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : forall (i' : inst) (_ : exec s i' s') (_ : eq i' (WhileDo b i))\n         (_ : P s), and (P s') (eq (evalB s' b) (Some false)))\n  (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c4_goal : forall (i' : inst) (_ : exec s i' s') (_ : eq i' (WhileDo b i))\n  (_ : P s), and (P s') (eq (evalB s' b) (Some false))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : forall (i' : inst) (_ : exec s i' s') (_ : eq i' (WhileDo b i))\n         (_ : P s), and (P s') (eq (evalB s' b) (Some false)))\n  (_ : P s) (_ : exec s (WhileDo b i) s'),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c2_s : state",
                    "c2_s' : state",
                    "c2_i : inst",
                    "c2_b : bExp",
                    "c2_P : forall _ : state, Prop",
                    "c1_evalB : forall (_ : state) (_ : bExp), option bool",
                    "c1_evalA : forall (_ : state) (_ : aExp), option Z",
                    "c1_update : forall (_ : state) (_ : Var) (_ : Z), option state",
                    "c1_Var : Set",
                    "c1_aExp : Set",
                    "c1_bExp : Set",
                    "c1_state : Set"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros i' Hexec .",
                "tactic_args": [
                    "c4_goal : forall (i' : inst) (_ : exec s i' s') (_ : eq i' (WhileDo b i))\n  (_ : P s), and (P s') (eq (evalB s' b) (Some false))"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : eq i' (WhileDo b i)) (_ : P s),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c5_i' : inst",
                    "c5_Hexec : exec s i' s'"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c5_goal : forall (_ : eq i' (WhileDo b i)) (_ : P s),\nand (P s') (eq (evalB s' b) (Some false))",
                    "c5_Hexec : exec s i' s'"
                ],
                "tactic_res": [
                    "c6_goal : forall (s : state) (_ : eq Skip (WhileDo b i)) (_ : P s),\nand (P s) (eq (evalB s b) (Some false))",
                    "c7_goal : forall (s s1 : state) (v : Var) (n : Z) (a : aExp)\n  (_ : eq (evalA s a) (Some n)) (_ : eq (update s v n) (Some s1))\n  (_ : eq (Assign v a) (WhileDo b i)) (_ : P s),\nand (P s1) (eq (evalB s1 b) (Some false))",
                    "c8_goal : forall (s s1 s2 : state) (i1 i2 : inst) (_ : exec s i1 s1)\n  (_ : forall (_ : eq i1 (WhileDo b i)) (_ : P s),\n       and (P s1) (eq (evalB s1 b) (Some false))) \n  (_ : exec s1 i2 s2)\n  (_ : forall (_ : eq i2 (WhileDo b i)) (_ : P s1),\n       and (P s2) (eq (evalB s2 b) (Some false)))\n  (_ : eq (Sequence i1 i2) (WhileDo b i)) (_ : P s),\nand (P s2) (eq (evalB s2 b) (Some false))",
                    "c9_goal : forall (s : state) (i0 : inst) (e : bExp)\n  (_ : eq (evalB s e) (Some false))\n  (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s),\nand (P s) (eq (evalB s b) (Some false))",
                    "c10_goal : forall (s s1 s2 : state) (i0 : inst) (e : bExp)\n  (_ : eq (evalB s e) (Some true)) (_ : exec s i0 s1)\n  (_ : forall (_ : eq i0 (WhileDo b i)) (_ : P s),\n       and (P s1) (eq (evalB s1 b) (Some false)))\n  (_ : exec s1 (WhileDo e i0) s2)\n  (_ : forall (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s1),\n       and (P s2) (eq (evalB s2 b) (Some false)))\n  (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s),\nand (P s2) (eq (evalB s2 b) (Some false))"
                ]
            },
            {
                "tactic_sig": "try ( intros ; discriminate ) .",
                "tactic_sig_no_out_arg": "try ( intros ; discriminate ) .",
                "tactic_args": [
                    "c6_goal : forall (s : state) (_ : eq Skip (WhileDo b i)) (_ : P s),\nand (P s) (eq (evalB s b) (Some false))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( intros ; discriminate ) .",
                "tactic_sig_no_out_arg": "try ( intros ; discriminate ) .",
                "tactic_args": [
                    "c7_goal : forall (s s1 : state) (v : Var) (n : Z) (a : aExp)\n  (_ : eq (evalA s a) (Some n)) (_ : eq (update s v n) (Some s1))\n  (_ : eq (Assign v a) (WhileDo b i)) (_ : P s),\nand (P s1) (eq (evalB s1 b) (Some false))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( intros ; discriminate ) .",
                "tactic_sig_no_out_arg": "try ( intros ; discriminate ) .",
                "tactic_args": [
                    "c8_goal : forall (s s1 s2 : state) (i1 i2 : inst) (_ : exec s i1 s1)\n  (_ : forall (_ : eq i1 (WhileDo b i)) (_ : P s),\n       and (P s1) (eq (evalB s1 b) (Some false))) \n  (_ : exec s1 i2 s2)\n  (_ : forall (_ : eq i2 (WhileDo b i)) (_ : P s1),\n       and (P s2) (eq (evalB s2 b) (Some false)))\n  (_ : eq (Sequence i1 i2) (WhileDo b i)) (_ : P s),\nand (P s2) (eq (evalB s2 b) (Some false))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros s0 i0 e Heval Heq .",
                "tactic_args": [
                    "c9_goal : forall (s : state) (i0 : inst) (e : bExp)\n  (_ : eq (evalB s e) (Some false))\n  (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s),\nand (P s) (eq (evalB s b) (Some false))"
                ],
                "tactic_res": [
                    "c11_goal : forall _ : P s0, and (P s0) (eq (evalB s0 b) (Some false))",
                    "c11_s0 : state",
                    "c11_i0 : inst",
                    "c11_e : bExp",
                    "c11_Heval : eq (evalB s0 e) (Some false)",
                    "c11_Heq : eq (WhileDo e i0) (WhileDo b i)"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c11_goal : forall _ : P s0, and (P s0) (eq (evalB s0 b) (Some false))",
                    "c11_Heq : eq (WhileDo e i0) (WhileDo b i)"
                ],
                "tactic_res": [
                    "c12_goal : forall (_ : eq i0 i) (_ : eq e b) (_ : P s0),\nand (P s0) (eq (evalB s0 b) (Some false))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H1 H2 .",
                "tactic_args": [
                    "c12_goal : forall (_ : eq i0 i) (_ : eq e b) (_ : P s0),\nand (P s0) (eq (evalB s0 b) (Some false))"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : P s0, and (P s0) (eq (evalB s0 b) (Some false))",
                    "c13_H1 : eq i0 i",
                    "c13_H2 : eq e b"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c13_goal : forall _ : P s0, and (P s0) (eq (evalB s0 b) (Some false))",
                    "c13_H2 : eq e b"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : P s0, and (P s0) (eq (evalB s0 e) (Some false))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall _ : P s0, and (P s0) (eq (evalB s0 e) (Some false))",
                    "c11_Heval : eq (evalB s0 e) (Some false)",
                    "c11_e : bExp",
                    "c11_s0 : state",
                    "c2_P : forall _ : state, Prop",
                    "c1_evalB : forall (_ : state) (_ : bExp), option bool",
                    "c1_evalA : forall (_ : state) (_ : aExp), option Z",
                    "c1_update : forall (_ : state) (_ : Var) (_ : Z), option state"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall (s s1 s2 : state) (i0 : inst) (e : bExp)\n  (_ : eq (evalB s e) (Some true)) (_ : exec s i0 s1)\n  (_ : forall (_ : eq i0 (WhileDo b i)) (_ : P s),\n       and (P s1) (eq (evalB s1 b) (Some false)))\n  (_ : exec s1 (WhileDo e i0) s2)\n  (_ : forall (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s1),\n       and (P s2) (eq (evalB s2 b) (Some false)))\n  (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s),\nand (P s2) (eq (evalB s2 b) (Some false))"
                ],
                "tactic_res": [
                    "c15_goal : and (P s2) (eq (evalB s2 b) (Some false))",
                    "c15_s0 : state",
                    "c15_s1 : state",
                    "c15_s2 : state",
                    "c15_i0 : inst",
                    "c15_e : bExp",
                    "c15_H0 : eq (evalB s0 e) (Some true)",
                    "c15_H1 : exec s0 i0 s1",
                    "c15_H2 : forall (_ : eq i0 (WhileDo b i)) (_ : P s0),\nand (P s1) (eq (evalB s1 b) (Some false))",
                    "c15_H3 : exec s1 (WhileDo e i0) s2",
                    "c15_H4 : forall (_ : eq (WhileDo e i0) (WhileDo b i)) (_ : P s1),\nand (P s2) (eq (evalB s2 b) (Some false))",
                    "c15_H5 : eq (WhileDo e i0) (WhileDo b i)",
                    "c15_H6 : P s0"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c15_goal : and (P s2) (eq (evalB s2 b) (Some false))",
                    "c15_H5 : eq (WhileDo e i0) (WhileDo b i)"
                ],
                "tactic_res": [
                    "c16_goal : forall (_ : eq i0 i) (_ : eq e b),\nand (P s2) (eq (evalB s2 b) (Some false))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H' H'' .",
                "tactic_args": [
                    "c16_goal : forall (_ : eq i0 i) (_ : eq e b),\nand (P s2) (eq (evalB s2 b) (Some false))"
                ],
                "tactic_res": [
                    "c17_goal : and (P s2) (eq (evalB s2 b) (Some false))",
                    "c17_H' : eq i0 i",
                    "c17_H'' : eq e b"
                ]
            },
            {
                "tactic_sig": "subst _i _i .",
                "tactic_sig_no_out_arg": "subst _i _i .",
                "tactic_args": [
                    "c17_goal : and (P s2) (eq (evalB s2 b) (Some false))",
                    "c15_i0 : inst",
                    "c2_b : bExp",
                    "c17_H'' : eq e b",
                    "c17_H' : eq i0 i"
                ],
                "tactic_res": [
                    "c18_goal : and (P s2) (eq (evalB s2 e) (Some false))",
                    "c18_H1 : exec s0 i s1",
                    "c18_H2 : forall (_ : eq i (WhileDo e i)) (_ : P s0),\nand (P s1) (eq (evalB s1 e) (Some false))",
                    "c18_H3 : exec s1 (WhileDo e i) s2",
                    "c18_H5 : eq (WhileDo e i) (WhileDo e i)",
                    "c18_H4 : forall (_ : eq (WhileDo e i) (WhileDo e i)) (_ : P s1),\nand (P s2) (eq (evalB s2 e) (Some false))",
                    "c18_H : forall (s1 s2 : state) (_ : P s1) (_ : eq (evalB s1 e) (Some true))\n  (_ : exec s1 i s2), P s2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : and (P s2) (eq (evalB s2 e) (Some false))",
                    "c15_H6 : P s0",
                    "c18_H1 : exec s0 i s1",
                    "c18_H4 : forall (_ : eq (WhileDo e i) (WhileDo e i)) (_ : P s1),\nand (P s2) (eq (evalB s2 e) (Some false))",
                    "c15_H0 : eq (evalB s0 e) (Some true)",
                    "c15_s2 : state",
                    "c18_H : forall (s1 s2 : state) (_ : P s1) (_ : eq (evalB s1 e) (Some true))\n  (_ : exec s1 i s2), P s2",
                    "c15_e : bExp",
                    "c2_P : forall _ : state, Prop",
                    "c1_evalB : forall (_ : state) (_ : bExp), option bool",
                    "c1_evalA : forall (_ : state) (_ : aExp), option Z",
                    "c1_update : forall (_ : state) (_ : Var) (_ : Z), option state"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sqr_01",
        "proof": [
            {
                "tactic_sig": "Lemma sqr_01 : forall x : nat , is_0_1 x -> is_0_1 ( x * x ) .",
                "tactic_sig_no_out_arg": "Lemma sqr_01 : forall x : nat , is_0_1 x -> is_0_1 ( x * x ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x : nat) (_ : is_0_1 x), is_0_1 (Init.Nat.mul x x)"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (x : nat) (_ : is_0_1 x), is_0_1 (Init.Nat.mul x x)"
                ],
                "tactic_res": [
                    "c2_goal : is_0_1 (Init.Nat.mul 0 0)",
                    "c3_goal : is_0_1 (Init.Nat.mul 1 1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : is_0_1 (Init.Nat.mul 0 0)"
                ],
                "tactic_res": [
                    "c4_goal : is_0_1 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : is_0_1 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : is_0_1 (Init.Nat.mul 1 1)"
                ],
                "tactic_res": [
                    "c5_goal : is_0_1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : is_0_1 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "elim_example",
        "proof": [
            {
                "tactic_sig": "Theorem elim_example : forall n : nat , n <= 1 -> n * n <= 1 .",
                "tactic_sig_no_out_arg": "Theorem elim_example : forall n : nat , n <= 1 -> n * n <= 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : le n 1), le (Init.Nat.mul n n) 1"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : le n 1), le (Init.Nat.mul n n) 1"
                ],
                "tactic_res": [
                    "c2_goal : le (Init.Nat.mul n n) 1",
                    "c2_n : nat",
                    "c2_H : le n 1"
                ]
            },
            {
                "tactic_sig": "destruct ( sqr_01 _i ) as [  | | ] .",
                "tactic_sig_no_out_arg": "destruct ( sqr_01 _i ) .",
                "tactic_args": [
                    "c2_goal : le (Init.Nat.mul n n) 1",
                    "c2_n : nat",
                    "c2_H : le n 1"
                ],
                "tactic_res": [
                    "c3_goal : is_0_1 n",
                    "c4_goal : le 0 1",
                    "c5_goal : le 1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : le 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inversion_clear _i .",
                "tactic_sig_no_out_arg": "inversion_clear _i .",
                "tactic_args": [
                    "c3_goal : is_0_1 n",
                    "c2_H : le n 1"
                ],
                "tactic_res": [
                    "c6_goal : is_0_1 1",
                    "c7_goal : is_0_1 n",
                    "c7_H0 : le n 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : is_0_1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inversion_clear _i .",
                "tactic_sig_no_out_arg": "inversion_clear _i .",
                "tactic_args": [
                    "c7_goal : is_0_1 n",
                    "c7_H0 : le n 0"
                ],
                "tactic_res": [
                    "c8_goal : is_0_1 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : is_0_1 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "not_even_1",
        "proof": [
            {
                "tactic_sig": "Theorem not_even_1 : ~ even 1 .",
                "tactic_sig_no_out_arg": "Theorem not_even_1 : ~ even 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : not (even 1)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : not (even 1)",
                    "_global_not : forall _ : Prop, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : even 1, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H .",
                "tactic_args": [
                    "c2_goal : forall _ : even 1, False"
                ],
                "tactic_res": [
                    "c3_goal : False",
                    "c3_H : even 1"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c3_goal : False",
                    "c3_H : even 1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus_2_even_inv",
        "proof": [
            {
                "tactic_sig": "Theorem plus_2_even_inv : forall n : nat , even ( S ( S n ) ) -> even n .",
                "tactic_sig_no_out_arg": "Theorem plus_2_even_inv : forall n : nat , even ( S ( S n ) ) -> even n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : even (S (S n))), even n"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : even (S (S n))), even n"
                ],
                "tactic_res": [
                    "c2_goal : even n",
                    "c2_n : nat",
                    "c2_H : even (S (S n))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_H : even (S (S n))"
                ],
                "tactic_res": [
                    "c2_H0 : eq n0 n",
                    "c2_H1 : even n",
                    "c2_n0 : nat"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c2_goal : even n",
                    "c2_H1 : even n",
                    "c2_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "not_even_1'",
        "proof": [
            {
                "tactic_sig": "Theorem not_even_1' : ~ even 1 .",
                "tactic_sig_no_out_arg": "Theorem not_even_1' : ~ even 1 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : not (even 1)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro H .",
                "tactic_args": [
                    "c1_goal : not (even 1)"
                ],
                "tactic_res": [
                    "c2_goal : False",
                    "c2_H : even 1"
                ]
            },
            {
                "tactic_sig": "generalize ( refl_equal 1 ) .",
                "tactic_sig_no_out_arg": "generalize ( refl_equal 1 ) .",
                "tactic_args": [
                    "c2_goal : False"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq 1 1, False"
                ]
            },
            {
                "tactic_sig": "pattern 1 at - 2 .",
                "tactic_sig_no_out_arg": "pattern 1 at - 2 .",
                "tactic_args": [
                    "c3_goal : forall _ : eq 1 1, False"
                ],
                "tactic_res": [
                    "c4_goal : (fun n : nat => forall _ : eq n 1, False) 1"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c4_goal : (fun n : nat => forall _ : eq n 1, False) 1",
                    "c2_H : even 1"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq 0 1, False",
                    "c6_goal : forall _ : eq (S (S n)) 1, False",
                    "c6_IHeven : forall _ : eq n 1, False",
                    "c6_H : even n",
                    "c6_n : nat"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : forall _ : eq 0 1, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : forall _ : eq (S (S n)) 1, False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "plus_2_even_inv'",
        "proof": [
            {
                "tactic_sig": "Theorem plus_2_even_inv' : forall n : nat , even ( S ( S n ) ) -> even n .",
                "tactic_sig_no_out_arg": "Theorem plus_2_even_inv' : forall n : nat , even ( S ( S n ) ) -> even n .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (n : nat) (_ : even (S (S n))), even n"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H .",
                "tactic_args": [
                    "c1_goal : forall (n : nat) (_ : even (S (S n))), even n"
                ],
                "tactic_res": [
                    "c2_goal : even n",
                    "c2_n : nat",
                    "c2_H : even (S (S n))"
                ]
            },
            {
                "tactic_sig": "generalize ( refl_equal ( S ( S _i ) ) ) .",
                "tactic_sig_no_out_arg": "generalize ( refl_equal ( S ( S _i ) ) ) .",
                "tactic_args": [
                    "c2_goal : even n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq (S (S n)) (S (S n)), even n"
                ]
            },
            {
                "tactic_sig": "pattern ( S ( S _i ) ) at - 2 .",
                "tactic_sig_no_out_arg": "pattern ( S ( S _i ) ) at - 2 .",
                "tactic_args": [
                    "c3_goal : forall _ : eq (S (S n)) (S (S n)), even n",
                    "c2_n : nat"
                ],
                "tactic_res": [
                    "c4_goal : (fun n0 : nat => forall _ : eq n0 (S (S n)), even n) (S (S n))"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "c4_goal : (fun n0 : nat => forall _ : eq n0 (S (S n)), even n) (S (S n))",
                    "c2_H : even (S (S n))"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq 0 (S (S n)), even n",
                    "c6_goal : forall _ : eq (S (S n0)) (S (S n)), even n",
                    "c6_IHeven : forall _ : eq n0 (S (S n)), even n",
                    "c6_H : even n0",
                    "c6_n0 : nat"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c5_goal : forall _ : eq 0 (S (S n)), even n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H0 .",
                "tactic_args": [
                    "c6_goal : forall _ : eq (S (S n0)) (S (S n)), even n"
                ],
                "tactic_res": [
                    "c7_goal : even n",
                    "c7_H0 : eq (S (S n0)) (S (S n))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c7_goal : even n",
                    "c7_H0 : eq (S (S n0)) (S (S n))"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq n0 n, even n"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "c8_goal : forall _ : eq n0 n, even n"
                ],
                "tactic_res": [
                    "c9_goal : even n",
                    "c9_H1 : eq n0 n"
                ]
            }
        ]
    },
    {
        "lemma_name": "isorted0",
        "proof": [
            {
                "tactic_sig": "Theorem isorted0 : impredicative_sorted nil .",
                "tactic_sig_no_out_arg": "Theorem isorted0 : impredicative_sorted nil .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : impredicative_sorted Datatypes.nil",
                    "c1_R : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c1_goal : impredicative_sorted Datatypes.nil"
                ],
                "tactic_res": [
                    "c2_goal : forall (P : forall _ : list A, Prop) (_ : P Datatypes.nil)\n  (_ : forall x : A, P (Datatypes.cons x Datatypes.nil))\n  (_ : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n         (_ : P (Datatypes.cons x2 l')),\n       P (Datatypes.cons x1 (Datatypes.cons x2 l'))), \nP Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (P : forall _ : list A, Prop) (_ : P Datatypes.nil)\n  (_ : forall x : A, P (Datatypes.cons x Datatypes.nil))\n  (_ : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n         (_ : P (Datatypes.cons x2 l')),\n       P (Datatypes.cons x1 (Datatypes.cons x2 l'))), \nP Datatypes.nil"
                ],
                "tactic_res": [
                    "c3_goal : P Datatypes.nil",
                    "c3_P : forall _ : list A, Prop",
                    "c3_H : P Datatypes.nil",
                    "c3_H0 : forall x : A, P (Datatypes.cons x Datatypes.nil)",
                    "c3_H1 : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ]
            },
            {
                "tactic_sig": "assumption .",
                "tactic_sig_no_out_arg": "assumption .",
                "tactic_args": [
                    "c3_goal : P Datatypes.nil",
                    "c3_H : P Datatypes.nil",
                    "c3_P : forall _ : list A, Prop",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "isorted1",
        "proof": [
            {
                "tactic_sig": "Theorem isorted1 : forall x : A , impredicative_sorted ( x :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem isorted1 : forall x : A , impredicative_sorted ( x :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : A, impredicative_sorted (Datatypes.cons x Datatypes.nil)",
                    "c1_R : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x : A, impredicative_sorted (Datatypes.cons x Datatypes.nil)",
                    "_global_impredicative_sorted : forall _ : list A, Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x : A) (P : forall _ : list A, Prop) (_ : P Datatypes.nil)\n  (_ : forall x0 : A, P (Datatypes.cons x0 Datatypes.nil))\n  (_ : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n         (_ : P (Datatypes.cons x2 l')),\n       P (Datatypes.cons x1 (Datatypes.cons x2 l'))),\nP (Datatypes.cons x Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : forall (x : A) (P : forall _ : list A, Prop) (_ : P Datatypes.nil)\n  (_ : forall x0 : A, P (Datatypes.cons x0 Datatypes.nil))\n  (_ : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n         (_ : P (Datatypes.cons x2 l')),\n       P (Datatypes.cons x1 (Datatypes.cons x2 l'))),\nP (Datatypes.cons x Datatypes.nil)",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "isorted2",
        "proof": [
            {
                "tactic_sig": "Theorem isorted2 : forall ( x1 x2 : A ) ( l' : list A ) , R x1 x2 -> impredicative_sorted ( x2 :: l' ) -> impredicative_sorted ( x1 :: x2 :: l' ) .",
                "tactic_sig_no_out_arg": "Theorem isorted2 : forall ( x1 x2 : A ) ( l' : list A ) , R x1 x2 -> impredicative_sorted ( x2 :: l' ) -> impredicative_sorted ( x1 :: x2 :: l' ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : impredicative_sorted (Datatypes.cons x2 l')),\nimpredicative_sorted (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c1_R : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x1 x2 l' Hr Hs P Hsn Hs1 Hs2 .",
                "tactic_args": [
                    "c1_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : impredicative_sorted (Datatypes.cons x2 l')),\nimpredicative_sorted (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ],
                "tactic_res": [
                    "c2_goal : P (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c2_x1 : A",
                    "c2_x2 : A",
                    "c2_l' : list A",
                    "c2_Hr : R x1 x2",
                    "c2_Hs : impredicative_sorted (Datatypes.cons x2 l')",
                    "c2_P : forall _ : list A, Prop",
                    "c2_Hsn : P Datatypes.nil",
                    "c2_Hs1 : forall x : A, P (Datatypes.cons x Datatypes.nil)",
                    "c2_Hs2 : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : P (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c2_Hs2 : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ],
                "tactic_res": [
                    "c3_goal : R x1 x2",
                    "c4_goal : P (Datatypes.cons x2 l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : R x1 x2",
                    "c2_Hr : R x1 x2",
                    "c2_x1 : A",
                    "c2_x2 : A",
                    "c1_R : relation A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : P (Datatypes.cons x2 l')",
                    "c2_Hs : impredicative_sorted (Datatypes.cons x2 l')"
                ],
                "tactic_res": [
                    "c5_goal : P Datatypes.nil",
                    "c6_goal : forall x : A, P (Datatypes.cons x Datatypes.nil)",
                    "c7_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : P Datatypes.nil",
                    "c2_Hsn : P Datatypes.nil",
                    "c2_P : forall _ : list A, Prop",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall x : A, P (Datatypes.cons x Datatypes.nil)",
                    "c2_Hs1 : forall x : A, P (Datatypes.cons x Datatypes.nil)",
                    "c2_P : forall _ : list A, Prop",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c2_Hs2 : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : P (Datatypes.cons x2 l')),\nP (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c2_P : forall _ : list A, Prop",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sorted_to_impredicative_sorted",
        "proof": [
            {
                "tactic_sig": "Theorem sorted_to_impredicative_sorted : forall l , sorted_im l -> impredicative_sorted l .",
                "tactic_sig_no_out_arg": "Theorem sorted_to_impredicative_sorted : forall l , sorted_im l -> impredicative_sorted l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (_ : sorted_im l), impredicative_sorted l",
                    "c1_R : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (_ : sorted_im l), impredicative_sorted l"
                ],
                "tactic_res": [
                    "c2_goal : impredicative_sorted Datatypes.nil",
                    "c3_goal : impredicative_sorted (Datatypes.cons x Datatypes.nil)",
                    "c3_x : A",
                    "c4_goal : impredicative_sorted (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c4_IHsorted_im : impredicative_sorted (Datatypes.cons x2 l')",
                    "c4_H0 : sorted_im (Datatypes.cons x2 l')",
                    "c4_H : R x1 x2",
                    "c4_l' : list A",
                    "c4_x2 : A",
                    "c4_x1 : A"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : impredicative_sorted Datatypes.nil",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : impredicative_sorted (Datatypes.cons x Datatypes.nil)",
                    "c3_x : A",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : impredicative_sorted (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c4_IHsorted_im : impredicative_sorted (Datatypes.cons x2 l')",
                    "c4_H : R x1 x2",
                    "c4_l' : list A",
                    "c4_x1 : A",
                    "c4_x2 : A",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "impredicative_sorted_to_sorted",
        "proof": [
            {
                "tactic_sig": "Theorem impredicative_sorted_to_sorted : forall l , impredicative_sorted l -> sorted_im l .",
                "tactic_sig_no_out_arg": "Theorem impredicative_sorted_to_sorted : forall l , impredicative_sorted l -> sorted_im l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list A) (_ : impredicative_sorted l), sorted_im l",
                    "c1_R : relation A",
                    "c1_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list A) (_ : impredicative_sorted l), sorted_im l"
                ],
                "tactic_res": [
                    "c2_goal : sorted_im l",
                    "c2_l : list A",
                    "c2_H : impredicative_sorted l"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : sorted_im l",
                    "c2_H : impredicative_sorted l"
                ],
                "tactic_res": [
                    "c3_goal : sorted_im Datatypes.nil",
                    "c4_goal : forall x : A, sorted_im (Datatypes.cons x Datatypes.nil)",
                    "c5_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : sorted_im (Datatypes.cons x2 l')),\nsorted_im (Datatypes.cons x1 (Datatypes.cons x2 l'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : sorted_im Datatypes.nil",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall x : A, sorted_im (Datatypes.cons x Datatypes.nil)",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (x1 x2 : A) (l' : list A) (_ : R x1 x2)\n  (_ : sorted_im (Datatypes.cons x2 l')),\nsorted_im (Datatypes.cons x1 (Datatypes.cons x2 l'))",
                    "c1_R : relation A",
                    "c1_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_oc",
        "proof": [
            {
                "tactic_sig": "Theorem wp_oc : wp ( open :: close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp_oc : wp ( open :: close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : wp (Datatypes.cons open (Datatypes.cons close Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: nil ++ close :: nil ) ) in | - * .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: nil ++ close :: nil ) ) in | - * .",
                "tactic_args": [
                    "c1_goal : wp (Datatypes.cons open (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": [
                    "c2_goal : wp\n  (Datatypes.cons open\n     (app Datatypes.nil (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : wp\n  (Datatypes.cons open\n     (app Datatypes.nil (Datatypes.cons close Datatypes.nil)))",
                    "_global_wp_encapsulate : forall (l : list par) (_ : wp l),\n       wp (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c3_goal : wp Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp Datatypes.nil",
                    "_global_wp_nil : wp Datatypes.nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_o_head_c",
        "proof": [
            {
                "tactic_sig": "Theorem wp_o_head_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( open :: l1 ++ close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_o_head_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( open :: l1 ++ close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : wp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp l1",
                    "c2_H2 : wp l2"
                ]
            },
            {
                "tactic_sig": "replace ( open :: _i ++ close :: _i ) with ( ( open :: _i ++ close :: nil ) ++ _i ) .",
                "tactic_sig_no_out_arg": "replace ( open :: _i ++ close :: _i ) with ( ( open :: _i ++ close :: nil ) ++ _i ) .",
                "tactic_args": [
                    "c2_goal : wp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp\n  (app\n     (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))\n     l2)",
                    "c4_goal : eq\n  (app\n     (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))\n     l2) (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp\n  (app\n     (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))\n     l2)",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c5_goal : wp (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))",
                    "c6_goal : wp l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : wp (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))",
                    "_global_wp_encapsulate : forall (l : list par) (_ : wp l),\n       wp (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c7_goal : wp l1"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : wp l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat ( simpl in | - * ; rewrite <- app_assoc ) .",
                "tactic_sig_no_out_arg": "repeat ( simpl in | - * ; rewrite <- app_assoc ) .",
                "tactic_args": [
                    "c4_goal : eq\n  (app\n     (Datatypes.cons open (app l1 (Datatypes.cons close Datatypes.nil)))\n     l2) (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (Datatypes.cons open\n     (app l1 (app (Datatypes.cons close Datatypes.nil) l2)))\n  (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c8_goal : eq\n  (Datatypes.cons open\n     (app l1 (app (Datatypes.cons close Datatypes.nil) l2)))\n  (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c9_goal : eq (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n  (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c9_goal : eq (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n  (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_o_tail_c",
        "proof": [
            {
                "tactic_sig": "Theorem wp_o_tail_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( l1 ++ open :: l2 ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp_o_tail_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( l1 ++ open :: l2 ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c2_goal : wp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp l1",
                    "c2_H2 : wp l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : wp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c3_goal : wp l1",
                    "c4_goal : wp (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c3_goal : wp l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now apply wp_encapsulate .",
                "tactic_sig_no_out_arg": "now apply wp_encapsulate .",
                "tactic_args": [
                    "c4_goal : wp (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bin_to_string_wp",
        "proof": [
            {
                "tactic_sig": "Theorem bin_to_string_wp : forall t : bin , wp ( bin_to_string t ) .",
                "tactic_sig_no_out_arg": "Theorem bin_to_string_wp : forall t : bin , wp ( bin_to_string t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t : bin, wp (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "simple induction t .",
                "tactic_sig_no_out_arg": "simple induction t .",
                "tactic_args": [
                    "c1_goal : forall t : bin, wp (bin_to_string t)"
                ],
                "tactic_res": [
                    "c2_goal : wp (bin_to_string L)",
                    "c2_t : bin",
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)), wp (bin_to_string (N b b0))",
                    "c3_t : bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wp (bin_to_string L)"
                ],
                "tactic_res": [
                    "c4_goal : wp Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : wp Datatypes.nil",
                    "_global_wp_nil : wp Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)), wp (bin_to_string (N b b0))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)),\nwp\n  (Datatypes.cons open\n     (app (bin_to_string b) (Datatypes.cons close (bin_to_string b0))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t1 H1 t2 H2 .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)),\nwp\n  (Datatypes.cons open\n     (app (bin_to_string b) (Datatypes.cons close (bin_to_string b0))))"
                ],
                "tactic_res": [
                    "c6_goal : wp\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close (bin_to_string t2))))",
                    "c6_t1 : bin",
                    "c6_H1 : wp (bin_to_string t1)",
                    "c6_t2 : bin",
                    "c6_H2 : wp (bin_to_string t2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : wp\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close (bin_to_string t2))))",
                    "_global_wp_o_head_c : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\n       wp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c7_goal : wp (bin_to_string t1)",
                    "c8_goal : wp (bin_to_string t2)"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp (bin_to_string t1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c8_goal : wp (bin_to_string t2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bin_to_string'_wp",
        "proof": [
            {
                "tactic_sig": "Theorem bin_to_string'_wp : forall t : bin , wp ( bin_to_string' t ) .",
                "tactic_sig_no_out_arg": "Theorem bin_to_string'_wp : forall t : bin , wp ( bin_to_string' t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t : bin, wp (bin_to_string' t)"
                ]
            },
            {
                "tactic_sig": "simple induction t .",
                "tactic_sig_no_out_arg": "simple induction t .",
                "tactic_args": [
                    "c1_goal : forall t : bin, wp (bin_to_string' t)"
                ],
                "tactic_res": [
                    "c2_goal : wp (bin_to_string' L)",
                    "c2_t : bin",
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)), wp (bin_to_string' (N b b0))",
                    "c3_t : bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wp (bin_to_string' L)"
                ],
                "tactic_res": [
                    "c4_goal : wp Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : wp Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)), wp (bin_to_string' (N b b0))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)),\nwp\n  (app (bin_to_string' b)\n     (Datatypes.cons open\n        (app (bin_to_string' b0) (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)),\nwp\n  (app (bin_to_string' b)\n     (Datatypes.cons open\n        (app (bin_to_string' b0) (Datatypes.cons close Datatypes.nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_rel_sound_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_rel_sound_aux : forall ( l1 l2 : list par ) ( t : bin ) , parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2 .",
                "tactic_sig_no_out_arg": "Theorem parse_rel_sound_aux : forall ( l1 l2 : list par ) ( t : bin ) , parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\neq l1 (app (bin_to_string t) l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 t H .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\neq l1 (app (bin_to_string t) l2)"
                ],
                "tactic_res": [
                    "c2_goal : eq l1 (app (bin_to_string t) l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin",
                    "c2_H : parse_rel l1 l2 t"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq l1 (app (bin_to_string t) l2)",
                    "c2_H : parse_rel l1 l2 t"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 l2 l3 : list par) (t1 t2 : bin)\n  (_ : parse_rel l1 (Datatypes.cons close l2) t1)\n  (_ : eq l1 (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (_ : parse_rel l2 l3 t2) (_ : eq l2 (app (bin_to_string t2) l3)),\neq (Datatypes.cons open l1) (app (bin_to_string (N t1 t2)) l3)",
                    "c4_goal : eq Datatypes.nil (app (bin_to_string L) Datatypes.nil)",
                    "c5_goal : forall l : list par,\neq (Datatypes.cons close l)\n  (app (bin_to_string L) (Datatypes.cons close l))"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 l3 t1 t2 Hp Hr1 Hp2 Hr2 .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 l3 : list par) (t1 t2 : bin)\n  (_ : parse_rel l1 (Datatypes.cons close l2) t1)\n  (_ : eq l1 (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (_ : parse_rel l2 l3 t2) (_ : eq l2 (app (bin_to_string t2) l3)),\neq (Datatypes.cons open l1) (app (bin_to_string (N t1 t2)) l3)"
                ],
                "tactic_res": [
                    "c6_goal : eq (Datatypes.cons open l1) (app (bin_to_string (N t1 t2)) l3)",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_l3 : list par",
                    "c6_t1 : bin",
                    "c6_t2 : bin",
                    "c6_Hp : parse_rel l1 (Datatypes.cons close l2) t1",
                    "c6_Hr1 : eq l1 (app (bin_to_string t1) (Datatypes.cons close l2))",
                    "c6_Hp2 : parse_rel l2 l3 t2",
                    "c6_Hr2 : eq l2 (app (bin_to_string t2) l3)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : eq (Datatypes.cons open l1) (app (bin_to_string (N t1 t2)) l3)"
                ],
                "tactic_res": [
                    "c7_goal : eq (Datatypes.cons open l1)\n  (Datatypes.cons open\n     (app\n        (app (bin_to_string t1)\n           (Datatypes.cons close (bin_to_string t2))) l3))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c7_goal : eq (Datatypes.cons open l1)\n  (Datatypes.cons open\n     (app\n        (app (bin_to_string t1)\n           (Datatypes.cons close (bin_to_string t2))) l3))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)",
                    "c6_Hr1 : eq l1 (app (bin_to_string t1) (Datatypes.cons close l2))"
                ],
                "tactic_res": [
                    "c8_goal : eq\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (Datatypes.cons open\n     (app (bin_to_string t1)\n        (app (Datatypes.cons close (bin_to_string t2)) l3)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (Datatypes.cons open\n     (app (bin_to_string t1)\n        (app (Datatypes.cons close (bin_to_string t2)) l3)))"
                ],
                "tactic_res": [
                    "c9_goal : eq\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (Datatypes.cons open\n     (app (bin_to_string t1)\n        (Datatypes.cons close (app (bin_to_string t2) l3))))"
                ]
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq\n  (Datatypes.cons open\n     (app (bin_to_string t1) (Datatypes.cons close l2)))\n  (Datatypes.cons open\n     (app (bin_to_string t1)\n        (Datatypes.cons close (app (bin_to_string t2) l3))))",
                    "c6_Hr2 : eq l2 (app (bin_to_string t2) l3)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : eq Datatypes.nil (app (bin_to_string L) Datatypes.nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : forall l : list par,\neq (Datatypes.cons close l)\n  (app (bin_to_string L) (Datatypes.cons close l))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_rel_sound",
        "proof": [
            {
                "tactic_sig": "Theorem parse_rel_sound : forall l : list par , ( exists t : bin , parse_rel l nil t ) -> wp l .",
                "tactic_sig_no_out_arg": "Theorem parse_rel_sound : forall l : list par , ( exists t : bin , parse_rel l nil t ) -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par)\n  (_ : ex (fun t : bin => parse_rel l Datatypes.nil t)), \nwp l"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros l [ t H ] .",
                "tactic_args": [
                    "c1_goal : forall (l : list par)\n  (_ : ex (fun t : bin => parse_rel l Datatypes.nil t)), \nwp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : parse_rel l Datatypes.nil t"
                ]
            },
            {
                "tactic_sig": "replace _i with ( bin_to_string _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( bin_to_string _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : wp (bin_to_string t)",
                    "c4_goal : eq (bin_to_string t) l"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp (bin_to_string t)",
                    "_global_bin_to_string_wp : forall t : bin, wp (bin_to_string t)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : eq (bin_to_string t) l"
                ],
                "tactic_res": [
                    "c5_goal : eq l (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "replace ( bin_to_string _i ) with ( bin_to_string _i ++ nil ) .",
                "tactic_sig_no_out_arg": "replace ( bin_to_string _i ) with ( bin_to_string _i ++ nil ) .",
                "tactic_args": [
                    "c5_goal : eq l (bin_to_string t)",
                    "c2_t : bin",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c6_goal : eq l (app (bin_to_string t) Datatypes.nil)",
                    "c7_goal : eq (app (bin_to_string t) Datatypes.nil) (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : eq l (app (bin_to_string t) Datatypes.nil)",
                    "_global_parse_rel_sound_aux : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\n       eq l1 (app (bin_to_string t) l2)"
                ],
                "tactic_res": [
                    "c8_goal : parse_rel l Datatypes.nil t"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : parse_rel l Datatypes.nil t",
                    "c2_H : parse_rel l Datatypes.nil t",
                    "c2_t : bin",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (app (bin_to_string t) Datatypes.nil) (bin_to_string t)",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l Datatypes.nil) l"
                ],
                "tactic_res": [
                    "c9_goal : eq (bin_to_string t) (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (bin_to_string t) (bin_to_string t)",
                    "c2_t : bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_concat",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_concat : forall l1 l2 : list par , wp' l1 -> wp' l2 -> wp' ( l1 ++ l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp'_concat : forall l1 l2 : list par , wp' l1 -> wp' l2 -> wp' ( l1 ++ l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : wp' l2, wp' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H : wp' l1"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c2_goal : forall _ : wp' l2, wp' (app l1 l2)",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : forall (l2 : list par) (_ : wp' l2), wp' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall (l2 : list par) (_ : wp' l2), wp' (app l1 l2)",
                    "c2_H : wp' l1"
                ],
                "tactic_res": [
                    "c4_goal : forall (l2 : list par) (_ : wp' l2), wp' (app Datatypes.nil l2)",
                    "c5_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l1 l3))\n  (_ : wp' l2)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l2 l3))\n  (l3 : list par) (_ : wp' l3),\nwp' (app (Datatypes.cons open (app l1 (Datatypes.cons close l2))) l3)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (l2 : list par) (_ : wp' l2), wp' (app Datatypes.nil l2)"
                ],
                "tactic_res": [
                    "c6_goal : forall (l2 : list par) (_ : wp' l2), wp' l2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (l2 : list par) (_ : wp' l2), wp' l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1' l2' Hb1' Hr1 Hb2' Hr2 l2 Hb2 .",
                "tactic_args": [
                    "c5_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l1 l3))\n  (_ : wp' l2)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l2 l3))\n  (l3 : list par) (_ : wp' l3),\nwp' (app (Datatypes.cons open (app l1 (Datatypes.cons close l2))) l3)"
                ],
                "tactic_res": [
                    "c7_goal : wp' (app (Datatypes.cons open (app l1' (Datatypes.cons close l2'))) l2)",
                    "c7_l1' : list par",
                    "c7_l2' : list par",
                    "c7_Hb1' : wp' l1'",
                    "c7_Hr1 : forall (l2 : list par) (_ : wp' l2), wp' (app l1' l2)",
                    "c7_Hb2' : wp' l2'",
                    "c7_Hr2 : forall (l2 : list par) (_ : wp' l2), wp' (app l2' l2)",
                    "c7_l2 : list par",
                    "c7_Hb2 : wp' l2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : wp' (app (Datatypes.cons open (app l1' (Datatypes.cons close l2'))) l2)"
                ],
                "tactic_res": [
                    "c8_goal : wp' (Datatypes.cons open (app (app l1' (Datatypes.cons close l2')) l2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : wp' (Datatypes.cons open (app (app l1' (Datatypes.cons close l2')) l2))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c9_goal : wp' (Datatypes.cons open (app l1' (app (Datatypes.cons close l2') l2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : wp' (Datatypes.cons open (app l1' (app (Datatypes.cons close l2') l2)))"
                ],
                "tactic_res": [
                    "c10_goal : wp' (Datatypes.cons open (app l1' (Datatypes.cons close (app l2' l2))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp' (Datatypes.cons open (app l1' (Datatypes.cons close (app l2' l2))))",
                    "_global_wp'_cons : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2),\n       wp' (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c11_goal : wp' l1'",
                    "c12_goal : wp' (app l2' l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : wp' l1'",
                    "c7_Hb1' : wp' l1'",
                    "c7_l1' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : wp' (app l2' l2)",
                    "c7_Hb2 : wp' l2",
                    "c7_l2 : list par",
                    "c7_Hr2 : forall (l2 : list par) (_ : wp' l2), wp' (app l2' l2)",
                    "c7_l2' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_encapsulate",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_encapsulate : forall l : list par , wp' l -> wp' ( open :: l ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp'_encapsulate : forall l : list par , wp' l -> wp' ( open :: l ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l),\nwp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l),\nwp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c2_goal : wp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))",
                    "c2_l : list par",
                    "c2_H : wp' l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))",
                    "c2_H : wp' l"
                ],
                "tactic_res": [
                    "c3_goal : wp'\n  (Datatypes.cons open\n     (app Datatypes.nil (Datatypes.cons close Datatypes.nil)))",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : wp'\n         (Datatypes.cons open\n            (app l1 (Datatypes.cons close Datatypes.nil))))\n  (_ : wp' l2)\n  (_ : wp'\n         (Datatypes.cons open\n            (app l2 (Datatypes.cons close Datatypes.nil)))),\nwp'\n  (Datatypes.cons open\n     (app (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n        (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp'\n  (Datatypes.cons open\n     (app Datatypes.nil (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : wp'\n         (Datatypes.cons open\n            (app l1 (Datatypes.cons close Datatypes.nil))))\n  (_ : wp' l2)\n  (_ : wp'\n         (Datatypes.cons open\n            (app l2 (Datatypes.cons close Datatypes.nil)))),\nwp'\n  (Datatypes.cons open\n     (app (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n        (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_imp_wp'",
        "proof": [
            {
                "tactic_sig": "Theorem wp_imp_wp' : forall l : list par , wp l -> wp' l .",
                "tactic_sig_no_out_arg": "Theorem wp_imp_wp' : forall l : list par , wp l -> wp' l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp' l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp' l"
                ],
                "tactic_res": [
                    "c2_goal : wp' l",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp' l",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : wp' Datatypes.nil",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp' l1) \n  (_ : wp l2) (_ : wp' l2), wp' (app l1 l2)",
                    "c5_goal : forall (l : list par) (_ : wp l) (_ : wp' l),\nwp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp' Datatypes.nil",
                    "_global_wp'_nil : wp' Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp' l1) \n  (_ : wp l2) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c6_goal : wp' (app l1 l2)",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_H0 : wp l1",
                    "c6_H1 : wp' l1",
                    "c6_H2 : wp l2",
                    "c6_H3 : wp' l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : wp' (app l1 l2)",
                    "_global_wp'_concat : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c7_goal : wp' l1",
                    "c8_goal : wp' l2"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp' l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c8_goal : wp' l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l) (_ : wp' l),\nwp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c9_goal : wp' (Datatypes.cons open (app l0 (Datatypes.cons close Datatypes.nil)))",
                    "c9_l0 : list par",
                    "c9_H0 : wp l0",
                    "c9_H1 : wp' l0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : wp' (Datatypes.cons open (app l0 (Datatypes.cons close Datatypes.nil)))",
                    "_global_wp'_encapsulate : forall (l : list par) (_ : wp' l),\n       wp' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c10_goal : wp' l0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c10_goal : wp' l0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_imp_wp",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_imp_wp : forall l : list par , wp' l -> wp l .",
                "tactic_sig_no_out_arg": "Theorem wp'_imp_wp : forall l : list par , wp' l -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_H : wp' l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_H : wp' l"
                ],
                "tactic_res": [
                    "c3_goal : wp Datatypes.nil",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp l1) \n  (_ : wp' l2) (_ : wp l2),\nwp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp l1) \n  (_ : wp' l2) (_ : wp l2),\nwp (Datatypes.cons open (app l1 (Datatypes.cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_concat",
        "proof": [
            {
                "tactic_sig": "Lemma wp''_concat : forall l1 l2 : list par , wp'' l1 -> wp'' l2 -> wp'' ( l1 ++ l2 ) .",
                "tactic_sig_no_out_arg": "Lemma wp''_concat : forall l1 l2 : list par , wp'' l1 -> wp'' l2 -> wp'' ( l1 ++ l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp'' l2), wp'' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp'' l2), wp'' (app l1 l2)"
                ],
                "tactic_res": [
                    "c2_goal : wp'' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp'' l1",
                    "c2_H2 : wp'' l2"
                ]
            },
            {
                "tactic_sig": "generalize _i _i .",
                "tactic_sig_no_out_arg": "generalize _i _i .",
                "tactic_args": [
                    "c2_goal : wp'' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_H1 : wp'' l1"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_H1 : wp'' l1",
                    "c2_l1 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l2)",
                    "c2_H2 : wp'' l2"
                ],
                "tactic_res": [
                    "c4_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 Datatypes.nil)",
                    "c5_goal : forall (l1 l2 : list par) (_ : wp'' l1)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l1))\n  (_ : wp'' l2)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l2))\n  (l3 : list par) (_ : wp'' l3),\nwp''\n  (app l3\n     (app l1\n        (Datatypes.cons open\n           (app l2 (Datatypes.cons close Datatypes.nil)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 Datatypes.nil)"
                ],
                "tactic_res": [
                    "c6_goal : wp'' (app l1 Datatypes.nil)",
                    "c6_l1 : list par",
                    "c6_H1 : wp'' l1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : wp'' (app l1 Datatypes.nil)",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l Datatypes.nil) l"
                ],
                "tactic_res": [
                    "c7_goal : wp'' l1"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp'' l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (l1 l2 : list par) (_ : wp'' l1)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l1))\n  (_ : wp'' l2)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l2))\n  (l3 : list par) (_ : wp'' l3),\nwp''\n  (app l3\n     (app l1\n        (Datatypes.cons open\n           (app l2 (Datatypes.cons close Datatypes.nil)))))"
                ],
                "tactic_res": [
                    "c8_goal : wp''\n  (app l3\n     (app l1\n        (Datatypes.cons open\n           (app l0 (Datatypes.cons close Datatypes.nil)))))",
                    "c8_l1 : list par",
                    "c8_l0 : list par",
                    "c8_H : wp'' l1",
                    "c8_H0 : forall (l2 : list par) (_ : wp'' l2), wp'' (app l2 l1)",
                    "c8_H1 : wp'' l0",
                    "c8_H3 : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l0)",
                    "c8_l3 : list par",
                    "c8_H4 : wp'' l3"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : wp''\n  (app l3\n     (app l1\n        (Datatypes.cons open\n           (app l0 (Datatypes.cons close Datatypes.nil)))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c9_goal : wp''\n  (app (app l3 l1)\n     (Datatypes.cons open (app l0 (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : wp''\n  (app (app l3 l1)\n     (Datatypes.cons open (app l0 (Datatypes.cons close Datatypes.nil))))",
                    "c8_H4 : wp'' l3",
                    "c8_l3 : list par",
                    "c8_H1 : wp'' l0",
                    "c8_H0 : forall (l2 : list par) (_ : wp'' l2), wp'' (app l2 l1)",
                    "c8_l1 : list par",
                    "c8_l0 : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_encapsulate",
        "proof": [
            {
                "tactic_sig": "Theorem wp''_encapsulate : forall l : list par , wp'' l -> wp'' ( open :: l ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp''_encapsulate : forall l : list par , wp'' l -> wp'' ( open :: l ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp'' l),\nwp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp'' l),\nwp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c2_goal : wp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))",
                    "c2_l : list par",
                    "c2_H : wp'' l"
                ]
            },
            {
                "tactic_sig": "change ( wp'' ( nil ++ open :: _i ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp'' ( nil ++ open :: _i ++ close :: nil ) ) .",
                "tactic_args": [
                    "c2_goal : wp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp''\n  (app Datatypes.nil\n     (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp''\n  (app Datatypes.nil\n     (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil))))",
                    "c2_H : wp'' l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_imp_wp''",
        "proof": [
            {
                "tactic_sig": "Theorem wp_imp_wp'' : forall l : list par , wp l -> wp'' l .",
                "tactic_sig_no_out_arg": "Theorem wp_imp_wp'' : forall l : list par , wp l -> wp'' l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp'' l"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp'' l"
                ],
                "tactic_res": [
                    "c2_goal : wp'' Datatypes.nil",
                    "c2_H : wp l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp'' l1) \n  (_ : wp l2) (_ : wp'' l2), wp'' (app l1 l2)",
                    "c3_H : wp l",
                    "c3_l : list par",
                    "c4_goal : forall (l : list par) (_ : wp l) (_ : wp'' l),\nwp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))",
                    "c4_H : wp l",
                    "c4_l : list par"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : wp'' Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp'' l1) \n  (_ : wp l2) (_ : wp'' l2), wp'' (app l1 l2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l : list par) (_ : wp l) (_ : wp'' l),\nwp'' (Datatypes.cons open (app l (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_imp_wp",
        "proof": [
            {
                "tactic_sig": "Theorem wp''_imp_wp : forall l : list par , wp'' l -> wp l .",
                "tactic_sig_no_out_arg": "Theorem wp''_imp_wp : forall l : list par , wp'' l -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp'' l), wp l"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp'' l), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp Datatypes.nil",
                    "c2_H : wp'' l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp l1) \n  (_ : wp'' l2) (_ : wp l2),\nwp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))",
                    "c3_H : wp'' l",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : wp Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp l1) \n  (_ : wp'' l2) (_ : wp l2),\nwp\n  (app l1\n     (Datatypes.cons open (app l2 (Datatypes.cons close Datatypes.nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_complete_aux",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_complete_aux : forall l : list par , wp l -> forall ( n : nat ) ( l' : list par ) , recognize n ( l ++ l' ) = recognize n l' .",
                "tactic_sig_no_out_arg": "Theorem recognize_complete_aux : forall l : list par , wp l -> forall ( n : nat ) ( l' : list par ) , recognize n ( l ++ l' ) = recognize n l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (l' : list par),\neq (recognize n (app Datatypes.nil l')) (recognize n l')",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l1 l')) (recognize n l')) \n  (_ : wp l2)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l2 l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq\n  (recognize n\n     (app\n        (Datatypes.cons open\n           (app l (Datatypes.cons close Datatypes.nil))) l'))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (l' : list par),\neq (recognize n (app Datatypes.nil l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (l' : list par), eq (recognize n l') (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (l' : list par), eq (recognize n l') (recognize n l')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 Hrec1 H2 Hrec2 n l' .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l1 l')) (recognize n l')) \n  (_ : wp l2)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l2 l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (app l1 l2) l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c7_goal : eq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "c7_l1 : list par",
                    "c7_l2 : list par",
                    "c7_H1 : wp l1",
                    "c7_Hrec1 : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c7_H2 : wp l2",
                    "c7_Hrec2 : forall (n : nat) (l' : list par),\neq (recognize n (app l2 l')) (recognize n l')",
                    "c7_n : nat",
                    "c7_l' : list par"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c8_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "transitivity ( recognize _i ( _i ++ _i ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( recognize _i ( _i ++ _i ) ) .",
                "tactic_args": [
                    "c8_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n l')",
                    "c7_n : nat",
                    "c7_l2 : list par",
                    "c7_l' : list par"
                ],
                "tactic_res": [
                    "c9_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n (app l2 l'))",
                    "c10_goal : eq (recognize n (app l2 l')) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n (app l2 l'))",
                    "c7_l' : list par",
                    "c7_n : nat",
                    "c7_Hrec1 : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c7_l1 : list par",
                    "c7_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (recognize n (app l2 l')) (recognize n l')",
                    "c7_l' : list par",
                    "c7_n : nat",
                    "c7_Hrec2 : forall (n : nat) (l' : list par),\neq (recognize n (app l2 l')) (recognize n l')",
                    "c7_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 H1 Hrec n l' .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq\n  (recognize n\n     (app\n        (Datatypes.cons open\n           (app l (Datatypes.cons close Datatypes.nil))) l'))\n  (recognize n l')"
                ],
                "tactic_res": [
                    "c11_goal : eq\n  (recognize n\n     (app\n        (Datatypes.cons open\n           (app l1 (Datatypes.cons close Datatypes.nil))) l'))\n  (recognize n l')",
                    "c11_l1 : list par",
                    "c11_H1 : wp l1",
                    "c11_Hrec : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c11_n : nat",
                    "c11_l' : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : eq\n  (recognize n\n     (app\n        (Datatypes.cons open\n           (app l1 (Datatypes.cons close Datatypes.nil))) l'))\n  (recognize n l')"
                ],
                "tactic_res": [
                    "c12_goal : eq\n  (recognize (S n)\n     (app (app l1 (Datatypes.cons close Datatypes.nil)) l'))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c12_goal : eq\n  (recognize (S n)\n     (app (app l1 (Datatypes.cons close Datatypes.nil)) l'))\n  (recognize n l')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c13_goal : eq\n  (recognize (S n)\n     (app l1 (app (Datatypes.cons close Datatypes.nil) l')))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq\n  (recognize (S n)\n     (app l1 (app (Datatypes.cons close Datatypes.nil) l')))\n  (recognize n l')",
                    "c11_Hrec : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c14_goal : eq (recognize (S n) (app (Datatypes.cons close Datatypes.nil) l'))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : eq (recognize (S n) (app (Datatypes.cons close Datatypes.nil) l'))\n  (recognize n l')"
                ],
                "tactic_res": [
                    "c15_goal : eq (recognize n l') (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq (recognize n l') (recognize n l')",
                    "c11_l' : list par",
                    "c11_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_complete",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_complete : forall l : list par , wp l -> recognize 0 l = true .",
                "tactic_sig_no_out_arg": "Theorem recognize_complete : forall l : list par , wp l -> recognize 0 l = true .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), eq (recognize 0 l) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), eq (recognize 0 l) true"
                ],
                "tactic_res": [
                    "c2_goal : eq (recognize 0 l) true",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) , _i .",
                "tactic_args": [
                    "c2_goal : eq (recognize 0 l) true",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l Datatypes.nil) l",
                    "c2_l : list par",
                    "_global_recognize_complete_aux : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c3_goal : eq (recognize 0 Datatypes.nil) true",
                    "c4_goal : wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (recognize 0 Datatypes.nil) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : wp l",
                    "c2_H : wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "app_decompose",
        "proof": [
            {
                "tactic_sig": "Theorem app_decompose : forall ( A : Type ) ( l1 l2 l3 l4 : list A ) , l1 ++ l2 = l3 ++ l4 -> ( exists l1' : list A , l1 = l3 ++ l1' /\\ l4 = l1' ++ l2 ) \\/ ( exists a : A , exists l2' : list A , l3 = l1 ++ a :: l2' /\\ l2 = ( a :: l2' ) ++ l4 ) .",
                "tactic_sig_no_out_arg": "Theorem app_decompose : forall ( A : Type ) ( l1 l2 l3 l4 : list A ) , l1 ++ l2 = l3 ++ l4 -> ( exists l1' : list A , l1 = l3 ++ l1' /\\ l4 = l1' ++ l2 ) \\/ ( exists a : A , exists l2' : list A , l3 = l1 ++ a :: l2' /\\ l2 = ( a :: l2' ) ++ l4 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l1 l2 l3 l4 : list A)\n  (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "simple induction l1 .",
                "tactic_sig_no_out_arg": "simple induction l1 .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l1 l2 l3 l4 : list A)\n  (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c2_goal : forall (l2 l3 l4 : list A) (_ : eq (app Datatypes.nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c2_l1 : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall (l2 l3 l4 : list A) (_ : eq (app l l2) (app l3 l4)),\n       or\n         (ex\n            (fun l1' : list A =>\n             and (eq l (app l3 l1')) (eq l4 (app l1' l2))))\n         (ex\n            (fun a0 : A =>\n             ex\n               (fun l2' : list A =>\n                and (eq l3 (app l (Datatypes.cons a0 l2')))\n                  (eq l2 (app (Datatypes.cons a0 l2') l4))))))\n  (l2 l3 l4 : list A)\n  (_ : eq (app (Datatypes.cons a l) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (Datatypes.cons a l) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))",
                    "c3_l1 : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l2 l3 .",
                "tactic_args": [
                    "c2_goal : forall (l2 l3 l4 : list A) (_ : eq (app Datatypes.nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c4_goal : forall (l4 : list A) (_ : eq (app Datatypes.nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c4_l2 : list A",
                    "c4_l3 : list A"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (l4 : list A) (_ : eq (app Datatypes.nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c4_l3 : list A"
                ],
                "tactic_res": [
                    "c5_goal : forall (l4 : list A)\n  (_ : eq (app Datatypes.nil l2) (app Datatypes.nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c6_goal : forall (a : A) (l l4 : list A)\n  (_ : eq (app Datatypes.nil l2) (app (Datatypes.cons a l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app (Datatypes.cons a l) l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a l)\n              (app Datatypes.nil (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l4 H .",
                "tactic_args": [
                    "c5_goal : forall (l4 : list A)\n  (_ : eq (app Datatypes.nil l2) (app Datatypes.nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c7_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c7_l4 : list A",
                    "c7_H : eq (app Datatypes.nil l2) (app Datatypes.nil l4)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c7_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil (app Datatypes.nil (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun l1' : list A =>\n   and (eq Datatypes.nil (app Datatypes.nil l1')) (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists ( nil ( _i := _i ) ) .",
                "tactic_sig_no_out_arg": "exists ( nil ( _i := _i ) ) .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun l1' : list A =>\n   and (eq Datatypes.nil (app Datatypes.nil l1')) (eq l4 (app l1' l2)))",
                    "c2_A : Type",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c9_goal : and (eq Datatypes.nil (app Datatypes.nil Datatypes.nil))\n  (eq l4 (app Datatypes.nil l2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : and (eq Datatypes.nil (app Datatypes.nil Datatypes.nil))\n  (eq l4 (app Datatypes.nil l2))",
                    "c7_H : eq (app Datatypes.nil l2) (app Datatypes.nil l4)",
                    "c4_l2 : list A",
                    "c7_l4 : list A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l3' Heq .",
                "tactic_args": [
                    "c6_goal : forall (a : A) (l l4 : list A)\n  (_ : eq (app Datatypes.nil l2) (app (Datatypes.cons a l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app (Datatypes.cons a l) l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a l)\n              (app Datatypes.nil (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq (app Datatypes.nil l2) (app (Datatypes.cons a l3') Heq),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app (Datatypes.cons a l3') l1'))\n        (eq Heq (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a l3')\n              (app Datatypes.nil (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') Heq)))))",
                    "c10_a : A",
                    "c10_l3' : list A",
                    "c10_Heq : list A"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c10_goal : forall _ : eq (app Datatypes.nil l2) (app (Datatypes.cons a l3') Heq),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq Datatypes.nil (app (Datatypes.cons a l3') l1'))\n        (eq Heq (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a l3')\n              (app Datatypes.nil (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') Heq)))))"
                ],
                "tactic_res": [
                    "c11_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and\n        (eq (Datatypes.cons a l3')\n           (app Datatypes.nil (Datatypes.cons a0 l2')))\n        (eq l2 (app (Datatypes.cons a0 l2') Heq))))",
                    "c11_H : eq (app Datatypes.nil l2) (app (Datatypes.cons a l3') Heq)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and\n        (eq (Datatypes.cons a l3')\n           (app Datatypes.nil (Datatypes.cons a0 l2')))\n        (eq l2 (app (Datatypes.cons a0 l2') Heq))))",
                    "c10_a : A"
                ],
                "tactic_res": [
                    "c12_goal : ex\n  (fun l2' : list A =>\n   and\n     (eq (Datatypes.cons a l3')\n        (app Datatypes.nil (Datatypes.cons a l2')))\n     (eq l2 (app (Datatypes.cons a l2') Heq)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun l2' : list A =>\n   and\n     (eq (Datatypes.cons a l3')\n        (app Datatypes.nil (Datatypes.cons a l2')))\n     (eq l2 (app (Datatypes.cons a l2') Heq)))",
                    "c10_l3' : list A"
                ],
                "tactic_res": [
                    "c13_goal : and\n  (eq (Datatypes.cons a l3') (app Datatypes.nil (Datatypes.cons a l3')))\n  (eq l2 (app (Datatypes.cons a l3') Heq))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : and\n  (eq (Datatypes.cons a l3') (app Datatypes.nil (Datatypes.cons a l3')))\n  (eq l2 (app (Datatypes.cons a l3') Heq))",
                    "c11_H : eq (app Datatypes.nil l2) (app (Datatypes.cons a l3') Heq)",
                    "c10_l3' : list A",
                    "c10_Heq : list A",
                    "c10_a : A",
                    "c4_l2 : list A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c3_l1 : list A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l1 Hrec l2 l3 .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall (l2 l3 l4 : list A) (_ : eq (app l l2) (app l3 l4)),\n       or\n         (ex\n            (fun l1' : list A =>\n             and (eq l (app l3 l1')) (eq l4 (app l1' l2))))\n         (ex\n            (fun a0 : A =>\n             ex\n               (fun l2' : list A =>\n                and (eq l3 (app l (Datatypes.cons a0 l2')))\n                  (eq l2 (app (Datatypes.cons a0 l2') l4))))))\n  (l2 l3 l4 : list A)\n  (_ : eq (app (Datatypes.cons a l) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (Datatypes.cons a l) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c14_goal : forall (l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq l3 (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))",
                    "c14_a : A",
                    "c14_l1 : list A",
                    "c14_Hrec : forall (l2 l3 l4 : list A) (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c14_l2 : list A",
                    "c14_l3 : list A"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c14_goal : forall (l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq l3 (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))",
                    "c14_l3 : list A"
                ],
                "tactic_res": [
                    "c15_goal : forall (l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app Datatypes.nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil\n              (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))",
                    "c16_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app (Datatypes.cons a0 l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app (Datatypes.cons a0 l) l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a0 l)\n              (app (Datatypes.cons a l1) (Datatypes.cons a1 l2')))\n           (eq l2 (app (Datatypes.cons a1 l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l4 H .",
                "tactic_args": [
                    "c15_goal : forall (l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app Datatypes.nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil\n              (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c17_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil\n              (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))",
                    "c17_l4 : list A",
                    "c17_H : eq (app (Datatypes.cons a l1) l2) (app Datatypes.nil l4)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c17_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq Datatypes.nil\n              (app (Datatypes.cons a l1) (Datatypes.cons a0 l2')))\n           (eq l2 (app (Datatypes.cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c18_goal : ex\n  (fun l1' : list A =>\n   and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n     (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists ( _i :: _i ) .",
                "tactic_sig_no_out_arg": "exists ( _i :: _i ) .",
                "tactic_args": [
                    "c18_goal : ex\n  (fun l1' : list A =>\n   and (eq (Datatypes.cons a l1) (app Datatypes.nil l1'))\n     (eq l4 (app l1' l2)))",
                    "c14_a : A",
                    "c14_l1 : list A"
                ],
                "tactic_res": [
                    "c19_goal : and\n  (eq (Datatypes.cons a l1) (app Datatypes.nil (Datatypes.cons a l1)))\n  (eq l4 (app (Datatypes.cons a l1) l2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : and\n  (eq (Datatypes.cons a l1) (app Datatypes.nil (Datatypes.cons a l1)))\n  (eq l4 (app (Datatypes.cons a l1) l2))",
                    "c17_H : eq (app (Datatypes.cons a l1) l2) (app Datatypes.nil l4)",
                    "c14_l2 : list A",
                    "c17_l4 : list A",
                    "c14_l1 : list A",
                    "c14_a : A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (app (Datatypes.cons a l1) l2) (app (Datatypes.cons a0 l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (app (Datatypes.cons a0 l) l1'))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a0 l)\n              (app (Datatypes.cons a l1) (Datatypes.cons a1 l2')))\n           (eq l2 (app (Datatypes.cons a1 l2') l4)))))"
                ],
                "tactic_res": [
                    "c20_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (Datatypes.cons a (app l1 l2)) (Datatypes.cons a0 (app l l4))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a0 (app l l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a0 l)\n              (Datatypes.cons a (app l1 (Datatypes.cons a1 l2'))))\n           (eq l2 (Datatypes.cons a1 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a' l3' l4 Heq .",
                "tactic_args": [
                    "c20_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (Datatypes.cons a (app l1 l2)) (Datatypes.cons a0 (app l l4))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a0 (app l l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a0 l)\n              (Datatypes.cons a (app l1 (Datatypes.cons a1 l2'))))\n           (eq l2 (Datatypes.cons a1 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c21_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c21_a' : A",
                    "c21_l3' : list A",
                    "c21_l4 : list A",
                    "c21_Heq : eq (Datatypes.cons a (app l1 l2)) (Datatypes.cons a' (app l3' l4))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c21_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c21_Heq : eq (Datatypes.cons a (app l1 l2)) (Datatypes.cons a' (app l3' l4))"
                ],
                "tactic_res": [
                    "c22_goal : forall (_ : eq (app l1 l2) (app l3' l4)) (_ : eq a a'),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq' Heq'' .",
                "tactic_args": [
                    "c22_goal : forall (_ : eq (app l1 l2) (app l3' l4)) (_ : eq a a'),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c23_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c23_Heq' : eq (app l1 l2) (app l3' l4)",
                    "c23_Heq'' : eq a a'"
                ]
            },
            {
                "tactic_sig": "elim _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c23_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c14_Hrec : forall (l2 l3 l4 : list A) (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (Datatypes.cons a l2')))\n           (eq l2 (app (Datatypes.cons a l2') l4)))))",
                    "c23_Heq' : eq (app l1 l2) (app l3' l4)"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  _ : ex\n        (fun l1' : list A =>\n         and (eq l1 (app l3' l1')) (eq l4 (app l1' l2))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c25_goal : forall\n  _ : ex\n        (fun a : A =>\n         ex\n           (fun l2' : list A =>\n            and (eq l3' (app l1 (Datatypes.cons a l2')))\n              (eq l2 (app (Datatypes.cons a l2') l4)))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ l1' [ Heq3 Heq4 ] ] .",
                "tactic_args": [
                    "c24_goal : forall\n  _ : ex\n        (fun l1' : list A =>\n         and (eq l1 (app l3' l1')) (eq l4 (app l1' l2))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c26_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c26_l1' : list A",
                    "c26_Heq3 : eq l1 (app l3' l1')",
                    "c26_Heq4 : eq l4 (app l1' l2)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c26_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c27_goal : ex\n  (fun l1' : list A =>\n   and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n     (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c27_goal : ex\n  (fun l1' : list A =>\n   and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n     (eq l4 (app l1' l2)))",
                    "c26_l1' : list A"
                ],
                "tactic_res": [
                    "c28_goal : and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n  (eq l4 (app l1' l2))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c28_goal : and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n  (eq l4 (app l1' l2))"
                ],
                "tactic_res": [
                    "c29_goal : eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1'))",
                    "c30_goal : eq l4 (app l1' l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : eq l4 (app l1' l2)",
                    "c26_Heq4 : eq l4 (app l1' l2)",
                    "c26_l1' : list A",
                    "c21_l4 : list A",
                    "c14_l2 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1'))",
                    "c23_Heq'' : eq a a'"
                ],
                "tactic_res": [
                    "c31_goal : eq (Datatypes.cons a' l1) (Datatypes.cons a' (app l3' l1'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : eq (Datatypes.cons a' l1) (Datatypes.cons a' (app l3' l1'))",
                    "c26_Heq3 : eq l1 (app l3' l1')"
                ],
                "tactic_res": [
                    "c32_goal : eq (Datatypes.cons a' (app l3' l1')) (Datatypes.cons a' (app l3' l1'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : eq (Datatypes.cons a' (app l3' l1')) (Datatypes.cons a' (app l3' l1'))",
                    "c26_l1' : list A",
                    "c21_l3' : list A",
                    "c21_a' : A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o [ _o [ _o _o ] ] ] .",
                "tactic_sig_no_out_arg": "intros [ a'' [ l2' [ Heq3 Heq4 ] ] ] .",
                "tactic_args": [
                    "c25_goal : forall\n  _ : ex\n        (fun a : A =>\n         ex\n           (fun l2' : list A =>\n            and (eq l3' (app l1 (Datatypes.cons a l2')))\n              (eq l2 (app (Datatypes.cons a l2') l4)))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c33_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))",
                    "c33_a'' : A",
                    "c33_l2' : list A",
                    "c33_Heq3 : eq l3' (app l1 (Datatypes.cons a'' l2'))",
                    "c33_Heq4 : eq l2 (app (Datatypes.cons a'' l2') l4)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c33_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (Datatypes.cons a l1) (Datatypes.cons a' (app l3' l1')))\n        (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and\n           (eq (Datatypes.cons a' l3')\n              (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n           (eq l2 (Datatypes.cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c34_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and\n        (eq (Datatypes.cons a' l3')\n           (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n        (eq l2 (Datatypes.cons a0 (app l2' l4)))))"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c34_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and\n        (eq (Datatypes.cons a' l3')\n           (Datatypes.cons a (app l1 (Datatypes.cons a0 l2'))))\n        (eq l2 (Datatypes.cons a0 (app l2' l4)))))",
                    "c33_a'' : A",
                    "c33_l2' : list A"
                ],
                "tactic_res": [
                    "c35_goal : and\n  (eq (Datatypes.cons a' l3')\n     (Datatypes.cons a (app l1 (Datatypes.cons a'' l2'))))\n  (eq l2 (Datatypes.cons a'' (app l2' l4)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c35_goal : and\n  (eq (Datatypes.cons a' l3')\n     (Datatypes.cons a (app l1 (Datatypes.cons a'' l2'))))\n  (eq l2 (Datatypes.cons a'' (app l2' l4)))"
                ],
                "tactic_res": [
                    "c36_goal : eq (Datatypes.cons a' l3')\n  (Datatypes.cons a (app l1 (Datatypes.cons a'' l2')))",
                    "c37_goal : eq l2 (Datatypes.cons a'' (app l2' l4))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : eq l2 (Datatypes.cons a'' (app l2' l4))",
                    "c33_Heq4 : eq l2 (app (Datatypes.cons a'' l2') l4)",
                    "c33_l2' : list A",
                    "c33_a'' : A",
                    "c21_l4 : list A",
                    "c14_l2 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : eq (Datatypes.cons a' l3')\n  (Datatypes.cons a (app l1 (Datatypes.cons a'' l2')))",
                    "c23_Heq'' : eq a a'"
                ],
                "tactic_res": [
                    "c38_goal : eq (Datatypes.cons a' l3')\n  (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c38_goal : eq (Datatypes.cons a' l3')\n  (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))",
                    "c33_Heq3 : eq l3' (app l1 (Datatypes.cons a'' l2'))"
                ],
                "tactic_res": [
                    "c39_goal : eq (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))\n  (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : eq (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))\n  (Datatypes.cons a' (app l1 (Datatypes.cons a'' l2')))",
                    "c33_l2' : list A",
                    "c33_a'' : A",
                    "c21_a' : A",
                    "c14_l1 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "length_app",
        "proof": [
            {
                "tactic_sig": "Theorem length_app : forall { A : Type } ( l1 l2 : list A ) , length ( l1 ++ l2 ) = length l1 + length l2 .",
                "tactic_sig_no_out_arg": "Theorem length_app : forall { A : Type } ( l1 l2 : list A ) , length ( l1 ++ l2 ) = length l1 + length l2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l1 l2 : list A),\neq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))"
                ]
            },
            {
                "tactic_sig": "simple induction l1 .",
                "tactic_sig_no_out_arg": "simple induction l1 .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l1 l2 : list A),\neq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))"
                ],
                "tactic_res": [
                    "c2_goal : forall l2 : list A,\neq (length (app Datatypes.nil l2))\n  (Init.Nat.add (length Datatypes.nil) (length l2))",
                    "c2_l1 : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (length (app (Datatypes.cons a l) l2))\n  (Init.Nat.add (length (Datatypes.cons a l)) (length l2))",
                    "c3_l1 : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c2_goal : forall l2 : list A,\neq (length (app Datatypes.nil l2))\n  (Init.Nat.add (length Datatypes.nil) (length l2))"
                ],
                "tactic_res": [
                    "c4_goal : forall l2 : list A, eq (length l2) (length l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall l2 : list A, eq (length l2) (length l2)",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (length (app (Datatypes.cons a l) l2))\n  (Init.Nat.add (length (Datatypes.cons a l)) (length l2))"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (S (length (app l l2))) (S (Init.Nat.add (length l) (length l2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (_ : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (S (length (app l l2))) (S (Init.Nat.add (length l) (length l2)))",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "length_rev",
        "proof": [
            {
                "tactic_sig": "Theorem length_rev : forall { A : Type } ( l : list A ) , length l = length ( rev l ) .",
                "tactic_sig_no_out_arg": "Theorem length_rev : forall { A : Type } ( l : list A ) , length l = length ( rev l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l : list A), eq (length l) (length (rev l))"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l : list A), eq (length l) (length (rev l))"
                ],
                "tactic_res": [
                    "c2_goal : eq (length Datatypes.nil) (length (rev Datatypes.nil))",
                    "c2_l : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A) (_ : eq (length l) (length (rev l))),\neq (length (Datatypes.cons a l)) (length (rev (Datatypes.cons a l)))",
                    "c3_l : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : eq (length Datatypes.nil) (length (rev Datatypes.nil))",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l' H .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A) (_ : eq (length l) (length (rev l))),\neq (length (Datatypes.cons a l)) (length (rev (Datatypes.cons a l)))"
                ],
                "tactic_res": [
                    "c4_goal : eq (length (Datatypes.cons a l')) (length (rev (Datatypes.cons a l')))",
                    "c4_a : A",
                    "c4_l' : list A",
                    "c4_H : eq (length l') (length (rev l'))"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c4_goal : eq (length (Datatypes.cons a l')) (length (rev (Datatypes.cons a l')))"
                ],
                "tactic_res": [
                    "c5_goal : eq (S (length l'))\n  (length (app (rev l') (Datatypes.cons a Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq (S (length l'))\n  (length (app (rev l') (Datatypes.cons a Datatypes.nil)))",
                    "_global_length_app : forall l1 l2 : list ?A,\n       eq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))\nwhere\n?A : [A : Type\n      l : list A\n      a : A\n      l' : list A\n      H : eq (length l') (length (rev l')) |- Type]"
                ],
                "tactic_res": [
                    "c6_goal : eq (S (length l'))\n  (Init.Nat.add (length (rev l'))\n     (length (Datatypes.cons a Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c6_goal : eq (S (length l'))\n  (Init.Nat.add (length (rev l'))\n     (length (Datatypes.cons a Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (S (length l')) (Init.Nat.add (length (rev l')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (S (length l')) (Init.Nat.add (length (rev l')) 1)",
                    "_global_plus_n_Sm : forall n m : nat, eq (S (Init.Nat.add n m)) (Init.Nat.add n (S m))"
                ],
                "tactic_res": [
                    "c8_goal : eq (S (length l')) (S (Init.Nat.add (length (rev l')) 0))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : eq (S (length l')) (S (Init.Nat.add (length (rev l')) 0))",
                    "c4_H : eq (length l') (length (rev l'))"
                ],
                "tactic_res": [
                    "c9_goal : eq (S (length (rev l'))) (S (Init.Nat.add (length (rev l')) 0))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c9_goal : eq (S (length (rev l'))) (S (Init.Nat.add (length (rev l')) 0))",
                    "c4_l' : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cons_to_app_end",
        "proof": [
            {
                "tactic_sig": "Theorem cons_to_app_end : forall { A : Type } ( l : list A ) ( a : A ) , exists b : A , exists l' : list A , a :: l = l' ++ b :: nil .",
                "tactic_sig_no_out_arg": "Theorem cons_to_app_end : forall { A : Type } ( l : list A ) ( a : A ) , exists b : A , exists l' : list A , a :: l = l' ++ b :: nil .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l : list A) (a : A),\nex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (Datatypes.cons a l) (app l' (Datatypes.cons b Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros A l a .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l : list A) (a : A),\nex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (Datatypes.cons a l) (app l' (Datatypes.cons b Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (Datatypes.cons a l) (app l' (Datatypes.cons b Datatypes.nil))))",
                    "c2_A : Type",
                    "c2_l : list A",
                    "c2_a : A"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i :: _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i :: _i ) ) .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (Datatypes.cons a l) (app l' (Datatypes.cons b Datatypes.nil))))",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l",
                    "c2_a : A",
                    "c2_l : list A"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (rev (Datatypes.cons a l)))\n        (app l' (Datatypes.cons b Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "assert ( H : 0 < length ( rev ( _i :: _i ) ) ) by ( rewrite <- length_rev ; simpl ; auto with arith ) .",
                "tactic_sig_no_out_arg": "assert ( H : 0 < length ( rev ( _i :: _i ) ) ) by ( rewrite <- length_rev ; simpl ; auto with arith ) .",
                "tactic_args": [
                    "c2_a : A",
                    "c2_l : list A",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c3_H : lt 0 (length (rev (Datatypes.cons a l)))"
                ]
            },
            {
                "tactic_sig": "destruct ( rev ( _i :: _i ) ) as [ | a0 l0 ] .",
                "tactic_sig_no_out_arg": "destruct ( rev ( _i :: _i ) ) as [ | a0 l0 ] .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (rev (Datatypes.cons a l)))\n        (app l' (Datatypes.cons b Datatypes.nil))))",
                    "c2_a : A",
                    "c2_l : list A",
                    "c3_H : lt 0 (length (rev (Datatypes.cons a l)))",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev Datatypes.nil) (app l' (Datatypes.cons b Datatypes.nil))))",
                    "c4_H : lt 0 (length Datatypes.nil)",
                    "c5_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (Datatypes.cons a0 l0))\n        (app l' (Datatypes.cons b Datatypes.nil))))",
                    "c5_H : lt 0 (length (Datatypes.cons a0 l0))",
                    "c5_l0 : list A",
                    "c5_a0 : A"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev Datatypes.nil) (app l' (Datatypes.cons b Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c6_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq Datatypes.nil (app l' (Datatypes.cons b Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.nlt_0_r 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.nlt_0_r 0 ) .",
                "tactic_args": [
                    "c6_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq Datatypes.nil (app l' (Datatypes.cons b Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c7_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : lt 0 0",
                    "c4_H : lt 0 (length Datatypes.nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , ( rev _i ) .",
                "tactic_sig_no_out_arg": "exists _i , ( rev _i ) .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (Datatypes.cons a0 l0))\n        (app l' (Datatypes.cons b Datatypes.nil))))",
                    "c5_a0 : A",
                    "c5_l0 : list A"
                ],
                "tactic_res": [
                    "c8_goal : eq (rev (Datatypes.cons a0 l0))\n  (app (rev l0) (Datatypes.cons a0 Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (rev (Datatypes.cons a0 l0))\n  (app (rev l0) (Datatypes.cons a0 Datatypes.nil))"
                ],
                "tactic_res": [
                    "c9_goal : eq (app (rev l0) (Datatypes.cons a0 Datatypes.nil))\n  (app (rev l0) (Datatypes.cons a0 Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (app (rev l0) (Datatypes.cons a0 Datatypes.nil))\n  (app (rev l0) (Datatypes.cons a0 Datatypes.nil))",
                    "c5_l0 : list A",
                    "c5_a0 : A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_same",
        "proof": [
            {
                "tactic_sig": "Theorem last_same : forall { A : Type } ( a b : A ) ( l1 l2 : list A ) , l1 ++ a :: nil = l2 ++ b :: nil -> l1 = l2 /\\ a = b .",
                "tactic_sig_no_out_arg": "Theorem last_same : forall { A : Type } ( a b : A ) ( l1 l2 : list A ) , l1 ++ a :: nil = l2 ++ b :: nil -> l1 = l2 /\\ a = b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (a b : A) (l1 l2 : list A)\n  (_ : eq (app l1 (Datatypes.cons a Datatypes.nil))\n         (app l2 (Datatypes.cons b Datatypes.nil))),\nand (eq l1 l2) (eq a b)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros A a b l1 l2 H .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (a b : A) (l1 l2 : list A)\n  (_ : eq (app l1 (Datatypes.cons a Datatypes.nil))\n         (app l2 (Datatypes.cons b Datatypes.nil))),\nand (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c2_goal : and (eq l1 l2) (eq a b)",
                    "c2_A : Type",
                    "c2_a : A",
                    "c2_b : A",
                    "c2_l1 : list A",
                    "c2_l2 : list A",
                    "c2_H : eq (app l1 (Datatypes.cons a Datatypes.nil))\n  (app l2 (Datatypes.cons b Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "assert ( e : _i :: rev _i = _i :: rev _i ) .",
                "tactic_sig_no_out_arg": "assert ( e : _i :: rev _i = _i :: rev _i ) .",
                "tactic_args": [
                    "c2_goal : and (eq l1 l2) (eq a b)",
                    "c2_a : A",
                    "c2_l1 : list A",
                    "c2_b : A",
                    "c2_l2 : list A"
                ],
                "tactic_res": [
                    "c3_goal : eq (Datatypes.cons a (rev l1)) (Datatypes.cons b (rev l2))",
                    "c4_goal : and (eq l1 l2) (eq a b)",
                    "c4_e : eq (Datatypes.cons a (rev l1)) (Datatypes.cons b (rev l2))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite <- rev_unit .",
                "tactic_sig_no_out_arg": "repeat rewrite <- rev_unit .",
                "tactic_args": [
                    "c3_goal : eq (Datatypes.cons a (rev l1)) (Datatypes.cons b (rev l2))"
                ],
                "tactic_res": [
                    "c5_goal : eq (rev (app l1 (Datatypes.cons a Datatypes.nil)))\n  (rev (app l2 (Datatypes.cons b Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq (rev (app l1 (Datatypes.cons a Datatypes.nil)))\n  (rev (app l2 (Datatypes.cons b Datatypes.nil)))",
                    "c2_H : eq (app l1 (Datatypes.cons a Datatypes.nil))\n  (app l2 (Datatypes.cons b Datatypes.nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c4_goal : and (eq l1 l2) (eq a b)",
                    "c4_e : eq (Datatypes.cons a (rev l1)) (Datatypes.cons b (rev l2))"
                ],
                "tactic_res": [
                    "c6_goal : forall (_ : eq (rev l1) (rev l2)) (_ : eq a b), and (eq l1 l2) (eq a b)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H1 H2 .",
                "tactic_args": [
                    "c6_goal : forall (_ : eq (rev l1) (rev l2)) (_ : eq a b), and (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c7_goal : and (eq l1 l2) (eq a b)",
                    "c7_H1 : eq (rev l1) (rev l2)",
                    "c7_H2 : eq a b"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c8_goal : eq l1 l2",
                    "c9_goal : eq a b"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq a b",
                    "c7_H2 : eq a b",
                    "c2_a : A",
                    "c2_b : A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) , _i .",
                "tactic_args": [
                    "c8_goal : eq l1 l2",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l",
                    "c2_l1 : list A",
                    "c7_H1 : eq (rev l1) (rev l2)"
                ],
                "tactic_res": [
                    "c10_goal : eq (rev (rev l2)) l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (rev (rev l2)) l2",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_remove_oc_aux",
        "proof": [
            {
                "tactic_sig": "Theorem wp_remove_oc_aux : forall l : list par , wp l -> forall l1 l2 : list par , l1 ++ l2 = l -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_remove_oc_aux : forall l : list par , wp l -> forall l1 l2 : list par , l1 ++ l2 = l -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n  (_ : eq (app l1 l2) l),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n  (_ : eq (app l1 l2) l),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) Datatypes.nil),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l1),\n       wp (app l3 (Datatypes.cons open (Datatypes.cons close l4))))\n  (_ : wp l2)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l2),\n       wp (app l3 (Datatypes.cons open (Datatypes.cons close l4))))\n  (l3 l4 : list par) (_ : eq (app l3 l4) (app l1 l2)),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\n       wp (app l1 (Datatypes.cons open (Datatypes.cons close l2))))\n  (l1 l2 : list par)\n  (_ : eq (app l1 l2)\n         (Datatypes.cons open\n            (app l (Datatypes.cons close Datatypes.nil)))),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) Datatypes.nil),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c6_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_H1 : eq (app l1 l2) Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "elim ( app_eq_nil _ _ _i ) .",
                "tactic_sig_no_out_arg": "elim ( app_eq_nil _ _ _i ) .",
                "tactic_args": [
                    "c6_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c6_H1 : eq (app l1 l2) Datatypes.nil"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : eq l1 Datatypes.nil) (_ : eq l2 Datatypes.nil),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq1 Heq2 .",
                "tactic_args": [
                    "c7_goal : forall (_ : eq l1 Datatypes.nil) (_ : eq l2 Datatypes.nil),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c8_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c8_Heq1 : eq l1 Datatypes.nil",
                    "c8_Heq2 : eq l2 Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c8_Heq1 : eq l1 Datatypes.nil"
                ],
                "tactic_res": [
                    "c9_goal : wp (app Datatypes.nil (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : wp (app Datatypes.nil (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c8_Heq2 : eq l2 Datatypes.nil"
                ],
                "tactic_res": [
                    "c10_goal : wp\n  (app Datatypes.nil\n     (Datatypes.cons open (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp\n  (app Datatypes.nil\n     (Datatypes.cons open (Datatypes.cons close Datatypes.nil)))",
                    "_global_wp_oc : wp (Datatypes.cons open (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 Hp1 Hr1 Hp2 Hr2 l3 l4 Heq .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l1),\n       wp (app l3 (Datatypes.cons open (Datatypes.cons close l4))))\n  (_ : wp l2)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l2),\n       wp (app l3 (Datatypes.cons open (Datatypes.cons close l4))))\n  (l3 l4 : list par) (_ : eq (app l3 l4) (app l1 l2)),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))"
                ],
                "tactic_res": [
                    "c11_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c11_l1 : list par",
                    "c11_l2 : list par",
                    "c11_Hp1 : wp l1",
                    "c11_Hr1 : forall (l2 l3 : list par) (_ : eq (app l2 l3) l1),\nwp (app l2 (Datatypes.cons open (Datatypes.cons close l3)))",
                    "c11_Hp2 : wp l2",
                    "c11_Hr2 : forall (l1 l3 : list par) (_ : eq (app l1 l3) l2),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l3)))",
                    "c11_l3 : list par",
                    "c11_l4 : list par",
                    "c11_Heq : eq (app l3 l4) (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "elim app_decompose with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim app_decompose with ( 1 := _i ) .",
                "tactic_args": [
                    "c11_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c11_Heq : eq (app l3 l4) (app l1 l2)"
                ],
                "tactic_res": [
                    "c12_goal : forall\n  _ : ex\n        (fun l1' : list par =>\n         and (eq l3 (app l1 l1')) (eq l2 (app l1' l4))),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c13_goal : forall\n  _ : ex\n        (fun a : par =>\n         ex\n           (fun l2' : list par =>\n            and (eq l1 (app l3 (Datatypes.cons a l2')))\n              (eq l4 (app (Datatypes.cons a l2') l2)))),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))"
                ]
            },
            {
                "tactic_sig": "intros [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ l1' [ Heq1 Heq2 ] ] .",
                "tactic_args": [
                    "c12_goal : forall\n  _ : ex\n        (fun l1' : list par =>\n         and (eq l3 (app l1 l1')) (eq l2 (app l1' l4))),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))"
                ],
                "tactic_res": [
                    "c14_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c14_l1' : list par",
                    "c14_Heq1 : eq l3 (app l1 l1')",
                    "c14_Heq2 : eq l2 (app l1' l4)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i .",
                "tactic_args": [
                    "c14_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c14_Heq1 : eq l3 (app l1 l1')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c15_goal : wp (app l1 (app l1' (Datatypes.cons open (Datatypes.cons close l4))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : wp (app l1 (app l1' (Datatypes.cons open (Datatypes.cons close l4))))",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c16_goal : wp l1",
                    "c17_goal : wp (app l1' (Datatypes.cons open (Datatypes.cons close l4)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : wp l1",
                    "c11_Hp1 : wp l1",
                    "c11_l1 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : wp (app l1' (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c14_Heq2 : eq l2 (app l1' l4)",
                    "c14_l1' : list par",
                    "c11_l4 : list par",
                    "c11_Hr2 : forall (l1 l3 : list par) (_ : eq (app l1 l3) l2),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l3)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o [ _o [ _o _o ] ] ] .",
                "tactic_sig_no_out_arg": "intros [ a' [ l2' [ Heq1 Heq2 ] ] ] .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : ex\n        (fun a : par =>\n         ex\n           (fun l2' : list par =>\n            and (eq l1 (app l3 (Datatypes.cons a l2')))\n              (eq l4 (app (Datatypes.cons a l2') l2)))),\nwp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))"
                ],
                "tactic_res": [
                    "c18_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c18_a' : par",
                    "c18_l2' : list par",
                    "c18_Heq1 : eq l1 (app l3 (Datatypes.cons a' l2'))",
                    "c18_Heq2 : eq l4 (app (Datatypes.cons a' l2') l2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : wp (app l3 (Datatypes.cons open (Datatypes.cons close l4)))",
                    "c18_Heq2 : eq l4 (app (Datatypes.cons a' l2') l2)"
                ],
                "tactic_res": [
                    "c19_goal : wp\n  (app l3\n     (Datatypes.cons open\n        (Datatypes.cons close (app (Datatypes.cons a' l2') l2))))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite app_comm_cons .",
                "tactic_sig_no_out_arg": "repeat rewrite app_comm_cons .",
                "tactic_args": [
                    "c19_goal : wp\n  (app l3\n     (Datatypes.cons open\n        (Datatypes.cons close (app (Datatypes.cons a' l2') l2))))"
                ],
                "tactic_res": [
                    "c20_goal : wp\n  (app l3\n     (app\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons a' l2'))) l2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : wp\n  (app l3\n     (app\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons a' l2'))) l2))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c21_goal : wp\n  (app\n     (app l3\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons a' l2')))) l2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : wp\n  (app\n     (app l3\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons a' l2')))) l2)",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c22_goal : wp\n  (app l3\n     (Datatypes.cons open\n        (Datatypes.cons close (Datatypes.cons a' l2'))))",
                    "c23_goal : wp l2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : wp\n  (app l3\n     (Datatypes.cons open\n        (Datatypes.cons close (Datatypes.cons a' l2'))))",
                    "c18_Heq1 : eq l1 (app l3 (Datatypes.cons a' l2'))",
                    "c18_l2' : list par",
                    "c18_a' : par",
                    "c11_l3 : list par",
                    "c11_Hr1 : forall (l2 l3 : list par) (_ : eq (app l2 l3) l1),\nwp (app l2 (Datatypes.cons open (Datatypes.cons close l3)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : wp l2",
                    "c11_Hp2 : wp l2",
                    "c11_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hp'' Hrec l1 .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\n       wp (app l1 (Datatypes.cons open (Datatypes.cons close l2))))\n  (l1 l2 : list par)\n  (_ : eq (app l1 l2)\n         (Datatypes.cons open\n            (app l (Datatypes.cons close Datatypes.nil)))),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c24_goal : forall (l2 : list par)\n  (_ : eq (app l1 l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c24_l' : list par",
                    "c24_Hp'' : wp l'",
                    "c24_Hrec : forall (l1 l2 : list par) (_ : eq (app l1 l2) l'),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c24_l1 : list par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c24_goal : forall (l2 : list par)\n  (_ : eq (app l1 l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c24_l1 : list par"
                ],
                "tactic_res": [
                    "c25_goal : forall (l2 : list par)\n  (_ : eq (app Datatypes.nil l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (app Datatypes.nil (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c26_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (app (Datatypes.cons p l) l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (app (Datatypes.cons p l)\n     (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c25_goal : forall (l2 : list par)\n  (_ : eq (app Datatypes.nil l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (app Datatypes.nil (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c27_goal : forall (l2 : list par)\n  (_ : eq l2\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (Datatypes.cons open (Datatypes.cons close l2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l2 Heq .",
                "tactic_args": [
                    "c27_goal : forall (l2 : list par)\n  (_ : eq l2\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp (Datatypes.cons open (Datatypes.cons close l2))"
                ],
                "tactic_res": [
                    "c28_goal : wp (Datatypes.cons open (Datatypes.cons close l2))",
                    "c28_l2 : list par",
                    "c28_Heq : eq l2\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : wp (Datatypes.cons open (Datatypes.cons close l2))",
                    "c28_Heq : eq l2\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c29_goal : wp\n  (Datatypes.cons open\n     (Datatypes.cons close\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil)))))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: nil ++ close :: open :: _i ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: nil ++ close :: open :: _i ++ close :: nil ) ) .",
                "tactic_args": [
                    "c29_goal : wp\n  (Datatypes.cons open\n     (Datatypes.cons close\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil)))))",
                    "c24_l' : list par"
                ],
                "tactic_res": [
                    "c30_goal : wp\n  (Datatypes.cons open\n     (app Datatypes.nil\n        (Datatypes.cons close\n           (Datatypes.cons open\n              (app l' (Datatypes.cons close Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : wp\n  (Datatypes.cons open\n     (app Datatypes.nil\n        (Datatypes.cons close\n           (Datatypes.cons open\n              (app l' (Datatypes.cons close Datatypes.nil))))))",
                    "c24_Hp'' : wp l'",
                    "c24_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c26_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (app (Datatypes.cons p l) l2)\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (app (Datatypes.cons p l)\n     (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c31_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (Datatypes.cons p (app l l2))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons p\n     (app l (Datatypes.cons open (Datatypes.cons close l2))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c l1' l2 .",
                "tactic_args": [
                    "c31_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (Datatypes.cons p (app l l2))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons p\n     (app l (Datatypes.cons open (Datatypes.cons close l2))))"
                ],
                "tactic_res": [
                    "c32_goal : forall\n  _ : eq (Datatypes.cons c (app l1' l2))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1' (Datatypes.cons open (Datatypes.cons close l2))))",
                    "c32_c : par",
                    "c32_l1' : list par",
                    "c32_l2 : list par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : eq (Datatypes.cons c (app l1' l2))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1' (Datatypes.cons open (Datatypes.cons close l2))))",
                    "c32_l2 : list par"
                ],
                "tactic_res": [
                    "c33_goal : forall\n  _ : eq (Datatypes.cons c (app l1' Datatypes.nil))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c34_goal : forall (p : par) (l : list par)\n  (_ : eq (Datatypes.cons c (app l1' (Datatypes.cons p l)))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons p l)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c33_goal : forall\n  _ : eq (Datatypes.cons c (app l1' Datatypes.nil))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c35_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c35_Heq : eq (Datatypes.cons c (app l1' Datatypes.nil))\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c35_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c35_Heq : eq (Datatypes.cons c (app l1' Datatypes.nil))\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c36_goal : forall\n  (_ : eq (app l1' Datatypes.nil)\n         (app l' (Datatypes.cons close Datatypes.nil))) \n  (_ : eq c open),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq1 Heq2 .",
                "tactic_args": [
                    "c36_goal : forall\n  (_ : eq (app l1' Datatypes.nil)\n         (app l' (Datatypes.cons close Datatypes.nil))) \n  (_ : eq c open),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))"
                ],
                "tactic_res": [
                    "c37_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c37_Heq1 : eq (app l1' Datatypes.nil)\n  (app l' (Datatypes.cons close Datatypes.nil))",
                    "c37_Heq2 : eq c open"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l Datatypes.nil) l",
                    "c37_Heq1 : eq (app l1' Datatypes.nil)\n  (app l' (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": [
                    "c37_Heq1 : eq l1' (app l' (Datatypes.cons close Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c37_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c37_Heq1 : eq l1' (app l' (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": [
                    "c38_goal : wp\n  (Datatypes.cons c\n     (app (app l' (Datatypes.cons close Datatypes.nil))\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c38_goal : wp\n  (Datatypes.cons c\n     (app (app l' (Datatypes.cons close Datatypes.nil))\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "c37_Heq2 : eq c open"
                ],
                "tactic_res": [
                    "c39_goal : wp\n  (Datatypes.cons open\n     (app (app l' (Datatypes.cons close Datatypes.nil))\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c39_goal : wp\n  (Datatypes.cons open\n     (app (app l' (Datatypes.cons close Datatypes.nil))\n        (Datatypes.cons open (Datatypes.cons close Datatypes.nil))))",
                    "_global_app_comm_cons : forall (A : Type) (x y : list A) (a : A),\n       eq (Datatypes.cons a (app x y)) (app (Datatypes.cons a x) y)"
                ],
                "tactic_res": [
                    "c40_goal : wp\n  (app\n     (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))\n     (Datatypes.cons open (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : wp\n  (app\n     (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))\n     (Datatypes.cons open (Datatypes.cons close Datatypes.nil)))",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c41_goal : wp (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))",
                    "c42_goal : wp (Datatypes.cons open (Datatypes.cons close Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : wp (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))",
                    "c24_Hp'' : wp l'",
                    "c24_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : wp (Datatypes.cons open (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros c' l2' .",
                "tactic_args": [
                    "c34_goal : forall (p : par) (l : list par)\n  (_ : eq (Datatypes.cons c (app l1' (Datatypes.cons p l)))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons p l)))))"
                ],
                "tactic_res": [
                    "c43_goal : forall\n  _ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))",
                    "c43_c' : par",
                    "c43_l2' : list par"
                ]
            },
            {
                "tactic_sig": "elim ( cons_to_app_end _i _i ) .",
                "tactic_sig_no_out_arg": "elim ( cons_to_app_end _i _i ) .",
                "tactic_args": [
                    "c43_goal : forall\n  _ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))",
                    "c43_l2' : list par",
                    "c43_c' : par"
                ],
                "tactic_res": [
                    "c44_goal : forall (x : par)\n  (_ : ex\n         (fun l' : list par =>\n          eq (Datatypes.cons c' l2')\n            (app l' (Datatypes.cons x Datatypes.nil))))\n  (_ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros c'' [ l2'' Heq ] .",
                "tactic_args": [
                    "c44_goal : forall (x : par)\n  (_ : ex\n         (fun l' : list par =>\n          eq (Datatypes.cons c' l2')\n            (app l' (Datatypes.cons x Datatypes.nil))))\n  (_ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n         (Datatypes.cons open\n            (app l' (Datatypes.cons close Datatypes.nil)))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))"
                ],
                "tactic_res": [
                    "c45_goal : forall\n  _ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))",
                    "c45_c'' : par",
                    "c45_l2'' : list par",
                    "c45_Heq : eq (Datatypes.cons c' l2')\n  (app l2'' (Datatypes.cons c'' Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c45_goal : forall\n  _ : eq (Datatypes.cons c (app l1' (Datatypes.cons c' l2')))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close (Datatypes.cons c' l2')))))",
                    "c45_Heq : eq (Datatypes.cons c' l2')\n  (app l2'' (Datatypes.cons c'' Datatypes.nil))"
                ],
                "tactic_res": [
                    "c46_goal : forall\n  _ : eq\n        (Datatypes.cons c\n           (app l1' (app l2'' (Datatypes.cons c'' Datatypes.nil))))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c46_goal : forall\n  _ : eq\n        (Datatypes.cons c\n           (app l1' (app l2'' (Datatypes.cons c'' Datatypes.nil))))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c47_goal : forall\n  _ : eq\n        (Datatypes.cons c\n           (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil)))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq1 .",
                "tactic_args": [
                    "c47_goal : forall\n  _ : eq\n        (Datatypes.cons c\n           (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil)))\n        (Datatypes.cons open\n           (app l' (Datatypes.cons close Datatypes.nil))),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ],
                "tactic_res": [
                    "c48_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c48_Heq1 : eq\n  (Datatypes.cons c\n     (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil)))\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c48_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c48_Heq1 : eq\n  (Datatypes.cons c\n     (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil)))\n  (Datatypes.cons open (app l' (Datatypes.cons close Datatypes.nil)))"
                ],
                "tactic_res": [
                    "c49_goal : forall\n  (_ : eq (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil))\n         (app l' (Datatypes.cons close Datatypes.nil))) \n  (_ : eq c open),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq2 Heq3 .",
                "tactic_args": [
                    "c49_goal : forall\n  (_ : eq (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil))\n         (app l' (Datatypes.cons close Datatypes.nil))) \n  (_ : eq c open),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ],
                "tactic_res": [
                    "c50_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c50_Heq2 : eq (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil))\n  (app l' (Datatypes.cons close Datatypes.nil))",
                    "c50_Heq3 : eq c open"
                ]
            },
            {
                "tactic_sig": "elim last_same with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim last_same with ( 1 := _i ) .",
                "tactic_args": [
                    "c50_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c50_Heq2 : eq (app (app l1' l2'') (Datatypes.cons c'' Datatypes.nil))\n  (app l' (Datatypes.cons close Datatypes.nil))"
                ],
                "tactic_res": [
                    "c51_goal : forall (_ : eq (app l1' l2'') l') (_ : eq c'' close),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq4 Heq5 .",
                "tactic_args": [
                    "c51_goal : forall (_ : eq (app l1' l2'') l') (_ : eq c'' close),\nwp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))"
                ],
                "tactic_res": [
                    "c52_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c52_Heq4 : eq (app l1' l2'') l'",
                    "c52_Heq5 : eq c'' close"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c52_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons c'' Datatypes.nil))))))",
                    "c52_Heq5 : eq c'' close"
                ],
                "tactic_res": [
                    "c53_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons close Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c53_goal : wp\n  (Datatypes.cons c\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons close Datatypes.nil))))))",
                    "c50_Heq3 : eq c open"
                ],
                "tactic_res": [
                    "c54_goal : wp\n  (Datatypes.cons open\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons close Datatypes.nil))))))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: _i ++ ( open :: close :: _i ) ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: _i ++ ( open :: close :: _i ) ++ close :: nil ) ) .",
                "tactic_args": [
                    "c54_goal : wp\n  (Datatypes.cons open\n     (app l1'\n        (Datatypes.cons open\n           (Datatypes.cons close\n              (app l2'' (Datatypes.cons close Datatypes.nil))))))",
                    "c32_l1' : list par",
                    "c45_l2'' : list par"
                ],
                "tactic_res": [
                    "c55_goal : wp\n  (Datatypes.cons open\n     (app l1'\n        (app (Datatypes.cons open (Datatypes.cons close l2''))\n           (Datatypes.cons close Datatypes.nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c55_goal : wp\n  (Datatypes.cons open\n     (app l1'\n        (app (Datatypes.cons open (Datatypes.cons close l2''))\n           (Datatypes.cons close Datatypes.nil))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c56_goal : wp\n  (Datatypes.cons open\n     (app (app l1' (Datatypes.cons open (Datatypes.cons close l2'')))\n        (Datatypes.cons close Datatypes.nil)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : wp\n  (Datatypes.cons open\n     (app (app l1' (Datatypes.cons open (Datatypes.cons close l2'')))\n        (Datatypes.cons close Datatypes.nil)))",
                    "c52_Heq4 : eq (app l1' l2'') l'",
                    "c45_l2'' : list par",
                    "c32_l1' : list par",
                    "c24_Hrec : forall (l1 l2 : list par) (_ : eq (app l1 l2) l'),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_remove_oc",
        "proof": [
            {
                "tactic_sig": "Theorem wp_remove_oc : forall l1 l2 : list par , wp ( l1 ++ l2 ) -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_remove_oc : forall l1 l2 : list par , wp ( l1 ++ l2 ) -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\nwp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H : wp (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( l := _i ++ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( l := _i ++ _i ) .",
                "tactic_args": [
                    "c2_goal : wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "_global_wp_remove_oc_aux : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n         (_ : eq (app l1 l2) l),\n       wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp (app l1 l2)",
                    "c4_goal : eq (app l1 l2) (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp (app l1 l2)",
                    "c2_H : wp (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (app l1 l2) (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "make_list_end",
        "proof": [
            {
                "tactic_sig": "Theorem make_list_end : forall ( A : Type ) ( a : A ) ( n : nat ) ( l : list A ) , make_list A a ( S n ) ++ l = make_list A a n ++ a :: l .",
                "tactic_sig_no_out_arg": "Theorem make_list_end : forall ( A : Type ) ( a : A ) ( n : nat ) ( l : list A ) , make_list A a ( S n ) ++ l = make_list A a n ++ a :: l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (a : A) (n : nat) (l : list A),\neq (app (make_list A a (S n)) l)\n  (app (make_list A a n) (Datatypes.cons a l))"
                ]
            },
            {
                "tactic_sig": "simple induction n .",
                "tactic_sig_no_out_arg": "simple induction n .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (a : A) (n : nat) (l : list A),\neq (app (make_list A a (S n)) l)\n  (app (make_list A a n) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c2_goal : forall l : list A,\neq (app (make_list A a 1) l)\n  (app (make_list A a 0) (Datatypes.cons a l))",
                    "c2_n : nat",
                    "c2_a : A",
                    "c2_A : Type",
                    "c3_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (Datatypes.cons a l))) \n  (l : list A),\neq (app (make_list A a (S (S n))) l)\n  (app (make_list A a (S n)) (Datatypes.cons a l))",
                    "c3_n : nat",
                    "c3_a : A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall l : list A,\neq (app (make_list A a 1) l)\n  (app (make_list A a 0) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c4_goal : forall l : list A, eq (Datatypes.cons a l) (Datatypes.cons a l)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (Datatypes.cons a l))) \n  (l : list A),\neq (app (make_list A a (S (S n))) l)\n  (app (make_list A a (S n)) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c5_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (Datatypes.cons a (app (make_list A a n) l))\n         (app (make_list A a n) (Datatypes.cons a l))) \n  (l : list A),\neq (Datatypes.cons a (Datatypes.cons a (app (make_list A a n) l)))\n  (Datatypes.cons a (app (make_list A a n) (Datatypes.cons a l)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : forall l : list A, eq (Datatypes.cons a l) (Datatypes.cons a l)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n' H l .",
                "tactic_args": [
                    "c5_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (Datatypes.cons a (app (make_list A a n) l))\n         (app (make_list A a n) (Datatypes.cons a l))) \n  (l : list A),\neq (Datatypes.cons a (Datatypes.cons a (app (make_list A a n) l)))\n  (Datatypes.cons a (app (make_list A a n) (Datatypes.cons a l)))"
                ],
                "tactic_res": [
                    "c6_goal : eq (Datatypes.cons a (Datatypes.cons a (app (make_list A a n') l)))\n  (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))",
                    "c6_n' : nat",
                    "c6_H : forall l : list A,\neq (Datatypes.cons a (app (make_list A a n') l))\n  (app (make_list A a n') (Datatypes.cons a l))",
                    "c6_l : list A"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (Datatypes.cons a (Datatypes.cons a (app (make_list A a n') l)))\n  (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))",
                    "c6_H : forall l : list A,\neq (Datatypes.cons a (app (make_list A a n') l))\n  (app (make_list A a n') (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c7_goal : eq (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))\n  (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : eq (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))\n  (Datatypes.cons a (app (make_list A a n') (Datatypes.cons a l)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_sound_aux",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_sound_aux : forall ( l : list par ) ( n : nat ) , recognize n l = true -> wp ( make_list _ open n ++ l ) .",
                "tactic_sig_no_out_arg": "Theorem recognize_sound_aux : forall ( l : list par ) ( n : nat ) , recognize n l = true -> wp ( make_list _ open n ++ l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (n : nat) (_ : eq (recognize n l) true),\nwp (app (make_list par open n) l)"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (n : nat) (_ : eq (recognize n l) true),\nwp (app (make_list par open n) l)"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : nat) (_ : eq (recognize n Datatypes.nil) true),\nwp (app (make_list par open n) Datatypes.nil)",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize n (Datatypes.cons a l)) true),\nwp (app (make_list par open n) (Datatypes.cons a l))",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (n : nat) (_ : eq (recognize n Datatypes.nil) true),\nwp (app (make_list par open n) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat)\n  (_ : eq match n with\n          | 0 => true\n          | S _ => false\n          end true), wp (app (make_list par open n) Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize n (Datatypes.cons a l)) true),\nwp (app (make_list par open n) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c5_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true),\nwp (app (make_list par open n) (Datatypes.cons a l))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c4_goal : forall (n : nat)\n  (_ : eq match n with\n          | 0 => true\n          | S _ => false\n          end true), wp (app (make_list par open n) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq match n with\n              | 0 => true\n              | S _ => false\n              end true, wp (app (make_list par open n) Datatypes.nil)",
                    "c6_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c6_goal : forall _ : eq match n with\n              | 0 => true\n              | S _ => false\n              end true, wp (app (make_list par open n) Datatypes.nil)",
                    "c6_n : nat"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq true true, wp (app (make_list par open 0) Datatypes.nil)",
                    "c8_goal : forall (n : nat) (_ : eq false true),\nwp (app (make_list par open (S n)) Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall _ : eq true true, wp (app (make_list par open 0) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq true true, wp Datatypes.nil"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall _ : eq true true, wp Datatypes.nil"
                ],
                "tactic_res": [
                    "c10_goal : wp Datatypes.nil",
                    "c10_H : eq true true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp Datatypes.nil",
                    "_global_wp_nil : wp Datatypes.nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n' H .",
                "tactic_args": [
                    "c8_goal : forall (n : nat) (_ : eq false true),\nwp (app (make_list par open (S n)) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c11_goal : wp (app (make_list par open (S n')) Datatypes.nil)",
                    "c11_n' : nat",
                    "c11_H : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c11_goal : wp (app (make_list par open (S n')) Datatypes.nil)",
                    "c11_H : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c5_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true),\nwp (app (make_list par open n) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c12_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true),\nwp (app (make_list par open n) (Datatypes.cons a l))",
                    "c12_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c12_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true),\nwp (app (make_list par open n) (Datatypes.cons a l))",
                    "c12_a : par"
                ],
                "tactic_res": [
                    "c13_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize (S n) l) true),\nwp (app (make_list par open n) (Datatypes.cons open l))",
                    "c14_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq match n with\n          | 0 => false\n          | S n' => recognize n' l\n          end true),\nwp (app (make_list par open n) (Datatypes.cons close l))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c12_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c12_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' H n H0 .",
                "tactic_args": [
                    "c13_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize (S n) l) true),\nwp (app (make_list par open n) (Datatypes.cons open l))"
                ],
                "tactic_res": [
                    "c15_goal : wp (app (make_list par open n) (Datatypes.cons open l'))",
                    "c15_l' : list par",
                    "c15_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c15_n : nat",
                    "c15_H0 : eq (recognize (S n) l') true"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c15_goal : wp (app (make_list par open n) (Datatypes.cons open l'))",
                    "_global_make_list_end : forall (A : Type) (a : A) (n : nat) (l : list A),\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c16_goal : wp (app (make_list par open (S n)) l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : wp (app (make_list par open (S n)) l')",
                    "c15_H0 : eq (recognize (S n) l') true",
                    "c15_n : nat",
                    "c15_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c15_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' H n .",
                "tactic_args": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq match n with\n          | 0 => false\n          | S n' => recognize n' l\n          end true),\nwp (app (make_list par open n) (Datatypes.cons close l))"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : eq match n with\n         | 0 => false\n         | S n' => recognize n' l'\n         end true,\nwp (app (make_list par open n) (Datatypes.cons close l'))",
                    "c17_l' : list par",
                    "c17_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c17_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : eq match n with\n         | 0 => false\n         | S n' => recognize n' l'\n         end true,\nwp (app (make_list par open n) (Datatypes.cons close l'))",
                    "c17_n : nat"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : eq false true,\nwp (app (make_list par open 0) (Datatypes.cons close l'))",
                    "c19_goal : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open (S n)) (Datatypes.cons close l'))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c17_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c17_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H' .",
                "tactic_args": [
                    "c18_goal : forall _ : eq false true,\nwp (app (make_list par open 0) (Datatypes.cons close l'))"
                ],
                "tactic_res": [
                    "c20_goal : wp (app (make_list par open 0) (Datatypes.cons close l'))",
                    "c20_H' : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c20_goal : wp (app (make_list par open 0) (Datatypes.cons close l'))",
                    "c20_H' : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H0 .",
                "tactic_args": [
                    "c19_goal : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open (S n)) (Datatypes.cons close l'))"
                ],
                "tactic_res": [
                    "c21_goal : wp (app (make_list par open (S n)) (Datatypes.cons close l'))",
                    "c21_n : nat",
                    "c21_H0 : eq (recognize n l') true"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : wp (app (make_list par open (S n)) (Datatypes.cons close l'))",
                    "_global_make_list_end : forall (A : Type) (a : A) (n : nat) (l : list A),\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (Datatypes.cons a l))"
                ],
                "tactic_res": [
                    "c22_goal : wp\n  (app (make_list par open n)\n     (Datatypes.cons open (Datatypes.cons close l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : wp\n  (app (make_list par open n)\n     (Datatypes.cons open (Datatypes.cons close l')))",
                    "_global_wp_remove_oc : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\n       wp (app l1 (Datatypes.cons open (Datatypes.cons close l2)))"
                ],
                "tactic_res": [
                    "c23_goal : wp (app (make_list par open n) l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : wp (app (make_list par open n) l')",
                    "c21_H0 : eq (recognize n l') true",
                    "c21_n : nat",
                    "c17_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c17_l' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_sound",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_sound : forall l : list par , recognize 0 l = true -> wp l .",
                "tactic_sig_no_out_arg": "Theorem recognize_sound : forall l : list par , recognize 0 l = true -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : eq (recognize 0 l) true), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : eq (recognize 0 l) true), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_H : eq (recognize 0 l) true"
                ]
            },
            {
                "tactic_sig": "generalize ( recognize_sound_aux _ _ _i ) .",
                "tactic_sig_no_out_arg": "generalize ( recognize_sound_aux _ _ _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_H : eq (recognize 0 l) true"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : wp (app (make_list par open 0) l), wp l"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : wp (app (make_list par open 0) l), wp l"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : wp l, wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall _ : wp l, wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_reject_indep_t",
        "proof": [
            {
                "tactic_sig": "Theorem parse_reject_indep_t : forall ( l : list par ) ( s : list bin ) ( t : bin ) , parse s t l = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l = None .",
                "tactic_sig_no_out_arg": "Theorem parse_reject_indep_t : forall ( l : list par ) ( s : list bin ) ( t : bin ) , parse s t l = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (s : list bin) (t : bin)\n  (_ : eq (parse s t l) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l) None"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (s : list bin) (t : bin)\n  (_ : eq (parse s t l) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l) None"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t : bin) (_ : eq (parse s t Datatypes.nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' Datatypes.nil) None",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons a l)) None",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t : bin) (_ : eq (parse s t Datatypes.nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' Datatypes.nil) None"
                ],
                "tactic_res": [
                    "c4_goal : forall (t : bin) (_ : eq (parse s t Datatypes.nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' Datatypes.nil) None",
                    "c4_s : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (t : bin) (_ : eq (parse s t Datatypes.nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' Datatypes.nil) None",
                    "c4_s : list bin"
                ],
                "tactic_res": [
                    "c5_goal : forall (t : bin) (_ : eq (parse Datatypes.nil t Datatypes.nil) None)\n  (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length Datatypes.nil)),\neq (parse s' t' Datatypes.nil) None",
                    "c6_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse (Datatypes.cons b l) t Datatypes.nil) None)\n  (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length (Datatypes.cons b l))),\neq (parse s' t' Datatypes.nil) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (t : bin) (_ : eq (parse Datatypes.nil t Datatypes.nil) None)\n  (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length Datatypes.nil)),\neq (parse s' t' Datatypes.nil) None"
                ],
                "tactic_res": [
                    "c7_goal : forall (t : bin) (_ : eq (Some t) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') 0),\neq\n  match s' with\n  | Datatypes.nil => Some t'\n  | Datatypes.cons _ _ => None\n  end None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t H .",
                "tactic_args": [
                    "c7_goal : forall (t : bin) (_ : eq (Some t) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') 0),\neq\n  match s' with\n  | Datatypes.nil => Some t'\n  | Datatypes.cons _ _ => None\n  end None"
                ],
                "tactic_res": [
                    "c8_goal : forall (s' : list bin) (t' : bin) (_ : eq (length s') 0),\neq\n  match s' with\n  | Datatypes.nil => Some t'\n  | Datatypes.cons _ _ => None\n  end None",
                    "c8_t : bin",
                    "c8_H : eq (Some t) None"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c8_goal : forall (s' : list bin) (t' : bin) (_ : eq (length s') 0),\neq\n  match s' with\n  | Datatypes.nil => Some t'\n  | Datatypes.cons _ _ => None\n  end None",
                    "c8_H : eq (Some t) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t H s' .",
                "tactic_args": [
                    "c6_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse (Datatypes.cons b l) t Datatypes.nil) None)\n  (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length (Datatypes.cons b l))),\neq (parse s' t' Datatypes.nil) None"
                ],
                "tactic_res": [
                    "c9_goal : forall (t' : bin) (_ : eq (length s') (length (Datatypes.cons t0 s0))),\neq (parse s' t' Datatypes.nil) None",
                    "c9_t0 : bin",
                    "c9_s0 : list bin",
                    "c9_t : bin",
                    "c9_H : eq (parse (Datatypes.cons t0 s0) t Datatypes.nil) None",
                    "c9_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c9_goal : forall (t' : bin) (_ : eq (length s') (length (Datatypes.cons t0 s0))),\neq (parse s' t' Datatypes.nil) None",
                    "c9_s' : list bin"
                ],
                "tactic_res": [
                    "c10_goal : forall (t' : bin)\n  (_ : eq (length Datatypes.nil) (length (Datatypes.cons t0 s0))),\neq (parse Datatypes.nil t' Datatypes.nil) None",
                    "c11_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length (Datatypes.cons t0 s0))),\neq (parse (Datatypes.cons b l) t' Datatypes.nil) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall (t' : bin)\n  (_ : eq (length Datatypes.nil) (length (Datatypes.cons t0 s0))),\neq (parse Datatypes.nil t' Datatypes.nil) None"
                ],
                "tactic_res": [
                    "c12_goal : forall (t' : bin) (_ : eq 0 (S (length s0))), eq (Some t') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t' Hle .",
                "tactic_args": [
                    "c12_goal : forall (t' : bin) (_ : eq 0 (S (length s0))), eq (Some t') None"
                ],
                "tactic_res": [
                    "c13_goal : eq (Some t') None",
                    "c13_t' : bin",
                    "c13_Hle : eq 0 (S (length s0))"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c13_goal : eq (Some t') None",
                    "c13_Hle : eq 0 (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length (Datatypes.cons t0 s0))),\neq (parse (Datatypes.cons b l) t' Datatypes.nil) None"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : bin) (l : list bin) (_ : bin)\n  (_ : eq (S (length l)) (S (length s0))), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall (_ : bin) (l : list bin) (_ : bin)\n  (_ : eq (S (length l)) (S (length s0))), eq None None",
                    "c9_s0 : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons a l)) None"
                ],
                "tactic_res": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons a l)) None",
                    "c15_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons a l)) None",
                    "c15_a : par"
                ],
                "tactic_res": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons open l)) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons open l)) None",
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons close l)) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons close l)) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons open l)) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons open l)) None"
                ],
                "tactic_res": [
                    "c18_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse (Datatypes.cons t' s') L l) None"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c15_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c18_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse (Datatypes.cons t' s') L l) None"
                ],
                "tactic_res": [
                    "c19_goal : forall (t : bin) (_ : eq (parse (Datatypes.cons t s) L l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse (Datatypes.cons t' s') L l') None",
                    "c19_l' : list par",
                    "c19_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c19_s : list bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (Datatypes.cons close l)) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (Datatypes.cons close l)) None"
                ],
                "tactic_res": [
                    "c20_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t' s' => parse s' (N t' t) l\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l\n  end None"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c15_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c20_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t' s' => parse s' (N t' t) l\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l\n  end None"
                ],
                "tactic_res": [
                    "c21_goal : forall (t : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t' s' => parse s' (N t' t) l'\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c21_l' : list par",
                    "c21_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c21_s : list bin"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t H s' t' Hle .",
                "tactic_args": [
                    "c19_goal : forall (t : bin) (_ : eq (parse (Datatypes.cons t s) L l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse (Datatypes.cons t' s') L l') None"
                ],
                "tactic_res": [
                    "c22_goal : eq (parse (Datatypes.cons t' s') L l') None",
                    "c22_t : bin",
                    "c22_H : eq (parse (Datatypes.cons t s) L l') None",
                    "c22_s' : list bin",
                    "c22_t' : bin",
                    "c22_Hle : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c22_goal : eq (parse (Datatypes.cons t' s') L l') None",
                    "c19_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c22_H : eq (parse (Datatypes.cons t s) L l') None"
                ],
                "tactic_res": [
                    "c23_goal : eq (length (Datatypes.cons t' s')) (length (Datatypes.cons t s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : eq (length (Datatypes.cons t' s')) (length (Datatypes.cons t s))"
                ],
                "tactic_res": [
                    "c24_goal : eq (S (length s')) (S (length s))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c24_goal : eq (S (length s')) (S (length s))",
                    "c22_Hle : eq (length s') (length s)",
                    "c22_s' : list bin",
                    "c19_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c21_goal : forall (t : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t' s' => parse s' (N t' t) l'\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c21_s : list bin"
                ],
                "tactic_res": [
                    "c25_goal : forall (_ : bin) (_ : eq None None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length Datatypes.nil)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c26_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse l (N b t) l') None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (Datatypes.cons b l))),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t H s' .",
                "tactic_args": [
                    "c25_goal : forall (_ : bin) (_ : eq None None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length Datatypes.nil)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ],
                "tactic_res": [
                    "c27_goal : forall (t' : bin) (_ : eq (length s') (length Datatypes.nil)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c27_t : bin",
                    "c27_H : eq None None",
                    "c27_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c27_goal : forall (t' : bin) (_ : eq (length s') (length Datatypes.nil)),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c27_s' : list bin"
                ],
                "tactic_res": [
                    "c28_goal : forall (_ : bin) (_ : eq (length Datatypes.nil) (length Datatypes.nil)),\neq None None",
                    "c29_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length Datatypes.nil)),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall (_ : bin) (_ : eq (length Datatypes.nil) (length Datatypes.nil)),\neq None None"
                ],
                "tactic_res": [
                    "c30_goal : forall (_ : bin) (_ : eq 0 0), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : forall (_ : bin) (_ : eq 0 0), eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length Datatypes.nil)),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c31_goal : forall (b : bin) (l : list bin) (t' : bin) (_ : eq (S (length l)) 0),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t' Hle .",
                "tactic_args": [
                    "c31_goal : forall (b : bin) (l : list bin) (t' : bin) (_ : eq (S (length l)) 0),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c32_goal : eq (parse s0 (N t0 t') l') None",
                    "c32_t0 : bin",
                    "c32_s0 : list bin",
                    "c32_t' : bin",
                    "c32_Hle : eq (S (length s0)) 0"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c32_goal : eq (parse s0 (N t0 t') l') None",
                    "c32_Hle : eq (S (length s0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t H s' .",
                "tactic_args": [
                    "c26_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse l (N b t) l') None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (Datatypes.cons b l))),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ],
                "tactic_res": [
                    "c33_goal : forall (t' : bin) (_ : eq (length s') (length (Datatypes.cons t0 s0))),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c33_t0 : bin",
                    "c33_s0 : list bin",
                    "c33_t : bin",
                    "c33_H : eq (parse s0 (N t0 t) l') None",
                    "c33_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c33_goal : forall (t' : bin) (_ : eq (length s') (length (Datatypes.cons t0 s0))),\neq\n  match s' with\n  | Datatypes.nil => None\n  | Datatypes.cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c33_s' : list bin"
                ],
                "tactic_res": [
                    "c34_goal : forall (_ : bin)\n  (_ : eq (length Datatypes.nil) (length (Datatypes.cons t0 s0))),\neq None None",
                    "c35_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length (Datatypes.cons t0 s0))),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c34_goal : forall (_ : bin)\n  (_ : eq (length Datatypes.nil) (length (Datatypes.cons t0 s0))),\neq None None"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : bin) (_ : eq 0 (S (length s0))), eq None None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c35_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (Datatypes.cons b l)) (length (Datatypes.cons t0 s0))),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c37_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (S (length l)) (S (length s0))),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t' H0 .",
                "tactic_args": [
                    "c36_goal : forall (_ : bin) (_ : eq 0 (S (length s0))), eq None None"
                ],
                "tactic_res": [
                    "c38_goal : eq None None",
                    "c38_t' : bin",
                    "c38_H0 : eq 0 (S (length s0))"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c38_goal : eq None None",
                    "c38_H0 : eq 0 (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t'0 s'0 t' Hle .",
                "tactic_args": [
                    "c37_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (S (length l)) (S (length s0))),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c39_goal : eq (parse s'0 (N t'0 t') l') None",
                    "c39_t'0 : bin",
                    "c39_s'0 : list bin",
                    "c39_t' : bin",
                    "c39_Hle : eq (S (length s'0)) (S (length s0))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c39_goal : eq (parse s'0 (N t'0 t') l') None",
                    "c21_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c33_H : eq (parse s0 (N t0 t) l') None"
                ],
                "tactic_res": [
                    "c40_goal : eq (length s'0) (length s0)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c39_Hle : eq (S (length s'0)) (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c40_goal : eq (length s'0) (length s0)",
                    "c39_Hle : eq (S (length s'0)) (S (length s0))",
                    "c39_s'0 : list bin",
                    "c33_s0 : list bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_complete_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_complete_aux : forall l : list par , wp' l -> forall ( s : list bin ) ( t : bin ) ( l' : list par ) , parse s t ( l ++ l' ) = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l' = None .",
                "tactic_sig_no_out_arg": "Theorem parse_complete_aux : forall l : list par , wp' l -> forall ( s : list bin ) ( t : bin ) ( l' : list par ) , parse s t ( l ++ l' ) = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l' = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l) (s : list bin) (t : bin)\n  (l' : list par) (_ : eq (parse s t (app l l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l) (s : list bin) (t : bin)\n  (l' : list par) (_ : eq (parse s t (app l l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app Datatypes.nil l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c2_H : wp' l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l1 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (_ : wp' l2)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l2 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (s : list bin) (t : bin)\n  (l' : list par)\n  (_ : eq\n         (parse s t\n            (app\n               (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n               l')) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c3_H : wp' l",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app Datatypes.nil l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c4_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t l') None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t l') None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c5_goal : eq (parse s' t' l') None",
                    "c5_s : list bin",
                    "c5_t : bin",
                    "c5_l' : list par",
                    "c5_H0 : eq (parse s t l') None",
                    "c5_s' : list bin",
                    "c5_t' : bin",
                    "c5_H1 : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c5_goal : eq (parse s' t' l') None",
                    "_global_parse_reject_indep_t : forall (l : list par) (s : list bin) (t : bin)\n         (_ : eq (parse s t l) None) (s' : list bin) \n         (t' : bin) (_ : eq (length s') (length s)), \n       eq (parse s' t' l) None"
                ],
                "tactic_res": [
                    "c6_goal : eq (parse ?s ?t l') None",
                    "c7_goal : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : eq (parse ?s ?t l') None",
                    "c5_H0 : eq (parse s t l') None",
                    "c5_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (length s') (length s)",
                    "c5_H1 : eq (length s') (length s)",
                    "c5_s' : list bin",
                    "c5_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 Hp1 Hr1 Hp2 Hr2 s t l' Hrej s' t' Hle .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l1 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (_ : wp' l2)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l2 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (s : list bin) (t : bin)\n  (l' : list par)\n  (_ : eq\n         (parse s t\n            (app\n               (Datatypes.cons open (app l1 (Datatypes.cons close l2)))\n               l')) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c8_goal : eq (parse s' t' l') None",
                    "c8_l1 : list par",
                    "c8_l2 : list par",
                    "c8_Hp1 : wp' l1",
                    "c8_Hr1 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l1 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_Hp2 : wp' l2",
                    "c8_Hr2 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l2 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_s : list bin",
                    "c8_t : bin",
                    "c8_l' : list par",
                    "c8_Hrej : eq\n  (parse s t\n     (app (Datatypes.cons open (app l1 (Datatypes.cons close l2))) l'))\n  None",
                    "c8_s' : list bin",
                    "c8_t' : bin",
                    "c8_Hle : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ) ( _i := _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ) ( _i := _i _i _i ) .",
                "tactic_args": [
                    "c8_goal : eq (parse s' t' l') None",
                    "c8_Hr2 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l2 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_s : list bin",
                    "c8_s' : list bin",
                    "c8_t : bin",
                    "_global_N : forall (_ : bin) (_ : bin), bin",
                    "c8_t : bin",
                    "_global_L : bin"
                ],
                "tactic_res": [
                    "c9_goal : eq (parse s' (N t L) (app l2 l')) None",
                    "c10_goal : eq (length s') (length s')"
                ]
            },
            {
                "tactic_sig": "change ( parse ( _i :: _i ) L ( close :: _i ++ _i ) = None ) in | - * .",
                "tactic_sig_no_out_arg": "change ( parse ( _i :: _i ) L ( close :: _i ++ _i ) = None ) in | - * .",
                "tactic_args": [
                    "c9_goal : eq (parse s' (N t L) (app l2 l')) None",
                    "c8_t : bin",
                    "c8_s' : list bin",
                    "c8_l2 : list par",
                    "c8_l' : list par"
                ],
                "tactic_res": [
                    "c11_goal : eq (parse (Datatypes.cons t s') L (Datatypes.cons close (app l2 l')))\n  None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c11_Hrej : eq\n  (parse s t\n     (app (Datatypes.cons open (app l1 (Datatypes.cons close l2))) l'))\n  None"
                ],
                "tactic_res": [
                    "c11_Hrej : eq\n  (parse (Datatypes.cons t s) L\n     (app (app l1 (Datatypes.cons close l2)) l')) None"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)",
                    "c11_Hrej : eq\n  (parse (Datatypes.cons t s) L\n     (app (app l1 (Datatypes.cons close l2)) l')) None"
                ],
                "tactic_res": [
                    "c11_Hrej : eq\n  (parse (Datatypes.cons t s) L\n     (app l1 (app (Datatypes.cons close l2) l'))) None"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c11_goal : eq (parse (Datatypes.cons t s') L (Datatypes.cons close (app l2 l')))\n  None",
                    "c8_Hr1 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l1 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c11_Hrej : eq\n  (parse (Datatypes.cons t s) L\n     (app l1 (app (Datatypes.cons close l2) l'))) None"
                ],
                "tactic_res": [
                    "c12_goal : eq (length (Datatypes.cons t s')) (length (Datatypes.cons t s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : eq (length (Datatypes.cons t s')) (length (Datatypes.cons t s))"
                ],
                "tactic_res": [
                    "c13_goal : eq (S (length s')) (S (length s))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c13_goal : eq (S (length s')) (S (length s))",
                    "c8_Hle : eq (length s') (length s)",
                    "c8_s' : list bin",
                    "c8_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (length s') (length s')",
                    "c8_s' : list bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_complete",
        "proof": [
            {
                "tactic_sig": "Theorem parse_complete : forall l : list par , wp l -> parse nil L l <> None .",
                "tactic_sig_no_out_arg": "Theorem parse_complete : forall l : list par , wp l -> parse nil L l <> None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l),\nnot (eq (parse Datatypes.nil L l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l),\nnot (eq (parse Datatypes.nil L l) None)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq (parse Datatypes.nil L l) None)",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "replace _i with ( _i ++ nil ) .",
                "tactic_sig_no_out_arg": "replace _i with ( _i ++ nil ) .",
                "tactic_args": [
                    "c2_goal : not (eq (parse Datatypes.nil L l) None)",
                    "c2_l : list par",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : not (eq (parse Datatypes.nil L (app l Datatypes.nil)) None)",
                    "c4_goal : eq (app l Datatypes.nil) l"
                ]
            },
            {
                "tactic_sig": "red in | - * .",
                "tactic_sig_no_out_arg": "red in | - * .",
                "tactic_args": [
                    "c3_goal : not (eq (parse Datatypes.nil L (app l Datatypes.nil)) None)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq (parse Datatypes.nil L (app l Datatypes.nil)) None, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H' .",
                "tactic_args": [
                    "c5_goal : forall _ : eq (parse Datatypes.nil L (app l Datatypes.nil)) None, False"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H' : eq (parse Datatypes.nil L (app l Datatypes.nil)) None"
                ]
            },
            {
                "tactic_sig": "assert ( e : parse nil L nil = None ) .",
                "tactic_sig_no_out_arg": "assert ( e : parse nil L nil = None ) .",
                "tactic_args": [
                    "c6_goal : False"
                ],
                "tactic_res": [
                    "c7_goal : eq (parse Datatypes.nil L Datatypes.nil) None",
                    "c8_goal : False",
                    "c8_e : eq (parse Datatypes.nil L Datatypes.nil) None"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c7_goal : eq (parse Datatypes.nil L Datatypes.nil) None",
                    "_global_parse_complete_aux : forall (l : list par) (_ : wp' l) (s : list bin) \n         (t : bin) (l' : list par) (_ : eq (parse s t (app l l')) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None",
                    "c6_H' : eq (parse Datatypes.nil L (app l Datatypes.nil)) None"
                ],
                "tactic_res": [
                    "c9_goal : wp' l",
                    "c10_goal : eq (length Datatypes.nil) (length Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (length Datatypes.nil) (length Datatypes.nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : wp' l",
                    "_global_wp_imp_wp' : forall (l : list par) (_ : wp l), wp' l"
                ],
                "tactic_res": [
                    "c11_goal : wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : wp l",
                    "c2_H : wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c8_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : eq (app l Datatypes.nil) l",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l Datatypes.nil) l"
                ],
                "tactic_res": [
                    "c12_goal : eq (app l Datatypes.nil) (app l Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq (app l Datatypes.nil) (app l Datatypes.nil)",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_invert_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_invert_aux : forall ( l : list par ) ( s : list bin ) ( t t' : bin ) , parse s t l = Some t' -> bin_to_string' t' = unparse_stack s ++ bin_to_string' t ++ l .",
                "tactic_sig_no_out_arg": "Theorem parse_invert_aux : forall ( l : list par ) ( s : list bin ) ( t t' : bin ) , parse s t l = Some t' -> bin_to_string' t' = unparse_stack s ++ bin_to_string' t ++ l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (s : list bin) (t t' : bin)\n  (_ : eq (parse s t l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l))"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (s : list bin) (t t' : bin)\n  (_ : eq (parse s t l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l))"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t t' : bin)\n  (_ : eq (parse s t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) Datatypes.nil))",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (Datatypes.cons a l)))",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t t' : bin)\n  (_ : eq (parse s t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) Datatypes.nil))"
                ],
                "tactic_res": [
                    "c4_goal : forall (t t' : bin) (_ : eq (parse s t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) Datatypes.nil))",
                    "c4_s : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (t t' : bin) (_ : eq (parse s t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) Datatypes.nil))",
                    "c4_s : list bin"
                ],
                "tactic_res": [
                    "c5_goal : forall (t t' : bin)\n  (_ : eq (parse Datatypes.nil t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) Datatypes.nil))",
                    "c6_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse (Datatypes.cons b l) t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons b l))\n     (app (bin_to_string' t) Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (t t' : bin)\n  (_ : eq (parse Datatypes.nil t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) Datatypes.nil))"
                ],
                "tactic_res": [
                    "c7_goal : forall (t t' : bin) (_ : eq (Some t) (Some t')),\neq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c7_goal : forall (t t' : bin) (_ : eq (Some t) (Some t')),\neq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c8_goal : eq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)",
                    "c8_t : bin",
                    "c8_t' : bin",
                    "c8_H : eq (Some t) (Some t')"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c8_goal : eq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)",
                    "c8_H : eq (Some t) (Some t')"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq t t',\neq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c9_goal : forall _ : eq t t',\neq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)"
                ],
                "tactic_res": [
                    "c10_goal : eq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)",
                    "c10_Heq : eq t t'"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (bin_to_string' t') (app (bin_to_string' t) Datatypes.nil)",
                    "c10_Heq : eq t t'"
                ],
                "tactic_res": [
                    "c11_goal : eq (bin_to_string' t') (app (bin_to_string' t') Datatypes.nil)"
                ]
            },
            {
                "tactic_sig": "now rewrite app_nil_r .",
                "tactic_sig_no_out_arg": "now rewrite app_nil_r .",
                "tactic_args": [
                    "c11_goal : eq (bin_to_string' t') (app (bin_to_string' t') Datatypes.nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse (Datatypes.cons b l) t Datatypes.nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons b l))\n     (app (bin_to_string' t) Datatypes.nil))"
                ],
                "tactic_res": [
                    "c12_goal : forall (b : bin) (l : list bin) (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app\n     (app (unparse_stack l)\n        (app (bin_to_string' b) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) Datatypes.nil))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t t' H .",
                "tactic_args": [
                    "c12_goal : forall (b : bin) (l : list bin) (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app\n     (app (unparse_stack l)\n        (app (bin_to_string' b) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) Datatypes.nil))"
                ],
                "tactic_res": [
                    "c13_goal : eq (bin_to_string' t')\n  (app\n     (app (unparse_stack s0)\n        (app (bin_to_string' t0) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) Datatypes.nil))",
                    "c13_t0 : bin",
                    "c13_s0 : list bin",
                    "c13_t : bin",
                    "c13_t' : bin",
                    "c13_H : eq None (Some t')"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c13_goal : eq (bin_to_string' t')\n  (app\n     (app (unparse_stack s0)\n        (app (bin_to_string' t0) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) Datatypes.nil))",
                    "c13_H : eq None (Some t')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (Datatypes.cons a l)))"
                ],
                "tactic_res": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (Datatypes.cons a l)))",
                    "c14_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (Datatypes.cons a l)))",
                    "c14_a : par"
                ],
                "tactic_res": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons open l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l)))",
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons close l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons open l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l)))"
                ],
                "tactic_res": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c14_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l)))"
                ],
                "tactic_res": [
                    "c18_goal : forall (t t' : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))",
                    "c18_l' : list par",
                    "c18_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c18_s : list bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (Datatypes.cons close l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l)))"
                ],
                "tactic_res": [
                    "c19_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t'0 s' => parse s' (N t'0 t) l\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c14_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c19_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t'0 s' => parse s' (N t'0 t) l\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l)))"
                ],
                "tactic_res": [
                    "c20_goal : forall (t t' : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t'0 s' => parse s' (N t'0 t) l'\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c20_l' : list par",
                    "c20_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c20_s : list bin"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c18_goal : forall (t t' : bin)\n  (_ : eq (parse (Datatypes.cons t s) L l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ],
                "tactic_res": [
                    "c21_goal : eq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))",
                    "c21_t : bin",
                    "c21_t' : bin",
                    "c21_H : eq (parse (Datatypes.cons t s) L l') (Some t')"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c21_goal : eq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))",
                    "c18_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c21_H : eq (parse (Datatypes.cons t s) L l') (Some t')"
                ],
                "tactic_res": [
                    "c22_goal : eq\n  (app (unparse_stack (Datatypes.cons t s)) (app (bin_to_string' L) l'))\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : eq\n  (app (unparse_stack (Datatypes.cons t s)) (app (bin_to_string' L) l'))\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ],
                "tactic_res": [
                    "c23_goal : eq\n  (app\n     (app (unparse_stack s)\n        (app (bin_to_string' t) (Datatypes.cons open Datatypes.nil)))\n     l')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ]
            },
            {
                "tactic_sig": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_sig_no_out_arg": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_args": [
                    "c23_goal : eq\n  (app\n     (app (unparse_stack s)\n        (app (bin_to_string' t) (Datatypes.cons open Datatypes.nil)))\n     l')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ],
                "tactic_res": [
                    "c24_goal : eq\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons open l')))",
                    "c21_t : bin",
                    "c18_s : list bin",
                    "c18_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c20_goal : forall (t t' : bin)\n  (_ : eq\n         match s with\n         | Datatypes.nil => None\n         | Datatypes.cons t'0 s' => parse s' (N t'0 t) l'\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s)\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c20_s : list bin"
                ],
                "tactic_res": [
                    "c25_goal : forall (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c26_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse l (N b t) l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons b l))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c25_goal : forall (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ],
                "tactic_res": [
                    "c27_goal : eq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c27_t : bin",
                    "c27_t' : bin",
                    "c27_H : eq None (Some t')"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c27_goal : eq (bin_to_string' t')\n  (app (unparse_stack Datatypes.nil)\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c27_H : eq None (Some t')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t t' Hp .",
                "tactic_args": [
                    "c26_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse l (N b t) l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons b l))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ],
                "tactic_res": [
                    "c28_goal : eq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons t0 s0))\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c28_t0 : bin",
                    "c28_s0 : list bin",
                    "c28_t : bin",
                    "c28_t' : bin",
                    "c28_Hp : eq (parse s0 (N t0 t) l') (Some t')"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c28_goal : eq (bin_to_string' t')\n  (app (unparse_stack (Datatypes.cons t0 s0))\n     (app (bin_to_string' t) (Datatypes.cons close l')))",
                    "c20_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c28_Hp : eq (parse s0 (N t0 t) l') (Some t')"
                ],
                "tactic_res": [
                    "c29_goal : eq (app (unparse_stack s0) (app (bin_to_string' (N t0 t)) l'))\n  (app (unparse_stack (Datatypes.cons t0 s0))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : eq (app (unparse_stack s0) (app (bin_to_string' (N t0 t)) l'))\n  (app (unparse_stack (Datatypes.cons t0 s0))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ],
                "tactic_res": [
                    "c30_goal : eq\n  (app (unparse_stack s0)\n     (app\n        (app (bin_to_string' t0)\n           (Datatypes.cons open\n              (app (bin_to_string' t)\n                 (Datatypes.cons close Datatypes.nil)))) l'))\n  (app\n     (app (unparse_stack s0)\n        (app (bin_to_string' t0) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ]
            },
            {
                "tactic_sig": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_sig_no_out_arg": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_args": [
                    "c30_goal : eq\n  (app (unparse_stack s0)\n     (app\n        (app (bin_to_string' t0)\n           (Datatypes.cons open\n              (app (bin_to_string' t)\n                 (Datatypes.cons close Datatypes.nil)))) l'))\n  (app\n     (app (unparse_stack s0)\n        (app (bin_to_string' t0) (Datatypes.cons open Datatypes.nil)))\n     (app (bin_to_string' t) (Datatypes.cons close l')))"
                ],
                "tactic_res": [
                    "c31_goal : eq\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (Datatypes.cons open\n           (app (bin_to_string' t) (Datatypes.cons close l')))))\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (Datatypes.cons open\n           (app (bin_to_string' t) (Datatypes.cons close l')))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : eq\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (Datatypes.cons open\n           (app (bin_to_string' t) (Datatypes.cons close l')))))\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (Datatypes.cons open\n           (app (bin_to_string' t) (Datatypes.cons close l')))))",
                    "c28_t : bin",
                    "c28_s0 : list bin",
                    "c28_t0 : bin",
                    "c20_l' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_invert",
        "proof": [
            {
                "tactic_sig": "Theorem parse_invert : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> bin_to_string' t = l .",
                "tactic_sig_no_out_arg": "Theorem parse_invert : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> bin_to_string' t = l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (t : bin)\n  (_ : eq (parse Datatypes.nil L l) (Some t)), eq (bin_to_string' t) l"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (t : bin)\n  (_ : eq (parse Datatypes.nil L l) (Some t)), eq (bin_to_string' t) l"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_to_string' t) l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : eq (parse Datatypes.nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "replace _i with ( unparse_stack nil ++ bin_to_string' L ++ _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( unparse_stack nil ++ bin_to_string' L ++ _i ) .",
                "tactic_args": [
                    "c2_goal : eq (bin_to_string' t) l",
                    "c2_l : list par",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : eq (bin_to_string' t)\n  (app (unparse_stack Datatypes.nil) (app (bin_to_string' L) l))",
                    "c4_goal : eq (app (unparse_stack Datatypes.nil) (app (bin_to_string' L) l)) l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (app (unparse_stack Datatypes.nil) (app (bin_to_string' L) l)) l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : eq (bin_to_string' t)\n  (app (unparse_stack Datatypes.nil) (app (bin_to_string' L) l))",
                    "_global_parse_invert_aux : forall (l : list par) (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l))"
                ],
                "tactic_res": [
                    "c5_goal : eq (parse Datatypes.nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (parse Datatypes.nil L l) (Some t)",
                    "c2_H : eq (parse Datatypes.nil L l) (Some t)",
                    "c2_t : bin",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_sound",
        "proof": [
            {
                "tactic_sig": "Theorem parse_sound : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> wp l .",
                "tactic_sig_no_out_arg": "Theorem parse_sound : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (t : bin)\n  (_ : eq (parse Datatypes.nil L l) (Some t)), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l t H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (t : bin)\n  (_ : eq (parse Datatypes.nil L l) (Some t)), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : eq (parse Datatypes.nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "_global_parse_invert : forall (l : list par) (t : bin)\n         (_ : eq (parse Datatypes.nil L l) (Some t)), \n       eq (bin_to_string' t) l",
                    "c2_H : eq (parse Datatypes.nil L l) (Some t)"
                ],
                "tactic_res": [
                    "c3_goal : wp (bin_to_string' t)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp (bin_to_string' t)",
                    "_global_bin_to_string'_wp : forall t : bin, wp (bin_to_string' t)"
                ],
                "tactic_res": []
            }
        ]
    }
]