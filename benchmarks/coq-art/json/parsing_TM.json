[
    {
        "lemma_name": "wp_oc",
        "proof": [
            {
                "tactic_sig": "Theorem wp_oc : wp ( open :: close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp_oc : wp ( open :: close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : wp (cons open (cons close nil))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: nil ++ close :: nil ) ) in | - * .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: nil ++ close :: nil ) ) in | - * .",
                "tactic_args": [
                    "c1_goal : wp (cons open (cons close nil))"
                ],
                "tactic_res": [
                    "c2_goal : wp (cons open (app nil (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : wp (cons open (app nil (cons close nil)))",
                    "_global_wp_encapsulate : forall (l : list par) (_ : wp l),\n       wp (cons open (app l (cons close nil)))"
                ],
                "tactic_res": [
                    "c3_goal : wp nil"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp nil",
                    "_global_wp_nil : wp nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_o_head_c",
        "proof": [
            {
                "tactic_sig": "Theorem wp_o_head_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( open :: l1 ++ close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_o_head_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( open :: l1 ++ close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (cons open (app l1 (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (cons open (app l1 (cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : wp (cons open (app l1 (cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp l1",
                    "c2_H2 : wp l2"
                ]
            },
            {
                "tactic_sig": "replace ( open :: _i ++ close :: _i ) with ( ( open :: _i ++ close :: nil ) ++ _i ) .",
                "tactic_sig_no_out_arg": "replace ( open :: _i ++ close :: _i ) with ( ( open :: _i ++ close :: nil ) ++ _i ) .",
                "tactic_args": [
                    "c2_goal : wp (cons open (app l1 (cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp (app (cons open (app l1 (cons close nil))) l2)",
                    "c4_goal : eq (app (cons open (app l1 (cons close nil))) l2)\n  (cons open (app l1 (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp (app (cons open (app l1 (cons close nil))) l2)",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c5_goal : wp (cons open (app l1 (cons close nil)))",
                    "c6_goal : wp l2"
                ]
            },
            {
                "tactic_sig": "custom7 wp_encapsulate .",
                "tactic_sig_no_out_arg": "custom7 wp_encapsulate .",
                "tactic_args": [
                    "c5_goal : wp (cons open (app l1 (cons close nil)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c6_goal : wp l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat ( simpl in | - * ; rewrite <- app_assoc ) .",
                "tactic_sig_no_out_arg": "repeat ( simpl in | - * ; rewrite <- app_assoc ) .",
                "tactic_args": [
                    "c4_goal : eq (app (cons open (app l1 (cons close nil))) l2)\n  (cons open (app l1 (cons close l2)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (cons open (app l1 (app (cons close nil) l2)))\n  (cons open (app l1 (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "custom18 .",
                "tactic_sig_no_out_arg": "custom18 .",
                "tactic_args": [
                    "c7_goal : eq (cons open (app l1 (app (cons close nil) l2)))\n  (cons open (app l1 (cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_o_tail_c",
        "proof": [
            {
                "tactic_sig": "Theorem wp_o_tail_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( l1 ++ open :: l2 ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp_o_tail_c : forall l1 l2 : list par , wp l1 -> wp l2 -> wp ( l1 ++ open :: l2 ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (app l1 (cons open (app l2 (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2),\nwp (app l1 (cons open (app l2 (cons close nil))))"
                ],
                "tactic_res": [
                    "c2_goal : wp (app l1 (cons open (app l2 (cons close nil))))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp l1",
                    "c2_H2 : wp l2"
                ]
            },
            {
                "tactic_sig": "custom7 wp_concat .",
                "tactic_sig_no_out_arg": "custom7 wp_concat .",
                "tactic_args": [
                    "c2_goal : wp (app l1 (cons open (app l2 (cons close nil))))"
                ],
                "tactic_res": [
                    "c3_goal : wp (cons open (app l2 (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "now apply wp_encapsulate .",
                "tactic_sig_no_out_arg": "now apply wp_encapsulate .",
                "tactic_args": [
                    "c3_goal : wp (cons open (app l2 (cons close nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bin_to_string_wp",
        "proof": [
            {
                "tactic_sig": "Theorem bin_to_string_wp : forall t : bin , wp ( bin_to_string t ) .",
                "tactic_sig_no_out_arg": "Theorem bin_to_string_wp : forall t : bin , wp ( bin_to_string t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t : bin, wp (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "simple induction t .",
                "tactic_sig_no_out_arg": "simple induction t .",
                "tactic_args": [
                    "c1_goal : forall t : bin, wp (bin_to_string t)"
                ],
                "tactic_res": [
                    "c2_goal : wp (bin_to_string L)",
                    "c2_t : bin",
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)), wp (bin_to_string (N b b0))",
                    "c3_t : bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wp (bin_to_string L)"
                ],
                "tactic_res": [
                    "c4_goal : wp nil"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : wp nil",
                    "_global_wp_nil : wp nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "custom12 t1 H1 t2 H2 .",
                "tactic_sig_no_out_arg": "custom12 t1 H1 t2 H2 .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string b)) (b0 : bin)\n  (_ : wp (bin_to_string b0)), wp (bin_to_string (N b b0))"
                ],
                "tactic_res": [
                    "c5_goal : wp (cons open (app (bin_to_string t1) (cons close (bin_to_string t2))))",
                    "c5_H2 : wp (bin_to_string t2)",
                    "c5_t2 : bin",
                    "c5_H1 : wp (bin_to_string t1)",
                    "c5_t1 : bin"
                ]
            },
            {
                "tactic_sig": "custom22 wp_o_head_c .",
                "tactic_sig_no_out_arg": "custom22 wp_o_head_c .",
                "tactic_args": [
                    "c5_goal : wp (cons open (app (bin_to_string t1) (cons close (bin_to_string t2))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bin_to_string'_wp",
        "proof": [
            {
                "tactic_sig": "Theorem bin_to_string'_wp : forall t : bin , wp ( bin_to_string' t ) .",
                "tactic_sig_no_out_arg": "Theorem bin_to_string'_wp : forall t : bin , wp ( bin_to_string' t ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall t : bin, wp (bin_to_string' t)"
                ]
            },
            {
                "tactic_sig": "simple induction t .",
                "tactic_sig_no_out_arg": "simple induction t .",
                "tactic_args": [
                    "c1_goal : forall t : bin, wp (bin_to_string' t)"
                ],
                "tactic_res": [
                    "c2_goal : wp (bin_to_string' L)",
                    "c2_t : bin",
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)), wp (bin_to_string' (N b b0))",
                    "c3_t : bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : wp (bin_to_string' L)"
                ],
                "tactic_res": [
                    "c4_goal : wp nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : wp nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)), wp (bin_to_string' (N b b0))"
                ],
                "tactic_res": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)),\nwp\n  (app (bin_to_string' b)\n     (cons open (app (bin_to_string' b0) (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (b : bin) (_ : wp (bin_to_string' b)) (b0 : bin)\n  (_ : wp (bin_to_string' b0)),\nwp\n  (app (bin_to_string' b)\n     (cons open (app (bin_to_string' b0) (cons close nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_rel_sound_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_rel_sound_aux : forall ( l1 l2 : list par ) ( t : bin ) , parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2 .",
                "tactic_sig_no_out_arg": "Theorem parse_rel_sound_aux : forall ( l1 l2 : list par ) ( t : bin ) , parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\neq l1 (app (bin_to_string t) l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 t H .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\neq l1 (app (bin_to_string t) l2)"
                ],
                "tactic_res": [
                    "c2_goal : eq l1 (app (bin_to_string t) l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin",
                    "c2_H : parse_rel l1 l2 t"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : eq l1 (app (bin_to_string t) l2)",
                    "c2_H : parse_rel l1 l2 t"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 l2 l3 : list par) (t1 t2 : bin)\n  (_ : parse_rel l1 (cons close l2) t1)\n  (_ : eq l1 (app (bin_to_string t1) (cons close l2)))\n  (_ : parse_rel l2 l3 t2) (_ : eq l2 (app (bin_to_string t2) l3)),\neq (cons open l1) (app (bin_to_string (N t1 t2)) l3)",
                    "c4_goal : eq nil (app (bin_to_string L) nil)",
                    "c5_goal : forall l : list par,\neq (cons close l) (app (bin_to_string L) (cons close l))"
                ]
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i _i _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i _i _i .",
                "tactic_args": [
                    "c2_H : parse_rel l1 l2 t",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_t : bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 l3 t1 t2 Hp Hr1 Hp2 Hr2 .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 l3 : list par) (t1 t2 : bin)\n  (_ : parse_rel l1 (cons close l2) t1)\n  (_ : eq l1 (app (bin_to_string t1) (cons close l2)))\n  (_ : parse_rel l2 l3 t2) (_ : eq l2 (app (bin_to_string t2) l3)),\neq (cons open l1) (app (bin_to_string (N t1 t2)) l3)"
                ],
                "tactic_res": [
                    "c6_goal : eq (cons open l1) (app (bin_to_string (N t1 t2)) l3)",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_l3 : list par",
                    "c6_t1 : bin",
                    "c6_t2 : bin",
                    "c6_Hp : parse_rel l1 (cons close l2) t1",
                    "c6_Hr1 : eq l1 (app (bin_to_string t1) (cons close l2))",
                    "c6_Hp2 : parse_rel l2 l3 t2",
                    "c6_Hr2 : eq l2 (app (bin_to_string t2) l3)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : eq (cons open l1) (app (bin_to_string (N t1 t2)) l3)"
                ],
                "tactic_res": [
                    "c7_goal : eq (cons open l1)\n  (cons open\n     (app (app (bin_to_string t1) (cons close (bin_to_string t2))) l3))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i , _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i , _i .",
                "tactic_args": [
                    "c7_goal : eq (cons open l1)\n  (cons open\n     (app (app (bin_to_string t1) (cons close (bin_to_string t2))) l3))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)",
                    "c6_Hr1 : eq l1 (app (bin_to_string t1) (cons close l2))"
                ],
                "tactic_res": [
                    "c8_goal : eq (cons open (app (bin_to_string t1) (cons close l2)))\n  (cons open\n     (app (bin_to_string t1) (app (cons close (bin_to_string t2)) l3)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (cons open (app (bin_to_string t1) (cons close l2)))\n  (cons open\n     (app (bin_to_string t1) (app (cons close (bin_to_string t2)) l3)))"
                ],
                "tactic_res": [
                    "c9_goal : eq (cons open (app (bin_to_string t1) (cons close l2)))\n  (cons open\n     (app (bin_to_string t1) (cons close (app (bin_to_string t2) l3))))"
                ]
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c9_goal : eq (cons open (app (bin_to_string t1) (cons close l2)))\n  (cons open\n     (app (bin_to_string t1) (cons close (app (bin_to_string t2) l3))))",
                    "c6_Hr2 : eq l2 (app (bin_to_string t2) l3)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c4_goal : eq nil (app (bin_to_string L) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c5_goal : forall l : list par,\neq (cons close l) (app (bin_to_string L) (cons close l))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_rel_sound",
        "proof": [
            {
                "tactic_sig": "Theorem parse_rel_sound : forall l : list par , ( exists t : bin , parse_rel l nil t ) -> wp l .",
                "tactic_sig_no_out_arg": "Theorem parse_rel_sound : forall l : list par , ( exists t : bin , parse_rel l nil t ) -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : ex (fun t : bin => parse_rel l nil t)), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros l [ t H ] .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : ex (fun t : bin => parse_rel l nil t)), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : parse_rel l nil t"
                ]
            },
            {
                "tactic_sig": "replace _i with ( bin_to_string _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( bin_to_string _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c3_goal : wp (bin_to_string t)",
                    "c4_goal : eq (bin_to_string t) l"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp (bin_to_string t)",
                    "_global_bin_to_string_wp : forall t : bin, wp (bin_to_string t)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c4_goal : eq (bin_to_string t) l"
                ],
                "tactic_res": [
                    "c5_goal : eq l (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "replace ( bin_to_string _i ) with ( bin_to_string _i ++ nil ) .",
                "tactic_sig_no_out_arg": "replace ( bin_to_string _i ) with ( bin_to_string _i ++ nil ) .",
                "tactic_args": [
                    "c5_goal : eq l (bin_to_string t)",
                    "c2_t : bin",
                    "c2_t : bin"
                ],
                "tactic_res": [
                    "c6_goal : eq l (app (bin_to_string t) nil)",
                    "c7_goal : eq (app (bin_to_string t) nil) (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : eq l (app (bin_to_string t) nil)",
                    "_global_parse_rel_sound_aux : forall (l1 l2 : list par) (t : bin) (_ : parse_rel l1 l2 t),\n       eq l1 (app (bin_to_string t) l2)"
                ],
                "tactic_res": [
                    "c8_goal : parse_rel l nil t"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : parse_rel l nil t",
                    "c2_H : parse_rel l nil t",
                    "c2_t : bin",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c7_goal : eq (app (bin_to_string t) nil) (bin_to_string t)",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l nil) l"
                ],
                "tactic_res": [
                    "c9_goal : eq (bin_to_string t) (bin_to_string t)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (bin_to_string t) (bin_to_string t)",
                    "c2_t : bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_concat",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_concat : forall l1 l2 : list par , wp' l1 -> wp' l2 -> wp' ( l1 ++ l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp'_concat : forall l1 l2 : list par , wp' l1 -> wp' l2 -> wp' ( l1 ++ l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : wp' l2, wp' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H : wp' l1"
                ]
            },
            {
                "tactic_sig": "generalize _i .",
                "tactic_sig_no_out_arg": "generalize _i .",
                "tactic_args": [
                    "c2_goal : forall _ : wp' l2, wp' (app l1 l2)",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : forall (l2 : list par) (_ : wp' l2), wp' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall (l2 : list par) (_ : wp' l2), wp' (app l1 l2)",
                    "c2_H : wp' l1"
                ],
                "tactic_res": [
                    "c4_goal : forall (l2 : list par) (_ : wp' l2), wp' (app nil l2)",
                    "c5_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l1 l3))\n  (_ : wp' l2)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l2 l3))\n  (l3 : list par) (_ : wp' l3),\nwp' (app (cons open (app l1 (cons close l2))) l3)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall (l2 : list par) (_ : wp' l2), wp' (app nil l2)"
                ],
                "tactic_res": [
                    "c6_goal : forall (l2 : list par) (_ : wp' l2), wp' l2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (l2 : list par) (_ : wp' l2), wp' l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1' l2' Hb1' Hr1 Hb2' Hr2 l2 Hb2 .",
                "tactic_args": [
                    "c5_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l1 l3))\n  (_ : wp' l2)\n  (_ : forall (l3 : list par) (_ : wp' l3), wp' (app l2 l3))\n  (l3 : list par) (_ : wp' l3),\nwp' (app (cons open (app l1 (cons close l2))) l3)"
                ],
                "tactic_res": [
                    "c7_goal : wp' (app (cons open (app l1' (cons close l2'))) l2)",
                    "c7_l1' : list par",
                    "c7_l2' : list par",
                    "c7_Hb1' : wp' l1'",
                    "c7_Hr1 : forall (l2 : list par) (_ : wp' l2), wp' (app l1' l2)",
                    "c7_Hb2' : wp' l2'",
                    "c7_Hr2 : forall (l2 : list par) (_ : wp' l2), wp' (app l2' l2)",
                    "c7_l2 : list par",
                    "c7_Hb2 : wp' l2"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : wp' (app (cons open (app l1' (cons close l2'))) l2)"
                ],
                "tactic_res": [
                    "c8_goal : wp' (cons open (app (app l1' (cons close l2')) l2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c8_goal : wp' (cons open (app (app l1' (cons close l2')) l2))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c9_goal : wp' (cons open (app l1' (app (cons close l2') l2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c9_goal : wp' (cons open (app l1' (app (cons close l2') l2)))"
                ],
                "tactic_res": [
                    "c10_goal : wp' (cons open (app l1' (cons close (app l2' l2))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp' (cons open (app l1' (cons close (app l2' l2))))",
                    "_global_wp'_cons : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2),\n       wp' (cons open (app l1 (cons close l2)))"
                ],
                "tactic_res": [
                    "c11_goal : wp' l1'",
                    "c12_goal : wp' (app l2' l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : wp' l1'",
                    "c7_Hb1' : wp' l1'",
                    "c7_l1' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : wp' (app l2' l2)",
                    "c7_Hb2 : wp' l2",
                    "c7_l2 : list par",
                    "c7_Hr2 : forall (l2 : list par) (_ : wp' l2), wp' (app l2' l2)",
                    "c7_l2' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_encapsulate",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_encapsulate : forall l : list par , wp' l -> wp' ( open :: l ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp'_encapsulate : forall l : list par , wp' l -> wp' ( open :: l ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l),\nwp' (cons open (app l (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l),\nwp' (cons open (app l (cons close nil)))"
                ],
                "tactic_res": [
                    "c2_goal : wp' (cons open (app l (cons close nil)))",
                    "c2_l : list par",
                    "c2_H : wp' l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp' (cons open (app l (cons close nil)))",
                    "c2_H : wp' l"
                ],
                "tactic_res": [
                    "c3_goal : wp' (cons open (app nil (cons close nil)))",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : wp' (cons open (app l1 (cons close nil)))) \n  (_ : wp' l2) (_ : wp' (cons open (app l2 (cons close nil)))),\nwp'\n  (cons open\n     (app (cons open (app l1 (cons close l2))) (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp' (cons open (app nil (cons close nil)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : wp' (cons open (app l1 (cons close nil)))) \n  (_ : wp' l2) (_ : wp' (cons open (app l2 (cons close nil)))),\nwp'\n  (cons open\n     (app (cons open (app l1 (cons close l2))) (cons close nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_imp_wp'",
        "proof": [
            {
                "tactic_sig": "Theorem wp_imp_wp' : forall l : list par , wp l -> wp' l .",
                "tactic_sig_no_out_arg": "Theorem wp_imp_wp' : forall l : list par , wp l -> wp' l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp' l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp' l"
                ],
                "tactic_res": [
                    "c2_goal : wp' l",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp' l",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : wp' nil",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp' l1) \n  (_ : wp l2) (_ : wp' l2), wp' (app l1 l2)",
                    "c5_goal : forall (l : list par) (_ : wp l) (_ : wp' l),\nwp' (cons open (app l (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp' nil",
                    "_global_wp'_nil : wp' nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp' l1) \n  (_ : wp l2) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c6_goal : wp' (app l1 l2)",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_H0 : wp l1",
                    "c6_H1 : wp' l1",
                    "c6_H2 : wp l2",
                    "c6_H3 : wp' l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : wp' (app l1 l2)",
                    "_global_wp'_concat : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp' l2), wp' (app l1 l2)"
                ],
                "tactic_res": [
                    "c7_goal : wp' l1",
                    "c8_goal : wp' l2"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp' l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c8_goal : wp' l2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l) (_ : wp' l),\nwp' (cons open (app l (cons close nil)))"
                ],
                "tactic_res": [
                    "c9_goal : wp' (cons open (app l0 (cons close nil)))",
                    "c9_l0 : list par",
                    "c9_H0 : wp l0",
                    "c9_H1 : wp' l0"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : wp' (cons open (app l0 (cons close nil)))",
                    "_global_wp'_encapsulate : forall (l : list par) (_ : wp' l),\n       wp' (cons open (app l (cons close nil)))"
                ],
                "tactic_res": [
                    "c10_goal : wp' l0"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c10_goal : wp' l0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp'_imp_wp",
        "proof": [
            {
                "tactic_sig": "Theorem wp'_imp_wp : forall l : list par , wp' l -> wp l .",
                "tactic_sig_no_out_arg": "Theorem wp'_imp_wp : forall l : list par , wp' l -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_H : wp' l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_H : wp' l"
                ],
                "tactic_res": [
                    "c3_goal : wp nil",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp l1) \n  (_ : wp' l2) (_ : wp l2), wp (cons open (app l1 (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp' l1) (_ : wp l1) \n  (_ : wp' l2) (_ : wp l2), wp (cons open (app l1 (cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_concat",
        "proof": [
            {
                "tactic_sig": "Lemma wp''_concat : forall l1 l2 : list par , wp'' l1 -> wp'' l2 -> wp'' ( l1 ++ l2 ) .",
                "tactic_sig_no_out_arg": "Lemma wp''_concat : forall l1 l2 : list par , wp'' l1 -> wp'' l2 -> wp'' ( l1 ++ l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp'' l2), wp'' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 H2 .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp'' l2), wp'' (app l1 l2)"
                ],
                "tactic_res": [
                    "c2_goal : wp'' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H1 : wp'' l1",
                    "c2_H2 : wp'' l2"
                ]
            },
            {
                "tactic_sig": "generalize _i _i .",
                "tactic_sig_no_out_arg": "generalize _i _i .",
                "tactic_args": [
                    "c2_goal : wp'' (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_H1 : wp'' l1"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "clear _i _i .",
                "tactic_sig_no_out_arg": "clear _i _i .",
                "tactic_args": [
                    "c2_H1 : wp'' l1",
                    "c2_l1 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c3_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l2)",
                    "c2_H2 : wp'' l2"
                ],
                "tactic_res": [
                    "c4_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 nil)",
                    "c5_goal : forall (l1 l2 : list par) (_ : wp'' l1)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l1))\n  (_ : wp'' l2)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l2))\n  (l3 : list par) (_ : wp'' l3),\nwp'' (app l3 (app l1 (cons open (app l2 (cons close nil)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 nil)"
                ],
                "tactic_res": [
                    "c6_goal : wp'' (app l1 nil)",
                    "c6_l1 : list par",
                    "c6_H1 : wp'' l1"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : wp'' (app l1 nil)",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l nil) l"
                ],
                "tactic_res": [
                    "c7_goal : wp'' l1"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : wp'' l1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c5_goal : forall (l1 l2 : list par) (_ : wp'' l1)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l1))\n  (_ : wp'' l2)\n  (_ : forall (l3 : list par) (_ : wp'' l3), wp'' (app l3 l2))\n  (l3 : list par) (_ : wp'' l3),\nwp'' (app l3 (app l1 (cons open (app l2 (cons close nil)))))"
                ],
                "tactic_res": [
                    "c8_goal : wp'' (app l3 (app l1 (cons open (app l0 (cons close nil)))))",
                    "c8_l1 : list par",
                    "c8_l0 : list par",
                    "c8_H : wp'' l1",
                    "c8_H0 : forall (l2 : list par) (_ : wp'' l2), wp'' (app l2 l1)",
                    "c8_H1 : wp'' l0",
                    "c8_H3 : forall (l1 : list par) (_ : wp'' l1), wp'' (app l1 l0)",
                    "c8_l3 : list par",
                    "c8_H4 : wp'' l3"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : wp'' (app l3 (app l1 (cons open (app l0 (cons close nil)))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c9_goal : wp'' (app (app l3 l1) (cons open (app l0 (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : wp'' (app (app l3 l1) (cons open (app l0 (cons close nil))))",
                    "c8_H4 : wp'' l3",
                    "c8_l3 : list par",
                    "c8_H1 : wp'' l0",
                    "c8_H0 : forall (l2 : list par) (_ : wp'' l2), wp'' (app l2 l1)",
                    "c8_l1 : list par",
                    "c8_l0 : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_encapsulate",
        "proof": [
            {
                "tactic_sig": "Theorem wp''_encapsulate : forall l : list par , wp'' l -> wp'' ( open :: l ++ close :: nil ) .",
                "tactic_sig_no_out_arg": "Theorem wp''_encapsulate : forall l : list par , wp'' l -> wp'' ( open :: l ++ close :: nil ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp'' l),\nwp'' (cons open (app l (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp'' l),\nwp'' (cons open (app l (cons close nil)))"
                ],
                "tactic_res": [
                    "c2_goal : wp'' (cons open (app l (cons close nil)))",
                    "c2_l : list par",
                    "c2_H : wp'' l"
                ]
            },
            {
                "tactic_sig": "change ( wp'' ( nil ++ open :: _i ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp'' ( nil ++ open :: _i ++ close :: nil ) ) .",
                "tactic_args": [
                    "c2_goal : wp'' (cons open (app l (cons close nil)))",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp'' (app nil (cons open (app l (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp'' (app nil (cons open (app l (cons close nil))))",
                    "c2_H : wp'' l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_imp_wp''",
        "proof": [
            {
                "tactic_sig": "Theorem wp_imp_wp'' : forall l : list par , wp l -> wp'' l .",
                "tactic_sig_no_out_arg": "Theorem wp_imp_wp'' : forall l : list par , wp l -> wp'' l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp'' l"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), wp'' l"
                ],
                "tactic_res": [
                    "c2_goal : wp'' nil",
                    "c2_H : wp l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp'' l1) \n  (_ : wp l2) (_ : wp'' l2), wp'' (app l1 l2)",
                    "c3_H : wp l",
                    "c3_l : list par",
                    "c4_goal : forall (l : list par) (_ : wp l) (_ : wp'' l),\nwp'' (cons open (app l (cons close nil)))",
                    "c4_H : wp l",
                    "c4_l : list par"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : wp'' nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp l1) (_ : wp'' l1) \n  (_ : wp l2) (_ : wp'' l2), wp'' (app l1 l2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (l : list par) (_ : wp l) (_ : wp'' l),\nwp'' (cons open (app l (cons close nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp''_imp_wp",
        "proof": [
            {
                "tactic_sig": "Theorem wp''_imp_wp : forall l : list par , wp'' l -> wp l .",
                "tactic_sig_no_out_arg": "Theorem wp''_imp_wp : forall l : list par , wp'' l -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp'' l), wp l"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp'' l), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp nil",
                    "c2_H : wp'' l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp l1) \n  (_ : wp'' l2) (_ : wp l2),\nwp (app l1 (cons open (app l2 (cons close nil))))",
                    "c3_H : wp'' l",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : wp nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp'' l1) (_ : wp l1) \n  (_ : wp'' l2) (_ : wp l2),\nwp (app l1 (cons open (app l2 (cons close nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_complete_aux",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_complete_aux : forall l : list par , wp l -> forall ( n : nat ) ( l' : list par ) , recognize n ( l ++ l' ) = recognize n l' .",
                "tactic_sig_no_out_arg": "Theorem recognize_complete_aux : forall l : list par , wp l -> forall ( n : nat ) ( l' : list par ) , recognize n ( l ++ l' ) = recognize n l' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (n : nat) (l' : list par),\neq (recognize n (app l l')) (recognize n l')",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : forall (n : nat) (l' : list par),\neq (recognize n (app nil l')) (recognize n l')",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l1 l')) (recognize n l')) \n  (_ : wp l2)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l2 l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (cons open (app l (cons close nil))) l'))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (n : nat) (l' : list par),\neq (recognize n (app nil l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c6_goal : forall (n : nat) (l' : list par), eq (recognize n l') (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (n : nat) (l' : list par), eq (recognize n l') (recognize n l')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 Hrec1 H2 Hrec2 n l' .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l1 l')) (recognize n l')) \n  (_ : wp l2)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l2 l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (app l1 l2) l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c7_goal : eq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "c7_l1 : list par",
                    "c7_l2 : list par",
                    "c7_H1 : wp l1",
                    "c7_Hrec1 : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c7_H2 : wp l2",
                    "c7_Hrec2 : forall (n : nat) (l' : list par),\neq (recognize n (app l2 l')) (recognize n l')",
                    "c7_n : nat",
                    "c7_l' : list par"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (recognize n (app (app l1 l2) l')) (recognize n l')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c8_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "transitivity ( recognize _i ( _i ++ _i ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( recognize _i ( _i ++ _i ) ) .",
                "tactic_args": [
                    "c8_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n l')",
                    "c7_n : nat",
                    "c7_l2 : list par",
                    "c7_l' : list par"
                ],
                "tactic_res": [
                    "c9_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n (app l2 l'))",
                    "c10_goal : eq (recognize n (app l2 l')) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (recognize n (app l1 (app l2 l'))) (recognize n (app l2 l'))",
                    "c7_l' : list par",
                    "c7_n : nat",
                    "c7_Hrec1 : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c7_l1 : list par",
                    "c7_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (recognize n (app l2 l')) (recognize n l')",
                    "c7_l' : list par",
                    "c7_n : nat",
                    "c7_Hrec2 : forall (n : nat) (l' : list par),\neq (recognize n (app l2 l')) (recognize n l')",
                    "c7_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 H1 Hrec n l' .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')) \n  (n : nat) (l' : list par),\neq (recognize n (app (cons open (app l (cons close nil))) l'))\n  (recognize n l')"
                ],
                "tactic_res": [
                    "c11_goal : eq (recognize n (app (cons open (app l1 (cons close nil))) l'))\n  (recognize n l')",
                    "c11_l1 : list par",
                    "c11_H1 : wp l1",
                    "c11_Hrec : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')",
                    "c11_n : nat",
                    "c11_l' : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : eq (recognize n (app (cons open (app l1 (cons close nil))) l'))\n  (recognize n l')"
                ],
                "tactic_res": [
                    "c12_goal : eq (recognize (S n) (app (app l1 (cons close nil)) l'))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c12_goal : eq (recognize (S n) (app (app l1 (cons close nil)) l'))\n  (recognize n l')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c13_goal : eq (recognize (S n) (app l1 (app (cons close nil) l')))\n  (recognize n l')"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c13_goal : eq (recognize (S n) (app l1 (app (cons close nil) l')))\n  (recognize n l')",
                    "c11_Hrec : forall (n : nat) (l' : list par),\neq (recognize n (app l1 l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c14_goal : eq (recognize (S n) (app (cons close nil) l')) (recognize n l')"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c14_goal : eq (recognize (S n) (app (cons close nil) l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c15_goal : eq (recognize n l') (recognize n l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : eq (recognize n l') (recognize n l')",
                    "c11_l' : list par",
                    "c11_n : nat"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_complete",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_complete : forall l : list par , wp l -> recognize 0 l = true .",
                "tactic_sig_no_out_arg": "Theorem recognize_complete : forall l : list par , wp l -> recognize 0 l = true .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), eq (recognize 0 l) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), eq (recognize 0 l) true"
                ],
                "tactic_res": [
                    "c2_goal : eq (recognize 0 l) true",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) , _i .",
                "tactic_args": [
                    "c2_goal : eq (recognize 0 l) true",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l nil) l",
                    "c2_l : list par",
                    "_global_recognize_complete_aux : forall (l : list par) (_ : wp l) (n : nat) (l' : list par),\n       eq (recognize n (app l l')) (recognize n l')"
                ],
                "tactic_res": [
                    "c3_goal : eq (recognize 0 nil) true",
                    "c4_goal : wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq (recognize 0 nil) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : wp l",
                    "c2_H : wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "app_decompose",
        "proof": [
            {
                "tactic_sig": "Theorem app_decompose : forall ( A : Type ) ( l1 l2 l3 l4 : list A ) , l1 ++ l2 = l3 ++ l4 -> ( exists l1' : list A , l1 = l3 ++ l1' /\\ l4 = l1' ++ l2 ) \\/ ( exists a : A , exists l2' : list A , l3 = l1 ++ a :: l2' /\\ l2 = ( a :: l2' ) ++ l4 ) .",
                "tactic_sig_no_out_arg": "Theorem app_decompose : forall ( A : Type ) ( l1 l2 l3 l4 : list A ) , l1 ++ l2 = l3 ++ l4 -> ( exists l1' : list A , l1 = l3 ++ l1' /\\ l4 = l1' ++ l2 ) \\/ ( exists a : A , exists l2' : list A , l3 = l1 ++ a :: l2' /\\ l2 = ( a :: l2' ) ++ l4 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l1 l2 l3 l4 : list A)\n  (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "simple induction l1 .",
                "tactic_sig_no_out_arg": "simple induction l1 .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l1 l2 l3 l4 : list A)\n  (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c2_goal : forall (l2 l3 l4 : list A) (_ : eq (app nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c2_l1 : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall (l2 l3 l4 : list A) (_ : eq (app l l2) (app l3 l4)),\n       or\n         (ex\n            (fun l1' : list A =>\n             and (eq l (app l3 l1')) (eq l4 (app l1' l2))))\n         (ex\n            (fun a0 : A =>\n             ex\n               (fun l2' : list A =>\n                and (eq l3 (app l (cons a0 l2')))\n                  (eq l2 (app (cons a0 l2') l4))))))\n  (l2 l3 l4 : list A) (_ : eq (app (cons a l) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (cons a l) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))",
                    "c3_l1 : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l2 l3 .",
                "tactic_args": [
                    "c2_goal : forall (l2 l3 l4 : list A) (_ : eq (app nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c4_goal : forall (l4 : list A) (_ : eq (app nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c4_l2 : list A",
                    "c4_l3 : list A"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (l4 : list A) (_ : eq (app nil l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c4_l3 : list A"
                ],
                "tactic_res": [
                    "c5_goal : forall (l4 : list A) (_ : eq (app nil l2) (app nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c6_goal : forall (a : A) (l l4 : list A)\n  (_ : eq (app nil l2) (app (cons a l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app (cons a l) l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a l) (app nil (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l4 H .",
                "tactic_args": [
                    "c5_goal : forall (l4 : list A) (_ : eq (app nil l2) (app nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c7_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c7_l4 : list A",
                    "c7_H : eq (app nil l2) (app nil l4)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c7_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app nil (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))"
                ],
                "tactic_res": [
                    "c8_goal : ex\n  (fun l1' : list A => and (eq nil (app nil l1')) (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists ( nil ( _i := _i ) ) .",
                "tactic_sig_no_out_arg": "exists ( nil ( _i := _i ) ) .",
                "tactic_args": [
                    "c8_goal : ex\n  (fun l1' : list A => and (eq nil (app nil l1')) (eq l4 (app l1' l2)))",
                    "c2_A : Type",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c9_goal : and (eq nil (app nil nil)) (eq l4 (app nil l2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : and (eq nil (app nil nil)) (eq l4 (app nil l2))",
                    "c7_H : eq (app nil l2) (app nil l4)",
                    "c4_l2 : list A",
                    "c7_l4 : list A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l3' Heq .",
                "tactic_args": [
                    "c6_goal : forall (a : A) (l l4 : list A)\n  (_ : eq (app nil l2) (app (cons a l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app (cons a l) l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a l) (app nil (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : eq (app nil l2) (app (cons a l3') Heq),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app (cons a l3') l1')) (eq Heq (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a l3') (app nil (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') Heq)))))",
                    "c10_a : A",
                    "c10_l3' : list A",
                    "c10_Heq : list A"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c10_goal : forall _ : eq (app nil l2) (app (cons a l3') Heq),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq nil (app (cons a l3') l1')) (eq Heq (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a l3') (app nil (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') Heq)))))"
                ],
                "tactic_res": [
                    "c11_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and (eq (cons a l3') (app nil (cons a0 l2')))\n        (eq l2 (app (cons a0 l2') Heq))))",
                    "c11_H : eq (app nil l2) (app (cons a l3') Heq)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c11_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and (eq (cons a l3') (app nil (cons a0 l2')))\n        (eq l2 (app (cons a0 l2') Heq))))",
                    "c10_a : A"
                ],
                "tactic_res": [
                    "c12_goal : ex\n  (fun l2' : list A =>\n   and (eq (cons a l3') (app nil (cons a l2')))\n     (eq l2 (app (cons a l2') Heq)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c12_goal : ex\n  (fun l2' : list A =>\n   and (eq (cons a l3') (app nil (cons a l2')))\n     (eq l2 (app (cons a l2') Heq)))",
                    "c10_l3' : list A"
                ],
                "tactic_res": [
                    "c13_goal : and (eq (cons a l3') (app nil (cons a l3')))\n  (eq l2 (app (cons a l3') Heq))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : and (eq (cons a l3') (app nil (cons a l3')))\n  (eq l2 (app (cons a l3') Heq))",
                    "c11_H : eq (app nil l2) (app (cons a l3') Heq)",
                    "c10_l3' : list A",
                    "c10_Heq : list A",
                    "c10_a : A",
                    "c4_l2 : list A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c3_l1 : list A"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l1 Hrec l2 l3 .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall (l2 l3 l4 : list A) (_ : eq (app l l2) (app l3 l4)),\n       or\n         (ex\n            (fun l1' : list A =>\n             and (eq l (app l3 l1')) (eq l4 (app l1' l2))))\n         (ex\n            (fun a0 : A =>\n             ex\n               (fun l2' : list A =>\n                and (eq l3 (app l (cons a0 l2')))\n                  (eq l2 (app (cons a0 l2') l4))))))\n  (l2 l3 l4 : list A) (_ : eq (app (cons a l) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (cons a l) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c14_goal : forall (l4 : list A) (_ : eq (app (cons a l1) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))",
                    "c14_a : A",
                    "c14_l1 : list A",
                    "c14_Hrec : forall (l2 l3 l4 : list A) (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c14_l2 : list A",
                    "c14_l3 : list A"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c14_goal : forall (l4 : list A) (_ : eq (app (cons a l1) l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))",
                    "c14_l3 : list A"
                ],
                "tactic_res": [
                    "c15_goal : forall (l4 : list A) (_ : eq (app (cons a l1) l2) (app nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))",
                    "c16_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (app (cons a l1) l2) (app (cons a0 l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app (cons a0 l) l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a0 l) (app (cons a l1) (cons a1 l2')))\n           (eq l2 (app (cons a1 l2') l4)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l4 H .",
                "tactic_args": [
                    "c15_goal : forall (l4 : list A) (_ : eq (app (cons a l1) l2) (app nil l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c17_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))",
                    "c17_l4 : list A",
                    "c17_H : eq (app (cons a l1) l2) (app nil l4)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c17_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq nil (app (cons a l1) (cons a0 l2')))\n           (eq l2 (app (cons a0 l2') l4)))))"
                ],
                "tactic_res": [
                    "c18_goal : ex\n  (fun l1' : list A =>\n   and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists ( _i :: _i ) .",
                "tactic_sig_no_out_arg": "exists ( _i :: _i ) .",
                "tactic_args": [
                    "c18_goal : ex\n  (fun l1' : list A =>\n   and (eq (cons a l1) (app nil l1')) (eq l4 (app l1' l2)))",
                    "c14_a : A",
                    "c14_l1 : list A"
                ],
                "tactic_res": [
                    "c19_goal : and (eq (cons a l1) (app nil (cons a l1))) (eq l4 (app (cons a l1) l2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : and (eq (cons a l1) (app nil (cons a l1))) (eq l4 (app (cons a l1) l2))",
                    "c17_H : eq (app (cons a l1) l2) (app nil l4)",
                    "c14_l2 : list A",
                    "c17_l4 : list A",
                    "c14_l1 : list A",
                    "c14_a : A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (app (cons a l1) l2) (app (cons a0 l) l4)),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (app (cons a0 l) l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a0 l) (app (cons a l1) (cons a1 l2')))\n           (eq l2 (app (cons a1 l2') l4)))))"
                ],
                "tactic_res": [
                    "c20_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (cons a (app l1 l2)) (cons a0 (app l l4))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a0 (app l l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a0 l) (cons a (app l1 (cons a1 l2'))))\n           (eq l2 (cons a1 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a' l3' l4 Heq .",
                "tactic_args": [
                    "c20_goal : forall (a0 : A) (l l4 : list A)\n  (_ : eq (cons a (app l1 l2)) (cons a0 (app l l4))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a0 (app l l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a1 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a0 l) (cons a (app l1 (cons a1 l2'))))\n           (eq l2 (cons a1 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c21_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c21_a' : A",
                    "c21_l3' : list A",
                    "c21_l4 : list A",
                    "c21_Heq : eq (cons a (app l1 l2)) (cons a' (app l3' l4))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c21_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c21_Heq : eq (cons a (app l1 l2)) (cons a' (app l3' l4))"
                ],
                "tactic_res": [
                    "c22_goal : forall (_ : eq (app l1 l2) (app l3' l4)) (_ : eq a a'),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq' Heq'' .",
                "tactic_args": [
                    "c22_goal : forall (_ : eq (app l1 l2) (app l3' l4)) (_ : eq a a'),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c23_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c23_Heq' : eq (app l1 l2) (app l3' l4)",
                    "c23_Heq'' : eq a a'"
                ]
            },
            {
                "tactic_sig": "elim _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c23_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c14_Hrec : forall (l2 l3 l4 : list A) (_ : eq (app l1 l2) (app l3 l4)),\nor\n  (ex\n     (fun l1' : list A => and (eq l1 (app l3 l1')) (eq l4 (app l1' l2))))\n  (ex\n     (fun a : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq l3 (app l1 (cons a l2')))\n           (eq l2 (app (cons a l2') l4)))))",
                    "c23_Heq' : eq (app l1 l2) (app l3' l4)"
                ],
                "tactic_res": [
                    "c24_goal : forall\n  _ : ex\n        (fun l1' : list A =>\n         and (eq l1 (app l3' l1')) (eq l4 (app l1' l2))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c25_goal : forall\n  _ : ex\n        (fun a : A =>\n         ex\n           (fun l2' : list A =>\n            and (eq l3' (app l1 (cons a l2')))\n              (eq l2 (app (cons a l2') l4)))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ]
            },
            {
                "tactic_sig": "intros [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ l1' [ Heq3 Heq4 ] ] .",
                "tactic_args": [
                    "c24_goal : forall\n  _ : ex\n        (fun l1' : list A =>\n         and (eq l1 (app l3' l1')) (eq l4 (app l1' l2))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c26_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c26_l1' : list A",
                    "c26_Heq3 : eq l1 (app l3' l1')",
                    "c26_Heq4 : eq l4 (app l1' l2)"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c26_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c27_goal : ex\n  (fun l1' : list A =>\n   and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2)))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c27_goal : ex\n  (fun l1' : list A =>\n   and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2)))",
                    "c26_l1' : list A"
                ],
                "tactic_res": [
                    "c28_goal : and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c28_goal : and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))"
                ],
                "tactic_res": [
                    "c29_goal : eq (cons a l1) (cons a' (app l3' l1'))",
                    "c30_goal : eq l4 (app l1' l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : eq l4 (app l1' l2)",
                    "c26_Heq4 : eq l4 (app l1' l2)",
                    "c26_l1' : list A",
                    "c21_l4 : list A",
                    "c14_l2 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c29_goal : eq (cons a l1) (cons a' (app l3' l1'))",
                    "c23_Heq'' : eq a a'"
                ],
                "tactic_res": [
                    "c31_goal : eq (cons a' l1) (cons a' (app l3' l1'))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : eq (cons a' l1) (cons a' (app l3' l1'))",
                    "c26_Heq3 : eq l1 (app l3' l1')"
                ],
                "tactic_res": [
                    "c32_goal : eq (cons a' (app l3' l1')) (cons a' (app l3' l1'))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : eq (cons a' (app l3' l1')) (cons a' (app l3' l1'))",
                    "c26_l1' : list A",
                    "c21_l3' : list A",
                    "c21_a' : A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o [ _o [ _o _o ] ] ] .",
                "tactic_sig_no_out_arg": "intros [ a'' [ l2' [ Heq3 Heq4 ] ] ] .",
                "tactic_args": [
                    "c25_goal : forall\n  _ : ex\n        (fun a : A =>\n         ex\n           (fun l2' : list A =>\n            and (eq l3' (app l1 (cons a l2')))\n              (eq l2 (app (cons a l2') l4)))),\nor\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c33_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))",
                    "c33_a'' : A",
                    "c33_l2' : list A",
                    "c33_Heq3 : eq l3' (app l1 (cons a'' l2'))",
                    "c33_Heq4 : eq l2 (app (cons a'' l2') l4)"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c33_goal : or\n  (ex\n     (fun l1' : list A =>\n      and (eq (cons a l1) (cons a' (app l3' l1'))) (eq l4 (app l1' l2))))\n  (ex\n     (fun a0 : A =>\n      ex\n        (fun l2' : list A =>\n         and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n           (eq l2 (cons a0 (app l2' l4))))))"
                ],
                "tactic_res": [
                    "c34_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n        (eq l2 (cons a0 (app l2' l4)))))"
                ]
            },
            {
                "tactic_sig": "exists _i , _i .",
                "tactic_sig_no_out_arg": "exists _i , _i .",
                "tactic_args": [
                    "c34_goal : ex\n  (fun a0 : A =>\n   ex\n     (fun l2' : list A =>\n      and (eq (cons a' l3') (cons a (app l1 (cons a0 l2'))))\n        (eq l2 (cons a0 (app l2' l4)))))",
                    "c33_a'' : A",
                    "c33_l2' : list A"
                ],
                "tactic_res": [
                    "c35_goal : and (eq (cons a' l3') (cons a (app l1 (cons a'' l2'))))\n  (eq l2 (cons a'' (app l2' l4)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c35_goal : and (eq (cons a' l3') (cons a (app l1 (cons a'' l2'))))\n  (eq l2 (cons a'' (app l2' l4)))"
                ],
                "tactic_res": [
                    "c36_goal : eq (cons a' l3') (cons a (app l1 (cons a'' l2')))",
                    "c37_goal : eq l2 (cons a'' (app l2' l4))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : eq l2 (cons a'' (app l2' l4))",
                    "c33_Heq4 : eq l2 (app (cons a'' l2') l4)",
                    "c33_l2' : list A",
                    "c33_a'' : A",
                    "c21_l4 : list A",
                    "c14_l2 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c36_goal : eq (cons a' l3') (cons a (app l1 (cons a'' l2')))",
                    "c23_Heq'' : eq a a'"
                ],
                "tactic_res": [
                    "c38_goal : eq (cons a' l3') (cons a' (app l1 (cons a'' l2')))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c38_goal : eq (cons a' l3') (cons a' (app l1 (cons a'' l2')))",
                    "c33_Heq3 : eq l3' (app l1 (cons a'' l2'))"
                ],
                "tactic_res": [
                    "c39_goal : eq (cons a' (app l1 (cons a'' l2'))) (cons a' (app l1 (cons a'' l2')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : eq (cons a' (app l1 (cons a'' l2'))) (cons a' (app l1 (cons a'' l2')))",
                    "c33_l2' : list A",
                    "c33_a'' : A",
                    "c21_a' : A",
                    "c14_l1 : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "length_app",
        "proof": [
            {
                "tactic_sig": "Theorem length_app : forall { A : Type } ( l1 l2 : list A ) , length ( l1 ++ l2 ) = length l1 + length l2 .",
                "tactic_sig_no_out_arg": "Theorem length_app : forall { A : Type } ( l1 l2 : list A ) , length ( l1 ++ l2 ) = length l1 + length l2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l1 l2 : list A),\neq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))"
                ]
            },
            {
                "tactic_sig": "simple induction l1 .",
                "tactic_sig_no_out_arg": "simple induction l1 .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l1 l2 : list A),\neq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))"
                ],
                "tactic_res": [
                    "c2_goal : forall l2 : list A,\neq (length (app nil l2)) (Init.Nat.add (length nil) (length l2))",
                    "c2_l1 : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (length (app (cons a l) l2))\n  (Init.Nat.add (length (cons a l)) (length l2))",
                    "c3_l1 : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c2_goal : forall l2 : list A,\neq (length (app nil l2)) (Init.Nat.add (length nil) (length l2))"
                ],
                "tactic_res": [
                    "c4_goal : forall l2 : list A, eq (length l2) (length l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall l2 : list A, eq (length l2) (length l2)",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (length (app (cons a l) l2))\n  (Init.Nat.add (length (cons a l)) (length l2))"
                ],
                "tactic_res": [
                    "c5_goal : forall (_ : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (S (length (app l l2))) (S (Init.Nat.add (length l) (length l2)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (_ : A) (l : list A)\n  (_ : forall l2 : list A,\n       eq (length (app l l2)) (Init.Nat.add (length l) (length l2)))\n  (l2 : list A),\neq (S (length (app l l2))) (S (Init.Nat.add (length l) (length l2)))",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "length_rev",
        "proof": [
            {
                "tactic_sig": "Theorem length_rev : forall { A : Type } ( l : list A ) , length l = length ( rev l ) .",
                "tactic_sig_no_out_arg": "Theorem length_rev : forall { A : Type } ( l : list A ) , length l = length ( rev l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l : list A), eq (length l) (length (rev l))"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l : list A), eq (length l) (length (rev l))"
                ],
                "tactic_res": [
                    "c2_goal : eq (length nil) (length (rev nil))",
                    "c2_l : list A",
                    "c2_A : Type",
                    "c3_goal : forall (a : A) (l : list A) (_ : eq (length l) (length (rev l))),\neq (length (cons a l)) (length (rev (cons a l)))",
                    "c3_l : list A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : eq (length nil) (length (rev nil))",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a l' H .",
                "tactic_args": [
                    "c3_goal : forall (a : A) (l : list A) (_ : eq (length l) (length (rev l))),\neq (length (cons a l)) (length (rev (cons a l)))"
                ],
                "tactic_res": [
                    "c4_goal : eq (length (cons a l')) (length (rev (cons a l')))",
                    "c4_a : A",
                    "c4_l' : list A",
                    "c4_H : eq (length l') (length (rev l'))"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c4_goal : eq (length (cons a l')) (length (rev (cons a l')))"
                ],
                "tactic_res": [
                    "c5_goal : eq (S (length l')) (length (app (rev l') (cons a nil)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq (S (length l')) (length (app (rev l') (cons a nil)))",
                    "_global_length_app : forall l1 l2 : list ?A,\n       eq (length (app l1 l2)) (Init.Nat.add (length l1) (length l2))\nwhere\n?A : [A : Type\n      l : list A\n      a : A\n      l' : list A\n      H : eq (length l') (length (rev l')) |- Type]"
                ],
                "tactic_res": [
                    "c6_goal : eq (S (length l'))\n  (Init.Nat.add (length (rev l')) (length (cons a nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in | - * .",
                "tactic_sig_no_out_arg": "simpl in | - * .",
                "tactic_args": [
                    "c6_goal : eq (S (length l'))\n  (Init.Nat.add (length (rev l')) (length (cons a nil)))"
                ],
                "tactic_res": [
                    "c7_goal : eq (S (length l')) (Init.Nat.add (length (rev l')) 1)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c7_goal : eq (S (length l')) (Init.Nat.add (length (rev l')) 1)",
                    "_global_plus_n_Sm : forall n m : nat, eq (S (Init.Nat.add n m)) (Init.Nat.add n (S m))"
                ],
                "tactic_res": [
                    "c8_goal : eq (S (length l')) (S (Init.Nat.add (length (rev l')) 0))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : eq (S (length l')) (S (Init.Nat.add (length (rev l')) 0))",
                    "c4_H : eq (length l') (length (rev l'))"
                ],
                "tactic_res": [
                    "c9_goal : eq (S (length (rev l'))) (S (Init.Nat.add (length (rev l')) 0))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c9_goal : eq (S (length (rev l'))) (S (Init.Nat.add (length (rev l')) 0))",
                    "c4_l' : list A",
                    "c3_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cons_to_app_end",
        "proof": [
            {
                "tactic_sig": "Theorem cons_to_app_end : forall { A : Type } ( l : list A ) ( a : A ) , exists b : A , exists l' : list A , a :: l = l' ++ b :: nil .",
                "tactic_sig_no_out_arg": "Theorem cons_to_app_end : forall { A : Type } ( l : list A ) ( a : A ) , exists b : A , exists l' : list A , a :: l = l' ++ b :: nil .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (l : list A) (a : A),\nex\n  (fun b : A =>\n   ex (fun l' : list A => eq (cons a l) (app l' (cons b nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros A l a .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (l : list A) (a : A),\nex\n  (fun b : A =>\n   ex (fun l' : list A => eq (cons a l) (app l' (cons b nil))))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (cons a l) (app l' (cons b nil))))",
                    "c2_A : Type",
                    "c2_l : list A",
                    "c2_a : A"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( _i ( _i :: _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i ( _i :: _i ) ) .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (cons a l) (app l' (cons b nil))))",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l",
                    "c2_a : A",
                    "c2_l : list A"
                ],
                "tactic_res": [
                    "c3_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (rev (cons a l))) (app l' (cons b nil))))"
                ]
            },
            {
                "tactic_sig": "assert ( H : 0 < length ( rev ( _i :: _i ) ) ) by ( rewrite <- length_rev ; simpl ; auto with arith ) .",
                "tactic_sig_no_out_arg": "assert ( H : 0 < length ( rev ( _i :: _i ) ) ) by ( rewrite <- length_rev ; simpl ; auto with arith ) .",
                "tactic_args": [
                    "c2_a : A",
                    "c2_l : list A",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c3_H : lt 0 (length (rev (cons a l)))"
                ]
            },
            {
                "tactic_sig": "destruct ( rev ( _i :: _i ) ) as [ | a0 l0 ] .",
                "tactic_sig_no_out_arg": "destruct ( rev ( _i :: _i ) ) as [ | a0 l0 ] .",
                "tactic_args": [
                    "c3_goal : ex\n  (fun b : A =>\n   ex\n     (fun l' : list A =>\n      eq (rev (rev (cons a l))) (app l' (cons b nil))))",
                    "c2_a : A",
                    "c2_l : list A",
                    "c3_H : lt 0 (length (rev (cons a l)))",
                    "c2_A : Type"
                ],
                "tactic_res": [
                    "c4_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (rev nil) (app l' (cons b nil))))",
                    "c4_H : lt 0 (length nil)",
                    "c5_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (rev (cons a0 l0)) (app l' (cons b nil))))",
                    "c5_H : lt 0 (length (cons a0 l0))",
                    "c5_l0 : list A",
                    "c5_a0 : A"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (rev nil) (app l' (cons b nil))))"
                ],
                "tactic_res": [
                    "c6_goal : ex (fun b : A => ex (fun l' : list A => eq nil (app l' (cons b nil))))"
                ]
            },
            {
                "tactic_sig": "elim ( Nat.nlt_0_r 0 ) .",
                "tactic_sig_no_out_arg": "elim ( Nat.nlt_0_r 0 ) .",
                "tactic_args": [
                    "c6_goal : ex (fun b : A => ex (fun l' : list A => eq nil (app l' (cons b nil))))"
                ],
                "tactic_res": [
                    "c7_goal : lt 0 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : lt 0 0",
                    "c4_H : lt 0 (length nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i , ( rev _i ) .",
                "tactic_sig_no_out_arg": "exists _i , ( rev _i ) .",
                "tactic_args": [
                    "c5_goal : ex\n  (fun b : A =>\n   ex (fun l' : list A => eq (rev (cons a0 l0)) (app l' (cons b nil))))",
                    "c5_a0 : A",
                    "c5_l0 : list A"
                ],
                "tactic_res": [
                    "c8_goal : eq (rev (cons a0 l0)) (app (rev l0) (cons a0 nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : eq (rev (cons a0 l0)) (app (rev l0) (cons a0 nil))"
                ],
                "tactic_res": [
                    "c9_goal : eq (app (rev l0) (cons a0 nil)) (app (rev l0) (cons a0 nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (app (rev l0) (cons a0 nil)) (app (rev l0) (cons a0 nil))",
                    "c5_l0 : list A",
                    "c5_a0 : A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_same",
        "proof": [
            {
                "tactic_sig": "Theorem last_same : forall { A : Type } ( a b : A ) ( l1 l2 : list A ) , l1 ++ a :: nil = l2 ++ b :: nil -> l1 = l2 /\\ a = b .",
                "tactic_sig_no_out_arg": "Theorem last_same : forall { A : Type } ( a b : A ) ( l1 l2 : list A ) , l1 ++ a :: nil = l2 ++ b :: nil -> l1 = l2 /\\ a = b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (a b : A) (l1 l2 : list A)\n  (_ : eq (app l1 (cons a nil)) (app l2 (cons b nil))),\nand (eq l1 l2) (eq a b)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros A a b l1 l2 H .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (a b : A) (l1 l2 : list A)\n  (_ : eq (app l1 (cons a nil)) (app l2 (cons b nil))),\nand (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c2_goal : and (eq l1 l2) (eq a b)",
                    "c2_A : Type",
                    "c2_a : A",
                    "c2_b : A",
                    "c2_l1 : list A",
                    "c2_l2 : list A",
                    "c2_H : eq (app l1 (cons a nil)) (app l2 (cons b nil))"
                ]
            },
            {
                "tactic_sig": "assert ( e : _i :: rev _i = _i :: rev _i ) .",
                "tactic_sig_no_out_arg": "assert ( e : _i :: rev _i = _i :: rev _i ) .",
                "tactic_args": [
                    "c2_goal : and (eq l1 l2) (eq a b)",
                    "c2_a : A",
                    "c2_l1 : list A",
                    "c2_b : A",
                    "c2_l2 : list A"
                ],
                "tactic_res": [
                    "c3_goal : eq (cons a (rev l1)) (cons b (rev l2))",
                    "c4_goal : and (eq l1 l2) (eq a b)",
                    "c4_e : eq (cons a (rev l1)) (cons b (rev l2))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite <- rev_unit .",
                "tactic_sig_no_out_arg": "repeat rewrite <- rev_unit .",
                "tactic_args": [
                    "c3_goal : eq (cons a (rev l1)) (cons b (rev l2))"
                ],
                "tactic_res": [
                    "c5_goal : eq (rev (app l1 (cons a nil))) (rev (app l2 (cons b nil)))"
                ]
            },
            {
                "tactic_sig": "now rewrite _i .",
                "tactic_sig_no_out_arg": "now rewrite _i .",
                "tactic_args": [
                    "c5_goal : eq (rev (app l1 (cons a nil))) (rev (app l2 (cons b nil)))",
                    "c2_H : eq (app l1 (cons a nil)) (app l2 (cons b nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c4_goal : and (eq l1 l2) (eq a b)",
                    "c4_e : eq (cons a (rev l1)) (cons b (rev l2))"
                ],
                "tactic_res": [
                    "c6_goal : forall (_ : eq (rev l1) (rev l2)) (_ : eq a b), and (eq l1 l2) (eq a b)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros H1 H2 .",
                "tactic_args": [
                    "c6_goal : forall (_ : eq (rev l1) (rev l2)) (_ : eq a b), and (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c7_goal : and (eq l1 l2) (eq a b)",
                    "c7_H1 : eq (rev l1) (rev l2)",
                    "c7_H2 : eq a b"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : and (eq l1 l2) (eq a b)"
                ],
                "tactic_res": [
                    "c8_goal : eq l1 l2",
                    "c9_goal : eq a b"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq a b",
                    "c7_H2 : eq a b",
                    "c2_a : A",
                    "c2_b : A",
                    "c2_A : Type"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- ( _i _i ) , _i .",
                "tactic_sig_no_out_arg": "rewrite <- ( _i _i ) , _i .",
                "tactic_args": [
                    "c8_goal : eq l1 l2",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l",
                    "c2_l1 : list A",
                    "c7_H1 : eq (rev l1) (rev l2)"
                ],
                "tactic_res": [
                    "c10_goal : eq (rev (rev l2)) l2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (rev (rev l2)) l2",
                    "_global_rev_involutive : forall (A : Type) (l : list A), eq (rev (rev l)) l"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_remove_oc_aux",
        "proof": [
            {
                "tactic_sig": "Theorem wp_remove_oc_aux : forall l : list par , wp l -> forall l1 l2 : list par , l1 ++ l2 = l -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_remove_oc_aux : forall l : list par , wp l -> forall l1 l2 : list par , l1 ++ l2 = l -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n  (_ : eq (app l1 l2) l), wp (app l1 (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n  (_ : eq (app l1 l2) l), wp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\nwp (app l1 (cons open (cons close l2)))",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c2_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\nwp (app l1 (cons open (cons close l2)))",
                    "c2_H : wp l"
                ],
                "tactic_res": [
                    "c3_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) nil),\nwp (app l1 (cons open (cons close l2)))",
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l1),\n       wp (app l3 (cons open (cons close l4)))) (_ : wp l2)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l2),\n       wp (app l3 (cons open (cons close l4)))) (l3 l4 : list par)\n  (_ : eq (app l3 l4) (app l1 l2)),\nwp (app l3 (cons open (cons close l4)))",
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\n       wp (app l1 (cons open (cons close l2)))) (l1 l2 : list par)\n  (_ : eq (app l1 l2) (cons open (app l (cons close nil)))),\nwp (app l1 (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 H1 .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : eq (app l1 l2) nil),\nwp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c6_goal : wp (app l1 (cons open (cons close l2)))",
                    "c6_l1 : list par",
                    "c6_l2 : list par",
                    "c6_H1 : eq (app l1 l2) nil"
                ]
            },
            {
                "tactic_sig": "elim ( app_eq_nil _ _ _i ) .",
                "tactic_sig_no_out_arg": "elim ( app_eq_nil _ _ _i ) .",
                "tactic_args": [
                    "c6_goal : wp (app l1 (cons open (cons close l2)))",
                    "c6_H1 : eq (app l1 l2) nil"
                ],
                "tactic_res": [
                    "c7_goal : forall (_ : eq l1 nil) (_ : eq l2 nil),\nwp (app l1 (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq1 Heq2 .",
                "tactic_args": [
                    "c7_goal : forall (_ : eq l1 nil) (_ : eq l2 nil),\nwp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c8_goal : wp (app l1 (cons open (cons close l2)))",
                    "c8_Heq1 : eq l1 nil",
                    "c8_Heq2 : eq l2 nil"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : wp (app l1 (cons open (cons close l2)))",
                    "c8_Heq1 : eq l1 nil"
                ],
                "tactic_res": [
                    "c9_goal : wp (app nil (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : wp (app nil (cons open (cons close l2)))",
                    "c8_Heq2 : eq l2 nil"
                ],
                "tactic_res": [
                    "c10_goal : wp (app nil (cons open (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp (app nil (cons open (cons close nil)))",
                    "_global_wp_oc : wp (cons open (cons close nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 Hp1 Hr1 Hp2 Hr2 l3 l4 Heq .",
                "tactic_args": [
                    "c4_goal : forall (l1 l2 : list par) (_ : wp l1)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l1),\n       wp (app l3 (cons open (cons close l4)))) (_ : wp l2)\n  (_ : forall (l3 l4 : list par) (_ : eq (app l3 l4) l2),\n       wp (app l3 (cons open (cons close l4)))) (l3 l4 : list par)\n  (_ : eq (app l3 l4) (app l1 l2)),\nwp (app l3 (cons open (cons close l4)))"
                ],
                "tactic_res": [
                    "c11_goal : wp (app l3 (cons open (cons close l4)))",
                    "c11_l1 : list par",
                    "c11_l2 : list par",
                    "c11_Hp1 : wp l1",
                    "c11_Hr1 : forall (l2 l3 : list par) (_ : eq (app l2 l3) l1),\nwp (app l2 (cons open (cons close l3)))",
                    "c11_Hp2 : wp l2",
                    "c11_Hr2 : forall (l1 l3 : list par) (_ : eq (app l1 l3) l2),\nwp (app l1 (cons open (cons close l3)))",
                    "c11_l3 : list par",
                    "c11_l4 : list par",
                    "c11_Heq : eq (app l3 l4) (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "elim app_decompose with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim app_decompose with ( 1 := _i ) .",
                "tactic_args": [
                    "c11_goal : wp (app l3 (cons open (cons close l4)))",
                    "c11_Heq : eq (app l3 l4) (app l1 l2)"
                ],
                "tactic_res": [
                    "c12_goal : forall\n  _ : ex\n        (fun l1' : list par =>\n         and (eq l3 (app l1 l1')) (eq l2 (app l1' l4))),\nwp (app l3 (cons open (cons close l4)))",
                    "c13_goal : forall\n  _ : ex\n        (fun a : par =>\n         ex\n           (fun l2' : list par =>\n            and (eq l1 (app l3 (cons a l2')))\n              (eq l4 (app (cons a l2') l2)))),\nwp (app l3 (cons open (cons close l4)))"
                ]
            },
            {
                "tactic_sig": "intros [ _o [ _o _o ] ] .",
                "tactic_sig_no_out_arg": "intros [ l1' [ Heq1 Heq2 ] ] .",
                "tactic_args": [
                    "c12_goal : forall\n  _ : ex\n        (fun l1' : list par =>\n         and (eq l3 (app l1 l1')) (eq l2 (app l1' l4))),\nwp (app l3 (cons open (cons close l4)))"
                ],
                "tactic_res": [
                    "c14_goal : wp (app l3 (cons open (cons close l4)))",
                    "c14_l1' : list par",
                    "c14_Heq1 : eq l3 (app l1 l1')",
                    "c14_Heq2 : eq l2 (app l1' l4)"
                ]
            },
            {
                "tactic_sig": "rewrite _i , <- _i .",
                "tactic_sig_no_out_arg": "rewrite _i , <- _i .",
                "tactic_args": [
                    "c14_goal : wp (app l3 (cons open (cons close l4)))",
                    "c14_Heq1 : eq l3 (app l1 l1')",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c15_goal : wp (app l1 (app l1' (cons open (cons close l4))))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : wp (app l1 (app l1' (cons open (cons close l4))))",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c16_goal : wp l1",
                    "c17_goal : wp (app l1' (cons open (cons close l4)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : wp l1",
                    "c11_Hp1 : wp l1",
                    "c11_l1 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : wp (app l1' (cons open (cons close l4)))",
                    "c14_Heq2 : eq l2 (app l1' l4)",
                    "c14_l1' : list par",
                    "c11_l4 : list par",
                    "c11_Hr2 : forall (l1 l3 : list par) (_ : eq (app l1 l3) l2),\nwp (app l1 (cons open (cons close l3)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros [ _o [ _o [ _o _o ] ] ] .",
                "tactic_sig_no_out_arg": "intros [ a' [ l2' [ Heq1 Heq2 ] ] ] .",
                "tactic_args": [
                    "c13_goal : forall\n  _ : ex\n        (fun a : par =>\n         ex\n           (fun l2' : list par =>\n            and (eq l1 (app l3 (cons a l2')))\n              (eq l4 (app (cons a l2') l2)))),\nwp (app l3 (cons open (cons close l4)))"
                ],
                "tactic_res": [
                    "c18_goal : wp (app l3 (cons open (cons close l4)))",
                    "c18_a' : par",
                    "c18_l2' : list par",
                    "c18_Heq1 : eq l1 (app l3 (cons a' l2'))",
                    "c18_Heq2 : eq l4 (app (cons a' l2') l2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c18_goal : wp (app l3 (cons open (cons close l4)))",
                    "c18_Heq2 : eq l4 (app (cons a' l2') l2)"
                ],
                "tactic_res": [
                    "c19_goal : wp (app l3 (cons open (cons close (app (cons a' l2') l2))))"
                ]
            },
            {
                "tactic_sig": "repeat rewrite app_comm_cons .",
                "tactic_sig_no_out_arg": "repeat rewrite app_comm_cons .",
                "tactic_args": [
                    "c19_goal : wp (app l3 (cons open (cons close (app (cons a' l2') l2))))"
                ],
                "tactic_res": [
                    "c20_goal : wp (app l3 (app (cons open (cons close (cons a' l2'))) l2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c20_goal : wp (app l3 (app (cons open (cons close (cons a' l2'))) l2))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c21_goal : wp (app (app l3 (cons open (cons close (cons a' l2')))) l2)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : wp (app (app l3 (cons open (cons close (cons a' l2')))) l2)",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c22_goal : wp (app l3 (cons open (cons close (cons a' l2'))))",
                    "c23_goal : wp l2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : wp (app l3 (cons open (cons close (cons a' l2'))))",
                    "c18_Heq1 : eq l1 (app l3 (cons a' l2'))",
                    "c18_l2' : list par",
                    "c18_a' : par",
                    "c11_l3 : list par",
                    "c11_Hr1 : forall (l2 l3 : list par) (_ : eq (app l2 l3) l1),\nwp (app l2 (cons open (cons close l3)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : wp l2",
                    "c11_Hp2 : wp l2",
                    "c11_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hp'' Hrec l1 .",
                "tactic_args": [
                    "c5_goal : forall (l : list par) (_ : wp l)\n  (_ : forall (l1 l2 : list par) (_ : eq (app l1 l2) l),\n       wp (app l1 (cons open (cons close l2)))) (l1 l2 : list par)\n  (_ : eq (app l1 l2) (cons open (app l (cons close nil)))),\nwp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c24_goal : forall (l2 : list par)\n  (_ : eq (app l1 l2) (cons open (app l' (cons close nil)))),\nwp (app l1 (cons open (cons close l2)))",
                    "c24_l' : list par",
                    "c24_Hp'' : wp l'",
                    "c24_Hrec : forall (l1 l2 : list par) (_ : eq (app l1 l2) l'),\nwp (app l1 (cons open (cons close l2)))",
                    "c24_l1 : list par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c24_goal : forall (l2 : list par)\n  (_ : eq (app l1 l2) (cons open (app l' (cons close nil)))),\nwp (app l1 (cons open (cons close l2)))",
                    "c24_l1 : list par"
                ],
                "tactic_res": [
                    "c25_goal : forall (l2 : list par)\n  (_ : eq (app nil l2) (cons open (app l' (cons close nil)))),\nwp (app nil (cons open (cons close l2)))",
                    "c26_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (app (cons p l) l2) (cons open (app l' (cons close nil)))),\nwp (app (cons p l) (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c25_goal : forall (l2 : list par)\n  (_ : eq (app nil l2) (cons open (app l' (cons close nil)))),\nwp (app nil (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c27_goal : forall (l2 : list par)\n  (_ : eq l2 (cons open (app l' (cons close nil)))),\nwp (cons open (cons close l2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l2 Heq .",
                "tactic_args": [
                    "c27_goal : forall (l2 : list par)\n  (_ : eq l2 (cons open (app l' (cons close nil)))),\nwp (cons open (cons close l2))"
                ],
                "tactic_res": [
                    "c28_goal : wp (cons open (cons close l2))",
                    "c28_l2 : list par",
                    "c28_Heq : eq l2 (cons open (app l' (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c28_goal : wp (cons open (cons close l2))",
                    "c28_Heq : eq l2 (cons open (app l' (cons close nil)))"
                ],
                "tactic_res": [
                    "c29_goal : wp (cons open (cons close (cons open (app l' (cons close nil)))))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: nil ++ close :: open :: _i ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: nil ++ close :: open :: _i ++ close :: nil ) ) .",
                "tactic_args": [
                    "c29_goal : wp (cons open (cons close (cons open (app l' (cons close nil)))))",
                    "c24_l' : list par"
                ],
                "tactic_res": [
                    "c30_goal : wp\n  (cons open\n     (app nil (cons close (cons open (app l' (cons close nil))))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : wp\n  (cons open\n     (app nil (cons close (cons open (app l' (cons close nil))))))",
                    "c24_Hp'' : wp l'",
                    "c24_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c26_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (app (cons p l) l2) (cons open (app l' (cons close nil)))),\nwp (app (cons p l) (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c31_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (cons p (app l l2)) (cons open (app l' (cons close nil)))),\nwp (cons p (app l (cons open (cons close l2))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c l1' l2 .",
                "tactic_args": [
                    "c31_goal : forall (p : par) (l l2 : list par)\n  (_ : eq (cons p (app l l2)) (cons open (app l' (cons close nil)))),\nwp (cons p (app l (cons open (cons close l2))))"
                ],
                "tactic_res": [
                    "c32_goal : forall\n  _ : eq (cons c (app l1' l2)) (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close l2))))",
                    "c32_c : par",
                    "c32_l1' : list par",
                    "c32_l2 : list par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c32_goal : forall\n  _ : eq (cons c (app l1' l2)) (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close l2))))",
                    "c32_l2 : list par"
                ],
                "tactic_res": [
                    "c33_goal : forall\n  _ : eq (cons c (app l1' nil)) (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close nil))))",
                    "c34_goal : forall (p : par) (l : list par)\n  (_ : eq (cons c (app l1' (cons p l)))\n         (cons open (app l' (cons close nil)))),\nwp (cons c (app l1' (cons open (cons close (cons p l)))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c33_goal : forall\n  _ : eq (cons c (app l1' nil)) (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close nil))))"
                ],
                "tactic_res": [
                    "c35_goal : wp (cons c (app l1' (cons open (cons close nil))))",
                    "c35_Heq : eq (cons c (app l1' nil)) (cons open (app l' (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c35_goal : wp (cons c (app l1' (cons open (cons close nil))))",
                    "c35_Heq : eq (cons c (app l1' nil)) (cons open (app l' (cons close nil)))"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : eq (app l1' nil) (app l' (cons close nil))) (_ : eq c open),\nwp (cons c (app l1' (cons open (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq1 Heq2 .",
                "tactic_args": [
                    "c36_goal : forall (_ : eq (app l1' nil) (app l' (cons close nil))) (_ : eq c open),\nwp (cons c (app l1' (cons open (cons close nil))))"
                ],
                "tactic_res": [
                    "c37_goal : wp (cons c (app l1' (cons open (cons close nil))))",
                    "c37_Heq1 : eq (app l1' nil) (app l' (cons close nil))",
                    "c37_Heq2 : eq c open"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l nil) l",
                    "c37_Heq1 : eq (app l1' nil) (app l' (cons close nil))"
                ],
                "tactic_res": [
                    "c37_Heq1 : eq l1' (app l' (cons close nil))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c37_goal : wp (cons c (app l1' (cons open (cons close nil))))",
                    "c37_Heq1 : eq l1' (app l' (cons close nil))"
                ],
                "tactic_res": [
                    "c38_goal : wp\n  (cons c (app (app l' (cons close nil)) (cons open (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c38_goal : wp\n  (cons c (app (app l' (cons close nil)) (cons open (cons close nil))))",
                    "c37_Heq2 : eq c open"
                ],
                "tactic_res": [
                    "c39_goal : wp\n  (cons open\n     (app (app l' (cons close nil)) (cons open (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c39_goal : wp\n  (cons open\n     (app (app l' (cons close nil)) (cons open (cons close nil))))",
                    "_global_app_comm_cons : forall (A : Type) (x y : list A) (a : A),\n       eq (cons a (app x y)) (app (cons a x) y)"
                ],
                "tactic_res": [
                    "c40_goal : wp\n  (app (cons open (app l' (cons close nil)))\n     (cons open (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : wp\n  (app (cons open (app l' (cons close nil)))\n     (cons open (cons close nil)))",
                    "_global_wp_concat : forall (l1 l2 : list par) (_ : wp l1) (_ : wp l2), wp (app l1 l2)"
                ],
                "tactic_res": [
                    "c41_goal : wp (cons open (app l' (cons close nil)))",
                    "c42_goal : wp (cons open (cons close nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : wp (cons open (app l' (cons close nil)))",
                    "c24_Hp'' : wp l'",
                    "c24_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : wp (cons open (cons close nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros c' l2' .",
                "tactic_args": [
                    "c34_goal : forall (p : par) (l : list par)\n  (_ : eq (cons c (app l1' (cons p l)))\n         (cons open (app l' (cons close nil)))),\nwp (cons c (app l1' (cons open (cons close (cons p l)))))"
                ],
                "tactic_res": [
                    "c43_goal : forall\n  _ : eq (cons c (app l1' (cons c' l2')))\n        (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))",
                    "c43_c' : par",
                    "c43_l2' : list par"
                ]
            },
            {
                "tactic_sig": "elim ( cons_to_app_end _i _i ) .",
                "tactic_sig_no_out_arg": "elim ( cons_to_app_end _i _i ) .",
                "tactic_args": [
                    "c43_goal : forall\n  _ : eq (cons c (app l1' (cons c' l2')))\n        (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))",
                    "c43_l2' : list par",
                    "c43_c' : par"
                ],
                "tactic_res": [
                    "c44_goal : forall (x : par)\n  (_ : ex (fun l' : list par => eq (cons c' l2') (app l' (cons x nil))))\n  (_ : eq (cons c (app l1' (cons c' l2')))\n         (cons open (app l' (cons close nil)))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))"
                ]
            },
            {
                "tactic_sig": "intros _o [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros c'' [ l2'' Heq ] .",
                "tactic_args": [
                    "c44_goal : forall (x : par)\n  (_ : ex (fun l' : list par => eq (cons c' l2') (app l' (cons x nil))))\n  (_ : eq (cons c (app l1' (cons c' l2')))\n         (cons open (app l' (cons close nil)))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))"
                ],
                "tactic_res": [
                    "c45_goal : forall\n  _ : eq (cons c (app l1' (cons c' l2')))\n        (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))",
                    "c45_c'' : par",
                    "c45_l2'' : list par",
                    "c45_Heq : eq (cons c' l2') (app l2'' (cons c'' nil))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c45_goal : forall\n  _ : eq (cons c (app l1' (cons c' l2')))\n        (cons open (app l' (cons close nil))),\nwp (cons c (app l1' (cons open (cons close (cons c' l2')))))",
                    "c45_Heq : eq (cons c' l2') (app l2'' (cons c'' nil))"
                ],
                "tactic_res": [
                    "c46_goal : forall\n  _ : eq (cons c (app l1' (app l2'' (cons c'' nil))))\n        (cons open (app l' (cons close nil))),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c46_goal : forall\n  _ : eq (cons c (app l1' (app l2'' (cons c'' nil))))\n        (cons open (app l' (cons close nil))),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c47_goal : forall\n  _ : eq (cons c (app (app l1' l2'') (cons c'' nil)))\n        (cons open (app l' (cons close nil))),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq1 .",
                "tactic_args": [
                    "c47_goal : forall\n  _ : eq (cons c (app (app l1' l2'') (cons c'' nil)))\n        (cons open (app l' (cons close nil))),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ],
                "tactic_res": [
                    "c48_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c48_Heq1 : eq (cons c (app (app l1' l2'') (cons c'' nil)))\n  (cons open (app l' (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c48_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c48_Heq1 : eq (cons c (app (app l1' l2'') (cons c'' nil)))\n  (cons open (app l' (cons close nil)))"
                ],
                "tactic_res": [
                    "c49_goal : forall\n  (_ : eq (app (app l1' l2'') (cons c'' nil)) (app l' (cons close nil)))\n  (_ : eq c open),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq2 Heq3 .",
                "tactic_args": [
                    "c49_goal : forall\n  (_ : eq (app (app l1' l2'') (cons c'' nil)) (app l' (cons close nil)))\n  (_ : eq c open),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ],
                "tactic_res": [
                    "c50_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c50_Heq2 : eq (app (app l1' l2'') (cons c'' nil)) (app l' (cons close nil))",
                    "c50_Heq3 : eq c open"
                ]
            },
            {
                "tactic_sig": "elim last_same with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "elim last_same with ( 1 := _i ) .",
                "tactic_args": [
                    "c50_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c50_Heq2 : eq (app (app l1' l2'') (cons c'' nil)) (app l' (cons close nil))"
                ],
                "tactic_res": [
                    "c51_goal : forall (_ : eq (app l1' l2'') l') (_ : eq c'' close),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Heq4 Heq5 .",
                "tactic_args": [
                    "c51_goal : forall (_ : eq (app l1' l2'') l') (_ : eq c'' close),\nwp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))"
                ],
                "tactic_res": [
                    "c52_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c52_Heq4 : eq (app l1' l2'') l'",
                    "c52_Heq5 : eq c'' close"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c52_goal : wp\n  (cons c (app l1' (cons open (cons close (app l2'' (cons c'' nil))))))",
                    "c52_Heq5 : eq c'' close"
                ],
                "tactic_res": [
                    "c53_goal : wp\n  (cons c\n     (app l1' (cons open (cons close (app l2'' (cons close nil))))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c53_goal : wp\n  (cons c\n     (app l1' (cons open (cons close (app l2'' (cons close nil))))))",
                    "c50_Heq3 : eq c open"
                ],
                "tactic_res": [
                    "c54_goal : wp\n  (cons open\n     (app l1' (cons open (cons close (app l2'' (cons close nil))))))"
                ]
            },
            {
                "tactic_sig": "change ( wp ( open :: _i ++ ( open :: close :: _i ) ++ close :: nil ) ) .",
                "tactic_sig_no_out_arg": "change ( wp ( open :: _i ++ ( open :: close :: _i ) ++ close :: nil ) ) .",
                "tactic_args": [
                    "c54_goal : wp\n  (cons open\n     (app l1' (cons open (cons close (app l2'' (cons close nil))))))",
                    "c32_l1' : list par",
                    "c45_l2'' : list par"
                ],
                "tactic_res": [
                    "c55_goal : wp\n  (cons open\n     (app l1' (app (cons open (cons close l2'')) (cons close nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c55_goal : wp\n  (cons open\n     (app l1' (app (cons open (cons close l2'')) (cons close nil))))",
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)"
                ],
                "tactic_res": [
                    "c56_goal : wp\n  (cons open\n     (app (app l1' (cons open (cons close l2''))) (cons close nil)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : wp\n  (cons open\n     (app (app l1' (cons open (cons close l2''))) (cons close nil)))",
                    "c52_Heq4 : eq (app l1' l2'') l'",
                    "c45_l2'' : list par",
                    "c32_l1' : list par",
                    "c24_Hrec : forall (l1 l2 : list par) (_ : eq (app l1 l2) l'),\nwp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "wp_remove_oc",
        "proof": [
            {
                "tactic_sig": "Theorem wp_remove_oc : forall l1 l2 : list par , wp ( l1 ++ l2 ) -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_sig_no_out_arg": "Theorem wp_remove_oc : forall l1 l2 : list par , wp ( l1 ++ l2 ) -> wp ( l1 ++ open :: close :: l2 ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\nwp (app l1 (cons open (cons close l2)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\nwp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c2_goal : wp (app l1 (cons open (cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par",
                    "c2_H : wp (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( l := _i ++ _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( l := _i ++ _i ) .",
                "tactic_args": [
                    "c2_goal : wp (app l1 (cons open (cons close l2)))",
                    "_global_wp_remove_oc_aux : forall (l : list par) (_ : wp l) (l1 l2 : list par)\n         (_ : eq (app l1 l2) l), wp (app l1 (cons open (cons close l2)))",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": [
                    "c3_goal : wp (app l1 l2)",
                    "c4_goal : eq (app l1 l2) (app l1 l2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : wp (app l1 l2)",
                    "c2_H : wp (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (app l1 l2) (app l1 l2)",
                    "c2_l1 : list par",
                    "c2_l2 : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "make_list_end",
        "proof": [
            {
                "tactic_sig": "Theorem make_list_end : forall ( A : Type ) ( a : A ) ( n : nat ) ( l : list A ) , make_list A a ( S n ) ++ l = make_list A a n ++ a :: l .",
                "tactic_sig_no_out_arg": "Theorem make_list_end : forall ( A : Type ) ( a : A ) ( n : nat ) ( l : list A ) , make_list A a ( S n ) ++ l = make_list A a n ++ a :: l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (A : Type) (a : A) (n : nat) (l : list A),\neq (app (make_list A a (S n)) l) (app (make_list A a n) (cons a l))"
                ]
            },
            {
                "tactic_sig": "simple induction n .",
                "tactic_sig_no_out_arg": "simple induction n .",
                "tactic_args": [
                    "c1_goal : forall (A : Type) (a : A) (n : nat) (l : list A),\neq (app (make_list A a (S n)) l) (app (make_list A a n) (cons a l))"
                ],
                "tactic_res": [
                    "c2_goal : forall l : list A,\neq (app (make_list A a 1) l) (app (make_list A a 0) (cons a l))",
                    "c2_n : nat",
                    "c2_a : A",
                    "c2_A : Type",
                    "c3_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (cons a l))) (l : list A),\neq (app (make_list A a (S (S n))) l)\n  (app (make_list A a (S n)) (cons a l))",
                    "c3_n : nat",
                    "c3_a : A",
                    "c3_A : Type"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall l : list A,\neq (app (make_list A a 1) l) (app (make_list A a 0) (cons a l))"
                ],
                "tactic_res": [
                    "c4_goal : forall l : list A, eq (cons a l) (cons a l)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (app (make_list A a (S n)) l)\n         (app (make_list A a n) (cons a l))) (l : list A),\neq (app (make_list A a (S (S n))) l)\n  (app (make_list A a (S n)) (cons a l))"
                ],
                "tactic_res": [
                    "c5_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (cons a (app (make_list A a n) l))\n         (app (make_list A a n) (cons a l))) (l : list A),\neq (cons a (cons a (app (make_list A a n) l)))\n  (cons a (app (make_list A a n) (cons a l)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c4_goal : forall l : list A, eq (cons a l) (cons a l)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros n' H l .",
                "tactic_args": [
                    "c5_goal : forall (n : nat)\n  (_ : forall l : list A,\n       eq (cons a (app (make_list A a n) l))\n         (app (make_list A a n) (cons a l))) (l : list A),\neq (cons a (cons a (app (make_list A a n) l)))\n  (cons a (app (make_list A a n) (cons a l)))"
                ],
                "tactic_res": [
                    "c6_goal : eq (cons a (cons a (app (make_list A a n') l)))\n  (cons a (app (make_list A a n') (cons a l)))",
                    "c6_n' : nat",
                    "c6_H : forall l : list A,\neq (cons a (app (make_list A a n') l))\n  (app (make_list A a n') (cons a l))",
                    "c6_l : list A"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eq (cons a (cons a (app (make_list A a n') l)))\n  (cons a (app (make_list A a n') (cons a l)))",
                    "c6_H : forall l : list A,\neq (cons a (app (make_list A a n') l))\n  (app (make_list A a n') (cons a l))"
                ],
                "tactic_res": [
                    "c7_goal : eq (cons a (app (make_list A a n') (cons a l)))\n  (cons a (app (make_list A a n') (cons a l)))"
                ]
            },
            {
                "tactic_sig": "trivial .",
                "tactic_sig_no_out_arg": "trivial .",
                "tactic_args": [
                    "c7_goal : eq (cons a (app (make_list A a n') (cons a l)))\n  (cons a (app (make_list A a n') (cons a l)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_sound_aux",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_sound_aux : forall ( l : list par ) ( n : nat ) , recognize n l = true -> wp ( make_list _ open n ++ l ) .",
                "tactic_sig_no_out_arg": "Theorem recognize_sound_aux : forall ( l : list par ) ( n : nat ) , recognize n l = true -> wp ( make_list _ open n ++ l ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (n : nat) (_ : eq (recognize n l) true),\nwp (app (make_list par open n) l)"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (n : nat) (_ : eq (recognize n l) true),\nwp (app (make_list par open n) l)"
                ],
                "tactic_res": [
                    "c2_goal : forall (n : nat) (_ : eq (recognize n nil) true),\nwp (app (make_list par open n) nil)",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize n (cons a l)) true),\nwp (app (make_list par open n) (cons a l))",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (n : nat) (_ : eq (recognize n nil) true),\nwp (app (make_list par open n) nil)"
                ],
                "tactic_res": [
                    "c4_goal : forall (n : nat)\n  (_ : eq match n with\n          | 0 => true\n          | S _ => false\n          end true), wp (app (make_list par open n) nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize n (cons a l)) true),\nwp (app (make_list par open n) (cons a l))"
                ],
                "tactic_res": [
                    "c5_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true), wp (app (make_list par open n) (cons a l))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros n .",
                "tactic_args": [
                    "c4_goal : forall (n : nat)\n  (_ : eq match n with\n          | 0 => true\n          | S _ => false\n          end true), wp (app (make_list par open n) nil)"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : eq match n with\n              | 0 => true\n              | S _ => false\n              end true, wp (app (make_list par open n) nil)",
                    "c6_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c6_goal : forall _ : eq match n with\n              | 0 => true\n              | S _ => false\n              end true, wp (app (make_list par open n) nil)",
                    "c6_n : nat"
                ],
                "tactic_res": [
                    "c7_goal : forall _ : eq true true, wp (app (make_list par open 0) nil)",
                    "c8_goal : forall (n : nat) (_ : eq false true),\nwp (app (make_list par open (S n)) nil)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : forall _ : eq true true, wp (app (make_list par open 0) nil)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq true true, wp nil"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall _ : eq true true, wp nil"
                ],
                "tactic_res": [
                    "c10_goal : wp nil",
                    "c10_H : eq true true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : wp nil",
                    "_global_wp_nil : wp nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n' H .",
                "tactic_args": [
                    "c8_goal : forall (n : nat) (_ : eq false true),\nwp (app (make_list par open (S n)) nil)"
                ],
                "tactic_res": [
                    "c11_goal : wp (app (make_list par open (S n')) nil)",
                    "c11_n' : nat",
                    "c11_H : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c11_goal : wp (app (make_list par open (S n')) nil)",
                    "c11_H : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c5_goal : forall (a : par) (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true), wp (app (make_list par open n) (cons a l))"
                ],
                "tactic_res": [
                    "c12_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true), wp (app (make_list par open n) (cons a l))",
                    "c12_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c12_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq\n         match a with\n         | open => recognize (S n) l\n         | close =>\n             match n with\n             | 0 => false\n             | S n' => recognize n' l\n             end\n         end true), wp (app (make_list par open n) (cons a l))",
                    "c12_a : par"
                ],
                "tactic_res": [
                    "c13_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize (S n) l) true),\nwp (app (make_list par open n) (cons open l))",
                    "c14_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq match n with\n          | 0 => false\n          | S n' => recognize n' l\n          end true), wp (app (make_list par open n) (cons close l))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c12_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c12_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' H n H0 .",
                "tactic_args": [
                    "c13_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq (recognize (S n) l) true),\nwp (app (make_list par open n) (cons open l))"
                ],
                "tactic_res": [
                    "c15_goal : wp (app (make_list par open n) (cons open l'))",
                    "c15_l' : list par",
                    "c15_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c15_n : nat",
                    "c15_H0 : eq (recognize (S n) l') true"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c15_goal : wp (app (make_list par open n) (cons open l'))",
                    "_global_make_list_end : forall (A : Type) (a : A) (n : nat) (l : list A),\n       eq (app (make_list A a (S n)) l) (app (make_list A a n) (cons a l))"
                ],
                "tactic_res": [
                    "c16_goal : wp (app (make_list par open (S n)) l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : wp (app (make_list par open (S n)) l')",
                    "c15_H0 : eq (recognize (S n) l') true",
                    "c15_n : nat",
                    "c15_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c15_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' H n .",
                "tactic_args": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (n : nat) (_ : eq (recognize n l) true),\n       wp (app (make_list par open n) l)) (n : nat)\n  (_ : eq match n with\n          | 0 => false\n          | S n' => recognize n' l\n          end true), wp (app (make_list par open n) (cons close l))"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : eq match n with\n         | 0 => false\n         | S n' => recognize n' l'\n         end true, wp (app (make_list par open n) (cons close l'))",
                    "c17_l' : list par",
                    "c17_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c17_n : nat"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : eq match n with\n         | 0 => false\n         | S n' => recognize n' l'\n         end true, wp (app (make_list par open n) (cons close l'))",
                    "c17_n : nat"
                ],
                "tactic_res": [
                    "c18_goal : forall _ : eq false true,\nwp (app (make_list par open 0) (cons close l'))",
                    "c19_goal : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open (S n)) (cons close l'))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c17_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c17_n : nat"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H' .",
                "tactic_args": [
                    "c18_goal : forall _ : eq false true,\nwp (app (make_list par open 0) (cons close l'))"
                ],
                "tactic_res": [
                    "c20_goal : wp (app (make_list par open 0) (cons close l'))",
                    "c20_H' : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c20_goal : wp (app (make_list par open 0) (cons close l'))",
                    "c20_H' : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n H0 .",
                "tactic_args": [
                    "c19_goal : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open (S n)) (cons close l'))"
                ],
                "tactic_res": [
                    "c21_goal : wp (app (make_list par open (S n)) (cons close l'))",
                    "c21_n : nat",
                    "c21_H0 : eq (recognize n l') true"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : wp (app (make_list par open (S n)) (cons close l'))",
                    "_global_make_list_end : forall (A : Type) (a : A) (n : nat) (l : list A),\n       eq (app (make_list A a (S n)) l) (app (make_list A a n) (cons a l))"
                ],
                "tactic_res": [
                    "c22_goal : wp (app (make_list par open n) (cons open (cons close l')))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : wp (app (make_list par open n) (cons open (cons close l')))",
                    "_global_wp_remove_oc : forall (l1 l2 : list par) (_ : wp (app l1 l2)),\n       wp (app l1 (cons open (cons close l2)))"
                ],
                "tactic_res": [
                    "c23_goal : wp (app (make_list par open n) l')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : wp (app (make_list par open n) l')",
                    "c21_H0 : eq (recognize n l') true",
                    "c21_n : nat",
                    "c17_H : forall (n : nat) (_ : eq (recognize n l') true),\nwp (app (make_list par open n) l')",
                    "c17_l' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "recognize_sound",
        "proof": [
            {
                "tactic_sig": "Theorem recognize_sound : forall l : list par , recognize 0 l = true -> wp l .",
                "tactic_sig_no_out_arg": "Theorem recognize_sound : forall l : list par , recognize 0 l = true -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : eq (recognize 0 l) true), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : eq (recognize 0 l) true), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_H : eq (recognize 0 l) true"
                ]
            },
            {
                "tactic_sig": "generalize ( recognize_sound_aux _ _ _i ) .",
                "tactic_sig_no_out_arg": "generalize ( recognize_sound_aux _ _ _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "c2_H : eq (recognize 0 l) true"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : wp (app (make_list par open 0) l), wp l"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : wp (app (make_list par open 0) l), wp l"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : wp l, wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall _ : wp l, wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_reject_indep_t",
        "proof": [
            {
                "tactic_sig": "Theorem parse_reject_indep_t : forall ( l : list par ) ( s : list bin ) ( t : bin ) , parse s t l = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l = None .",
                "tactic_sig_no_out_arg": "Theorem parse_reject_indep_t : forall ( l : list par ) ( s : list bin ) ( t : bin ) , parse s t l = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (s : list bin) (t : bin)\n  (_ : eq (parse s t l) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l) None"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (s : list bin) (t : bin)\n  (_ : eq (parse s t l) None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l) None"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t : bin) (_ : eq (parse s t nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' nil) None",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons a l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons a l)) None",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t : bin) (_ : eq (parse s t nil) None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' nil) None"
                ],
                "tactic_res": [
                    "c4_goal : forall (t : bin) (_ : eq (parse s t nil) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' nil) None",
                    "c4_s : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (t : bin) (_ : eq (parse s t nil) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' nil) None",
                    "c4_s : list bin"
                ],
                "tactic_res": [
                    "c5_goal : forall (t : bin) (_ : eq (parse nil t nil) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length nil)),\neq (parse s' t' nil) None",
                    "c6_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse (cons b l) t nil) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (cons b l))),\neq (parse s' t' nil) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (t : bin) (_ : eq (parse nil t nil) None) (s' : list bin)\n  (t' : bin) (_ : eq (length s') (length nil)),\neq (parse s' t' nil) None"
                ],
                "tactic_res": [
                    "c7_goal : forall (t : bin) (_ : eq (Some t) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') 0),\neq match s' with\n   | nil => Some t'\n   | cons _ _ => None\n   end None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t H .",
                "tactic_args": [
                    "c7_goal : forall (t : bin) (_ : eq (Some t) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') 0),\neq match s' with\n   | nil => Some t'\n   | cons _ _ => None\n   end None"
                ],
                "tactic_res": [
                    "c8_goal : forall (s' : list bin) (t' : bin) (_ : eq (length s') 0),\neq match s' with\n   | nil => Some t'\n   | cons _ _ => None\n   end None",
                    "c8_t : bin",
                    "c8_H : eq (Some t) None"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c8_goal : forall (s' : list bin) (t' : bin) (_ : eq (length s') 0),\neq match s' with\n   | nil => Some t'\n   | cons _ _ => None\n   end None",
                    "c8_H : eq (Some t) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t H s' .",
                "tactic_args": [
                    "c6_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse (cons b l) t nil) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (cons b l))),\neq (parse s' t' nil) None"
                ],
                "tactic_res": [
                    "c9_goal : forall (t' : bin) (_ : eq (length s') (length (cons t0 s0))),\neq (parse s' t' nil) None",
                    "c9_t0 : bin",
                    "c9_s0 : list bin",
                    "c9_t : bin",
                    "c9_H : eq (parse (cons t0 s0) t nil) None",
                    "c9_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c9_goal : forall (t' : bin) (_ : eq (length s') (length (cons t0 s0))),\neq (parse s' t' nil) None",
                    "c9_s' : list bin"
                ],
                "tactic_res": [
                    "c10_goal : forall (t' : bin) (_ : eq (length nil) (length (cons t0 s0))),\neq (parse nil t' nil) None",
                    "c11_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length (cons t0 s0))),\neq (parse (cons b l) t' nil) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c10_goal : forall (t' : bin) (_ : eq (length nil) (length (cons t0 s0))),\neq (parse nil t' nil) None"
                ],
                "tactic_res": [
                    "c12_goal : forall (t' : bin) (_ : eq 0 (S (length s0))), eq (Some t') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t' Hle .",
                "tactic_args": [
                    "c12_goal : forall (t' : bin) (_ : eq 0 (S (length s0))), eq (Some t') None"
                ],
                "tactic_res": [
                    "c13_goal : eq (Some t') None",
                    "c13_t' : bin",
                    "c13_Hle : eq 0 (S (length s0))"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c13_goal : eq (Some t') None",
                    "c13_Hle : eq 0 (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c11_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length (cons t0 s0))),\neq (parse (cons b l) t' nil) None"
                ],
                "tactic_res": [
                    "c14_goal : forall (_ : bin) (l : list bin) (_ : bin)\n  (_ : eq (S (length l)) (S (length s0))), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : forall (_ : bin) (l : list bin) (_ : bin)\n  (_ : eq (S (length l)) (S (length s0))), eq None None",
                    "c9_s0 : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons a l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons a l)) None"
                ],
                "tactic_res": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons a l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons a l)) None",
                    "c15_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons a l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons a l)) None",
                    "c15_a : par"
                ],
                "tactic_res": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons open l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons open l)) None",
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons close l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons close l)) None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons open l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons open l)) None"
                ],
                "tactic_res": [
                    "c18_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse (cons t s) L l) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse (cons t' s') L l) None"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c15_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c18_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse (cons t s) L l) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse (cons t' s') L l) None"
                ],
                "tactic_res": [
                    "c19_goal : forall (t : bin) (_ : eq (parse (cons t s) L l') None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse (cons t' s') L l') None",
                    "c19_l' : list par",
                    "c19_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c19_s : list bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq (parse s t (cons close l)) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' (cons close l)) None"
                ],
                "tactic_res": [
                    "c20_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t' s' => parse s' (N t' t) l\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l\n  end None"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c15_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c20_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t : bin) (_ : eq (parse s t l) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l) None) (s : list bin) (t : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t' s' => parse s' (N t' t) l\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l\n  end None"
                ],
                "tactic_res": [
                    "c21_goal : forall (t : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t' s' => parse s' (N t' t) l'\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c21_l' : list par",
                    "c21_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c21_s : list bin"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t H s' t' Hle .",
                "tactic_args": [
                    "c19_goal : forall (t : bin) (_ : eq (parse (cons t s) L l') None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse (cons t' s') L l') None"
                ],
                "tactic_res": [
                    "c22_goal : eq (parse (cons t' s') L l') None",
                    "c22_t : bin",
                    "c22_H : eq (parse (cons t s) L l') None",
                    "c22_s' : list bin",
                    "c22_t' : bin",
                    "c22_Hle : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c22_goal : eq (parse (cons t' s') L l') None",
                    "c19_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c22_H : eq (parse (cons t s) L l') None"
                ],
                "tactic_res": [
                    "c23_goal : eq (length (cons t' s')) (length (cons t s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c23_goal : eq (length (cons t' s')) (length (cons t s))"
                ],
                "tactic_res": [
                    "c24_goal : eq (S (length s')) (S (length s))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c24_goal : eq (S (length s')) (S (length s))",
                    "c22_Hle : eq (length s') (length s)",
                    "c22_s' : list bin",
                    "c19_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c21_goal : forall (t : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t' s' => parse s' (N t' t) l'\n         end None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c21_s : list bin"
                ],
                "tactic_res": [
                    "c25_goal : forall (_ : bin) (_ : eq None None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length nil)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None",
                    "c26_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse l (N b t) l') None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (cons b l))),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t H s' .",
                "tactic_args": [
                    "c25_goal : forall (_ : bin) (_ : eq None None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length nil)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ],
                "tactic_res": [
                    "c27_goal : forall (t' : bin) (_ : eq (length s') (length nil)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c27_t : bin",
                    "c27_H : eq None None",
                    "c27_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c27_goal : forall (t' : bin) (_ : eq (length s') (length nil)),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c27_s' : list bin"
                ],
                "tactic_res": [
                    "c28_goal : forall (_ : bin) (_ : eq (length nil) (length nil)), eq None None",
                    "c29_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length nil)),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c28_goal : forall (_ : bin) (_ : eq (length nil) (length nil)), eq None None"
                ],
                "tactic_res": [
                    "c30_goal : forall (_ : bin) (_ : eq 0 0), eq None None"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : forall (_ : bin) (_ : eq 0 0), eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length nil)),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c31_goal : forall (b : bin) (l : list bin) (t' : bin) (_ : eq (S (length l)) 0),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t' Hle .",
                "tactic_args": [
                    "c31_goal : forall (b : bin) (l : list bin) (t' : bin) (_ : eq (S (length l)) 0),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c32_goal : eq (parse s0 (N t0 t') l') None",
                    "c32_t0 : bin",
                    "c32_s0 : list bin",
                    "c32_t' : bin",
                    "c32_Hle : eq (S (length s0)) 0"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c32_goal : eq (parse s0 (N t0 t') l') None",
                    "c32_Hle : eq (S (length s0)) 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t H s' .",
                "tactic_args": [
                    "c26_goal : forall (b : bin) (l : list bin) (t : bin)\n  (_ : eq (parse l (N b t) l') None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length (cons b l))),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s'0 => parse s'0 (N t'0 t') l'\n  end None"
                ],
                "tactic_res": [
                    "c33_goal : forall (t' : bin) (_ : eq (length s') (length (cons t0 s0))),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c33_t0 : bin",
                    "c33_s0 : list bin",
                    "c33_t : bin",
                    "c33_H : eq (parse s0 (N t0 t) l') None",
                    "c33_s' : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c33_goal : forall (t' : bin) (_ : eq (length s') (length (cons t0 s0))),\neq\n  match s' with\n  | nil => None\n  | cons t'0 s' => parse s' (N t'0 t') l'\n  end None",
                    "c33_s' : list bin"
                ],
                "tactic_res": [
                    "c34_goal : forall (_ : bin) (_ : eq (length nil) (length (cons t0 s0))),\neq None None",
                    "c35_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length (cons t0 s0))),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c34_goal : forall (_ : bin) (_ : eq (length nil) (length (cons t0 s0))),\neq None None"
                ],
                "tactic_res": [
                    "c36_goal : forall (_ : bin) (_ : eq 0 (S (length s0))), eq None None"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c35_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (length (cons b l)) (length (cons t0 s0))),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c37_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (S (length l)) (S (length s0))),\neq (parse l (N b t') l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros t' H0 .",
                "tactic_args": [
                    "c36_goal : forall (_ : bin) (_ : eq 0 (S (length s0))), eq None None"
                ],
                "tactic_res": [
                    "c38_goal : eq None None",
                    "c38_t' : bin",
                    "c38_H0 : eq 0 (S (length s0))"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c38_goal : eq None None",
                    "c38_H0 : eq 0 (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t'0 s'0 t' Hle .",
                "tactic_args": [
                    "c37_goal : forall (b : bin) (l : list bin) (t' : bin)\n  (_ : eq (S (length l)) (S (length s0))),\neq (parse l (N b t') l') None"
                ],
                "tactic_res": [
                    "c39_goal : eq (parse s'0 (N t'0 t') l') None",
                    "c39_t'0 : bin",
                    "c39_s'0 : list bin",
                    "c39_t' : bin",
                    "c39_Hle : eq (S (length s'0)) (S (length s0))"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c39_goal : eq (parse s'0 (N t'0 t') l') None",
                    "c21_Hrec : forall (s : list bin) (t : bin) (_ : eq (parse s t l') None)\n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None",
                    "c33_H : eq (parse s0 (N t0 t) l') None"
                ],
                "tactic_res": [
                    "c40_goal : eq (length s'0) (length s0)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c39_Hle : eq (S (length s'0)) (S (length s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c40_goal : eq (length s'0) (length s0)",
                    "c39_Hle : eq (S (length s'0)) (S (length s0))",
                    "c39_s'0 : list bin",
                    "c33_s0 : list bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_complete_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_complete_aux : forall l : list par , wp' l -> forall ( s : list bin ) ( t : bin ) ( l' : list par ) , parse s t ( l ++ l' ) = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l' = None .",
                "tactic_sig_no_out_arg": "Theorem parse_complete_aux : forall l : list par , wp' l -> forall ( s : list bin ) ( t : bin ) ( l' : list par ) , parse s t ( l ++ l' ) = None -> forall ( s' : list bin ) ( t' : bin ) , length s' = length s -> parse s' t' l' = None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp' l) (s : list bin) (t : bin)\n  (l' : list par) (_ : eq (parse s t (app l l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None"
                ]
            },
            {
                "tactic_sig": "simple induction 1 .",
                "tactic_sig_no_out_arg": "simple induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp' l) (s : list bin) (t : bin)\n  (l' : list par) (_ : eq (parse s t (app l l')) None) \n  (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\neq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app nil l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c2_H : wp' l",
                    "c2_l : list par",
                    "c3_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l1 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (_ : wp' l2)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l2 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (s : list bin) (t : bin)\n  (l' : list par)\n  (_ : eq (parse s t (app (cons open (app l1 (cons close l2))) l'))\n         None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c3_H : wp' l",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app nil l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c4_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t l') None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t l') None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c5_goal : eq (parse s' t' l') None",
                    "c5_s : list bin",
                    "c5_t : bin",
                    "c5_l' : list par",
                    "c5_H0 : eq (parse s t l') None",
                    "c5_s' : list bin",
                    "c5_t' : bin",
                    "c5_H1 : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c5_goal : eq (parse s' t' l') None",
                    "_global_parse_reject_indep_t : forall (l : list par) (s : list bin) (t : bin)\n         (_ : eq (parse s t l) None) (s' : list bin) \n         (t' : bin) (_ : eq (length s') (length s)), \n       eq (parse s' t' l) None"
                ],
                "tactic_res": [
                    "c6_goal : eq (parse ?s ?t l') None",
                    "c7_goal : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : eq (parse ?s ?t l') None",
                    "c5_H0 : eq (parse s t l') None",
                    "c5_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c7_goal : eq (length s') (length s)",
                    "c5_H1 : eq (length s') (length s)",
                    "c5_s' : list bin",
                    "c5_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l1 l2 Hp1 Hr1 Hp2 Hr2 s t l' Hrej s' t' Hle .",
                "tactic_args": [
                    "c3_goal : forall (l1 l2 : list par) (_ : wp' l1)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l1 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (_ : wp' l2)\n  (_ : forall (s : list bin) (t : bin) (l' : list par)\n         (_ : eq (parse s t (app l2 l')) None) (s' : list bin)\n         (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None) (s : list bin) (t : bin)\n  (l' : list par)\n  (_ : eq (parse s t (app (cons open (app l1 (cons close l2))) l'))\n         None) (s' : list bin) (t' : bin)\n  (_ : eq (length s') (length s)), eq (parse s' t' l') None"
                ],
                "tactic_res": [
                    "c8_goal : eq (parse s' t' l') None",
                    "c8_l1 : list par",
                    "c8_l2 : list par",
                    "c8_Hp1 : wp' l1",
                    "c8_Hr1 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l1 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_Hp2 : wp' l2",
                    "c8_Hr2 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l2 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_s : list bin",
                    "c8_t : bin",
                    "c8_l' : list par",
                    "c8_Hrej : eq (parse s t (app (cons open (app l1 (cons close l2))) l')) None",
                    "c8_s' : list bin",
                    "c8_t' : bin",
                    "c8_Hle : eq (length s') (length s)"
                ]
            },
            {
                "tactic_sig": "apply _i with ( _i := _i ) ( _i := _i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( _i := _i ) ( _i := _i _i _i ) .",
                "tactic_args": [
                    "c8_goal : eq (parse s' t' l') None",
                    "c8_Hr2 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l2 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c8_s : list bin",
                    "c8_s' : list bin",
                    "c8_t : bin",
                    "_global_N : forall (_ : bin) (_ : bin), bin",
                    "c8_t : bin",
                    "_global_L : bin"
                ],
                "tactic_res": [
                    "c9_goal : eq (parse s' (N t L) (app l2 l')) None",
                    "c10_goal : eq (length s') (length s')"
                ]
            },
            {
                "tactic_sig": "change ( parse ( _i :: _i ) L ( close :: _i ++ _i ) = None ) in | - * .",
                "tactic_sig_no_out_arg": "change ( parse ( _i :: _i ) L ( close :: _i ++ _i ) = None ) in | - * .",
                "tactic_args": [
                    "c9_goal : eq (parse s' (N t L) (app l2 l')) None",
                    "c8_t : bin",
                    "c8_s' : list bin",
                    "c8_l2 : list par",
                    "c8_l' : list par"
                ],
                "tactic_res": [
                    "c11_goal : eq (parse (cons t s') L (cons close (app l2 l'))) None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c11_Hrej : eq (parse s t (app (cons open (app l1 (cons close l2))) l')) None"
                ],
                "tactic_res": [
                    "c11_Hrej : eq (parse (cons t s) L (app (app l1 (cons close l2)) l')) None"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_app_assoc : forall (A : Type) (l m n : list A),\n       eq (app l (app m n)) (app (app l m) n)",
                    "c11_Hrej : eq (parse (cons t s) L (app (app l1 (cons close l2)) l')) None"
                ],
                "tactic_res": [
                    "c11_Hrej : eq (parse (cons t s) L (app l1 (app (cons close l2) l'))) None"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c11_goal : eq (parse (cons t s') L (cons close (app l2 l'))) None",
                    "c8_Hr1 : forall (s : list bin) (t : bin) (l' : list par)\n  (_ : eq (parse s t (app l1 l')) None) (s' : list bin) \n  (t' : bin) (_ : eq (length s') (length s)), eq (parse s' t' l') None",
                    "c11_Hrej : eq (parse (cons t s) L (app l1 (app (cons close l2) l'))) None"
                ],
                "tactic_res": [
                    "c12_goal : eq (length (cons t s')) (length (cons t s))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : eq (length (cons t s')) (length (cons t s))"
                ],
                "tactic_res": [
                    "c13_goal : eq (S (length s')) (S (length s))"
                ]
            },
            {
                "tactic_sig": "auto with arith .",
                "tactic_sig_no_out_arg": "auto with arith .",
                "tactic_args": [
                    "c13_goal : eq (S (length s')) (S (length s))",
                    "c8_Hle : eq (length s') (length s)",
                    "c8_s' : list bin",
                    "c8_s : list bin"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (length s') (length s')",
                    "c8_s' : list bin"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_complete",
        "proof": [
            {
                "tactic_sig": "Theorem parse_complete : forall l : list par , wp l -> parse nil L l <> None .",
                "tactic_sig_no_out_arg": "Theorem parse_complete : forall l : list par , wp l -> parse nil L l <> None .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (_ : wp l), not (eq (parse nil L l) None)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros l H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (_ : wp l), not (eq (parse nil L l) None)"
                ],
                "tactic_res": [
                    "c2_goal : not (eq (parse nil L l) None)",
                    "c2_l : list par",
                    "c2_H : wp l"
                ]
            },
            {
                "tactic_sig": "replace _i with ( _i ++ nil ) .",
                "tactic_sig_no_out_arg": "replace _i with ( _i ++ nil ) .",
                "tactic_args": [
                    "c2_goal : not (eq (parse nil L l) None)",
                    "c2_l : list par",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : not (eq (parse nil L (app l nil)) None)",
                    "c4_goal : eq (app l nil) l"
                ]
            },
            {
                "tactic_sig": "red in | - * .",
                "tactic_sig_no_out_arg": "red in | - * .",
                "tactic_args": [
                    "c3_goal : not (eq (parse nil L (app l nil)) None)"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : eq (parse nil L (app l nil)) None, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros H' .",
                "tactic_args": [
                    "c5_goal : forall _ : eq (parse nil L (app l nil)) None, False"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H' : eq (parse nil L (app l nil)) None"
                ]
            },
            {
                "tactic_sig": "assert ( e : parse nil L nil = None ) .",
                "tactic_sig_no_out_arg": "assert ( e : parse nil L nil = None ) .",
                "tactic_args": [
                    "c6_goal : False"
                ],
                "tactic_res": [
                    "c7_goal : eq (parse nil L nil) None",
                    "c8_goal : False",
                    "c8_e : eq (parse nil L nil) None"
                ]
            },
            {
                "tactic_sig": "apply _i with ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( 2 := _i ) .",
                "tactic_args": [
                    "c7_goal : eq (parse nil L nil) None",
                    "_global_parse_complete_aux : forall (l : list par) (_ : wp' l) (s : list bin) \n         (t : bin) (l' : list par) (_ : eq (parse s t (app l l')) None)\n         (s' : list bin) (t' : bin) (_ : eq (length s') (length s)),\n       eq (parse s' t' l') None",
                    "c6_H' : eq (parse nil L (app l nil)) None"
                ],
                "tactic_res": [
                    "c9_goal : wp' l",
                    "c10_goal : eq (length nil) (length nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (length nil) (length nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : wp' l",
                    "_global_wp_imp_wp' : forall (l : list par) (_ : wp l), wp' l"
                ],
                "tactic_res": [
                    "c11_goal : wp l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : wp l",
                    "c2_H : wp l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c8_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c4_goal : eq (app l nil) l",
                    "_global_app_nil_r : forall (A : Type) (l : list A), eq (app l nil) l"
                ],
                "tactic_res": [
                    "c12_goal : eq (app l nil) (app l nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq (app l nil) (app l nil)",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_invert_aux",
        "proof": [
            {
                "tactic_sig": "Theorem parse_invert_aux : forall ( l : list par ) ( s : list bin ) ( t t' : bin ) , parse s t l = Some t' -> bin_to_string' t' = unparse_stack s ++ bin_to_string' t ++ l .",
                "tactic_sig_no_out_arg": "Theorem parse_invert_aux : forall ( l : list par ) ( s : list bin ) ( t t' : bin ) , parse s t l = Some t' -> bin_to_string' t' = unparse_stack s ++ bin_to_string' t ++ l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (s : list bin) (t t' : bin)\n  (_ : eq (parse s t l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l))"
                ]
            },
            {
                "tactic_sig": "simple induction l .",
                "tactic_sig_no_out_arg": "simple induction l .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (s : list bin) (t t' : bin)\n  (_ : eq (parse s t l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l))"
                ],
                "tactic_res": [
                    "c2_goal : forall (s : list bin) (t t' : bin) (_ : eq (parse s t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) nil))",
                    "c2_l : list par",
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse s t (cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons a l)))",
                    "c3_l : list par"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros s .",
                "tactic_args": [
                    "c2_goal : forall (s : list bin) (t t' : bin) (_ : eq (parse s t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) nil))"
                ],
                "tactic_res": [
                    "c4_goal : forall (t t' : bin) (_ : eq (parse s t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) nil))",
                    "c4_s : list bin"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c4_goal : forall (t t' : bin) (_ : eq (parse s t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) nil))",
                    "c4_s : list bin"
                ],
                "tactic_res": [
                    "c5_goal : forall (t t' : bin) (_ : eq (parse nil t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) nil))",
                    "c6_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse (cons b l) t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (cons b l)) (app (bin_to_string' t) nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : forall (t t' : bin) (_ : eq (parse nil t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) nil))"
                ],
                "tactic_res": [
                    "c7_goal : forall (t t' : bin) (_ : eq (Some t) (Some t')),\neq (bin_to_string' t') (app (bin_to_string' t) nil)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c7_goal : forall (t t' : bin) (_ : eq (Some t) (Some t')),\neq (bin_to_string' t') (app (bin_to_string' t) nil)"
                ],
                "tactic_res": [
                    "c8_goal : eq (bin_to_string' t') (app (bin_to_string' t) nil)",
                    "c8_t : bin",
                    "c8_t' : bin",
                    "c8_H : eq (Some t) (Some t')"
                ]
            },
            {
                "tactic_sig": "injection _i .",
                "tactic_sig_no_out_arg": "injection _i .",
                "tactic_args": [
                    "c8_goal : eq (bin_to_string' t') (app (bin_to_string' t) nil)",
                    "c8_H : eq (Some t) (Some t')"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq t t', eq (bin_to_string' t') (app (bin_to_string' t) nil)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros Heq .",
                "tactic_args": [
                    "c9_goal : forall _ : eq t t', eq (bin_to_string' t') (app (bin_to_string' t) nil)"
                ],
                "tactic_res": [
                    "c10_goal : eq (bin_to_string' t') (app (bin_to_string' t) nil)",
                    "c10_Heq : eq t t'"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : eq (bin_to_string' t') (app (bin_to_string' t) nil)",
                    "c10_Heq : eq t t'"
                ],
                "tactic_res": [
                    "c11_goal : eq (bin_to_string' t') (app (bin_to_string' t') nil)"
                ]
            },
            {
                "tactic_sig": "now rewrite app_nil_r .",
                "tactic_sig_no_out_arg": "now rewrite app_nil_r .",
                "tactic_args": [
                    "c11_goal : eq (bin_to_string' t') (app (bin_to_string' t') nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse (cons b l) t nil) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (cons b l)) (app (bin_to_string' t) nil))"
                ],
                "tactic_res": [
                    "c12_goal : forall (b : bin) (l : list bin) (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (app (unparse_stack l) (app (bin_to_string' b) (cons open nil)))\n     (app (bin_to_string' t) nil))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t t' H .",
                "tactic_args": [
                    "c12_goal : forall (b : bin) (l : list bin) (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (app (unparse_stack l) (app (bin_to_string' b) (cons open nil)))\n     (app (bin_to_string' t) nil))"
                ],
                "tactic_res": [
                    "c13_goal : eq (bin_to_string' t')\n  (app\n     (app (unparse_stack s0) (app (bin_to_string' t0) (cons open nil)))\n     (app (bin_to_string' t) nil))",
                    "c13_t0 : bin",
                    "c13_s0 : list bin",
                    "c13_t : bin",
                    "c13_t' : bin",
                    "c13_H : eq None (Some t')"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c13_goal : eq (bin_to_string' t')\n  (app\n     (app (unparse_stack s0) (app (bin_to_string' t0) (cons open nil)))\n     (app (bin_to_string' t) nil))",
                    "c13_H : eq None (Some t')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros a .",
                "tactic_args": [
                    "c3_goal : forall (a : par) (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse s t (cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons a l)))"
                ],
                "tactic_res": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse s t (cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons a l)))",
                    "c14_a : par"
                ]
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c14_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse s t (cons a l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons a l)))",
                    "c14_a : par"
                ],
                "tactic_res": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (cons open l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l)))",
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (cons close l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (cons open l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l)))"
                ],
                "tactic_res": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse (cons t s) L l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c14_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c17_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin) (_ : eq (parse (cons t s) L l) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l)))"
                ],
                "tactic_res": [
                    "c18_goal : forall (t t' : bin) (_ : eq (parse (cons t s) L l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))",
                    "c18_l' : list par",
                    "c18_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c18_s : list bin"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c16_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq (parse s t (cons close l)) (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l)))"
                ],
                "tactic_res": [
                    "c19_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t'0 s' => parse s' (N t'0 t) l\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "c14_a : par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l' Hrec s .",
                "tactic_args": [
                    "c19_goal : forall (l : list par)\n  (_ : forall (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l)))\n  (s : list bin) (t t' : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t'0 s' => parse s' (N t'0 t) l\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l)))"
                ],
                "tactic_res": [
                    "c20_goal : forall (t t' : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t'0 s' => parse s' (N t'0 t) l'\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l')))",
                    "c20_l' : list par",
                    "c20_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c20_s : list bin"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c18_goal : forall (t t' : bin) (_ : eq (parse (cons t s) L l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ],
                "tactic_res": [
                    "c21_goal : eq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))",
                    "c21_t : bin",
                    "c21_t' : bin",
                    "c21_H : eq (parse (cons t s) L l') (Some t')"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c21_goal : eq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))",
                    "c18_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c21_H : eq (parse (cons t s) L l') (Some t')"
                ],
                "tactic_res": [
                    "c22_goal : eq (app (unparse_stack (cons t s)) (app (bin_to_string' L) l'))\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c22_goal : eq (app (unparse_stack (cons t s)) (app (bin_to_string' L) l'))\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ],
                "tactic_res": [
                    "c23_goal : eq\n  (app (app (unparse_stack s) (app (bin_to_string' t) (cons open nil)))\n     l')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ]
            },
            {
                "tactic_sig": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_sig_no_out_arg": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_args": [
                    "c23_goal : eq\n  (app (app (unparse_stack s) (app (bin_to_string' t) (cons open nil)))\n     l')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ],
                "tactic_res": [
                    "c24_goal : eq (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : eq (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))\n  (app (unparse_stack s) (app (bin_to_string' t) (cons open l')))",
                    "c21_t : bin",
                    "c18_s : list bin",
                    "c18_l' : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "case _i .",
                "tactic_sig_no_out_arg": "case _i .",
                "tactic_args": [
                    "c20_goal : forall (t t' : bin)\n  (_ : eq\n         match s with\n         | nil => None\n         | cons t'0 s' => parse s' (N t'0 t) l'\n         end (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) (cons close l')))",
                    "c20_s : list bin"
                ],
                "tactic_res": [
                    "c25_goal : forall (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) (cons close l')))",
                    "c26_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse l (N b t) l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (cons b l))\n     (app (bin_to_string' t) (cons close l')))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros t t' H .",
                "tactic_args": [
                    "c25_goal : forall (t t' : bin) (_ : eq None (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) (cons close l')))"
                ],
                "tactic_res": [
                    "c27_goal : eq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) (cons close l')))",
                    "c27_t : bin",
                    "c27_t' : bin",
                    "c27_H : eq None (Some t')"
                ]
            },
            {
                "tactic_sig": "discriminate _i .",
                "tactic_sig_no_out_arg": "discriminate _i .",
                "tactic_args": [
                    "c27_goal : eq (bin_to_string' t')\n  (app (unparse_stack nil) (app (bin_to_string' t) (cons close l')))",
                    "c27_H : eq None (Some t')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros t0 s0 t t' Hp .",
                "tactic_args": [
                    "c26_goal : forall (b : bin) (l : list bin) (t t' : bin)\n  (_ : eq (parse l (N b t) l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack (cons b l))\n     (app (bin_to_string' t) (cons close l')))"
                ],
                "tactic_res": [
                    "c28_goal : eq (bin_to_string' t')\n  (app (unparse_stack (cons t0 s0))\n     (app (bin_to_string' t) (cons close l')))",
                    "c28_t0 : bin",
                    "c28_s0 : list bin",
                    "c28_t : bin",
                    "c28_t' : bin",
                    "c28_Hp : eq (parse s0 (N t0 t) l') (Some t')"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c28_goal : eq (bin_to_string' t')\n  (app (unparse_stack (cons t0 s0))\n     (app (bin_to_string' t) (cons close l')))",
                    "c20_Hrec : forall (s : list bin) (t t' : bin) (_ : eq (parse s t l') (Some t')),\neq (bin_to_string' t')\n  (app (unparse_stack s) (app (bin_to_string' t) l'))",
                    "c28_Hp : eq (parse s0 (N t0 t) l') (Some t')"
                ],
                "tactic_res": [
                    "c29_goal : eq (app (unparse_stack s0) (app (bin_to_string' (N t0 t)) l'))\n  (app (unparse_stack (cons t0 s0))\n     (app (bin_to_string' t) (cons close l')))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c29_goal : eq (app (unparse_stack s0) (app (bin_to_string' (N t0 t)) l'))\n  (app (unparse_stack (cons t0 s0))\n     (app (bin_to_string' t) (cons close l')))"
                ],
                "tactic_res": [
                    "c30_goal : eq\n  (app (unparse_stack s0)\n     (app\n        (app (bin_to_string' t0)\n           (cons open (app (bin_to_string' t) (cons close nil)))) l'))\n  (app\n     (app (unparse_stack s0) (app (bin_to_string' t0) (cons open nil)))\n     (app (bin_to_string' t) (cons close l')))"
                ]
            },
            {
                "tactic_sig": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_sig_no_out_arg": "repeat ( rewrite <- app_assoc ; simpl ) .",
                "tactic_args": [
                    "c30_goal : eq\n  (app (unparse_stack s0)\n     (app\n        (app (bin_to_string' t0)\n           (cons open (app (bin_to_string' t) (cons close nil)))) l'))\n  (app\n     (app (unparse_stack s0) (app (bin_to_string' t0) (cons open nil)))\n     (app (bin_to_string' t) (cons close l')))"
                ],
                "tactic_res": [
                    "c31_goal : eq\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (cons open (app (bin_to_string' t) (cons close l')))))\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (cons open (app (bin_to_string' t) (cons close l')))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : eq\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (cons open (app (bin_to_string' t) (cons close l')))))\n  (app (unparse_stack s0)\n     (app (bin_to_string' t0)\n        (cons open (app (bin_to_string' t) (cons close l')))))",
                    "c28_t : bin",
                    "c28_s0 : list bin",
                    "c28_t0 : bin",
                    "c20_l' : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_invert",
        "proof": [
            {
                "tactic_sig": "Theorem parse_invert : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> bin_to_string' t = l .",
                "tactic_sig_no_out_arg": "Theorem parse_invert : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> bin_to_string' t = l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (t : bin) (_ : eq (parse nil L l) (Some t)),\neq (bin_to_string' t) l"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (t : bin) (_ : eq (parse nil L l) (Some t)),\neq (bin_to_string' t) l"
                ],
                "tactic_res": [
                    "c2_goal : eq (bin_to_string' t) l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : eq (parse nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "replace _i with ( unparse_stack nil ++ bin_to_string' L ++ _i ) .",
                "tactic_sig_no_out_arg": "replace _i with ( unparse_stack nil ++ bin_to_string' L ++ _i ) .",
                "tactic_args": [
                    "c2_goal : eq (bin_to_string' t) l",
                    "c2_l : list par",
                    "c2_l : list par"
                ],
                "tactic_res": [
                    "c3_goal : eq (bin_to_string' t)\n  (app (unparse_stack nil) (app (bin_to_string' L) l))",
                    "c4_goal : eq (app (unparse_stack nil) (app (bin_to_string' L) l)) l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq (app (unparse_stack nil) (app (bin_to_string' L) l)) l",
                    "c2_l : list par"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : eq (bin_to_string' t)\n  (app (unparse_stack nil) (app (bin_to_string' L) l))",
                    "_global_parse_invert_aux : forall (l : list par) (s : list bin) (t t' : bin)\n         (_ : eq (parse s t l) (Some t')),\n       eq (bin_to_string' t')\n         (app (unparse_stack s) (app (bin_to_string' t) l))"
                ],
                "tactic_res": [
                    "c5_goal : eq (parse nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (parse nil L l) (Some t)",
                    "c2_H : eq (parse nil L l) (Some t)",
                    "c2_t : bin",
                    "c2_l : list par"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "parse_sound",
        "proof": [
            {
                "tactic_sig": "Theorem parse_sound : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> wp l .",
                "tactic_sig_no_out_arg": "Theorem parse_sound : forall ( l : list par ) ( t : bin ) , parse nil L l = Some t -> wp l .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (l : list par) (t : bin) (_ : eq (parse nil L l) (Some t)), wp l"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros l t H .",
                "tactic_args": [
                    "c1_goal : forall (l : list par) (t : bin) (_ : eq (parse nil L l) (Some t)), wp l"
                ],
                "tactic_res": [
                    "c2_goal : wp l",
                    "c2_l : list par",
                    "c2_t : bin",
                    "c2_H : eq (parse nil L l) (Some t)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i with ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- _i with ( 1 := _i ) .",
                "tactic_args": [
                    "c2_goal : wp l",
                    "_global_parse_invert : forall (l : list par) (t : bin) (_ : eq (parse nil L l) (Some t)),\n       eq (bin_to_string' t) l",
                    "c2_H : eq (parse nil L l) (Some t)"
                ],
                "tactic_res": [
                    "c3_goal : wp (bin_to_string' t)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : wp (bin_to_string' t)",
                    "_global_bin_to_string'_wp : forall t : bin, wp (bin_to_string' t)"
                ],
                "tactic_res": []
            }
        ]
    }
]