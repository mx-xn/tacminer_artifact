[
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "equivalence .",
                "tactic_sig_no_out_arg": "equivalence .",
                "tactic_args": [
                    "_goal : Equivalence\n  (fun F G : Functor =>\n   sigT\n     (fun iso : forall x : C, Isomorphism (F x) (G x) =>\n      forall (x y : C) (f : hom x y),\n      equiv (fmap f)\n        (compose (compose (from (iso y)) (fmap f)) (iso x))))"
                ],
                "tactic_res": [
                    "_goal : Isomorphism (y x1) (x x1)",
                    "_goal : equiv (fmap f)\n  (compose (compose (from ((fun x1 : C => ?Goal) y0)) (fmap f))\n     ((fun x1 : C => ?Goal) x1))",
                    "_goal : Isomorphism (x x2) (z x2)",
                    "_goal : equiv (fmap f)\n  (compose (compose (from ((fun x2 : C => ?Goal1) y0)) (fmap f))\n     ((fun x2 : C => ?Goal1) x2))",
                    "x1 : obj",
                    "e : forall (x1 y0 : C) (f : hom x1 y0),\nequiv (fmap f) (compose (compose (from (x0 y0)) (fmap f)) (x0 x1))",
                    "x0 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x : Functor",
                    "y : Functor",
                    "f : hom x1 y0",
                    "y0 : obj",
                    "x2 : obj",
                    "e : forall (x y0 : C) (f : hom x y0),\nequiv (fmap f) (compose (compose (from (x0 y0)) (fmap f)) (x0 x))",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "e0 : forall (x0 y0 : C) (f : hom x0 y0),\nequiv (fmap f) (compose (compose (from (x1 y0)) (fmap f)) (x1 x0))",
                    "x1 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "z : Functor",
                    "f : hom x2 y0"
                ]
            },
            {
                "tactic_sig": "isomorphism .",
                "tactic_sig_no_out_arg": "isomorphism .",
                "tactic_args": [
                    "_goal : Isomorphism (y x1) (x x1)"
                ],
                "tactic_res": [
                    "_goal : hom (y x1) (x x1)",
                    "_goal : hom (x x1) (y x1)",
                    "_goal : equiv (compose ?Goal2 ?Goal3) id",
                    "_goal : equiv (compose ?Goal3 ?Goal2) id"
                ]
            },
            {
                "tactic_sig": "exact ( from ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "exact ( from ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : hom (y x1) (x x1)",
                    "_goal : equiv (fmap f)\n  (compose (compose (from ((fun x1 : C => ?Goal) y0)) (fmap f))\n     ((fun x1 : C => ?Goal) x1))",
                    "x0 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x1 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := ?Goal2;\n               from := ?Goal3;\n               iso_to_from := ?Goal4 : equiv (compose ?Goal2 ?Goal3) id;\n               iso_from_to := ?Goal5 : equiv (compose ?Goal3 ?Goal2) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := ?Goal2;\n         from := ?Goal3;\n         iso_to_from := ?Goal4 : equiv (compose ?Goal2 ?Goal3) id;\n         iso_from_to := ?Goal5 : equiv (compose ?Goal3 ?Goal2) id\n       |}) x1))"
                ]
            },
            {
                "tactic_sig": "exact ( to ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "exact ( to ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : hom (x x1) (y x1)",
                    "_goal : equiv (compose ?Goal2 ?Goal3) id",
                    "_goal : equiv (compose ?Goal3 ?Goal2) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := ?Goal2;\n               from := ?Goal3;\n               iso_to_from := ?Goal4 : equiv (compose ?Goal2 ?Goal3) id;\n               iso_from_to := ?Goal5 : equiv (compose ?Goal3 ?Goal2) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := ?Goal2;\n         from := ?Goal3;\n         iso_to_from := ?Goal4 : equiv (compose ?Goal2 ?Goal3) id;\n         iso_from_to := ?Goal5 : equiv (compose ?Goal3 ?Goal2) id\n       |}) x1))",
                    "x0 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x1 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (from (x0 x1)) ?Goal2) id",
                    "_goal : equiv (compose ?Goal2 (from (x0 x1))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := ?Goal2;\n               iso_to_from :=\n                 ?Goal3 : equiv (compose (from (x0 x1)) ?Goal2) id;\n               iso_from_to :=\n                 ?Goal4 : equiv (compose ?Goal2 (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := ?Goal2;\n         iso_to_from :=\n           ?Goal3 : equiv (compose (from (x0 x1)) ?Goal2) id;\n         iso_from_to :=\n           ?Goal4 : equiv (compose ?Goal2 (from (x0 x1))) id\n       |}) x1))"
                ]
            },
            {
                "tactic_sig": "apply iso_from_to .",
                "tactic_sig_no_out_arg": "apply iso_from_to .",
                "tactic_args": [
                    "_goal : equiv (compose (from (x0 x1)) ?Goal2) id",
                    "_goal : equiv (compose ?Goal2 (from (x0 x1))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := ?Goal2;\n               iso_to_from :=\n                 ?Goal3 : equiv (compose (from (x0 x1)) ?Goal2) id;\n               iso_from_to :=\n                 ?Goal4 : equiv (compose ?Goal2 (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := ?Goal2;\n         iso_to_from :=\n           ?Goal3 : equiv (compose (from (x0 x1)) ?Goal2) id;\n         iso_from_to :=\n           ?Goal4 : equiv (compose ?Goal2 (from (x0 x1))) id\n       |}) x1))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (x0 x1) (from (x0 x1))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := x0 x1;\n               iso_to_from :=\n                 ?Goal2 : equiv (compose (from (x0 x1)) (x0 x1)) id;\n               iso_from_to :=\n                 ?Goal3 : equiv (compose (x0 x1) (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := x0 x1;\n         iso_to_from :=\n           ?Goal2 : equiv (compose (from (x0 x1)) (x0 x1)) id;\n         iso_from_to :=\n           ?Goal3 : equiv (compose (x0 x1) (from (x0 x1))) id\n       |}) x1))"
                ]
            },
            {
                "tactic_sig": "apply iso_to_from .",
                "tactic_sig_no_out_arg": "apply iso_to_from .",
                "tactic_args": [
                    "_goal : equiv (compose (x0 x1) (from (x0 x1))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := x0 x1;\n               iso_to_from :=\n                 ?Goal2 : equiv (compose (from (x0 x1)) (x0 x1)) id;\n               iso_from_to :=\n                 ?Goal3 : equiv (compose (x0 x1) (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := x0 x1;\n         iso_to_from :=\n           ?Goal2 : equiv (compose (from (x0 x1)) (x0 x1)) id;\n         iso_from_to :=\n           ?Goal3 : equiv (compose (x0 x1) (from (x0 x1))) id\n       |}) x1))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := x0 x1;\n               iso_to_from :=\n                 iso_from_to (x0 x1)\n                 :\n                 equiv (compose (from (x0 x1)) (x0 x1)) id;\n               iso_from_to :=\n                 ?Goal2 : equiv (compose (x0 x1) (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := x0 x1;\n         iso_to_from :=\n           iso_from_to (x0 x1)\n           :\n           equiv (compose (from (x0 x1)) (x0 x1)) id;\n         iso_from_to :=\n           ?Goal2 : equiv (compose (x0 x1) (from (x0 x1))) id\n       |}) x1))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x1 : C =>\n             {|\n               to := from (x0 x1);\n               from := x0 x1;\n               iso_to_from :=\n                 iso_from_to (x0 x1)\n                 :\n                 equiv (compose (from (x0 x1)) (x0 x1)) id;\n               iso_from_to :=\n                 ?Goal2 : equiv (compose (x0 x1) (from (x0 x1))) id\n             |}) y0)) (fmap f))\n     ((fun x1 : C =>\n       {|\n         to := from (x0 x1);\n         from := x0 x1;\n         iso_to_from :=\n           iso_from_to (x0 x1)\n           :\n           equiv (compose (from (x0 x1)) (x0 x1)) id;\n         iso_from_to :=\n           ?Goal2 : equiv (compose (x0 x1) (from (x0 x1))) id\n       |}) x1))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose (x0 y0) (fmap f)) (from (x0 x1)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose (x0 y0) (fmap f)) (from (x0 x1)))",
                    "e : forall (x1 y0 : C) (f : hom x1 y0),\nequiv (fmap f) (compose (compose (from (x0 y0)) (fmap f)) (x0 x1))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (x0 y0)\n        (compose (compose (from (x0 y0)) (fmap f)) (x0 x1)))\n     (from (x0 x1)))"
                ]
            },
            {
                "tactic_sig": "rewrite !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (x0 y0)\n        (compose (compose (from (x0 y0)) (fmap f)) (x0 x1)))\n     (from (x0 x1)))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (compose (compose (x0 y0) (from (x0 y0))) (fmap f))\n        (x0 x1)) (from (x0 x1)))"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from , id_left .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from , id_left .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (compose (compose (x0 y0) (from (x0 y0))) (fmap f))\n        (x0 x1)) (from (x0 x1)))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose (fmap f) (x0 x1)) (from (x0 x1)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- comp_assoc .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose (fmap f) (x0 x1)) (from (x0 x1)))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (fmap f) (compose (x0 x1) (from (x0 x1))))"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from , id_right .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from , id_right .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (fmap f) (compose (x0 x1) (from (x0 x1))))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (fmap f)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (fmap f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "isomorphism .",
                "tactic_sig_no_out_arg": "isomorphism .",
                "tactic_args": [
                    "_goal : Isomorphism (x x2) (z x2)"
                ],
                "tactic_res": [
                    "_goal : hom (x x2) (z x2)",
                    "_goal : hom (z x2) (x x2)",
                    "_goal : equiv (compose ?Goal0 ?Goal1) id",
                    "_goal : equiv (compose ?Goal1 ?Goal0) id"
                ]
            },
            {
                "tactic_sig": "apply ( to ( _i _i ) \u2218 to ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( to ( _i _i ) \u2218 to ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : hom (x x2) (z x2)",
                    "_goal : equiv (fmap f)\n  (compose (compose (from ((fun x2 : C => ?Goal1) y0)) (fmap f))\n     ((fun x2 : C => ?Goal1) x2))",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "x2 : obj",
                    "x1 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x2 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := ?Goal0;\n               from := ?Goal1;\n               iso_to_from := ?Goal2 : equiv (compose ?Goal0 ?Goal1) id;\n               iso_from_to := ?Goal3 : equiv (compose ?Goal1 ?Goal0) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := ?Goal0;\n         from := ?Goal1;\n         iso_to_from := ?Goal2 : equiv (compose ?Goal0 ?Goal1) id;\n         iso_from_to := ?Goal3 : equiv (compose ?Goal1 ?Goal0) id\n       |}) x2))"
                ]
            },
            {
                "tactic_sig": "apply ( from ( _i _i ) \u2218 from ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( from ( _i _i ) \u2218 from ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : hom (z x2) (x x2)",
                    "_goal : equiv (compose ?Goal0 ?Goal1) id",
                    "_goal : equiv (compose ?Goal1 ?Goal0) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := ?Goal0;\n               from := ?Goal1;\n               iso_to_from := ?Goal2 : equiv (compose ?Goal0 ?Goal1) id;\n               iso_from_to := ?Goal3 : equiv (compose ?Goal1 ?Goal0) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := ?Goal0;\n         from := ?Goal1;\n         iso_to_from := ?Goal2 : equiv (compose ?Goal0 ?Goal1) id;\n         iso_from_to := ?Goal3 : equiv (compose ?Goal1 ?Goal0) id\n       |}) x2))",
                    "x1 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x2 : obj",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "x2 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := ?Goal0;\n               iso_to_from :=\n                 ?Goal1\n                 :\n                 equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id;\n               iso_from_to :=\n                 ?Goal2\n                 :\n                 equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := ?Goal0;\n         iso_to_from :=\n           ?Goal1 : equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id;\n         iso_from_to :=\n           ?Goal2 : equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := ?Goal0;\n               iso_to_from :=\n                 ?Goal1\n                 :\n                 equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id;\n               iso_from_to :=\n                 ?Goal2\n                 :\n                 equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := ?Goal0;\n         iso_to_from :=\n           ?Goal1 : equiv (compose (compose (x0 x2) (x1 x2)) ?Goal0) id;\n         iso_from_to :=\n           ?Goal2 : equiv (compose ?Goal0 (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (x0 x2)\n     (compose (x1 x2) (compose (from (x1 x2)) (from (x0 x2))))) id",
                    "_goal : equiv\n  (compose (compose (from (x1 x2)) (from (x0 x2)))\n     (compose (x0 x2) (x1 x2))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := compose (from (x1 x2)) (from (x0 x2));\n               iso_to_from :=\n                 ?Goal0\n                 :\n                 equiv\n                   (compose (compose (x0 x2) (x1 x2))\n                      (compose (from (x1 x2)) (from (x0 x2)))) id;\n               iso_from_to :=\n                 ?Goal1\n                 :\n                 equiv\n                   (compose (compose (from (x1 x2)) (from (x0 x2)))\n                      (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := compose (from (x1 x2)) (from (x0 x2));\n         iso_to_from :=\n           ?Goal0\n           :\n           equiv\n             (compose (compose (x0 x2) (x1 x2))\n                (compose (from (x1 x2)) (from (x0 x2)))) id;\n         iso_from_to :=\n           ?Goal1\n           :\n           equiv\n             (compose (compose (from (x1 x2)) (from (x0 x2)))\n                (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (x0 x2)\n     (compose (x1 x2) (compose (from (x1 x2)) (from (x0 x2))))) id",
                    "x1 : forall x0 : C, Isomorphism (x x0) (y x0)",
                    "x2 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (x0 x2)\n     (compose (compose (x1 x2) (from (x1 x2))) (from (x0 x2)))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from , id_left .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from , id_left .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (x0 x2)\n     (compose (compose (x1 x2) (from (x1 x2))) (from (x0 x2)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (x0 x2) (from (x0 x2))) id"
                ]
            },
            {
                "tactic_sig": "apply iso_to_from .",
                "tactic_sig_no_out_arg": "apply iso_to_from .",
                "tactic_args": [
                    "_goal : equiv (compose (x0 x2) (from (x0 x2))) id"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (compose (from (x1 x2)) (from (x0 x2)))\n     (compose (x0 x2) (x1 x2))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := compose (from (x1 x2)) (from (x0 x2));\n               iso_to_from :=\n                 ?Goal0\n                 :\n                 equiv\n                   (compose (compose (x0 x2) (x1 x2))\n                      (compose (from (x1 x2)) (from (x0 x2)))) id;\n               iso_from_to :=\n                 ?Goal1\n                 :\n                 equiv\n                   (compose (compose (from (x1 x2)) (from (x0 x2)))\n                      (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := compose (from (x1 x2)) (from (x0 x2));\n         iso_to_from :=\n           ?Goal0\n           :\n           equiv\n             (compose (compose (x0 x2) (x1 x2))\n                (compose (from (x1 x2)) (from (x0 x2)))) id;\n         iso_from_to :=\n           ?Goal1\n           :\n           equiv\n             (compose (compose (from (x1 x2)) (from (x0 x2)))\n                (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x1 x2))\n     (compose (from (x0 x2)) (compose (x0 x2) (x1 x2)))) id",
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := compose (from (x1 x2)) (from (x0 x2));\n               iso_to_from :=\n                 (fun\n                    lemma : equiv\n                              (compose (x0 x2)\n                                 (compose (x1 x2)\n                                    (compose (from (x1 x2))\n                                       (from (x0 x2)))))\n                              (compose (compose (x0 x2) (x1 x2))\n                                 (compose (from (x1 x2)) (from (x0 x2))))\n                  =>\n                  trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                    (compose (compose (x0 x2) (x1 x2))\n                       (compose (from (x1 x2)) (from (x0 x2))))\n                    (compose (x0 x2)\n                       (compose (x1 x2)\n                          (compose (from (x1 x2)) (from (x0 x2)))))\n                    (symmetry lemma) id id (eq_proper_proxy id))\n                   (comp_assoc (x0 x2) (x1 x2)\n                      (compose (from (x1 x2)) (from (x0 x2))))\n                   ((fun\n                       lemma : equiv\n                                 (compose (x1 x2)\n                                    (compose (from (x1 x2))\n                                       (from (x0 x2))))\n                                 (compose\n                                    (compose (x1 x2) (from (x1 x2)))\n                                    (from (x0 x2))) =>\n                     trans_co_eq_inv_arrow_morphism\n                       Equivalence_Transitive\n                       (compose (x0 x2)\n                          (compose (x1 x2)\n                             (compose (from (x1 x2)) (from (x0 x2)))))\n                       (compose (x0 x2)\n                          (compose (compose (x1 x2) (from (x1 x2)))\n                             (from (x0 x2))))\n                       (Reflexive_partial_app_morphism compose_respects\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (x0 x2))\n                          (compose (x1 x2)\n                             (compose (from (x1 x2)) (from (x0 x2))))\n                          (compose (compose (x1 x2) (from (x1 x2)))\n                             (from (x0 x2))) lemma) id id\n                       (eq_proper_proxy id))\n                      (comp_assoc (x1 x2) (from (x1 x2)) (from (x0 x2)))\n                      ((fun\n                          lemma : equiv\n                                    (compose (x1 x2) (from (x1 x2))) id\n                        =>\n                        trans_co_eq_inv_arrow_morphism\n                          Equivalence_Transitive\n                          (compose (x0 x2)\n                             (compose (compose (x1 x2) (from (x1 x2)))\n                                (from (x0 x2))))\n                          (compose (x0 x2) (compose id (from (x0 x2))))\n                          (Reflexive_partial_app_morphism\n                             compose_respects\n                             (reflexive_proper_proxy\n                                Equivalence_Reflexive \n                                (x0 x2))\n                             (compose (compose (x1 x2) (from (x1 x2)))\n                                (from (x0 x2)))\n                             (compose id (from (x0 x2)))\n                             (compose_respects\n                                (compose (x1 x2) (from (x1 x2))) id\n                                lemma (from (x0 x2)) \n                                (from (x0 x2))\n                                (reflexive_proper_proxy\n                                   Equivalence_Reflexive \n                                   (from (x0 x2))))) id id\n                          (eq_proper_proxy id)) (iso_to_from (x1 x2))\n                         ((fun\n                             lemma : equiv (compose id (from (x0 x2)))\n                                       (from (x0 x2)) =>\n                           trans_co_eq_inv_arrow_morphism\n                             Equivalence_Transitive\n                             (compose (x0 x2)\n                                (compose id (from (x0 x2))))\n                             (compose (x0 x2) (from (x0 x2)))\n                             (Reflexive_partial_app_morphism\n                                compose_respects\n                                (reflexive_proper_proxy\n                                   Equivalence_Reflexive \n                                   (x0 x2)) (compose id (from (x0 x2)))\n                                (from (x0 x2)) lemma) id id\n                             (eq_proper_proxy id))\n                            (id_left (from (x0 x2)))\n                            (iso_to_from (x0 x2)))))\n                 :\n                 equiv\n                   (compose (compose (x0 x2) (x1 x2))\n                      (compose (from (x1 x2)) (from (x0 x2)))) id;\n               iso_from_to :=\n                 ?Goal0\n                 :\n                 equiv\n                   (compose (compose (from (x1 x2)) (from (x0 x2)))\n                      (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := compose (from (x1 x2)) (from (x0 x2));\n         iso_to_from :=\n           (fun\n              lemma : equiv\n                        (compose (x0 x2)\n                           (compose (x1 x2)\n                              (compose (from (x1 x2)) (from (x0 x2)))))\n                        (compose (compose (x0 x2) (x1 x2))\n                           (compose (from (x1 x2)) (from (x0 x2)))) =>\n            trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n              (compose (compose (x0 x2) (x1 x2))\n                 (compose (from (x1 x2)) (from (x0 x2))))\n              (compose (x0 x2)\n                 (compose (x1 x2)\n                    (compose (from (x1 x2)) (from (x0 x2)))))\n              (symmetry lemma) id id (eq_proper_proxy id))\n             (comp_assoc (x0 x2) (x1 x2)\n                (compose (from (x1 x2)) (from (x0 x2))))\n             ((fun\n                 lemma : equiv\n                           (compose (x1 x2)\n                              (compose (from (x1 x2)) (from (x0 x2))))\n                           (compose (compose (x1 x2) (from (x1 x2)))\n                              (from (x0 x2))) =>\n               trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                 (compose (x0 x2)\n                    (compose (x1 x2)\n                       (compose (from (x1 x2)) (from (x0 x2)))))\n                 (compose (x0 x2)\n                    (compose (compose (x1 x2) (from (x1 x2)))\n                       (from (x0 x2))))\n                 (Reflexive_partial_app_morphism compose_respects\n                    (reflexive_proper_proxy Equivalence_Reflexive\n                       (x0 x2))\n                    (compose (x1 x2)\n                       (compose (from (x1 x2)) (from (x0 x2))))\n                    (compose (compose (x1 x2) (from (x1 x2)))\n                       (from (x0 x2))) lemma) id id\n                 (eq_proper_proxy id))\n                (comp_assoc (x1 x2) (from (x1 x2)) (from (x0 x2)))\n                ((fun lemma : equiv (compose (x1 x2) (from (x1 x2))) id\n                  =>\n                  trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                    (compose (x0 x2)\n                       (compose (compose (x1 x2) (from (x1 x2)))\n                          (from (x0 x2))))\n                    (compose (x0 x2) (compose id (from (x0 x2))))\n                    (Reflexive_partial_app_morphism compose_respects\n                       (reflexive_proper_proxy Equivalence_Reflexive\n                          (x0 x2))\n                       (compose (compose (x1 x2) (from (x1 x2)))\n                          (from (x0 x2))) (compose id (from (x0 x2)))\n                       (compose_respects\n                          (compose (x1 x2) (from (x1 x2))) id lemma\n                          (from (x0 x2)) (from (x0 x2))\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (from (x0 x2))))) id id\n                    (eq_proper_proxy id)) (iso_to_from (x1 x2))\n                   ((fun\n                       lemma : equiv (compose id (from (x0 x2)))\n                                 (from (x0 x2)) =>\n                     trans_co_eq_inv_arrow_morphism\n                       Equivalence_Transitive\n                       (compose (x0 x2) (compose id (from (x0 x2))))\n                       (compose (x0 x2) (from (x0 x2)))\n                       (Reflexive_partial_app_morphism compose_respects\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (x0 x2)) (compose id (from (x0 x2)))\n                          (from (x0 x2)) lemma) id id\n                       (eq_proper_proxy id)) (id_left (from (x0 x2)))\n                      (iso_to_from (x0 x2)))))\n           :\n           equiv\n             (compose (compose (x0 x2) (x1 x2))\n                (compose (from (x1 x2)) (from (x0 x2)))) id;\n         iso_from_to :=\n           ?Goal0\n           :\n           equiv\n             (compose (compose (from (x1 x2)) (from (x0 x2)))\n                (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( _i _i ) \u207b\u00b9 ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( _i _i ) \u207b\u00b9 ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x1 x2))\n     (compose (from (x0 x2)) (compose (x0 x2) (x1 x2)))) id",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "x2 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x1 x2))\n     (compose (compose (from (x0 x2)) (x0 x2)) (x1 x2))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_from_to , id_left .",
                "tactic_sig_no_out_arg": "rewrite iso_from_to , id_left .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x1 x2))\n     (compose (compose (from (x0 x2)) (x0 x2)) (x1 x2))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (from (x1 x2)) (x1 x2)) id"
                ]
            },
            {
                "tactic_sig": "apply iso_from_to .",
                "tactic_sig_no_out_arg": "apply iso_from_to .",
                "tactic_args": [
                    "_goal : equiv (compose (from (x1 x2)) (x1 x2)) id"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (from\n           ((fun x2 : C =>\n             {|\n               to := compose (x0 x2) (x1 x2);\n               from := compose (from (x1 x2)) (from (x0 x2));\n               iso_to_from :=\n                 (fun\n                    lemma : equiv\n                              (compose (x0 x2)\n                                 (compose (x1 x2)\n                                    (compose (from (x1 x2))\n                                       (from (x0 x2)))))\n                              (compose (compose (x0 x2) (x1 x2))\n                                 (compose (from (x1 x2)) (from (x0 x2))))\n                  =>\n                  trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                    (compose (compose (x0 x2) (x1 x2))\n                       (compose (from (x1 x2)) (from (x0 x2))))\n                    (compose (x0 x2)\n                       (compose (x1 x2)\n                          (compose (from (x1 x2)) (from (x0 x2)))))\n                    (symmetry lemma) id id (eq_proper_proxy id))\n                   (comp_assoc (x0 x2) (x1 x2)\n                      (compose (from (x1 x2)) (from (x0 x2))))\n                   ((fun\n                       lemma : equiv\n                                 (compose (x1 x2)\n                                    (compose (from (x1 x2))\n                                       (from (x0 x2))))\n                                 (compose\n                                    (compose (x1 x2) (from (x1 x2)))\n                                    (from (x0 x2))) =>\n                     trans_co_eq_inv_arrow_morphism\n                       Equivalence_Transitive\n                       (compose (x0 x2)\n                          (compose (x1 x2)\n                             (compose (from (x1 x2)) (from (x0 x2)))))\n                       (compose (x0 x2)\n                          (compose (compose (x1 x2) (from (x1 x2)))\n                             (from (x0 x2))))\n                       (Reflexive_partial_app_morphism compose_respects\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (x0 x2))\n                          (compose (x1 x2)\n                             (compose (from (x1 x2)) (from (x0 x2))))\n                          (compose (compose (x1 x2) (from (x1 x2)))\n                             (from (x0 x2))) lemma) id id\n                       (eq_proper_proxy id))\n                      (comp_assoc (x1 x2) (from (x1 x2)) (from (x0 x2)))\n                      ((fun\n                          lemma : equiv\n                                    (compose (x1 x2) (from (x1 x2))) id\n                        =>\n                        trans_co_eq_inv_arrow_morphism\n                          Equivalence_Transitive\n                          (compose (x0 x2)\n                             (compose (compose (x1 x2) (from (x1 x2)))\n                                (from (x0 x2))))\n                          (compose (x0 x2) (compose id (from (x0 x2))))\n                          (Reflexive_partial_app_morphism\n                             compose_respects\n                             (reflexive_proper_proxy\n                                Equivalence_Reflexive \n                                (x0 x2))\n                             (compose (compose (x1 x2) (from (x1 x2)))\n                                (from (x0 x2)))\n                             (compose id (from (x0 x2)))\n                             (compose_respects\n                                (compose (x1 x2) (from (x1 x2))) id\n                                lemma (from (x0 x2)) \n                                (from (x0 x2))\n                                (reflexive_proper_proxy\n                                   Equivalence_Reflexive \n                                   (from (x0 x2))))) id id\n                          (eq_proper_proxy id)) (iso_to_from (x1 x2))\n                         ((fun\n                             lemma : equiv (compose id (from (x0 x2)))\n                                       (from (x0 x2)) =>\n                           trans_co_eq_inv_arrow_morphism\n                             Equivalence_Transitive\n                             (compose (x0 x2)\n                                (compose id (from (x0 x2))))\n                             (compose (x0 x2) (from (x0 x2)))\n                             (Reflexive_partial_app_morphism\n                                compose_respects\n                                (reflexive_proper_proxy\n                                   Equivalence_Reflexive \n                                   (x0 x2)) (compose id (from (x0 x2)))\n                                (from (x0 x2)) lemma) id id\n                             (eq_proper_proxy id))\n                            (id_left (from (x0 x2)))\n                            (iso_to_from (x0 x2)))))\n                 :\n                 equiv\n                   (compose (compose (x0 x2) (x1 x2))\n                      (compose (from (x1 x2)) (from (x0 x2)))) id;\n               iso_from_to :=\n                 ?Goal0\n                 :\n                 equiv\n                   (compose (compose (from (x1 x2)) (from (x0 x2)))\n                      (compose (x0 x2) (x1 x2))) id\n             |}) y0)) (fmap f))\n     ((fun x2 : C =>\n       {|\n         to := compose (x0 x2) (x1 x2);\n         from := compose (from (x1 x2)) (from (x0 x2));\n         iso_to_from :=\n           (fun\n              lemma : equiv\n                        (compose (x0 x2)\n                           (compose (x1 x2)\n                              (compose (from (x1 x2)) (from (x0 x2)))))\n                        (compose (compose (x0 x2) (x1 x2))\n                           (compose (from (x1 x2)) (from (x0 x2)))) =>\n            trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n              (compose (compose (x0 x2) (x1 x2))\n                 (compose (from (x1 x2)) (from (x0 x2))))\n              (compose (x0 x2)\n                 (compose (x1 x2)\n                    (compose (from (x1 x2)) (from (x0 x2)))))\n              (symmetry lemma) id id (eq_proper_proxy id))\n             (comp_assoc (x0 x2) (x1 x2)\n                (compose (from (x1 x2)) (from (x0 x2))))\n             ((fun\n                 lemma : equiv\n                           (compose (x1 x2)\n                              (compose (from (x1 x2)) (from (x0 x2))))\n                           (compose (compose (x1 x2) (from (x1 x2)))\n                              (from (x0 x2))) =>\n               trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                 (compose (x0 x2)\n                    (compose (x1 x2)\n                       (compose (from (x1 x2)) (from (x0 x2)))))\n                 (compose (x0 x2)\n                    (compose (compose (x1 x2) (from (x1 x2)))\n                       (from (x0 x2))))\n                 (Reflexive_partial_app_morphism compose_respects\n                    (reflexive_proper_proxy Equivalence_Reflexive\n                       (x0 x2))\n                    (compose (x1 x2)\n                       (compose (from (x1 x2)) (from (x0 x2))))\n                    (compose (compose (x1 x2) (from (x1 x2)))\n                       (from (x0 x2))) lemma) id id\n                 (eq_proper_proxy id))\n                (comp_assoc (x1 x2) (from (x1 x2)) (from (x0 x2)))\n                ((fun lemma : equiv (compose (x1 x2) (from (x1 x2))) id\n                  =>\n                  trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                    (compose (x0 x2)\n                       (compose (compose (x1 x2) (from (x1 x2)))\n                          (from (x0 x2))))\n                    (compose (x0 x2) (compose id (from (x0 x2))))\n                    (Reflexive_partial_app_morphism compose_respects\n                       (reflexive_proper_proxy Equivalence_Reflexive\n                          (x0 x2))\n                       (compose (compose (x1 x2) (from (x1 x2)))\n                          (from (x0 x2))) (compose id (from (x0 x2)))\n                       (compose_respects\n                          (compose (x1 x2) (from (x1 x2))) id lemma\n                          (from (x0 x2)) (from (x0 x2))\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (from (x0 x2))))) id id\n                    (eq_proper_proxy id)) (iso_to_from (x1 x2))\n                   ((fun\n                       lemma : equiv (compose id (from (x0 x2)))\n                                 (from (x0 x2)) =>\n                     trans_co_eq_inv_arrow_morphism\n                       Equivalence_Transitive\n                       (compose (x0 x2) (compose id (from (x0 x2))))\n                       (compose (x0 x2) (from (x0 x2)))\n                       (Reflexive_partial_app_morphism compose_respects\n                          (reflexive_proper_proxy Equivalence_Reflexive\n                             (x0 x2)) (compose id (from (x0 x2)))\n                          (from (x0 x2)) lemma) id id\n                       (eq_proper_proxy id)) (id_left (from (x0 x2)))\n                      (iso_to_from (x0 x2)))))\n           :\n           equiv\n             (compose (compose (x0 x2) (x1 x2))\n                (compose (from (x1 x2)) (from (x0 x2)))) id;\n         iso_from_to :=\n           ?Goal0\n           :\n           equiv\n             (compose (compose (from (x1 x2)) (from (x0 x2)))\n                (compose (x0 x2) (x1 x2))) id\n       |}) x2))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose (compose (compose (from (x1 y0)) (from (x0 y0))) (fmap f))\n     (compose (x0 x2) (x1 x2)))"
                ]
            },
            {
                "tactic_sig": "rewrite !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose (compose (compose (from (x1 y0)) (from (x0 y0))) (fmap f))\n     (compose (x0 x2) (x1 x2)))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (compose (compose (from (x1 y0)) (from (x0 y0))) (fmap f))\n        (x0 x2)) (x1 x2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( comp_assoc _ ( _i _i ) \u207b\u00b9 ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( comp_assoc _ ( _i _i ) \u207b\u00b9 ) .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (compose (compose (from (x1 y0)) (from (x0 y0))) (fmap f))\n        (x0 x2)) (x1 x2))",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "y0 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (compose (from (x1 y0)) (compose (from (x0 y0)) (fmap f)))\n        (x0 x2)) (x1 x2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( comp_assoc _ ( ( _i _i ) \u207b\u00b9 \u2218 _ ) ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( comp_assoc _ ( ( _i _i ) \u207b\u00b9 \u2218 _ ) ) .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose\n        (compose (from (x1 y0)) (compose (from (x0 y0)) (fmap f)))\n        (x0 x2)) (x1 x2))",
                    "x0 : forall x : C, Isomorphism (y x) (z x)",
                    "y0 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (from (x1 y0))\n        (compose (compose (from (x0 y0)) (fmap f)) (x0 x2))) \n     (x1 x2))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (compose\n     (compose (from (x1 y0))\n        (compose (compose (from (x0 y0)) (fmap f)) (x0 x2))) \n     (x1 x2))",
                    "e : forall (x y0 : C) (f : hom x y0),\nequiv (fmap f) (compose (compose (from (x0 y0)) (fmap f)) (x0 x))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose (from (x1 y0)) (fmap f)) (x1 x2))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose (from (x1 y0)) (fmap f)) (x1 x2))",
                    "e0 : forall (x0 y0 : C) (f : hom x0 y0),\nequiv (fmap f) (compose (compose (from (x1 y0)) (fmap f)) (x1 x0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_equiv_to_fmap",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : C) (f : hom x y),\nequiv (compose (projT1 eqv y) (fmap f))\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (projT1 eqv y) (fmap f))\n  (compose (fmap f) (projT1 eqv x))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "rewrite <- id_right .",
                "tactic_sig_no_out_arg": "rewrite <- id_right .",
                "tactic_args": [
                    "_goal : equiv (compose (projT1 eqv y) (fmap f))\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (compose (projT1 eqv y) (fmap f)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "rewrite ( ( `2 _i ) _ _ ) .",
                "tactic_sig_no_out_arg": "rewrite ( ( `2 _i ) _ _ ) .",
                "tactic_args": [
                    "_goal : equiv (compose (compose (projT1 eqv y) (fmap f)) id)\n  (compose (fmap f) (projT1 eqv x))",
                    "eqv : equiv F G"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose\n     (compose (projT1 eqv y)\n        (compose (compose (from (projT1 eqv y)) (fmap f))\n           (projT1 eqv x))) id) (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "rewrite !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose\n     (compose (projT1 eqv y)\n        (compose (compose (from (projT1 eqv y)) (fmap f))\n           (projT1 eqv x))) id) (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose\n     (compose\n        (compose (compose (projT1 eqv y) (from (projT1 eqv y)))\n           (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from .",
                "tactic_args": [
                    "_goal : equiv\n  (compose\n     (compose\n        (compose (compose (projT1 eqv y) (from (projT1 eqv y)))\n           (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (compose (compose id (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (compose (compose (compose id (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (compose (compose id (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (compose (compose (compose id (fmap f)) (projT1 eqv x)) id)\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (fmap f) (projT1 eqv x))\n  (compose (fmap f) (projT1 eqv x))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (compose (fmap f) (projT1 eqv x))\n  (compose (fmap f) (projT1 eqv x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_equiv_fmap_from",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : C) (f : hom x y),\nequiv (compose (fmap f) (from (projT1 eqv x)))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (fmap f) (from (projT1 eqv x)))\n  (compose (from (projT1 eqv y)) (fmap f))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "rewrite <- id_left .",
                "tactic_sig_no_out_arg": "rewrite <- id_left .",
                "tactic_args": [
                    "_goal : equiv (compose (fmap f) (from (projT1 eqv x)))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose id (compose (fmap f) (from (projT1 eqv x))))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ]
            },
            {
                "tactic_sig": "rewrite ( ( `2 _i ) _ _ ) .",
                "tactic_sig_no_out_arg": "rewrite ( ( `2 _i ) _ _ ) .",
                "tactic_args": [
                    "_goal : equiv (compose id (compose (fmap f) (from (projT1 eqv x))))\n  (compose (from (projT1 eqv y)) (fmap f))",
                    "eqv : equiv F G"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose id\n     (compose\n        (compose (compose (from (projT1 eqv y)) (fmap f))\n           (projT1 eqv x)) (from (projT1 eqv x))))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ]
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose id\n     (compose\n        (compose (compose (from (projT1 eqv y)) (fmap f))\n           (projT1 eqv x)) (from (projT1 eqv x))))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose id\n     (compose (from (projT1 eqv y))\n        (compose (fmap f)\n           (compose (projT1 eqv x) (from (projT1 eqv x))))))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from .",
                "tactic_args": [
                    "_goal : equiv\n  (compose id\n     (compose (from (projT1 eqv y))\n        (compose (fmap f)\n           (compose (projT1 eqv x) (from (projT1 eqv x))))))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose id (compose (from (projT1 eqv y)) (compose (fmap f) id)))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ]
            },
            {
                "tactic_sig": "now cat .",
                "tactic_sig_no_out_arg": "now cat .",
                "tactic_args": [
                    "_goal : equiv\n  (compose id (compose (from (projT1 eqv y)) (compose (fmap f) id)))\n  (compose (from (projT1 eqv y)) (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "proper .",
                "tactic_sig_no_out_arg": "proper .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (fun f : hom x y => fmap (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap x0)) (fmap (fmap y0))",
                    "X : equiv x0 y0",
                    "x0 : hom x y",
                    "y0 : hom x y"
                ]
            },
            {
                "tactic_sig": "rewrites .",
                "tactic_sig_no_out_arg": "rewrites .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap x0)) (fmap (fmap y0))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap y0)) (fmap (fmap y0))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap y0)) (fmap (fmap y0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (compose f g)))\n  (compose (fmap (fmap f)) (fmap (fmap g)))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (compose f g)))\n  (compose (fmap (fmap f)) (fmap (fmap g)))"
                ]
            },
            {
                "tactic_sig": "rewrite !fmap_comp .",
                "tactic_sig_no_out_arg": "rewrite !fmap_comp .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (compose f g)))\n  (compose (fmap (fmap f)) (fmap (fmap g)))"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (fmap (fmap f)) (fmap (fmap g)))\n  (compose (fmap (fmap f)) (fmap (fmap g)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : equiv (compose (fmap (fmap f)) (fmap (fmap g)))\n  (compose (fmap (fmap f)) (fmap (fmap g)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "proper .",
                "tactic_sig_no_out_arg": "proper .",
                "tactic_args": [
                    "_goal : respectful\n  (fun F G : Functor =>\n   sigT\n     (fun iso : forall x : D, Isomorphism (F x) (G x) =>\n      forall (x y : D) (f : hom x y),\n      equiv (fmap f)\n        (compose (compose (from (iso y)) (fmap f)) (iso x))))\n  (respectful\n     (fun F G : Functor =>\n      sigT\n        (fun iso : forall x : C, Isomorphism (F x) (G x) =>\n         forall (x y : C) (f : hom x y),\n         equiv (fmap f)\n           (compose (compose (from (iso y)) (fmap f)) (iso x))))\n     (fun F G : Functor =>\n      sigT\n        (fun iso : forall x : C, Isomorphism (F x) (G x) =>\n         forall (x y : C) (f : hom x y),\n         equiv (fmap f)\n           (compose (compose (from (iso y)) (fmap f)) (iso x)))))\n  Compose Compose"
                ],
                "tactic_res": [
                    "_goal : Isomorphism (x (x0 x3)) (y (y0 x3))",
                    "_goal : equiv (fmap (fmap f))\n  (compose (compose (from ((fun x3 : C => ?Goal) y1)) (fmap (fmap f)))\n     ((fun x3 : C => ?Goal) x3))",
                    "x3 : obj",
                    "e : forall (x y : C) (f : hom x y),\nequiv (fmap f) (compose (compose (from (x1 y)) (fmap f)) (x1 x))",
                    "x1 : forall x : C, Isomorphism (x0 x) (y0 x)",
                    "x0 : Functor",
                    "y0 : Functor",
                    "e0 : forall (x0 y0 : D) (f : hom x0 y0),\nequiv (fmap f) (compose (compose (from (x2 y0)) (fmap f)) (x2 x0))",
                    "x2 : forall x0 : D, Isomorphism (x x0) (y x0)",
                    "x : Functor",
                    "y : Functor",
                    "f : hom x3 y1",
                    "y1 : obj"
                ]
            },
            {
                "tactic_sig": "isomorphism .",
                "tactic_sig_no_out_arg": "isomorphism .",
                "tactic_args": [
                    "_goal : Isomorphism (x (x0 x3)) (y (y0 x3))"
                ],
                "tactic_res": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))",
                    "_goal : hom (y (y0 x3)) (x (x0 x3))",
                    "_goal : equiv (compose ?Goal0 ?Goal1) id",
                    "_goal : equiv (compose ?Goal1 ?Goal0) id"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose ?Goal0 ?Goal1) id",
                    "_goal : equiv (compose ?Goal1 ?Goal0) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (?Goal3 : hom (x (x0 x3)) (y (y0 x3))) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (?Goal3 : hom (x (x0 x3)) (y (y0 x3)))) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ],
                "tactic_res": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose (?Goal3 : hom (x (x0 x3)) (y (y0 x3))) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (?Goal3 : hom (x (x0 x3)) (y (y0 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (?Goal2 : hom (x (x0 x3)) (y (y0 x3)))\n     (?Goal3 : hom (y (y0 x3)) (x (x0 x3)))) id",
                    "_goal : equiv\n  (compose (?Goal3 : hom (y (y0 x3)) (x (x0 x3)))\n     (?Goal2 : hom (x (x0 x3)) (y (y0 x3)))) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ],
                "tactic_res": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (?Goal2 : hom (x (x0 x3)) (y (y0 x3)))\n     (?Goal3 : hom (y (y0 x3)) (x (x0 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose ?Goal0 ?Goal1) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ],
                "tactic_res": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (?Goal3 : hom (y (y0 x3)) (x (x0 x3)))\n     (?Goal2 : hom (x (x0 x3)) (y (y0 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose ?Goal1 ?Goal0) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ],
                "tactic_res": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))"
                ]
            },
            {
                "tactic_sig": "exact ( fmap ( to ( _i _i ) ) \u2218 to ( _i ( _i _i ) ) ) .",
                "tactic_sig_no_out_arg": "exact ( fmap ( to ( _i _i ) ) \u2218 to ( _i ( _i _i ) ) ) .",
                "tactic_args": [
                    "_goal : hom (x (x0 x3)) (y (y0 x3))",
                    "_goal : equiv (fmap (fmap f))\n  (compose (compose (from ((fun x3 : C => ?Goal) y1)) (fmap (fmap f)))\n     ((fun x3 : C => ?Goal) x3))",
                    "x1 : forall x : C, Isomorphism (x0 x) (y0 x)",
                    "x3 : obj",
                    "x2 : forall x0 : D, Isomorphism (x x0) (y x0)",
                    "x0 : Functor",
                    "x3 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to := ?Goal0 : hom (x (x0 x3)) (y (y0 x3));\n               from := ?Goal1 : hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal2\n                  :\n                  equiv\n                    (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                       (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                      (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal3\n                  :\n                  equiv\n                    (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                       (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                      (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to := ?Goal0 : hom (x (x0 x3)) (y (y0 x3));\n         from := ?Goal1 : hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal2\n            :\n            equiv\n              (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                 (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal3\n            :\n            equiv\n              (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                 (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ]
            },
            {
                "tactic_sig": "exact ( from ( _i ( _i _i ) ) \u2218 fmap ( from ( _i _i ) ) ) .",
                "tactic_sig_no_out_arg": "exact ( from ( _i ( _i _i ) ) \u2218 fmap ( from ( _i _i ) ) ) .",
                "tactic_args": [
                    "_goal : hom (y (y0 x3)) (x (x0 x3))",
                    "_goal : equiv (compose ?Goal0 ?Goal1) id",
                    "_goal : equiv (compose ?Goal1 ?Goal0) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to := ?Goal0 : hom (x (x0 x3)) (y (y0 x3));\n               from := ?Goal1 : hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal2\n                  :\n                  equiv\n                    (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                       (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                      (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal3\n                  :\n                  equiv\n                    (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                       (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                      (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to := ?Goal0 : hom (x (x0 x3)) (y (y0 x3));\n         from := ?Goal1 : hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal2\n            :\n            equiv\n              (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                 (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))\n                (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal3\n            :\n            equiv\n              (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                 (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal1 : hom (y (y0 x3)) (x (x0 x3)))\n                (?Goal0 : hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))",
                    "x2 : forall x0 : D, Isomorphism (x x0) (y x0)",
                    "x0 : Functor",
                    "x3 : obj",
                    "x1 : forall x : C, Isomorphism (x0 x) (y0 x)",
                    "x3 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (compose (fmap (x1 x3)) (x2 (x0 x3))) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (compose (fmap (x1 x3)) (x2 (x0 x3)))) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from := ?Goal0 : hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal1\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal2\n                  :\n                  equiv\n                    (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from := ?Goal0 : hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal1\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal2\n            :\n            equiv\n              (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ]
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv (compose (compose (fmap (x1 x3)) (x2 (x0 x3))) ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 (compose (fmap (x1 x3)) (x2 (x0 x3)))) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from := ?Goal0 : hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal1\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal2\n                  :\n                  equiv\n                    (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from := ?Goal0 : hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal1\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal2\n            :\n            equiv\n              (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose (?Goal0 : hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (fmap (x1 x3))\n     (compose (x2 (x0 x3))\n        (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))) id",
                    "_goal : equiv\n  (compose (compose (from (x2 (x0 x3))) (fmap (from (x1 x3))))\n     (compose (fmap (x1 x3)) (x2 (x0 x3)))) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from :=\n                 compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal0\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal1\n                  :\n                  equiv\n                    (compose\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from :=\n           compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n           :\n           hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal0\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal1\n            :\n            equiv\n              (compose\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( _i ( _i _i ) ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( _i ( _i _i ) ) ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (fmap (x1 x3))\n     (compose (x2 (x0 x3))\n        (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))) id",
                    "x2 : forall x0 : D, Isomorphism (x x0) (y x0)",
                    "x0 : Functor",
                    "x3 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (fmap (x1 x3))\n     (compose (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n        (fmap (from (x1 x3))))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from , id_left .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from , id_left .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (fmap (x1 x3))\n     (compose (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n        (fmap (from (x1 x3))))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (fmap (x1 x3)) (fmap (from (x1 x3)))) id"
                ]
            },
            {
                "tactic_sig": "rewrite <- fmap_comp .",
                "tactic_sig_no_out_arg": "rewrite <- fmap_comp .",
                "tactic_args": [
                    "_goal : equiv (compose (fmap (x1 x3)) (fmap (from (x1 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (compose (x1 x3) (from (x1 x3)))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_to_from .",
                "tactic_sig_no_out_arg": "rewrite iso_to_from .",
                "tactic_args": [
                    "_goal : equiv (fmap (compose (x1 x3) (from (x1 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap id) id"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap id) id"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap id) id"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap id) id"
                ],
                "tactic_res": [
                    "_goal : equiv id id"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv id id"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (compose (from (x2 (x0 x3))) (fmap (from (x1 x3))))\n     (compose (fmap (x1 x3)) (x2 (x0 x3)))) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from :=\n                 compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 (?Goal0\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal1\n                  :\n                  equiv\n                    (compose\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from :=\n           compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n           :\n           hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           (?Goal0\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal1\n            :\n            equiv\n              (compose\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (fmap (from (x1 x3)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3))))) id",
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from :=\n                 compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 ((fun\n                     lemma : equiv\n                               (compose (fmap (x1 x3))\n                                  (compose (x2 (x0 x3))\n                                     (compose (from (x2 (x0 x3)))\n                                        (fmap (from (x1 x3))))))\n                               (compose\n                                  (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                                  (compose (from (x2 (x0 x3)))\n                                     (fmap (from (x1 x3))))) =>\n                   trans_co_eq_inv_arrow_morphism\n                     Equivalence_Transitive\n                     (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3)))))\n                     (compose (fmap (x1 x3))\n                        (compose (x2 (x0 x3))\n                           (compose (from (x2 (x0 x3)))\n                              (fmap (from (x1 x3)))))) \n                     (symmetry lemma) id id (eq_proper_proxy id))\n                    (comp_assoc (fmap (x1 x3)) (x2 (x0 x3))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))))\n                    ((fun\n                        lemma : equiv\n                                  (compose (x2 (x0 x3))\n                                     (compose (from (x2 (x0 x3)))\n                                        (fmap (from (x1 x3)))))\n                                  (compose\n                                     (compose (x2 (x0 x3))\n                                        (from (x2 (x0 x3))))\n                                     (fmap (from (x1 x3)))) =>\n                      trans_co_eq_inv_arrow_morphism\n                        Equivalence_Transitive\n                        (compose (fmap (x1 x3))\n                           (compose (x2 (x0 x3))\n                              (compose (from (x2 (x0 x3)))\n                                 (fmap (from (x1 x3))))))\n                        (compose (fmap (x1 x3))\n                           (compose\n                              (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                              (fmap (from (x1 x3)))))\n                        (Reflexive_partial_app_morphism\n                           compose_respects\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive \n                              (fmap (x1 x3)))\n                           (compose (x2 (x0 x3))\n                              (compose (from (x2 (x0 x3)))\n                                 (fmap (from (x1 x3)))))\n                           (compose\n                              (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                              (fmap (from (x1 x3)))) lemma) id id\n                        (eq_proper_proxy id))\n                       (comp_assoc (x2 (x0 x3)) (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3))))\n                       ((fun\n                           lemma : equiv\n                                     (compose (x2 (x0 x3))\n                                        (from (x2 (x0 x3)))) id =>\n                         trans_co_eq_inv_arrow_morphism\n                           Equivalence_Transitive\n                           (compose (fmap (x1 x3))\n                              (compose\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3))))\n                                 (fmap (from (x1 x3)))))\n                           (compose (fmap (x1 x3))\n                              (compose id (fmap (from (x1 x3)))))\n                           (Reflexive_partial_app_morphism\n                              compose_respects\n                              (reflexive_proper_proxy\n                                 Equivalence_Reflexive \n                                 (fmap (x1 x3)))\n                              (compose\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3))))\n                                 (fmap (from (x1 x3))))\n                              (compose id (fmap (from (x1 x3))))\n                              (compose_respects\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3)))) id lemma\n                                 (fmap (from (x1 x3)))\n                                 (fmap (from (x1 x3)))\n                                 (reflexive_proper_proxy\n                                    Equivalence_Reflexive\n                                    (fmap (from (x1 x3)))))) id id\n                           (eq_proper_proxy id))\n                          (iso_to_from (x2 (x0 x3)))\n                          ((fun\n                              lemma : equiv\n                                        (compose id\n                                           (fmap (from (x1 x3))))\n                                        (fmap (from (x1 x3))) =>\n                            trans_co_eq_inv_arrow_morphism\n                              Equivalence_Transitive\n                              (compose (fmap (x1 x3))\n                                 (compose id (fmap (from (x1 x3)))))\n                              (compose (fmap (x1 x3))\n                                 (fmap (from (x1 x3))))\n                              (Reflexive_partial_app_morphism\n                                 compose_respects\n                                 (reflexive_proper_proxy\n                                    Equivalence_Reflexive\n                                    (fmap (x1 x3)))\n                                 (compose id (fmap (from (x1 x3))))\n                                 (fmap (from (x1 x3))) lemma) id id\n                              (eq_proper_proxy id))\n                             (id_left (fmap (from (x1 x3))))\n                             ((fun\n                                 lemma : equiv\n                                           (fmap\n                                              (compose \n                                                 (x1 x3) \n                                                 (from (x1 x3))))\n                                           (compose \n                                              (fmap (x1 x3))\n                                              (fmap (from (x1 x3)))) =>\n                               trans_co_eq_inv_arrow_morphism\n                                 Equivalence_Transitive\n                                 (compose (fmap (x1 x3))\n                                    (fmap (from (x1 x3))))\n                                 (fmap (compose (x1 x3) (from (x1 x3))))\n                                 (symmetry lemma) id id\n                                 (eq_proper_proxy id))\n                                (fmap_comp (x1 x3) (from (x1 x3)))\n                                ((fun\n                                    lemma : equiv\n                                              (compose \n                                                 (x1 x3) \n                                                 (from (x1 x3))) id =>\n                                  trans_co_eq_inv_arrow_morphism\n                                    Equivalence_Transitive\n                                    (fmap\n                                       (compose (x1 x3) (from (x1 x3))))\n                                    (fmap id)\n                                    (fmap_respects \n                                       (y0 x3) (y0 x3)\n                                       (compose (x1 x3) (from (x1 x3)))\n                                       id lemma) id id\n                                    (eq_proper_proxy id))\n                                   (iso_to_from (x1 x3))\n                                   ((fun lemma : equiv (fmap id) id =>\n                                     trans_co_eq_inv_arrow_morphism\n                                       Equivalence_Transitive \n                                       (fmap id) id lemma id id\n                                       (eq_proper_proxy id)) fmap_id\n                                      (reflexivity id)))))))\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal0\n                  :\n                  equiv\n                    (compose\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from :=\n           compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n           :\n           hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           ((fun\n               lemma : equiv\n                         (compose (fmap (x1 x3))\n                            (compose (x2 (x0 x3))\n                               (compose (from (x2 (x0 x3)))\n                                  (fmap (from (x1 x3))))))\n                         (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                            (compose (from (x2 (x0 x3)))\n                               (fmap (from (x1 x3))))) =>\n             trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n               (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                  (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))\n               (compose (fmap (x1 x3))\n                  (compose (x2 (x0 x3))\n                     (compose (from (x2 (x0 x3))) (fmap (from (x1 x3))))))\n               (symmetry lemma) id id (eq_proper_proxy id))\n              (comp_assoc (fmap (x1 x3)) (x2 (x0 x3))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))\n              ((fun\n                  lemma : equiv\n                            (compose (x2 (x0 x3))\n                               (compose (from (x2 (x0 x3)))\n                                  (fmap (from (x1 x3)))))\n                            (compose\n                               (compose (x2 (x0 x3))\n                                  (from (x2 (x0 x3))))\n                               (fmap (from (x1 x3)))) =>\n                trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                  (compose (fmap (x1 x3))\n                     (compose (x2 (x0 x3))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3))))))\n                  (compose (fmap (x1 x3))\n                     (compose\n                        (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                        (fmap (from (x1 x3)))))\n                  (Reflexive_partial_app_morphism compose_respects\n                     (reflexive_proper_proxy Equivalence_Reflexive\n                        (fmap (x1 x3)))\n                     (compose (x2 (x0 x3))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3)))))\n                     (compose\n                        (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                        (fmap (from (x1 x3)))) lemma) id id\n                  (eq_proper_proxy id))\n                 (comp_assoc (x2 (x0 x3)) (from (x2 (x0 x3)))\n                    (fmap (from (x1 x3))))\n                 ((fun\n                     lemma : equiv\n                               (compose (x2 (x0 x3))\n                                  (from (x2 (x0 x3)))) id =>\n                   trans_co_eq_inv_arrow_morphism\n                     Equivalence_Transitive\n                     (compose (fmap (x1 x3))\n                        (compose\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           (fmap (from (x1 x3)))))\n                     (compose (fmap (x1 x3))\n                        (compose id (fmap (from (x1 x3)))))\n                     (Reflexive_partial_app_morphism compose_respects\n                        (reflexive_proper_proxy Equivalence_Reflexive\n                           (fmap (x1 x3)))\n                        (compose\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           (fmap (from (x1 x3))))\n                        (compose id (fmap (from (x1 x3))))\n                        (compose_respects\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           id lemma (fmap (from (x1 x3)))\n                           (fmap (from (x1 x3)))\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive\n                              (fmap (from (x1 x3)))))) id id\n                     (eq_proper_proxy id)) (iso_to_from (x2 (x0 x3)))\n                    ((fun\n                        lemma : equiv\n                                  (compose id (fmap (from (x1 x3))))\n                                  (fmap (from (x1 x3))) =>\n                      trans_co_eq_inv_arrow_morphism\n                        Equivalence_Transitive\n                        (compose (fmap (x1 x3))\n                           (compose id (fmap (from (x1 x3)))))\n                        (compose (fmap (x1 x3)) (fmap (from (x1 x3))))\n                        (Reflexive_partial_app_morphism\n                           compose_respects\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive \n                              (fmap (x1 x3)))\n                           (compose id (fmap (from (x1 x3))))\n                           (fmap (from (x1 x3))) lemma) id id\n                        (eq_proper_proxy id))\n                       (id_left (fmap (from (x1 x3))))\n                       ((fun\n                           lemma : equiv\n                                     (fmap\n                                        (compose (x1 x3) (from (x1 x3))))\n                                     (compose (fmap (x1 x3))\n                                        (fmap (from (x1 x3)))) =>\n                         trans_co_eq_inv_arrow_morphism\n                           Equivalence_Transitive\n                           (compose (fmap (x1 x3))\n                              (fmap (from (x1 x3))))\n                           (fmap (compose (x1 x3) (from (x1 x3))))\n                           (symmetry lemma) id id \n                           (eq_proper_proxy id))\n                          (fmap_comp (x1 x3) (from (x1 x3)))\n                          ((fun\n                              lemma : equiv\n                                        (compose (x1 x3) (from (x1 x3)))\n                                        id =>\n                            trans_co_eq_inv_arrow_morphism\n                              Equivalence_Transitive\n                              (fmap (compose (x1 x3) (from (x1 x3))))\n                              (fmap id)\n                              (fmap_respects (y0 x3) \n                                 (y0 x3)\n                                 (compose (x1 x3) (from (x1 x3))) id\n                                 lemma) id id (eq_proper_proxy id))\n                             (iso_to_from (x1 x3))\n                             ((fun lemma : equiv (fmap id) id =>\n                               trans_co_eq_inv_arrow_morphism\n                                 Equivalence_Transitive \n                                 (fmap id) id lemma id id\n                                 (eq_proper_proxy id)) fmap_id\n                                (reflexivity id)))))))\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal0\n            :\n            equiv\n              (compose\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (fmap (from (x1 x3)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3))))) id"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (compose (fmap (from (x1 x3))) (fmap (x1 x3)))\n        (x2 (x0 x3)))) id"
                ]
            },
            {
                "tactic_sig": "rewrite <- fmap_comp .",
                "tactic_sig_no_out_arg": "rewrite <- fmap_comp .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (compose (fmap (from (x1 x3))) (fmap (x1 x3)))\n        (x2 (x0 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (fmap (compose (from (x1 x3)) (x1 x3))) (x2 (x0 x3)))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_from_to , fmap_id , id_left .",
                "tactic_sig_no_out_arg": "rewrite iso_from_to , fmap_id , id_left .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 x3)))\n     (compose (fmap (compose (from (x1 x3)) (x1 x3))) (x2 (x0 x3)))) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (from (x2 (x0 x3))) (x2 (x0 x3))) id"
                ]
            },
            {
                "tactic_sig": "rewrite iso_from_to .",
                "tactic_sig_no_out_arg": "rewrite iso_from_to .",
                "tactic_args": [
                    "_goal : equiv (compose (from (x2 (x0 x3))) (x2 (x0 x3))) id"
                ],
                "tactic_res": [
                    "_goal : equiv id id"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv id id"
                ],
                "tactic_res": [
                    "_goal : equiv id id"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv id id"
                ],
                "tactic_res": [
                    "_goal : equiv id id"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv id id"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose\n        (from\n           ((fun x3 : C =>\n             {|\n               to :=\n                 compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3));\n               from :=\n                 compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3));\n               iso_to_from :=\n                 ((fun\n                     lemma : equiv\n                               (compose (fmap (x1 x3))\n                                  (compose (x2 (x0 x3))\n                                     (compose (from (x2 (x0 x3)))\n                                        (fmap (from (x1 x3))))))\n                               (compose\n                                  (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                                  (compose (from (x2 (x0 x3)))\n                                     (fmap (from (x1 x3))))) =>\n                   trans_co_eq_inv_arrow_morphism\n                     Equivalence_Transitive\n                     (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3)))))\n                     (compose (fmap (x1 x3))\n                        (compose (x2 (x0 x3))\n                           (compose (from (x2 (x0 x3)))\n                              (fmap (from (x1 x3)))))) \n                     (symmetry lemma) id id (eq_proper_proxy id))\n                    (comp_assoc (fmap (x1 x3)) (x2 (x0 x3))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))))\n                    ((fun\n                        lemma : equiv\n                                  (compose (x2 (x0 x3))\n                                     (compose (from (x2 (x0 x3)))\n                                        (fmap (from (x1 x3)))))\n                                  (compose\n                                     (compose (x2 (x0 x3))\n                                        (from (x2 (x0 x3))))\n                                     (fmap (from (x1 x3)))) =>\n                      trans_co_eq_inv_arrow_morphism\n                        Equivalence_Transitive\n                        (compose (fmap (x1 x3))\n                           (compose (x2 (x0 x3))\n                              (compose (from (x2 (x0 x3)))\n                                 (fmap (from (x1 x3))))))\n                        (compose (fmap (x1 x3))\n                           (compose\n                              (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                              (fmap (from (x1 x3)))))\n                        (Reflexive_partial_app_morphism\n                           compose_respects\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive \n                              (fmap (x1 x3)))\n                           (compose (x2 (x0 x3))\n                              (compose (from (x2 (x0 x3)))\n                                 (fmap (from (x1 x3)))))\n                           (compose\n                              (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                              (fmap (from (x1 x3)))) lemma) id id\n                        (eq_proper_proxy id))\n                       (comp_assoc (x2 (x0 x3)) (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3))))\n                       ((fun\n                           lemma : equiv\n                                     (compose (x2 (x0 x3))\n                                        (from (x2 (x0 x3)))) id =>\n                         trans_co_eq_inv_arrow_morphism\n                           Equivalence_Transitive\n                           (compose (fmap (x1 x3))\n                              (compose\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3))))\n                                 (fmap (from (x1 x3)))))\n                           (compose (fmap (x1 x3))\n                              (compose id (fmap (from (x1 x3)))))\n                           (Reflexive_partial_app_morphism\n                              compose_respects\n                              (reflexive_proper_proxy\n                                 Equivalence_Reflexive \n                                 (fmap (x1 x3)))\n                              (compose\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3))))\n                                 (fmap (from (x1 x3))))\n                              (compose id (fmap (from (x1 x3))))\n                              (compose_respects\n                                 (compose (x2 (x0 x3))\n                                    (from (x2 (x0 x3)))) id lemma\n                                 (fmap (from (x1 x3)))\n                                 (fmap (from (x1 x3)))\n                                 (reflexive_proper_proxy\n                                    Equivalence_Reflexive\n                                    (fmap (from (x1 x3)))))) id id\n                           (eq_proper_proxy id))\n                          (iso_to_from (x2 (x0 x3)))\n                          ((fun\n                              lemma : equiv\n                                        (compose id\n                                           (fmap (from (x1 x3))))\n                                        (fmap (from (x1 x3))) =>\n                            trans_co_eq_inv_arrow_morphism\n                              Equivalence_Transitive\n                              (compose (fmap (x1 x3))\n                                 (compose id (fmap (from (x1 x3)))))\n                              (compose (fmap (x1 x3))\n                                 (fmap (from (x1 x3))))\n                              (Reflexive_partial_app_morphism\n                                 compose_respects\n                                 (reflexive_proper_proxy\n                                    Equivalence_Reflexive\n                                    (fmap (x1 x3)))\n                                 (compose id (fmap (from (x1 x3))))\n                                 (fmap (from (x1 x3))) lemma) id id\n                              (eq_proper_proxy id))\n                             (id_left (fmap (from (x1 x3))))\n                             ((fun\n                                 lemma : equiv\n                                           (fmap\n                                              (compose \n                                                 (x1 x3) \n                                                 (from (x1 x3))))\n                                           (compose \n                                              (fmap (x1 x3))\n                                              (fmap (from (x1 x3)))) =>\n                               trans_co_eq_inv_arrow_morphism\n                                 Equivalence_Transitive\n                                 (compose (fmap (x1 x3))\n                                    (fmap (from (x1 x3))))\n                                 (fmap (compose (x1 x3) (from (x1 x3))))\n                                 (symmetry lemma) id id\n                                 (eq_proper_proxy id))\n                                (fmap_comp (x1 x3) (from (x1 x3)))\n                                ((fun\n                                    lemma : equiv\n                                              (compose \n                                                 (x1 x3) \n                                                 (from (x1 x3))) id =>\n                                  trans_co_eq_inv_arrow_morphism\n                                    Equivalence_Transitive\n                                    (fmap\n                                       (compose (x1 x3) (from (x1 x3))))\n                                    (fmap id)\n                                    (fmap_respects \n                                       (y0 x3) (y0 x3)\n                                       (compose (x1 x3) (from (x1 x3)))\n                                       id lemma) id id\n                                    (eq_proper_proxy id))\n                                   (iso_to_from (x1 x3))\n                                   ((fun lemma : equiv (fmap id) id =>\n                                     trans_co_eq_inv_arrow_morphism\n                                       Equivalence_Transitive \n                                       (fmap id) id lemma id id\n                                       (eq_proper_proxy id)) fmap_id\n                                      (reflexivity id)))))))\n                  :\n                  equiv\n                    (compose\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))) id;\n               iso_from_to :=\n                 (?Goal0\n                  :\n                  equiv\n                    (compose\n                       (compose (from (x2 (x0 x3)))\n                          (fmap (from (x1 x3)))\n                        :\n                        hom (y (y0 x3)) (x (x0 x3)))\n                       (compose (fmap (x1 x3)) (x2 (x0 x3))\n                        :\n                        hom (x (x0 x3)) (y (y0 x3)))) id)\n                 :\n                 equiv\n                   (compose\n                      (compose (from (x2 (x0 x3)))\n                         (fmap (from (x1 x3)))\n                       :\n                       hom (y (y0 x3)) (x (x0 x3)))\n                      (compose (fmap (x1 x3)) (x2 (x0 x3))\n                       :\n                       hom (x (x0 x3)) (y (y0 x3)))) id\n             |}) y1)) (fmap (fmap f)))\n     ((fun x3 : C =>\n       {|\n         to :=\n           compose (fmap (x1 x3)) (x2 (x0 x3))\n           :\n           hom (x (x0 x3)) (y (y0 x3));\n         from :=\n           compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n           :\n           hom (y (y0 x3)) (x (x0 x3));\n         iso_to_from :=\n           ((fun\n               lemma : equiv\n                         (compose (fmap (x1 x3))\n                            (compose (x2 (x0 x3))\n                               (compose (from (x2 (x0 x3)))\n                                  (fmap (from (x1 x3))))))\n                         (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                            (compose (from (x2 (x0 x3)))\n                               (fmap (from (x1 x3))))) =>\n             trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n               (compose (compose (fmap (x1 x3)) (x2 (x0 x3)))\n                  (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))\n               (compose (fmap (x1 x3))\n                  (compose (x2 (x0 x3))\n                     (compose (from (x2 (x0 x3))) (fmap (from (x1 x3))))))\n               (symmetry lemma) id id (eq_proper_proxy id))\n              (comp_assoc (fmap (x1 x3)) (x2 (x0 x3))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))))\n              ((fun\n                  lemma : equiv\n                            (compose (x2 (x0 x3))\n                               (compose (from (x2 (x0 x3)))\n                                  (fmap (from (x1 x3)))))\n                            (compose\n                               (compose (x2 (x0 x3))\n                                  (from (x2 (x0 x3))))\n                               (fmap (from (x1 x3)))) =>\n                trans_co_eq_inv_arrow_morphism Equivalence_Transitive\n                  (compose (fmap (x1 x3))\n                     (compose (x2 (x0 x3))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3))))))\n                  (compose (fmap (x1 x3))\n                     (compose\n                        (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                        (fmap (from (x1 x3)))))\n                  (Reflexive_partial_app_morphism compose_respects\n                     (reflexive_proper_proxy Equivalence_Reflexive\n                        (fmap (x1 x3)))\n                     (compose (x2 (x0 x3))\n                        (compose (from (x2 (x0 x3)))\n                           (fmap (from (x1 x3)))))\n                     (compose\n                        (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                        (fmap (from (x1 x3)))) lemma) id id\n                  (eq_proper_proxy id))\n                 (comp_assoc (x2 (x0 x3)) (from (x2 (x0 x3)))\n                    (fmap (from (x1 x3))))\n                 ((fun\n                     lemma : equiv\n                               (compose (x2 (x0 x3))\n                                  (from (x2 (x0 x3)))) id =>\n                   trans_co_eq_inv_arrow_morphism\n                     Equivalence_Transitive\n                     (compose (fmap (x1 x3))\n                        (compose\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           (fmap (from (x1 x3)))))\n                     (compose (fmap (x1 x3))\n                        (compose id (fmap (from (x1 x3)))))\n                     (Reflexive_partial_app_morphism compose_respects\n                        (reflexive_proper_proxy Equivalence_Reflexive\n                           (fmap (x1 x3)))\n                        (compose\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           (fmap (from (x1 x3))))\n                        (compose id (fmap (from (x1 x3))))\n                        (compose_respects\n                           (compose (x2 (x0 x3)) (from (x2 (x0 x3))))\n                           id lemma (fmap (from (x1 x3)))\n                           (fmap (from (x1 x3)))\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive\n                              (fmap (from (x1 x3)))))) id id\n                     (eq_proper_proxy id)) (iso_to_from (x2 (x0 x3)))\n                    ((fun\n                        lemma : equiv\n                                  (compose id (fmap (from (x1 x3))))\n                                  (fmap (from (x1 x3))) =>\n                      trans_co_eq_inv_arrow_morphism\n                        Equivalence_Transitive\n                        (compose (fmap (x1 x3))\n                           (compose id (fmap (from (x1 x3)))))\n                        (compose (fmap (x1 x3)) (fmap (from (x1 x3))))\n                        (Reflexive_partial_app_morphism\n                           compose_respects\n                           (reflexive_proper_proxy\n                              Equivalence_Reflexive \n                              (fmap (x1 x3)))\n                           (compose id (fmap (from (x1 x3))))\n                           (fmap (from (x1 x3))) lemma) id id\n                        (eq_proper_proxy id))\n                       (id_left (fmap (from (x1 x3))))\n                       ((fun\n                           lemma : equiv\n                                     (fmap\n                                        (compose (x1 x3) (from (x1 x3))))\n                                     (compose (fmap (x1 x3))\n                                        (fmap (from (x1 x3)))) =>\n                         trans_co_eq_inv_arrow_morphism\n                           Equivalence_Transitive\n                           (compose (fmap (x1 x3))\n                              (fmap (from (x1 x3))))\n                           (fmap (compose (x1 x3) (from (x1 x3))))\n                           (symmetry lemma) id id \n                           (eq_proper_proxy id))\n                          (fmap_comp (x1 x3) (from (x1 x3)))\n                          ((fun\n                              lemma : equiv\n                                        (compose (x1 x3) (from (x1 x3)))\n                                        id =>\n                            trans_co_eq_inv_arrow_morphism\n                              Equivalence_Transitive\n                              (fmap (compose (x1 x3) (from (x1 x3))))\n                              (fmap id)\n                              (fmap_respects (y0 x3) \n                                 (y0 x3)\n                                 (compose (x1 x3) (from (x1 x3))) id\n                                 lemma) id id (eq_proper_proxy id))\n                             (iso_to_from (x1 x3))\n                             ((fun lemma : equiv (fmap id) id =>\n                               trans_co_eq_inv_arrow_morphism\n                                 Equivalence_Transitive \n                                 (fmap id) id lemma id id\n                                 (eq_proper_proxy id)) fmap_id\n                                (reflexivity id)))))))\n            :\n            equiv\n              (compose\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))) id;\n         iso_from_to :=\n           (?Goal0\n            :\n            equiv\n              (compose\n                 (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                  :\n                  hom (y (y0 x3)) (x (x0 x3)))\n                 (compose (fmap (x1 x3)) (x2 (x0 x3))\n                  :\n                  hom (x (x0 x3)) (y (y0 x3)))) id)\n           :\n           equiv\n             (compose\n                (compose (from (x2 (x0 x3))) (fmap (from (x1 x3)))\n                 :\n                 hom (y (y0 x3)) (x (x0 x3)))\n                (compose (fmap (x1 x3)) (x2 (x0 x3))\n                 :\n                 hom (x (x0 x3)) (y (y0 x3)))) id\n       |}) x3))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose (compose (from (x2 (x0 y1))) (fmap (from (x1 y1))))\n        (fmap (fmap f))) (compose (fmap (x1 x3)) (x2 (x0 x3))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap f))\n  (compose\n     (compose (compose (from (x2 (x0 y1))) (fmap (from (x1 y1))))\n        (fmap (fmap f))) (compose (fmap (x1 x3)) (x2 (x0 x3))))",
                    "e0 : forall (x0 y0 : D) (f : hom x0 y0),\nequiv (fmap f) (compose (compose (from (x2 y0)) (fmap f)) (x2 x0))",
                    "e : forall (x y : C) (f : hom x y),\nequiv (fmap f) (compose (compose (from (x1 y)) (fmap f)) (x1 x))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))\n  (compose\n     (compose (compose (from (x2 (x0 y1))) (fmap (from (x1 y1))))\n        (fmap (fmap f))) (compose (fmap (x1 x3)) (x2 (x0 x3))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite <- !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))\n  (compose\n     (compose (compose (from (x2 (x0 y1))) (fmap (from (x1 y1))))\n        (fmap (fmap f))) (compose (fmap (x1 x3)) (x2 (x0 x3))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (fmap (from (x1 y1)))\n        (compose (fmap (fmap f)) (compose (fmap (x1 x3)) (x2 (x0 x3))))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (fmap (from (x1 y1)))\n        (compose (fmap (fmap f)) (compose (fmap (x1 x3)) (x2 (x0 x3))))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (compose (fmap (from (x1 y1))) (fmap (fmap f)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3)))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- fmap_comp .",
                "tactic_sig_no_out_arg": "rewrite <- fmap_comp .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (compose (fmap (from (x1 y1))) (fmap (fmap f)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3)))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (fmap (compose (from (x1 y1)) (fmap f)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3)))))"
                ]
            },
            {
                "tactic_sig": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_sig_no_out_arg": "rewrite ( comp_assoc ( fmap _ ) ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose (fmap (compose (from (x1 y1)) (fmap f)))\n        (compose (fmap (x1 x3)) (x2 (x0 x3)))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (compose (fmap (compose (from (x1 y1)) (fmap f)))\n           (fmap (x1 x3))) (x2 (x0 x3))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- fmap_comp .",
                "tactic_sig_no_out_arg": "rewrite <- fmap_comp .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (compose (fmap (compose (from (x1 y1)) (fmap f)))\n           (fmap (x1 x3))) (x2 (x0 x3))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3)))\n        (x2 (x0 x3))))"
                ]
            },
            {
                "tactic_sig": "rewrite !comp_assoc .",
                "tactic_sig_no_out_arg": "rewrite !comp_assoc .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (from (x1 y1)) (compose (fmap f) (x1 x3))))\n        (x2 (x0 x3))))\n  (compose (from (x2 (x0 y1)))\n     (compose\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3)))\n        (x2 (x0 x3))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : equiv\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))\n  (compose\n     (compose (from (x2 (x0 y1)))\n        (fmap (compose (compose (from (x1 y1)) (fmap f)) (x1 x3))))\n     (x2 (x0 x3)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fobj_Compose",
        "proof": [
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (Compose F G x) (F (G x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_equiv_id_right",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose F Id) F"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose id (fmap f)) id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (fmap f)"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (fmap f)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_equiv_id_left",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose Id F) F"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose id (fmap f)) id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (compose (compose id (fmap f)) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f) (fmap f)"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap f) (fmap f)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_equiv_comp_assoc",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose F (Compose G H)) (Compose (Compose F G) H)"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f) (compose (compose (from iso_id) (fmap f)) iso_id)"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (compose (compose id (fmap (fmap (fmap f)))) id)"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f))) (fmap (fmap (fmap f)))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f))) (fmap (fmap (fmap f)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "FullyFaithful",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : C) (_ : Isomorphism (F x) (F y)), Isomorphism x y"
                ],
                "tactic_res": [
                    "_goal : Isomorphism x y",
                    "X : Isomorphism (F x) (F y)",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : Isomorphism x y"
                ],
                "tactic_res": [
                    "_goal : hom x y",
                    "_goal : hom y x",
                    "_goal : equiv (compose ?to ?from) id",
                    "_goal : equiv (compose ?from ?to) id"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose ?to ?from) id",
                    "_goal : equiv (compose ?from ?to) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (?Goal1 : hom x y) ?from) id",
                    "_goal : equiv (compose ?from (?Goal1 : hom x y)) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom x y"
                ],
                "tactic_res": [
                    "_goal : hom x y"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose (?Goal1 : hom x y) ?from) id",
                    "_goal : equiv (compose ?from (?Goal1 : hom x y)) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (?Goal1 : hom x y) (?Goal2 : hom y x)) id",
                    "_goal : equiv (compose (?Goal2 : hom y x) (?Goal1 : hom x y)) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom x y"
                ],
                "tactic_res": [
                    "_goal : hom x y"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose (?Goal1 : hom x y) (?Goal2 : hom y x)) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose ?Goal ?Goal0) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom x y"
                ],
                "tactic_res": [
                    "_goal : hom x y"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv (compose (?Goal2 : hom y x) (?Goal1 : hom x y)) id"
                ],
                "tactic_res": [
                    "_goal : equiv (compose ?Goal0 ?Goal) id"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : hom x y"
                ],
                "tactic_res": [
                    "_goal : hom x y"
                ]
            },
            {
                "tactic_sig": "apply prefmap , _i .",
                "tactic_sig_no_out_arg": "apply prefmap , _i .",
                "tactic_args": [
                    "_goal : hom x y",
                    "X : Isomorphism (F x) (F y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply prefmap , _i .",
                "tactic_sig_no_out_arg": "apply prefmap , _i .",
                "tactic_args": [
                    "_goal : hom y x",
                    "_goal : equiv (compose ?Goal ?Goal0) id",
                    "_goal : equiv (compose ?Goal0 ?Goal) id",
                    "X : Isomorphism (F x) (F y)"
                ],
                "tactic_res": [
                    "_goal : equiv (compose (prefmap (let X0 := to X in X0)) ?Goal) id",
                    "_goal : equiv (compose ?Goal (prefmap (let X0 := to X in X0))) id"
                ]
            },
            {
                "tactic_sig": "abstract ( simpl ; rewrite <- prefmap_comp ; destruct _i ; rewrite iso_to_from ; apply prefmap_id ) .",
                "tactic_sig_no_out_arg": "abstract ( simpl ; rewrite <- prefmap_comp ; destruct _i ; rewrite iso_to_from ; apply prefmap_id ) .",
                "tactic_args": [
                    "_goal : equiv (compose (prefmap (let X0 := to X in X0)) ?Goal) id",
                    "_goal : equiv (compose ?Goal (prefmap (let X0 := to X in X0))) id",
                    "H : Full F"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (compose (prefmap (let X0 := from X in X0))\n     (prefmap (let X0 := to X in X0))) id"
                ]
            },
            {
                "tactic_sig": "abstract ( simpl ; rewrite <- prefmap_comp ; destruct _i ; rewrite iso_from_to ; apply prefmap_id ) .",
                "tactic_sig_no_out_arg": "abstract ( simpl ; rewrite <- prefmap_comp ; destruct _i ; rewrite iso_from_to ; apply prefmap_id ) .",
                "tactic_args": [
                    "_goal : equiv\n  (compose (prefmap (let X0 := from X in X0))\n     (prefmap (let X0 := to X in X0))) id",
                    "H : Full F"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "FromAFunctor_ToAFunctor",
        "proof": [
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (ToAFunctor F) F"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ToAFunctor_FromAFunctor",
        "proof": [
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (ToAFunctor H) H"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_adjunction",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a a' p x y .",
                "tactic_args": [
                    "_goal : forall (a a' : A) (p : eq a a') (x : B a) (y : B a'),\nprod (forall _ : R a x (transport_r B p y), R a' (transport B p x) y)\n  (forall _ : R a' (transport B p x) y, R a x (transport_r B p y))"
                ],
                "tactic_res": [
                    "_goal : prod (forall _ : R a x (transport_r B p y), R a' (transport B p x) y)\n  (forall _ : R a' (transport B p x) y, R a x (transport_r B p y))",
                    "y : B a'",
                    "x : B a",
                    "p : eq a a'",
                    "a : A",
                    "a' : A"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : prod (forall _ : R a x (transport_r B p y), R a' (transport B p x) y)\n  (forall _ : R a' (transport B p x) y, R a x (transport_r B p y))"
                ],
                "tactic_res": [
                    "_goal : forall _ : R a x (transport_r B p y), R a' (transport B p x) y",
                    "_goal : forall _ : R a' (transport B p x) y, R a x (transport_r B p y)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall _ : R a x (transport_r B p y), R a' (transport B p x) y",
                    "p : eq a a'"
                ],
                "tactic_res": [
                    "_goal : forall _ : R a x (transport_r B eq_refl y),\nR a (transport B eq_refl x) y",
                    "y : B a"
                ]
            },
            {
                "tactic_sig": "now unfold transport_r .",
                "tactic_sig_no_out_arg": "now unfold transport_r .",
                "tactic_args": [
                    "_goal : forall _ : R a x (transport_r B eq_refl y),\nR a (transport B eq_refl x) y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall _ : R a' (transport B p x) y, R a x (transport_r B p y)",
                    "p : eq a a'"
                ],
                "tactic_res": [
                    "_goal : forall _ : R a (transport B eq_refl x) y,\nR a x (transport_r B eq_refl y)",
                    "y : B a"
                ]
            },
            {
                "tactic_sig": "now unfold transport_r .",
                "tactic_sig_no_out_arg": "now unfold transport_r .",
                "tactic_args": [
                    "_goal : forall _ : R a (transport B eq_refl x) y,\nR a x (transport_r B eq_refl y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_relation_exchange",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a a' b b' p q t .",
                "tactic_args": [
                    "_goal : forall (a a' b b' : A) (p : eq a b) (q : eq a' b') (t : R a a'),\neq\n  (transport (fun z : A => R b z) q\n     (transport (fun k : A => R k a') p t))\n  (transport (fun k : A => R k b') p\n     (transport (fun z : A => R a z) q t))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (transport (fun z : A => R b z) q\n     (transport (fun k : A => R k a') p t))\n  (transport (fun k : A => R k b') p\n     (transport (fun z : A => R a z) q t))",
                    "t : R a a'",
                    "q : eq a' b'",
                    "p : eq a b",
                    "a : A",
                    "a' : A",
                    "b : A",
                    "b' : A"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq\n  (transport (fun z : A => R b z) q\n     (transport (fun k : A => R k a') p t))\n  (transport (fun k : A => R k b') p\n     (transport (fun z : A => R a z) q t))",
                    "p : eq a b",
                    "q : eq a' b'"
                ],
                "tactic_res": [
                    "_goal : eq\n  (transport (fun z : A => R a z) eq_refl\n     (transport (fun k : A => R k a') eq_refl t))\n  (transport (fun k : A => R k a') eq_refl\n     (transport (fun z : A => R a z) eq_refl t))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (transport (fun z : A => R a z) eq_refl\n     (transport (fun k : A => R k a') eq_refl t))\n  (transport (fun k : A => R k a') eq_refl\n     (transport (fun z : A => R a z) eq_refl t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_trans",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a0 a1 a2 x p q .",
                "tactic_args": [
                    "_goal : forall (a0 a1 a2 : A) (x : B a0) (p : eq a0 a1) (q : eq a1 a2),\neq (transport B q (transport B p x)) (transport B (eq_trans p q) x)"
                ],
                "tactic_res": [
                    "_goal : eq (transport B q (transport B p x)) (transport B (eq_trans p q) x)",
                    "q : eq a1 a2",
                    "p : eq a0 a1",
                    "x : B a0",
                    "a0 : A",
                    "a1 : A",
                    "a2 : A"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq (transport B q (transport B p x)) (transport B (eq_trans p q) x)",
                    "p : eq a0 a1",
                    "q : eq a1 a2"
                ],
                "tactic_res": [
                    "_goal : eq (transport B eq_refl (transport B eq_refl x))\n  (transport B (eq_trans eq_refl eq_refl) x)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (transport B eq_refl (transport B eq_refl x))\n  (transport B (eq_trans eq_refl eq_refl) x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_r_trans",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros a0 a1 a2 x p q .",
                "tactic_args": [
                    "_goal : forall (a0 a1 a2 : A) (x : B a2) (p : eq a0 a1) (q : eq a1 a2),\neq (transport_r B p (transport_r B q x))\n  (transport_r B (eq_trans p q) x)"
                ],
                "tactic_res": [
                    "_goal : eq (transport_r B p (transport_r B q x))\n  (transport_r B (eq_trans p q) x)",
                    "q : eq a1 a2",
                    "p : eq a0 a1",
                    "x : B a2",
                    "a0 : A",
                    "a1 : A",
                    "a2 : A"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [_o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq (transport_r B p (transport_r B q x))\n  (transport_r B (eq_trans p q) x)",
                    "p : eq a0 a1",
                    "q : eq a1 a2"
                ],
                "tactic_res": [
                    "_goal : eq (transport_r B eq_refl (transport_r B eq_refl x))\n  (transport_r B (eq_trans eq_refl eq_refl) x)",
                    "x : B a0"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (transport_r B eq_refl (transport_r B eq_refl x))\n  (transport_r B (eq_trans eq_refl eq_refl) x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "proper_transport",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b p .",
                "tactic_args": [
                    "_goal : forall (a a' : A) (p : eq a a'),\nProper (respectful equiv equiv) (transport B p)"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv) (transport B p)",
                    "p : eq a b",
                    "a : A",
                    "b : A"
                ]
            },
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport B p)",
                    "p : eq a b"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv) (transport B eq_refl)"
                ]
            },
            {
                "tactic_sig": "now unfold transport .",
                "tactic_sig_no_out_arg": "now unfold transport .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport B eq_refl)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "proper_transport_r",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros a b p .",
                "tactic_args": [
                    "_goal : forall (a a' : A) (p : eq a a'),\nProper (respectful equiv equiv) (transport_r B p)"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv) (transport_r B p)",
                    "p : eq a b",
                    "a : A",
                    "b : A"
                ]
            },
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport_r B p)",
                    "p : eq a b"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv) (transport_r B eq_refl)"
                ]
            },
            {
                "tactic_sig": "now ( unfold transport_r ) .",
                "tactic_sig_no_out_arg": "now ( unfold transport_r ) .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport_r B eq_refl)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "proper_transport_r",
        "proof": [
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport (fun z : A => B z d) p)",
                    "p : eq c c'"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv)\n  (transport (fun z : A => B z d) eq_refl)"
                ]
            },
            {
                "tactic_sig": "now trivial .",
                "tactic_sig_no_out_arg": "now trivial .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv)\n  (transport (fun z : A => B z d) eq_refl)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "proper_transport_r",
        "proof": [
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv) (transport (fun z : A => B c z) p)",
                    "p : eq d d'"
                ],
                "tactic_res": [
                    "_goal : Proper (respectful equiv equiv)\n  (transport (fun z : A => B c z) eq_refl)"
                ]
            },
            {
                "tactic_sig": "now trivial .",
                "tactic_sig_no_out_arg": "now trivial .",
                "tactic_args": [
                    "_goal : Proper (respectful equiv equiv)\n  (transport (fun z : A => B c z) eq_refl)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "equivalence .",
                "tactic_sig_no_out_arg": "equivalence .",
                "tactic_args": [
                    "_goal : Equivalence\n  (fun F G : Functor =>\n   sigT\n     (fun eq_on_obj : forall x : C, eq (F x) (G x) =>\n      forall (x y : C) (f : hom x y),\n      equiv\n        (transport (fun z : D => hom (F x) z) (eq_on_obj y) (fmap f))\n        (transport_r (fun z : D => hom z (G y)) (eq_on_obj x) (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (y x1) z)\n     ((fun x1 : C => eq_sym (x0 x1)) y0) (fmap f))\n  (transport_r (fun z : D => hom z (x y0))\n     ((fun x1 : C => eq_sym (x0 x1)) x1) (fmap f))",
                    "_goal : eq (x x2) (z x2)",
                    "_goal : equiv\n  (transport (fun z : D => hom (x x2) z) ((fun x2 : C => ?Goal0) y0)\n     (fmap f))\n  (transport_r (fun z0 : D => hom z0 (z y0))\n     ((fun x2 : C => ?Goal0) x2) (fmap f))",
                    "f : hom x1 y0",
                    "x1 : obj",
                    "y0 : obj",
                    "e : forall (x1 y0 : C) (f : hom x1 y0),\nequiv (transport (fun z : D => hom (x x1) z) (x0 y0) (fmap f))\n  (transport_r (fun z : D => hom z (y y0)) (x0 x1) (fmap f))",
                    "x0 : forall x0 : C, eq (x x0) (y x0)",
                    "x : Functor",
                    "y : Functor",
                    "x2 : obj",
                    "e : forall (x y0 : C) (f : hom x y0),\nequiv (transport (fun z : D => hom (y x) z) (x0 y0) (fmap f))\n  (transport_r (fun z0 : D => hom z0 (z y0)) (x0 x) (fmap f))",
                    "x0 : forall x : C, eq (y x) (z x)",
                    "e0 : forall (x0 y0 : C) (f : hom x0 y0),\nequiv (transport (fun z : D => hom (x x0) z) (x1 y0) (fmap f))\n  (transport_r (fun z : D => hom z (y y0)) (x1 x0) (fmap f))",
                    "x1 : forall x0 : C, eq (x x0) (y x0)",
                    "z : Functor",
                    "f : hom x2 y0"
                ]
            },
            {
                "tactic_sig": "unfold transport_r .",
                "tactic_sig_no_out_arg": "unfold transport_r .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (y x1) z)\n     ((fun x1 : C => eq_sym (x0 x1)) y0) (fmap f))\n  (transport_r (fun z : D => hom z (x y0))\n     ((fun x1 : C => eq_sym (x0 x1)) x1) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (transport (fun z : D => hom (y x1) z) (eq_sym (x0 y0)) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (eq_sym (eq_sym (x0 x1)))\n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "rewrite eq_sym_involutive .",
                "tactic_sig_no_out_arg": "rewrite eq_sym_involutive .",
                "tactic_args": [
                    "_goal : equiv (transport (fun z : D => hom (y x1) z) (eq_sym (x0 y0)) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (eq_sym (eq_sym (x0 x1)))\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (transport (fun z : D => hom (y x1) z) (eq_sym (x0 y0)) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))"
                ]
            },
            {
                "tactic_sig": "fold ( transport_r ( \u03bb _i : obj [ _i ] , fobj [ _i ] _i ~ { _i } ~ > _i ) ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "fold ( transport_r ( \u03bb _i : obj [ _i ] , fobj [ _i ] _i ~ { _i } ~ > _i ) ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : equiv (transport (fun z : D => hom (y x1) z) (eq_sym (x0 y0)) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))",
                    "z : Functor",
                    "D : Category",
                    "y : Functor",
                    "x1 : obj",
                    "D : Category",
                    "z : Functor",
                    "x0 : forall x0 : C, eq (x x0) (y x0)",
                    "y0 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (transport_r (fun z : D => hom (y x1) z) (x0 y0) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "_goal : equiv (transport_r (fun z : D => hom (y x1) z) (x0 y0) (fmap f))\n  (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))\n  (transport_r (fun z : D => hom (y x1) z) (x0 y0) (fmap f))"
                ]
            },
            {
                "tactic_sig": "rename _i into F , _i into G , _i into eq_ob , _i into _i , _i into _i .",
                "tactic_sig_no_out_arg": "rename _i into F , _i into G , _i into eq_ob , _i into _i , _i into _i .",
                "tactic_args": [
                    "_goal : equiv (transport (fun z : D => hom z (x y0)) (x0 x1) (fmap f))\n  (transport_r (fun z : D => hom (y x1) z) (x0 y0) (fmap f))",
                    "x : Functor",
                    "y : Functor",
                    "x0 : forall x0 : C, eq (x x0) (y x0)",
                    "x1 : obj",
                    "x : Functor",
                    "y0 : obj",
                    "y : Functor"
                ],
                "tactic_res": [
                    "_goal : equiv (transport (fun z : D => hom z (F y)) (eq_ob x) (fmap f))\n  (transport_r (fun z : D => hom (G x) z) (eq_ob y) (fmap f))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj",
                    "e : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f))\n  (transport_r (fun z : D => hom z (G y)) (eq_ob x) (fmap f))",
                    "eq_ob : forall x : C, eq (F x) (G x)",
                    "F : Functor",
                    "G : Functor"
                ]
            },
            {
                "tactic_sig": "refine ( ( snd ( transport_adjunction _i ( hom ( fobj [ _i ] _i ) ) ( fun d t s => t \u2248 s ) _ _ _ _ _ ) ) _ ) .",
                "tactic_sig_no_out_arg": "refine ( ( snd ( transport_adjunction _i ( hom ( fobj [ _i ] _i ) ) ( fun d t s => t \u2248 s ) _ _ _ _ _ ) ) _ ) .",
                "tactic_args": [
                    "_goal : equiv (transport (fun z : D => hom z (F y)) (eq_ob x) (fmap f))\n  (transport_r (fun z : D => hom (G x) z) (eq_ob y) (fmap f))",
                    "D : Category",
                    "G : Functor",
                    "x : obj"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (hom (G x)) (eq_ob y)\n     (transport (fun z : D => hom z (F y)) (eq_ob x) (fmap f)))\n  (fmap f)"
                ]
            },
            {
                "tactic_sig": "rewrite transport_relation_exchange .",
                "tactic_sig_no_out_arg": "rewrite transport_relation_exchange .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (hom (G x)) (eq_ob y)\n     (transport (fun z : D => hom z (F y)) (eq_ob x) (fmap f)))\n  (fmap f)"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun k : D => hom k (G y)) (eq_ob x)\n     (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f)))\n  (fmap f)"
                ]
            },
            {
                "tactic_sig": "refine ( ( fst ( transport_adjunction _i ( fun d' => hom d' ( fobj [ _i ] _i ) ) ( fun d t s => t \u2248 s ) _ _ _ _ _ ) ) _ ) .",
                "tactic_sig_no_out_arg": "refine ( ( fst ( transport_adjunction _i ( fun d' => hom d' ( fobj [ _i ] _i ) ) ( fun d t s => t \u2248 s ) _ _ _ _ _ ) ) _ ) .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun k : D => hom k (G y)) (eq_ob x)\n     (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f)))\n  (fmap f)",
                    "D : Category",
                    "G : Functor",
                    "y : obj"
                ],
                "tactic_res": [
                    "_goal : equiv (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f))\n  (transport_r (fun d' : D => hom d' (G y)) (eq_ob x) (fmap f))"
                ]
            },
            {
                "tactic_sig": "exact ( _i _ _ _ ) .",
                "tactic_sig_no_out_arg": "exact ( _i _ _ _ ) .",
                "tactic_args": [
                    "_goal : equiv (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f))\n  (transport_r (fun d' : D => hom d' (G y)) (eq_ob x) (fmap f))",
                    "e : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (F x) z) (eq_ob y) (fmap f))\n  (transport_r (fun z : D => hom z (G y)) (eq_ob x) (fmap f))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exact ( eq_trans ( _i _i ) ( _i _i ) ) .",
                "tactic_sig_no_out_arg": "exact ( eq_trans ( _i _i ) ( _i _i ) ) .",
                "tactic_args": [
                    "_goal : eq (x x2) (z x2)",
                    "x1 : forall x0 : C, eq (x x0) (y x0)",
                    "x2 : obj",
                    "x0 : forall x : C, eq (y x) (z x)",
                    "x2 : obj"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rename _i into F , _i into G , _i into H , _i into F_eq_ob_G , _i into F_eq_ob_G_resp_mor , _i into G_eq_ob_H , _i into G_eq_ob_H_resp_mor , _i into domf , _i into codf .",
                "tactic_sig_no_out_arg": "rename _i into F , _i into G , _i into H , _i into F_eq_ob_G , _i into F_eq_ob_G_resp_mor , _i into G_eq_ob_H , _i into G_eq_ob_H_resp_mor , _i into domf , _i into codf .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (x x2) z) ((fun x2 : C => ?Goal0) y0)\n     (fmap f))\n  (transport_r (fun z0 : D => hom z0 (z y0))\n     ((fun x2 : C => ?Goal0) x2) (fmap f))",
                    "x : Functor",
                    "y : Functor",
                    "z : Functor",
                    "x1 : forall x0 : C, eq (x x0) (y x0)",
                    "e0 : forall (x0 y0 : C) (f : hom x0 y0),\nequiv (transport (fun z : D => hom (x x0) z) (x1 y0) (fmap f))\n  (transport_r (fun z : D => hom z (y y0)) (x1 x0) (fmap f))",
                    "x0 : forall x : C, eq (y x) (z x)",
                    "e : forall (x y0 : C) (f : hom x y0),\nequiv (transport (fun z : D => hom (y x) z) (x0 y0) (fmap f))\n  (transport_r (fun z0 : D => hom z0 (z y0)) (x0 x) (fmap f))",
                    "x2 : obj",
                    "y0 : obj"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z)\n     ((fun x2 : C => eq_trans (F_eq_ob_G x2) (G_eq_ob_H x2)) codf)\n     (fmap f))\n  (transport_r (fun z : D => hom z (H codf))\n     ((fun x2 : C => eq_trans (F_eq_ob_G x2) (G_eq_ob_H x2)) domf)\n     (fmap f))",
                    "f : hom domf codf",
                    "domf : obj",
                    "codf : obj",
                    "G_eq_ob_H_resp_mor : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (G x) z) (G_eq_ob_H y) (fmap f))\n  (transport_r (fun z : D => hom z (H y)) (G_eq_ob_H x) (fmap f))",
                    "G_eq_ob_H : forall x : C, eq (G x) (H x)",
                    "F_eq_ob_G_resp_mor : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (F x) z) (F_eq_ob_G y) (fmap f))\n  (transport_r (fun z : D => hom z (G y)) (F_eq_ob_G x) (fmap f))",
                    "F_eq_ob_G : forall x : C, eq (F x) (G x)",
                    "F : Functor",
                    "G : Functor",
                    "H : Functor"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z)\n     ((fun x2 : C => eq_trans (F_eq_ob_G x2) (G_eq_ob_H x2)) codf)\n     (fmap f))\n  (transport_r (fun z : D => hom z (H codf))\n     ((fun x2 : C => eq_trans (F_eq_ob_G x2) (G_eq_ob_H x2)) domf)\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z)\n     (eq_trans (F_eq_ob_G codf) (G_eq_ob_H codf)) \n     (fmap f))\n  (transport_r (fun z : D => hom z (H codf))\n     (eq_trans (F_eq_ob_G domf) (G_eq_ob_H domf)) \n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "rewrite <- transport_trans , <- transport_r_trans .",
                "tactic_sig_no_out_arg": "rewrite <- transport_trans , <- transport_r_trans .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z)\n     (eq_trans (F_eq_ob_G codf) (G_eq_ob_H codf)) \n     (fmap f))\n  (transport_r (fun z : D => hom z (H codf))\n     (eq_trans (F_eq_ob_G domf) (G_eq_ob_H domf)) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport (fun z : D => hom (F domf) z) (F_eq_ob_G codf) (fmap f)))\n  (transport_r (fun z : D => hom z (H codf)) (F_eq_ob_G domf)\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport (fun z : D => hom (F domf) z) (F_eq_ob_G codf) (fmap f)))\n  (transport_r (fun z : D => hom z (H codf)) (F_eq_ob_G domf)\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))",
                    "F_eq_ob_G_resp_mor : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (F x) z) (F_eq_ob_G y) (fmap f))\n  (transport_r (fun z : D => hom z (G y)) (F_eq_ob_G x) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport_r (fun z : D => hom z (G codf)) (F_eq_ob_G domf)\n        (fmap f)))\n  (transport_r (fun z : D => hom z (H codf)) (F_eq_ob_G domf)\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ]
            },
            {
                "tactic_sig": "unfold transport_r at 1 2 .",
                "tactic_sig_no_out_arg": "unfold transport_r at 1 2 .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport_r (fun z : D => hom z (G codf)) (F_eq_ob_G domf)\n        (fmap f)))\n  (transport_r (fun z : D => hom z (H codf)) (F_eq_ob_G domf)\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport (fun z : D => hom z (G codf)) (eq_sym (F_eq_ob_G domf))\n        (fmap f)))\n  (transport (fun z : D => hom z (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ]
            },
            {
                "tactic_sig": "rewrite transport_relation_exchange .",
                "tactic_sig_no_out_arg": "rewrite transport_relation_exchange .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (F domf) z) (G_eq_ob_H codf)\n     (transport (fun z : D => hom z (G codf)) (eq_sym (F_eq_ob_G domf))\n        (fmap f)))\n  (transport (fun z : D => hom z (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun k : D => hom k (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport (fun z : D => hom (G domf) z) (G_eq_ob_H codf) (fmap f)))\n  (transport (fun z : D => hom z (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ]
            },
            {
                "tactic_sig": "apply proper_transport_dom .",
                "tactic_sig_no_out_arg": "apply proper_transport_dom .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun k : D => hom k (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport (fun z : D => hom (G domf) z) (G_eq_ob_H codf) (fmap f)))\n  (transport (fun z : D => hom z (H codf)) (eq_sym (F_eq_ob_G domf))\n     (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf)\n        (fmap f)))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : D => hom (G domf) z) (G_eq_ob_H codf) (fmap f))\n  (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf) (fmap f))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : D => hom (G domf) z) (G_eq_ob_H codf) (fmap f))\n  (transport_r (fun z : D => hom z (H codf)) (G_eq_ob_H domf) (fmap f))",
                    "G_eq_ob_H_resp_mor : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (G x) z) (G_eq_ob_H y) (fmap f))\n  (transport_r (fun z : D => hom z (H y)) (G_eq_ob_H x) (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_f_equal",
        "proof": [
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (transport (fun a : A => C (f a)) p t)\n  (transport (fun b : B => C b) (f_equal f p) t)",
                    "p : eq x y"
                ],
                "tactic_res": [
                    "_goal : eq (transport (fun a : A => C (f a)) eq_refl t)\n  (transport (fun b : B => C b) (f_equal f eq_refl) t)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (transport (fun a : A => C (f a)) eq_refl t)\n  (transport (fun b : B => C b) (f_equal f eq_refl) t)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_functorial_dom",
        "proof": [
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (fmap (transport (fun z : C => hom z d) p f))\n  (transport (fun z : D => hom z (F d)) (f_equal F p) (fmap f))",
                    "p : eq c c'"
                ],
                "tactic_res": [
                    "_goal : eq (fmap (transport (fun z : C => hom z d) eq_refl f))\n  (transport (fun z : D => hom z (F d)) (f_equal F eq_refl) (fmap f))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (fmap (transport (fun z : C => hom z d) eq_refl f))\n  (transport (fun z : D => hom z (F d)) (f_equal F eq_refl) (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "transport_functorial_cod",
        "proof": [
            {
                "tactic_sig": "destruct _i as [] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (fmap (transport (fun z : C => hom c z) p f))\n  (transport (fun z : D => hom (F c) z) (f_equal F p) (fmap f))",
                    "p : eq d d'"
                ],
                "tactic_res": [
                    "_goal : eq (fmap (transport (fun z : C => hom c z) eq_refl f))\n  (transport (fun z : D => hom (F c) z) (f_equal F eq_refl) (fmap f))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (fmap (transport (fun z : C => hom c z) eq_refl f))\n  (transport (fun z : D => hom (F c) z) (f_equal F eq_refl) (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros F G [ FG_eq_on_obj FG_morphismcoherence ] H K [ HK_eq_on_obj HK_morphismcoherence ] .",
                "tactic_args": [
                    "_goal : respectful\n  (fun F G : Functor =>\n   sigT\n     (fun eq_on_obj : forall x : D, eq (F x) (G x) =>\n      forall (x y : D) (f : hom x y),\n      equiv\n        (transport (fun z : E => hom (F x) z) (eq_on_obj y) (fmap f))\n        (transport_r (fun z : E => hom z (G y)) (eq_on_obj x) (fmap f))))\n  (respectful\n     (fun F G : Functor =>\n      sigT\n        (fun eq_on_obj : forall x : C, eq (F x) (G x) =>\n         forall (x y : C) (f : hom x y),\n         equiv\n           (transport (fun z : D => hom (F x) z) (eq_on_obj y) (fmap f))\n           (transport_r (fun z : D => hom z (G y)) \n              (eq_on_obj x) (fmap f))))\n     (fun F G : Functor =>\n      sigT\n        (fun eq_on_obj : forall x : C, eq (F x) (G x) =>\n         forall (x y : C) (f : hom x y),\n         equiv\n           (transport (fun z : E => hom (F x) z) (eq_on_obj y) (fmap f))\n           (transport_r (fun z : E => hom z (G y)) \n              (eq_on_obj x) (fmap f))))) Compose Compose"
                ],
                "tactic_res": [
                    "_goal : sigT\n  (fun eq_on_obj : forall x : C, eq (Compose F H x) (Compose G K x) =>\n   forall (x y : C) (f : hom x y),\n   equiv\n     (transport (fun z : E => hom (Compose F H x) z) \n        (eq_on_obj y) (fmap f))\n     (transport_r (fun z : E => hom z (Compose G K y)) \n        (eq_on_obj x) (fmap f)))",
                    "HK_morphismcoherence : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (H x) z) (HK_eq_on_obj y) (fmap f))\n  (transport_r (fun z : D => hom z (K y)) (HK_eq_on_obj x) (fmap f))",
                    "HK_eq_on_obj : forall x : C, eq (H x) (K x)",
                    "H : Functor",
                    "K : Functor",
                    "FG_morphismcoherence : forall (x y : D) (f : hom x y),\nequiv (transport (fun z : E => hom (F x) z) (FG_eq_on_obj y) (fmap f))\n  (transport_r (fun z : E => hom z (G y)) (FG_eq_on_obj x) (fmap f))",
                    "FG_eq_on_obj : forall x : D, eq (F x) (G x)",
                    "F : Functor",
                    "G : Functor"
                ]
            },
            {
                "tactic_sig": "unshelve eapply ( _ ; _ ) .",
                "tactic_sig_no_out_arg": "unshelve eapply ( _ ; _ ) .",
                "tactic_args": [
                    "_goal : sigT\n  (fun eq_on_obj : forall x : C, eq (Compose F H x) (Compose G K x) =>\n   forall (x y : C) (f : hom x y),\n   equiv\n     (transport (fun z : E => hom (Compose F H x) z) \n        (eq_on_obj y) (fmap f))\n     (transport_r (fun z : E => hom z (Compose G K y)) \n        (eq_on_obj x) (fmap f)))"
                ],
                "tactic_res": [
                    "_goal : forall x : C, eq (Compose F H x) (Compose G K x)",
                    "_goal : (fun eq_on_obj : forall x : C, eq (Compose F H x) (Compose G K x) =>\n forall (x y : C) (f : hom x y),\n equiv\n   (transport (fun z : E => hom (Compose F H x) z) \n      (eq_on_obj y) (fmap f))\n   (transport_r (fun z : E => hom z (Compose G K y)) \n      (eq_on_obj x) (fmap f))) ?x"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro c .",
                "tactic_args": [
                    "_goal : forall x : C, eq (Compose F H x) (Compose G K x)"
                ],
                "tactic_res": [
                    "_goal : eq (Compose F H c) (Compose G K c)",
                    "c : obj"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Compose F H c) (Compose G K c)"
                ],
                "tactic_res": [
                    "_goal : eq (F (H c)) (G (K c))"
                ]
            },
            {
                "tactic_sig": "exact ( eq_trans ( f_equal ( fobj [ _i ] ) ( _i _i ) ) ( _i ( fobj [ _i ] _i ) ) ) .",
                "tactic_sig_no_out_arg": "exact ( eq_trans ( f_equal ( fobj [ _i ] ) ( _i _i ) ) ( _i ( fobj [ _i ] _i ) ) ) .",
                "tactic_args": [
                    "_goal : eq (F (H c)) (G (K c))",
                    "F : Functor",
                    "HK_eq_on_obj : forall x : C, eq (H x) (K x)",
                    "c : obj",
                    "FG_eq_on_obj : forall x : D, eq (F x) (G x)",
                    "K : Functor",
                    "c : obj"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros c c' f .",
                "tactic_args": [
                    "_goal : (fun eq_on_obj : forall x : C, eq (Compose F H x) (Compose G K x) =>\n forall (x y : C) (f : hom x y),\n equiv\n   (transport (fun z : E => hom (Compose F H x) z) \n      (eq_on_obj y) (fmap f))\n   (transport_r (fun z : E => hom z (Compose G K y)) \n      (eq_on_obj x) (fmap f))) ?x"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (Compose F H c) z)\n     (eq_trans (f_equal F (HK_eq_on_obj c')) (FG_eq_on_obj (K c')))\n     (fmap f))\n  (transport_r (fun z : E => hom z (Compose G K c'))\n     (eq_trans (f_equal F (HK_eq_on_obj c)) (FG_eq_on_obj (K c)))\n     (fmap f))",
                    "f : hom c c'",
                    "c : obj",
                    "c' : obj"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (Compose F H c) z)\n     (eq_trans (f_equal F (HK_eq_on_obj c')) (FG_eq_on_obj (K c')))\n     (fmap f))\n  (transport_r (fun z : E => hom z (Compose G K c'))\n     (eq_trans (f_equal F (HK_eq_on_obj c)) (FG_eq_on_obj (K c)))\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z)\n     (eq_trans (f_equal F (HK_eq_on_obj c')) (FG_eq_on_obj (K c')))\n     (fmap (fmap f)))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (eq_trans (f_equal F (HK_eq_on_obj c)) (FG_eq_on_obj (K c)))\n     (fmap (fmap f)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- transport_trans , <- transport_r_trans .",
                "tactic_sig_no_out_arg": "rewrite <- transport_trans , <- transport_r_trans .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z)\n     (eq_trans (f_equal F (HK_eq_on_obj c')) (FG_eq_on_obj (K c')))\n     (fmap (fmap f)))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (eq_trans (f_equal F (HK_eq_on_obj c)) (FG_eq_on_obj (K c)))\n     (fmap (fmap f)))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (transport (fun z : E => hom (F (H c)) z)\n        (f_equal F (HK_eq_on_obj c')) (fmap (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- transport_functorial_cod .",
                "tactic_sig_no_out_arg": "rewrite <- transport_functorial_cod .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (transport (fun z : E => hom (F (H c)) z)\n        (f_equal F (HK_eq_on_obj c')) (fmap (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport (fun z : D => hom (H c) z) (HK_eq_on_obj c')\n           (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport (fun z : D => hom (H c) z) (HK_eq_on_obj c')\n           (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))",
                    "HK_morphismcoherence : forall (x y : C) (f : hom x y),\nequiv (transport (fun z : D => hom (H x) z) (HK_eq_on_obj y) (fmap f))\n  (transport_r (fun z : D => hom z (K y)) (HK_eq_on_obj x) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport_r (fun z : D => hom z (K c')) (HK_eq_on_obj c)\n           (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "unfold transport_r at 1 2 .",
                "tactic_sig_no_out_arg": "unfold transport_r at 1 2 .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport_r (fun z : D => hom z (K c')) (HK_eq_on_obj c)\n           (fmap f))))\n  (transport_r (fun z : E => hom z (G (K c')))\n     (f_equal F (HK_eq_on_obj c))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport (fun z : D => hom z (K c'))\n           (eq_sym (HK_eq_on_obj c)) (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "rewrite transport_functorial_dom .",
                "tactic_sig_no_out_arg": "rewrite transport_functorial_dom .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (fmap\n        (transport (fun z : D => hom z (K c'))\n           (eq_sym (HK_eq_on_obj c)) (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (transport (fun z : E => hom z (F (K c')))\n        (f_equal F (eq_sym (HK_eq_on_obj c))) (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "rewrite transport_relation_exchange .",
                "tactic_sig_no_out_arg": "rewrite transport_relation_exchange .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (H c)) z) (FG_eq_on_obj (K c'))\n     (transport (fun z : E => hom z (F (K c')))\n        (f_equal F (eq_sym (HK_eq_on_obj c))) (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun k : E => hom k (G (K c')))\n     (f_equal F (eq_sym (HK_eq_on_obj c)))\n     (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n        (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- eq_sym_map_distr .",
                "tactic_sig_no_out_arg": "rewrite <- eq_sym_map_distr .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun k : E => hom k (G (K c')))\n     (f_equal F (eq_sym (HK_eq_on_obj c)))\n     (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n        (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun k : E => hom k (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n        (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "apply proper_transport_dom .",
                "tactic_sig_no_out_arg": "apply proper_transport_dom .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun k : E => hom k (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n        (fmap (fmap f))))\n  (transport (fun z : E => hom z (G (K c')))\n     (eq_sym (f_equal F (HK_eq_on_obj c)))\n     (transport_r (fun z : E => hom z (G (K c'))) \n        (FG_eq_on_obj (K c)) (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n     (fmap (fmap f)))\n  (transport_r (fun z : E => hom z (G (K c'))) (FG_eq_on_obj (K c))\n     (fmap (fmap f)))"
                ]
            },
            {
                "tactic_sig": "now trivial .",
                "tactic_sig_no_out_arg": "now trivial .",
                "tactic_args": [
                    "_goal : equiv\n  (transport (fun z : E => hom (F (K c)) z) (FG_eq_on_obj (K c'))\n     (fmap (fmap f)))\n  (transport_r (fun z : E => hom z (G (K c'))) (FG_eq_on_obj (K c))\n     (fmap (fmap f)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_strict_equiv_id_right",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose F Id) F"
                ],
                "tactic_res": [
                    "_goal : forall x : A, eq (Compose F Id x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z) \n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : B => hom z (F y)) (?eq_on_obj x) (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall x : A, eq (Compose F Id x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z) \n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : B => hom z (F y)) (?eq_on_obj x) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall x : A, eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     ((?Goal0 : forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     ((?Goal0 : forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : A, eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     ((?Goal0 : forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     ((?Goal0 : forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))",
                    "x : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose F Id x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose F Id x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_strict_equiv_id_left",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose Id F) F"
                ],
                "tactic_res": [
                    "_goal : forall x : A, eq (Compose Id F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z) \n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : B => hom z (F y)) (?eq_on_obj x) (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall x : A, eq (Compose Id F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z) \n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : B => hom z (F y)) (?eq_on_obj x) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall x : A, eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     ((?Goal0 : forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     ((?Goal0 : forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : A, eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     ((?Goal0 : forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     ((?Goal0 : forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))",
                    "x : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)"
                ],
                "tactic_res": [
                    "_goal : eq (F x) (F x)"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : eq (F x) (F x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : B => hom (Compose Id F x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) y) \n     (fmap f))\n  (transport_r (fun z : B => hom z (F y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A, eq (Compose Id F x0) (F x0)) x) \n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ]
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : equiv (fmap f)\n  (transport_r (fun z : B => hom z (F y)) eq_refl (fmap f))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "fun_strict_equiv_comp_assoc",
        "proof": [
            {
                "tactic_sig": "unshelve econstructor .",
                "tactic_sig_no_out_arg": "unshelve econstructor .",
                "tactic_args": [
                    "_goal : equiv (Compose F (Compose G H)) (Compose (Compose F G) H)"
                ],
                "tactic_res": [
                    "_goal : forall x : A,\neq (Compose F (Compose G H) x) (Compose (Compose F G) H x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (?eq_on_obj x) (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall x : A,\neq (Compose F (Compose G H) x) (Compose (Compose F G) H x)",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (?eq_on_obj y) (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (?eq_on_obj x) (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall x : A, eq (F (G (H x))) (F (G (H x)))",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     ((?Goal0\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     ((?Goal0\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : A, eq (F (G (H x))) (F (G (H x)))",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     ((?Goal0\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     ((?Goal0\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))",
                    "x : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))"
                ],
                "tactic_res": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))"
                ],
                "tactic_res": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : eq (F (G (H x))) (F (G (H x)))",
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (((fun x0 : A => ?Goal0@{x:=x0})\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv\n  (transport (fun z : D => hom (Compose F (Compose G H) x) z)\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) y)\n     (fmap f))\n  (transport_r (fun z : D => hom z (Compose (Compose F G) H y))\n     (((fun x0 : A => eq_refl)\n       :\n       forall x0 : A,\n       eq (Compose F (Compose G H) x0) (Compose (Compose F G) H x0)) x)\n     (fmap f))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : A) (f : hom x y),\nequiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))",
                    "f : hom x y",
                    "x : obj",
                    "y : obj"
                ]
            },
            {
                "tactic_sig": "simplify .",
                "tactic_sig_no_out_arg": "simplify .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "autorewrite with categories .",
                "tactic_sig_no_out_arg": "autorewrite with categories .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "auto with category_laws .",
                "tactic_sig_no_out_arg": "auto with category_laws .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ],
                "tactic_res": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ]
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : equiv (fmap (fmap (fmap f)))\n  (transport_r (fun z : D => hom z (F (G (H y)))) eq_refl\n     (fmap (fmap (fmap f))))"
                ],
                "tactic_res": []
            }
        ]
    }
]